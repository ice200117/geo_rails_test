<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>application-156c0c51078c74a6f4a4e9b64a78597df2f9d7704c6e446ca7029a516189ff9c.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/darkfish.js"></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../1_log.html">1.log</a>
  
    <li><a href="../../Gemfile.html">Gemfile</a>
  
    <li><a href="../../Gemfile_lock.html">Gemfile.lock</a>
  
    <li><a href="../../README_rdoc.html">README</a>
  
    <li><a href="../../Rakefile.html">Rakefile</a>
  
    <li><a href="../../Session_vim.html">Session.vim</a>
  
    <li><a href="../../app/assets/javascripts/application_js.html">application.js</a>
  
    <li><a href="../../app/assets/javascripts/barcity_js.html">barcity.js</a>
  
    <li><a href="../../app/assets/javascripts/bdqxSelector_js.html">bdqxSelector.js</a>
  
    <li><a href="../../app/assets/javascripts/bdqx_compare_chart_js.html">bdqx_compare_chart.js</a>
  
    <li><a href="../../app/assets/javascripts/bootstrap-table_min_js.html">bootstrap-table.min.js</a>
  
    <li><a href="../../app/assets/javascripts/bootstrap_min_js.html">bootstrap.min.js</a>
  
    <li><a href="../../app/assets/javascripts/chart_js.html">chart.js</a>
  
    <li><a href="../../app/assets/javascripts/citySelector_js.html">citySelector.js</a>
  
    <li><a href="../../app/assets/javascripts/city_compare_chart_js.html">city_compare_chart.js</a>
  
    <li><a href="../../app/assets/javascripts/counties_coffee.html">counties.coffee</a>
  
    <li><a href="../../app/assets/javascripts/crypto_zq-min_js.html">crypto_zq-min.js</a>
  
    <li><a href="../../app/assets/javascripts/daterangepicker_js.html">daterangepicker.js</a>
  
    <li><a href="../../app/assets/javascripts/forecast_points_coffee.html">forecast_points.coffee</a>
  
    <li><a href="../../app/assets/javascripts/index_welcome_js.html">index_welcome.js</a>
  
    <li><a href="../../app/assets/javascripts/jquery-ui-datepicker_js.html">jquery-ui-datepicker.js</a>
  
    <li><a href="../../app/assets/javascripts/jquery_min_js.html">jquery.min.js</a>
  
    <li><a href="../../app/assets/javascripts/jquery_cookie_js.html">jquery_cookie.js</a>
  
    <li><a href="../../app/assets/javascripts/jquery_min_js.html">jquery_min.js</a>
  
    <li><a href="../../app/assets/javascripts/map_js.html">map.js</a>
  
    <li><a href="../../app/assets/javascripts/map_welcome_js.html">map_welcome.js</a>
  
    <li><a href="../../app/assets/javascripts/moment_js.html">moment.js</a>
  
    <li><a href="../../app/assets/javascripts/qinhuangdao_coffee.html">qinhuangdao.coffee</a>
  
    <li><a href="../../app/assets/javascripts/querys_coffee.html">querys.coffee</a>
  
    <li><a href="../../app/assets/javascripts/respond_js.html">respond.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/BMap/BMap_js.html">BMap.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/BMap/main_js.html">main.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart_js.html">chart.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/bar_js.html">bar.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/base_js.html">base.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/chord_js.html">chord.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/eventRiver_js.html">eventRiver.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/force_js.html">force.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/funnel_js.html">funnel.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/gauge_js.html">gauge.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/island_js.html">island.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/k_js.html">k.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/line_js.html">line.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/map_js.html">map.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/pie_js.html">pie.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/radar_js.html">radar.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/chart/scatter_js.html">scatter.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component_js.html">component.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/axis_js.html">axis.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/base_js.html">base.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/categoryAxis_js.html">categoryAxis.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/dataRange_js.html">dataRange.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/dataView_js.html">dataView.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/dataZoom_js.html">dataZoom.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/grid_js.html">grid.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/legend_js.html">legend.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/polar_js.html">polar.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/roamController_js.html">roamController.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/timeline_js.html">timeline.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/title_js.html">title.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/toolbox_js.html">toolbox.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/tooltip_js.html">tooltip.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/component/valueAxis_js.html">valueAxis.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/config_js.html">config.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/data/Graph_js.html">Graph.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/data/KDTree_js.html">KDTree.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/data/Tree_js.html">Tree.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/data/quickSelect_js.html">quickSelect.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/echarts-all_js.html">echarts-all.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/echarts_js.html">echarts.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/layout/Chord_js.html">Chord.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/layout/EdgeBundling_js.html">EdgeBundling.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/layout/Force_js.html">Force.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/layout/Tree_js.html">Tree.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/layout/eventRiver_js.html">eventRiver.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/layout/forceLayoutWorker_js.html">forceLayoutWorker.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/theme/default_js.html">default.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/theme/infographic_js.html">infographic.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/theme/macarons_js.html">macarons.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/accMath_js.html">accMath.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/coordinates_js.html">coordinates.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/date_js.html">date.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/ecAnimation_js.html">ecAnimation.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/ecData_js.html">ecData.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/ecEffect_js.html">ecEffect.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/ecQuery_js.html">ecQuery.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/kwargs_js.html">kwargs.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoCoord_js.html">geoCoord.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/an_hui_geo_js.html">an_hui_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/ao_men_geo_js.html">ao_men_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/bei_jing_geo_js.html">bei_jing_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/china_geo_js.html">china_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/chong_qing_geo_js.html">chong_qing_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/fu_jian_geo_js.html">fu_jian_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/gan_su_geo_js.html">gan_su_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/guang_dong_geo_js.html">guang_dong_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/guang_xi_geo_js.html">guang_xi_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/gui_zhou_geo_js.html">gui_zhou_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/hai_nan_geo_js.html">hai_nan_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/he_bei_geo_js.html">he_bei_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/he_nan_geo_js.html">he_nan_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/hei_long_jiang_geo_js.html">hei_long_jiang_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/hu_bei_geo_js.html">hu_bei_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/hu_nan_geo_js.html">hu_nan_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/ji_lin_geo_js.html">ji_lin_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/jiang_su_geo_js.html">jiang_su_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/jiang_xi_geo_js.html">jiang_xi_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/liao_ning_geo_js.html">liao_ning_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/nei_meng_gu_geo_js.html">nei_meng_gu_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/ning_xia_geo_js.html">ning_xia_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/qing_hai_geo_js.html">qing_hai_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/shan_dong_geo_js.html">shan_dong_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/shan_xi_1_geo_js.html">shan_xi_1_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/shan_xi_2_geo_js.html">shan_xi_2_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/shang_hai_geo_js.html">shang_hai_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/si_chuan_geo_js.html">si_chuan_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/tai_wan_geo_js.html">tai_wan_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/tian_jin_geo_js.html">tian_jin_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/world_geo_js.html">world_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/xi_zang_geo_js.html">xi_zang_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/xiang_gang_geo_js.html">xiang_gang_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/xin_jiang_geo_js.html">xin_jiang_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/yun_nan_geo_js.html">yun_nan_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/geoJson/zhe_jiang_geo_js.html">zhe_jiang_geo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/params_js.html">params.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/encode_js.html">encode.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/an_hui_geo_json.html">an_hui_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/ao_men_geo_json.html">ao_men_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/bei_jing_geo_json.html">bei_jing_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/china_city_json.html">china_city.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/china_geo_json.html">china_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/chong_qing_geo_json.html">chong_qing_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/fu_jian_geo_json.html">fu_jian_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/gan_su_geo_json.html">gan_su_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/guang_dong_geo_json.html">guang_dong_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/guang_xi_geo_json.html">guang_xi_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/gui_zhou_geo_json.html">gui_zhou_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/hai_nan_geo_json.html">hai_nan_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/he_bei_geo_json.html">he_bei_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/he_nan_geo_json.html">he_nan_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/hei_long_jiang_geo_json.html">hei_long_jiang_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/hu_bei_geo_json.html">hu_bei_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/hu_nan_geo_json.html">hu_nan_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/ji_lin_geo_json.html">ji_lin_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/jiang_su_geo_json.html">jiang_su_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/jiang_xi_geo_json.html">jiang_xi_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/liao_ning_geo_json.html">liao_ning_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/nei_meng_gu_geo_json.html">nei_meng_gu_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/ning_xia_geo_json.html">ning_xia_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/qing_hai_geo_json.html">qing_hai_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/shan_dong_geo_json.html">shan_dong_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/shan_xi_1_geo_json.html">shan_xi_1_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/shan_xi_2_geo_json.html">shan_xi_2_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/shang_hai_geo_json.html">shang_hai_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/si_chuan_geo_json.html">si_chuan_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/tai_wan_geo_json.html">tai_wan_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/tian_jin_geo_json.html">tian_jin_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/world_geo_json.html">world_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/xi_zang_geo_json.html">xi_zang_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/xiang_gang_geo_json.html">xiang_gang_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/xin_jiang_geo_json.html">xin_jiang_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/yun_nan_geo_json.html">yun_nan_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/rawData/geoJson/zhe_jiang_geo_json.html">zhe_jiang_geo.json</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/mapData/textFixed_js.html">textFixed.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/ndarray_js.html">ndarray.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/number_js.html">number.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/projection/albers_js.html">albers.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/projection/mercator_js.html">mercator.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/projection/normal_js.html">normal.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/projection/svg_js.html">svg.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/Candle_js.html">Candle.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/Chain_js.html">Chain.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/Cross_js.html">Cross.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/GaugePointer_js.html">GaugePointer.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/HalfSmoothPolygon_js.html">HalfSmoothPolygon.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/HandlePolygon_js.html">HandlePolygon.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/Icon_js.html">Icon.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/MarkLine_js.html">MarkLine.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/Ribbon_js.html">Ribbon.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/Symbol_js.html">Symbol.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/shape/normalIsCover_js.html">normalIsCover.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/echarts/util/smartSteps_js.html">smartSteps.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/esl_js.html">esl.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/jquery_backstretch_min_js.html">jquery.backstretch.min.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/Group_js.html">Group.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/Handler_js.html">Handler.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/Layer_js.html">Layer.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/Painter_js.html">Painter.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/Storage_js.html">Storage.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/animation/Animation_js.html">Animation.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/animation/Clip_js.html">Clip.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/animation/easing_js.html">easing.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/config_js.html">config.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/dep/excanvas_js.html">excanvas.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/dep/excanvas2_js.html">excanvas2.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/dep/excanvas3_js.html">excanvas3.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/loadingEffect/Bar_js.html">Bar.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/loadingEffect/Base_js.html">Base.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/loadingEffect/Bubble_js.html">Bubble.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/loadingEffect/DynamicLine_js.html">DynamicLine.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/loadingEffect/Ring_js.html">Ring.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/loadingEffect/Spin_js.html">Spin.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/loadingEffect/Whirling_js.html">Whirling.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/mixin/Eventful_js.html">Eventful.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/mixin/Transformable_js.html">Transformable.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Base_js.html">Base.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/BezierCurve_js.html">BezierCurve.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Circle_js.html">Circle.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Droplet_js.html">Droplet.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Ellipse_js.html">Ellipse.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Heart_js.html">Heart.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Image_js.html">Image.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Isogon_js.html">Isogon.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Line_js.html">Line.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Path_js.html">Path.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Polygon_js.html">Polygon.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Polyline_js.html">Polyline.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Rectangle_js.html">Rectangle.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Ring_js.html">Ring.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Rose_js.html">Rose.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Sector_js.html">Sector.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/ShapeBundle_js.html">ShapeBundle.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Star_js.html">Star.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Text_js.html">Text.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/Trochoid_js.html">Trochoid.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/util/PathProxy_js.html">PathProxy.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/util/dashedLineTo_js.html">dashedLineTo.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/util/smoothBezier_js.html">smoothBezier.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/shape/util/smoothSpline_js.html">smoothSpline.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/area_js.html">area.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/color_js.html">color.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/computeBoundingBox_js.html">computeBoundingBox.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/curve_js.html">curve.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/env_js.html">env.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/event_js.html">event.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/guid_js.html">guid.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/http_js.html">http.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/log_js.html">log.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/math_js.html">math.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/matrix_js.html">matrix.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/util_js.html">util.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/tool/vector_js.html">vector.js</a>
  
    <li><a href="../../app/assets/javascripts/vendor/zrender/zrender_js.html">zrender.js</a>
  
    <li><a href="../../app/assets/javascripts/welcome_js.html">welcome.js</a>
  
    <li><a href="../../app/assets/stylesheets/application_scss.html">application.scss</a>
  
    <li><a href="../../app/assets/stylesheets/counties_scss.html">counties.scss</a>
  
    <li><a href="../../app/assets/stylesheets/css/bootstrap-table_min_css.html">bootstrap-table.min.css</a>
  
    <li><a href="../../app/assets/stylesheets/css/bootstrap_min_css.html">bootstrap.min.css</a>
  
    <li><a href="../../app/assets/stylesheets/css/button_css.html">button.css</a>
  
    <li><a href="../../app/assets/stylesheets/css/daterangepicker-bs3_css.html">daterangepicker-bs3.css</a>
  
    <li><a href="../../app/assets/stylesheets/css/jquery-ui_css.html">jquery-ui.css</a>
  
    <li><a href="../../app/assets/stylesheets/css/styles_css.html">styles.css</a>
  
    <li><a href="../../app/assets/stylesheets/css/wdatepicker_css.html">wdatepicker.css</a>
  
    <li><a href="../../app/assets/stylesheets/forecast_points_scss.html">forecast_points.scss</a>
  
    <li><a href="../../app/assets/stylesheets/map_scss.html">map.scss</a>
  
    <li><a href="../../app/assets/stylesheets/qinhuangdao_scss.html">qinhuangdao.scss</a>
  
    <li><a href="../../app/assets/stylesheets/querys_scss.html">querys.scss</a>
  
    <li><a href="../../app/assets/stylesheets/scaffolds_scss.html">scaffolds.scss</a>
  
    <li><a href="../../app/assets/stylesheets/welcome_scss.html">welcome.scss</a>
  
    <li><a href="../../app/views/forecast_points/index_json_jbuilder.html">index.json.jbuilder</a>
  
    <li><a href="../../app/views/forecast_points/show_json_jbuilder.html">show.json.jbuilder</a>
  
    <li><a href="../../app/views/layouts/nav_bak_txt.html">nav_bak</a>
  
    <li><a href="../../config_ru.html">config.ru</a>
  
    <li><a href="../../cron_log_log.html">cron_log.log</a>
  
    <li><a href="../../db/structure_sql.html">structure.sql</a>
  
    <li><a href="../../hb_txt.html">hb</a>
  
    <li><a href="../../interfaceall_sh.html">interfaceall.sh</a>
  
    <li><a href="../../interfaceexcepjjj_sh.html">interfaceexcepjjj.sh</a>
  
    <li><a href="../../lib/tasks/cucumber_rake.html">cucumber.rake</a>
  
    <li><a href="../../lib/tasks/custom_rake.html">custom.rake</a>
  
    <li><a href="../../lib/tasks/predictionio_rake.html">predictionio.rake</a>
  
    <li><a href="../../log/development_log.html">development.log</a>
  
    <li><a href="../../log/getdata_log.html">getdata.log</a>
  
    <li><a href="../../log/produciton_log.html">produciton.log</a>
  
    <li><a href="../../log/production_log.html">production.log</a>
  
    <li><a href="../../log/test_log.html">test.log</a>
  
    <li><a href="../../logfile.html">logfile</a>
  
    <li><a href="../../pio_log.html">pio.log</a>
  
    <li><a href="../../public/404_html.html">404.html</a>
  
    <li><a href="../../public/422_html.html">422.html</a>
  
    <li><a href="../../public/500_html.html">500.html</a>
  
    <li><a href="../../public/adj/baoding_txt.html">baoding</a>
  
    <li><a href="../../public/adj/beijing_txt.html">beijing</a>
  
    <li><a href="../../public/adj/cangzhou_txt.html">cangzhou</a>
  
    <li><a href="../../public/adj/chengde_txt.html">chengde</a>
  
    <li><a href="../../public/adj/handan_txt.html">handan</a>
  
    <li><a href="../../public/adj/hengshui_txt.html">hengshui</a>
  
    <li><a href="../../public/adj/langfang_txt.html">langfang</a>
  
    <li><a href="../../public/adj/qinhuangdao_txt.html">qinhuangdao</a>
  
    <li><a href="../../public/adj/shijiazhuang_txt.html">shijiazhuang</a>
  
    <li><a href="../../public/adj/tangshan_txt.html">tangshan</a>
  
    <li><a href="../../public/adj/tianjin_txt.html">tianjin</a>
  
    <li><a href="../../public/adj/xingtai_txt.html">xingtai</a>
  
    <li><a href="../../public/adj/zhangjiakou_txt.html">zhangjiakou</a>
  
    <li><a href="../../public/adj/zz/anyang_txt.html">anyang</a>
  
    <li><a href="../../public/adj/zz/hebi_txt.html">hebi</a>
  
    <li><a href="../../public/adj/zz/jiaozuo_txt.html">jiaozuo</a>
  
    <li><a href="../../public/adj/zz/kaifeng_txt.html">kaifeng</a>
  
    <li><a href="../../public/adj/zz/luohe_txt.html">luohe</a>
  
    <li><a href="../../public/adj/zz/luoyang_txt.html">luoyang</a>
  
    <li><a href="../../public/adj/zz/nanyang_txt.html">nanyang</a>
  
    <li><a href="../../public/adj/zz/pingdingshan_txt.html">pingdingshan</a>
  
    <li><a href="../../public/adj/zz/puyang_txt.html">puyang</a>
  
    <li><a href="../../public/adj/zz/sanmenxia_txt.html">sanmenxia</a>
  
    <li><a href="../../public/adj/zz/shangqiu_txt.html">shangqiu</a>
  
    <li><a href="../../public/adj/zz/xinxiang_txt.html">xinxiang</a>
  
    <li><a href="../../public/adj/zz/xinyang_txt.html">xinyang</a>
  
    <li><a href="../../public/adj/zz/xuchang_txt.html">xuchang</a>
  
    <li><a href="../../public/adj/zz/zhengzhou_txt.html">zhengzhou</a>
  
    <li><a href="../../public/adj/zz/zhoukou_txt.html">zhoukou</a>
  
    <li><a href="../../public/adj/zz/zhumadian_txt.html">zhumadian</a>
  
    <li><a href="../../public/assets/application-01b3632f52df31675718067faed88379777213045d86aaa0440df8a5b1ec6961_css.html">application-01b3632f52df31675718067faed88379777213045d86aaa0440df8a5b1ec6961.css</a>
  
    <li><a href="../../public/assets/application-156c0c51078c74a6f4a4e9b64a78597df2f9d7704c6e446ca7029a516189ff9c_js.html">application-156c0c51078c74a6f4a4e9b64a78597df2f9d7704c6e446ca7029a516189ff9c.js</a>
  
    <li><a href="../../public/assets/application-1759aacb144855bbe5a0705904b4f66d1908d62673f2843bf40a61ee3a30faec_js.html">application-1759aacb144855bbe5a0705904b4f66d1908d62673f2843bf40a61ee3a30faec.js</a>
  
    <li><a href="../../public/assets/application-2c6a539f9e575c39d137b1e2e686328fb2ef98d50ff6d3d06427fc6d51ae0891_css.html">application-2c6a539f9e575c39d137b1e2e686328fb2ef98d50ff6d3d06427fc6d51ae0891.css</a>
  
    <li><a href="../../public/assets/application-332889d8ce83a18e1d60ced64852b2a054f610863695e52d726e60307437b365_css.html">application-332889d8ce83a18e1d60ced64852b2a054f610863695e52d726e60307437b365.css</a>
  
    <li><a href="../../public/assets/application-497ea77b064d49523466d86be6b7fed9ec44a63a37db640dbc531fa101b02ef1_js.html">application-497ea77b064d49523466d86be6b7fed9ec44a63a37db640dbc531fa101b02ef1.js</a>
  
    <li><a href="../../public/assets/application-4deedf77c73f20b45ca7e8d423c878725e13bb3789264ef03989ea38c7ffa4a2_css.html">application-4deedf77c73f20b45ca7e8d423c878725e13bb3789264ef03989ea38c7ffa4a2.css</a>
  
    <li><a href="../../public/assets/application-64ebeffca59295d5a442597c35b7414230fec50eab77ec3c07b6aa222e953336_js.html">application-64ebeffca59295d5a442597c35b7414230fec50eab77ec3c07b6aa222e953336.js</a>
  
    <li><a href="../../public/assets/application-784aab81ae1fb7f9dd4359423c3ae0dccd29b86bad307bc63124e6e532fdff1d_css.html">application-784aab81ae1fb7f9dd4359423c3ae0dccd29b86bad307bc63124e6e532fdff1d.css</a>
  
    <li><a href="../../public/assets/application-9fa781c8aba5392dd17eb2bf6051898315d80955db584ed203c1085d476e37eb_js.html">application-9fa781c8aba5392dd17eb2bf6051898315d80955db584ed203c1085d476e37eb.js</a>
  
    <li><a href="../../public/assets/application-a4a4fed82f44f1ab1199e98c3c7455e6896829488f5e980a5abe2d8d3daadce3_js.html">application-a4a4fed82f44f1ab1199e98c3c7455e6896829488f5e980a5abe2d8d3daadce3.js</a>
  
    <li><a href="../../public/assets/application-afd375c2f107d9016d95e8d696e8367d30fee1d2ff79c2af94cc9088d0380c1b_css.html">application-afd375c2f107d9016d95e8d696e8367d30fee1d2ff79c2af94cc9088d0380c1b.css</a>
  
    <li><a href="../../public/assets/application-ee122470ac5385b166e76182803c5f6dffaa5bea1e8233e214e67e611817a9c5_js.html">application-ee122470ac5385b166e76182803c5f6dffaa5bea1e8233e214e67e611817a9c5.js</a>
  
    <li><a href="../../public/assets/barcity-ab33f0bfb0e24b02b0961d8e021cac7ac6b09f9a29134c1eab719aa2077e844b_js.html">barcity-ab33f0bfb0e24b02b0961d8e021cac7ac6b09f9a29134c1eab719aa2077e844b.js</a>
  
    <li><a href="../../public/assets/bdqxSelector-8269b647a5bf52f872b50eaec33449e78777769c5318aea2fa632c30cf773bbc_js.html">bdqxSelector-8269b647a5bf52f872b50eaec33449e78777769c5318aea2fa632c30cf773bbc.js</a>
  
    <li><a href="../../public/assets/bdqxSelector-c460e7bc37a409d1b92aaddf7a9bdf56d06478b12268021b7edc3d80dc8ce842_js.html">bdqxSelector-c460e7bc37a409d1b92aaddf7a9bdf56d06478b12268021b7edc3d80dc8ce842.js</a>
  
    <li><a href="../../public/assets/bdqx_compare_chart-b98ad5a94ec10f910bee22b1ea63def4b3680e78b8b7fad58b78c328f984f3af_js.html">bdqx_compare_chart-b98ad5a94ec10f910bee22b1ea63def4b3680e78b8b7fad58b78c328f984f3af.js</a>
  
    <li><a href="../../public/assets/bdqx_compare_chart-be153d3310f442a5a6ad72046c967d5bbac277b258d096696a59253cb5e0f338_js.html">bdqx_compare_chart-be153d3310f442a5a6ad72046c967d5bbac277b258d096696a59253cb5e0f338.js</a>
  
    <li><a href="../../public/assets/bdqx_compare_chart-f179c8e87ec5f84a1504945389e15486e761cf02f3388deeae793cb6c08e1d31_js.html">bdqx_compare_chart-f179c8e87ec5f84a1504945389e15486e761cf02f3388deeae793cb6c08e1d31.js</a>
  
    <li><a href="../../public/assets/bootstrap-table_min-05fa9171e28636cec93d9f8da52ef0b8dd82c6959347cdec0daa13f2f1dabc77_js.html">bootstrap-table.min-05fa9171e28636cec93d9f8da52ef0b8dd82c6959347cdec0daa13f2f1dabc77.js</a>
  
    <li><a href="../../public/assets/bootstrap-table_min-785b4e36c2bda84d4485f2d3aaefcbdd1b5ad44fa3b02e6b59bc542ae37c3bc5_js.html">bootstrap-table.min-785b4e36c2bda84d4485f2d3aaefcbdd1b5ad44fa3b02e6b59bc542ae37c3bc5.js</a>
  
    <li><a href="../../public/assets/bootstrap-table_min-fb2867ddb5b74e404cd8c4ea28e0f1bce836c7d0f2ba6c4d2ce86ec2d476482d_js.html">bootstrap-table.min-fb2867ddb5b74e404cd8c4ea28e0f1bce836c7d0f2ba6c4d2ce86ec2d476482d.js</a>
  
    <li><a href="../../public/assets/bootstrap_min-7bab9b26b668c14a9c35af637078d94fca079226c6be0866eab22d549524ddec_js.html">bootstrap.min-7bab9b26b668c14a9c35af637078d94fca079226c6be0866eab22d549524ddec.js</a>
  
    <li><a href="../../public/assets/bootstrap_min-d66e555f160df017adf1ca16a36cd609a36d49c51637e365c5b8847d0065fa40_js.html">bootstrap.min-d66e555f160df017adf1ca16a36cd609a36d49c51637e365c5b8847d0065fa40.js</a>
  
    <li><a href="../../public/assets/bootstrap_min-e747123d97807d3512f80b11139230adce80c372e02b13cab04802e1dab12378_js.html">bootstrap.min-e747123d97807d3512f80b11139230adce80c372e02b13cab04802e1dab12378.js</a>
  
    <li><a href="../../public/assets/bootstrap/glyphicons-halflings-regular-3c8f142df5ab3046bbeb3c3310ae4fa9_svg.html">glyphicons-halflings-regular-3c8f142df5ab3046bbeb3c3310ae4fa9.svg</a>
  
    <li><a href="../../public/assets/bootstrap/glyphicons-halflings-regular-42f60659d265c1a3c30f9fa42abcbb56bd4a53af4d83d316d6dd7a36903c43e5_svg.html">glyphicons-halflings-regular-42f60659d265c1a3c30f9fa42abcbb56bd4a53af4d83d316d6dd7a36903c43e5.svg</a>
  
    <li><a href="../../public/assets/chart-28494bae3f6ec425cadc597793272b1efac5edddea23532fd89bb22931efc5ab_js.html">chart-28494bae3f6ec425cadc597793272b1efac5edddea23532fd89bb22931efc5ab.js</a>
  
    <li><a href="../../public/assets/chart-60763fbd396efd96555f2b3f1a29e8dc9718aef44034b1b622e85565da8993a0_js.html">chart-60763fbd396efd96555f2b3f1a29e8dc9718aef44034b1b622e85565da8993a0.js</a>
  
    <li><a href="../../public/assets/chart-f1dd26a0b52edc5af59da624b1eff33ea9bd629c4f1f73e010f5b4d5bfea0bcc_js.html">chart-f1dd26a0b52edc5af59da624b1eff33ea9bd629c4f1f73e010f5b4d5bfea0bcc.js</a>
  
    <li><a href="../../public/assets/chartkick-9c3851265350aa923c8130ee68594d3dcd2eecfcb4f425d15425ad992d9f6bc9_js.html">chartkick-9c3851265350aa923c8130ee68594d3dcd2eecfcb4f425d15425ad992d9f6bc9.js</a>
  
    <li><a href="../../public/assets/chartkick-b8b304fb1d86e77c562807d5d3baf924c4d01fab5f593e29409921eb4468a868_js.html">chartkick-b8b304fb1d86e77c562807d5d3baf924c4d01fab5f593e29409921eb4468a868.js</a>
  
    <li><a href="../../public/assets/chartkick-c33f97212de7f499029d66ddf93fb10e12286d4bf207b6fbeaabb0e93a03e9f7_js.html">chartkick-c33f97212de7f499029d66ddf93fb10e12286d4bf207b6fbeaabb0e93a03e9f7.js</a>
  
    <li><a href="../../public/assets/china_city/application-8ebd2d60a18ee5b43b83e34cc71b79a3fff6095c04c5459e1961336aeb7a1653_js.html">application-8ebd2d60a18ee5b43b83e34cc71b79a3fff6095c04c5459e1961336aeb7a1653.js</a>
  
    <li><a href="../../public/assets/china_city/application-a480b603687e8f1635b6f4512c105ae5_js.html">application-a480b603687e8f1635b6f4512c105ae5.js</a>
  
    <li><a href="../../public/assets/china_city/application-a7d8016344e2f9cd8f5a21250809c81dcf8ef21df49096b55320d71291ad00eb_js.html">application-a7d8016344e2f9cd8f5a21250809c81dcf8ef21df49096b55320d71291ad00eb.js</a>
  
    <li><a href="../../public/assets/china_city/application-b4a5fecf2b3b07d08217026bc92a933a75f4bd2b402774361a233021eab60e51_js.html">application-b4a5fecf2b3b07d08217026bc92a933a75f4bd2b402774361a233021eab60e51.js</a>
  
    <li><a href="../../public/assets/china_city/application-c06dd6a542ea15147e6794e03643f87c_css.html">application-c06dd6a542ea15147e6794e03643f87c.css</a>
  
    <li><a href="../../public/assets/china_city/application-d190388cf79159e7dfd6f7ad3b1f3ea8d054afb621d1947eade10dc05838ae98_js.html">application-d190388cf79159e7dfd6f7ad3b1f3ea8d054afb621d1947eade10dc05838ae98.js</a>
  
    <li><a href="../../public/assets/china_city/application-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855_css.html">application-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css</a>
  
    <li><a href="../../public/assets/china_city/application-f9e7c1541e1b8783561468c59162bd896007380f5a3799ef2169d3a3fdf40bed_css.html">application-f9e7c1541e1b8783561468c59162bd896007380f5a3799ef2169d3a3fdf40bed.css</a>
  
    <li><a href="../../public/assets/citySelector-1e935c7161fc5794d07feb958a19413aa66a3bdb891ad104accf8977d132a174_js.html">citySelector-1e935c7161fc5794d07feb958a19413aa66a3bdb891ad104accf8977d132a174.js</a>
  
    <li><a href="../../public/assets/citySelector-39a754751be9d2473d5ec432977130b59b50b7b9a7e875e61a7fa27fa2a79eba_js.html">citySelector-39a754751be9d2473d5ec432977130b59b50b7b9a7e875e61a7fa27fa2a79eba.js</a>
  
    <li><a href="../../public/assets/citySelector-9a0ee26433b1e9ac124a208ad9d8c298c502c6446121cc02e9050afc7aadf484_js.html">citySelector-9a0ee26433b1e9ac124a208ad9d8c298c502c6446121cc02e9050afc7aadf484.js</a>
  
    <li><a href="../../public/assets/city_compare_chart-491539ab35db73f177efca7cdfd7f248c7565107ee2cb63096292184f881ae07_js.html">city_compare_chart-491539ab35db73f177efca7cdfd7f248c7565107ee2cb63096292184f881ae07.js</a>
  
    <li><a href="../../public/assets/city_compare_chart-67886d91d6bd63853d5ee4a10c157ed3f9054ff08e19f94244ccc9b0558f1a4d_js.html">city_compare_chart-67886d91d6bd63853d5ee4a10c157ed3f9054ff08e19f94244ccc9b0558f1a4d.js</a>
  
    <li><a href="../../public/assets/city_compare_chart-69a341696abc8206011f7e7aacb47c1ccfd66e0fcd58f8f81591bd1c74d677c0_js.html">city_compare_chart-69a341696abc8206011f7e7aacb47c1ccfd66e0fcd58f8f81591bd1c74d677c0.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/comment/comment-7a2af2b0a8a2135bea2f9115eaf6daf9_js.html">comment-7a2af2b0a8a2135bea2f9115eaf6daf9.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/comment/continuecomment-8ac5305c8d93303876c9321d169384c4_js.html">continuecomment-8ac5305c8d93303876c9321d169384c4.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/dialog/dialog-4218ced94cbe2a04e8378962a1cc3217_js.html">dialog-4218ced94cbe2a04e8378962a1cc3217.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/dialog/dialog-7147853a80ceecad1e832bc22979cda8_css.html">dialog-7147853a80ceecad1e832bc22979cda8.css</a>
  
    <li><a href="../../public/assets/codemirror/addons/display/fullscreen-1673600eb6320e4c033da809ab0fca4a_css.html">fullscreen-1673600eb6320e4c033da809ab0fca4a.css</a>
  
    <li><a href="../../public/assets/codemirror/addons/display/fullscreen-c21f0a81cb6a6083f55f791958ded181_js.html">fullscreen-c21f0a81cb6a6083f55f791958ded181.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/display/panel-4c862b1e5aa822eb43e78d570c09d844_js.html">panel-4c862b1e5aa822eb43e78d570c09d844.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/display/placeholder-7f8690bcc422361f75096c63e7bc0252_js.html">placeholder-7f8690bcc422361f75096c63e7bc0252.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/display/rulers-fa45fcd3af96493813d1cbf6bdcc5300_js.html">rulers-fa45fcd3af96493813d1cbf6bdcc5300.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/edit/closebrackets-76ddf5817aabc4854d00f06d88278fac_js.html">closebrackets-76ddf5817aabc4854d00f06d88278fac.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/edit/closetag-bc34377b2a72cfdf583e7e34ecccc677_js.html">closetag-bc34377b2a72cfdf583e7e34ecccc677.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/edit/continuelist-f848662a934e1d54d7f06835239c49ca_js.html">continuelist-f848662a934e1d54d7f06835239c49ca.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/edit/matchbrackets-5840503ab219e5b763fb3092e01faa90_js.html">matchbrackets-5840503ab219e5b763fb3092e01faa90.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/edit/matchtags-aad3d2ab90d097cda02fee93f7a044fb_js.html">matchtags-aad3d2ab90d097cda02fee93f7a044fb.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/edit/trailingspace-41195793e8b872547000992bea301671_js.html">trailingspace-41195793e8b872547000992bea301671.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/fold/brace-fold-c28c1ffc4929240d0451739126c15241_js.html">brace-fold-c28c1ffc4929240d0451739126c15241.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/fold/comment-fold-3b82a98e48725147656e58cae96f78f6_js.html">comment-fold-3b82a98e48725147656e58cae96f78f6.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/fold/foldcode-e0cdf7990e150f22a54aecd1a81cef09_js.html">foldcode-e0cdf7990e150f22a54aecd1a81cef09.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/fold/foldgutter-c34e3dca5d8608926d2f24c030c4c716_js.html">foldgutter-c34e3dca5d8608926d2f24c030c4c716.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/fold/foldgutter-fec03d750fa0a8f8c222158662309698_css.html">foldgutter-fec03d750fa0a8f8c222158662309698.css</a>
  
    <li><a href="../../public/assets/codemirror/addons/fold/indent-fold-958ec7515ce872f7536ce4b0fbebca13_js.html">indent-fold-958ec7515ce872f7536ce4b0fbebca13.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/fold/markdown-fold-19c93d71c41437e30f53a30ff44b9ebf_js.html">markdown-fold-19c93d71c41437e30f53a30ff44b9ebf.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/fold/xml-fold-05a19a629f5bf3676aec5ed92afa8790_js.html">xml-fold-05a19a629f5bf3676aec5ed92afa8790.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/hint/anyword-hint-521888945d40790776b8b2a2ef22b3df_js.html">anyword-hint-521888945d40790776b8b2a2ef22b3df.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/hint/css-hint-9993adcce4c1cb8c4322e4f800a9cbb4_js.html">css-hint-9993adcce4c1cb8c4322e4f800a9cbb4.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/hint/html-hint-e2680033bf05b0c90f26eeca2798a79d_js.html">html-hint-e2680033bf05b0c90f26eeca2798a79d.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/hint/javascript-hint-29297db0d6ea8152de654261967aa5e2_js.html">javascript-hint-29297db0d6ea8152de654261967aa5e2.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/hint/show-hint-05eebe5a0662a19782ebc9d80edd029d_js.html">show-hint-05eebe5a0662a19782ebc9d80edd029d.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/hint/show-hint-73cee510931955d5b1a2831beca0125e_css.html">show-hint-73cee510931955d5b1a2831beca0125e.css</a>
  
    <li><a href="../../public/assets/codemirror/addons/hint/sql-hint-9f20529fb50def3a0f4042ed552a5c55_js.html">sql-hint-9f20529fb50def3a0f4042ed552a5c55.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/hint/xml-hint-7837f24ac3df6abf0215fbc906dac2af_js.html">xml-hint-7837f24ac3df6abf0215fbc906dac2af.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/lint/coffeescript-lint-b56b3e144a141e032cc56d544883572e_js.html">coffeescript-lint-b56b3e144a141e032cc56d544883572e.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/lint/css-lint-1dfd720891ecd1d180c152fe04b98d4a_js.html">css-lint-1dfd720891ecd1d180c152fe04b98d4a.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/lint/javascript-lint-806abe0eda8bca0000e1299affe26ed0_js.html">javascript-lint-806abe0eda8bca0000e1299affe26ed0.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/lint/json-lint-e043293878f3c6a251949aa46ca419e9_js.html">json-lint-e043293878f3c6a251949aa46ca419e9.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/lint/lint-17d815e8165ec483d535bd9b0e4a5041_js.html">lint-17d815e8165ec483d535bd9b0e4a5041.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/lint/lint-75b26e8c2c14ed774a683f6acd2b04c8_css.html">lint-75b26e8c2c14ed774a683f6acd2b04c8.css</a>
  
    <li><a href="../../public/assets/codemirror/addons/lint/yaml-lint-9b290aeeac6bc7018910e04a4d50e278_js.html">yaml-lint-9b290aeeac6bc7018910e04a4d50e278.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/merge/merge-438150f7c65659c548d994f951fcb0e3_css.html">merge-438150f7c65659c548d994f951fcb0e3.css</a>
  
    <li><a href="../../public/assets/codemirror/addons/merge/merge-a278b0aa2ff8c4b29b35ebadf0fe0ea9_js.html">merge-a278b0aa2ff8c4b29b35ebadf0fe0ea9.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/mode/loadmode-7db83c7c9f4e43d52e3b79462339f7e9_js.html">loadmode-7db83c7c9f4e43d52e3b79462339f7e9.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/mode/multiplex-06d9ff9d8e4f3380927e84a3f8211012_js.html">multiplex-06d9ff9d8e4f3380927e84a3f8211012.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/mode/overlay-e131c3d4c78c5e75cc7da8f0d90630ae_js.html">overlay-e131c3d4c78c5e75cc7da8f0d90630ae.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/mode/simple-947330429bc8fcf7d0532eee5c7ee9e9_js.html">simple-947330429bc8fcf7d0532eee5c7ee9e9.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/runmode/colorize-7704003dc45ea71dcb865458dcf6fc4b_js.html">colorize-7704003dc45ea71dcb865458dcf6fc4b.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/runmode/runmode-7e5938fa7a7efe6abf97eea940d87605_js.html">runmode-7e5938fa7a7efe6abf97eea940d87605.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/runmode/runmode-standalone-30f186cbd7e72fb5d03b14c7c34f658e_js.html">runmode-standalone-30f186cbd7e72fb5d03b14c7c34f658e.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/runmode/runmode_node-fe095bff1fe687793a750de744531ce6_js.html">runmode.node-fe095bff1fe687793a750de744531ce6.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/scroll/annotatescrollbar-5b6202b03d157a07094594e8a9cc5f2a_js.html">annotatescrollbar-5b6202b03d157a07094594e8a9cc5f2a.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/scroll/scrollpastend-ccc62d0be07d9ea636c096a3de791bdd_js.html">scrollpastend-ccc62d0be07d9ea636c096a3de791bdd.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/scroll/simplescrollbars-ccbc5d8dda82666c8a908553c82b3057_js.html">simplescrollbars-ccbc5d8dda82666c8a908553c82b3057.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/scroll/simplescrollbars-e281e4e78cb90c6fca027fc9e21977bc_css.html">simplescrollbars-e281e4e78cb90c6fca027fc9e21977bc.css</a>
  
    <li><a href="../../public/assets/codemirror/addons/search/match-highlighter-2f6e0e9a34acdb92d7a144ef68d8b6cc_js.html">match-highlighter-2f6e0e9a34acdb92d7a144ef68d8b6cc.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/search/matchesonscrollbar-0426c83f73b14b1db6a24ad15a63013b_js.html">matchesonscrollbar-0426c83f73b14b1db6a24ad15a63013b.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/search/matchesonscrollbar-ead2ddecee294db182e55dc3b4b4dd0b_css.html">matchesonscrollbar-ead2ddecee294db182e55dc3b4b4dd0b.css</a>
  
    <li><a href="../../public/assets/codemirror/addons/search/search-d4f4b70e7d87fff4a2352492d558868a_js.html">search-d4f4b70e7d87fff4a2352492d558868a.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/search/searchcursor-228b05400dfe0cca9b5dd5331ae420e0_js.html">searchcursor-228b05400dfe0cca9b5dd5331ae420e0.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/selection/active-line-5ad0da5679decc36c7f23342ce9696a6_js.html">active-line-5ad0da5679decc36c7f23342ce9696a6.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/selection/mark-selection-8541fbca0e3e2bbaefda19d881181e0d_js.html">mark-selection-8541fbca0e3e2bbaefda19d881181e0d.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/selection/selection-pointer-d48d83fe0930bdacab7803f9d34dfda4_js.html">selection-pointer-d48d83fe0930bdacab7803f9d34dfda4.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/tern/tern-ab8e05b9aecb9a7e09e537ad6139522e_js.html">tern-ab8e05b9aecb9a7e09e537ad6139522e.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/tern/tern-ca431ccf332479977d4f5aafa9efc8b6_css.html">tern-ca431ccf332479977d4f5aafa9efc8b6.css</a>
  
    <li><a href="../../public/assets/codemirror/addons/tern/worker-f108490c80a7d138126518a3c0dd7477_js.html">worker-f108490c80a7d138126518a3c0dd7477.js</a>
  
    <li><a href="../../public/assets/codemirror/addons/wrap/hardwrap-875e5b28fe3692394b34cd02e179ed5c_js.html">hardwrap-875e5b28fe3692394b34cd02e179ed5c.js</a>
  
    <li><a href="../../public/assets/codemirror/keymaps/emacs-810acbdcae254d58abd2cfcd375ab4be_js.html">emacs-810acbdcae254d58abd2cfcd375ab4be.js</a>
  
    <li><a href="../../public/assets/codemirror/keymaps/sublime-d9005867e9397e606a07b9a4057f2abf_js.html">sublime-d9005867e9397e606a07b9a4057f2abf.js</a>
  
    <li><a href="../../public/assets/codemirror/keymaps/vim-6ad44dc90dab01b196439508572bf82d_js.html">vim-6ad44dc90dab01b196439508572bf82d.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/apl-ff9457c9c74c0d62fa6a6cae87d6da46_js.html">apl-ff9457c9c74c0d62fa6a6cae87d6da46.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/asterisk-31b5ec8f891f02c507caa3499e65c1cc_js.html">asterisk-31b5ec8f891f02c507caa3499e65c1cc.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/clike-9403c50242f4d11143e2aaa09127327d_js.html">clike-9403c50242f4d11143e2aaa09127327d.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/clojure-1c5bf57336df34605bcb9e9605c44fba_js.html">clojure-1c5bf57336df34605bcb9e9605c44fba.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/cobol-8435b71f6620f3fb81f82eda4fc9f5c7_js.html">cobol-8435b71f6620f3fb81f82eda4fc9f5c7.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/coffeescript-a017bafd368701b597f64d45e2f24320_js.html">coffeescript-a017bafd368701b597f64d45e2f24320.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/commonlisp-0ffb0cfb4f8f033df84e9abb6ed07614_js.html">commonlisp-0ffb0cfb4f8f033df84e9abb6ed07614.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/css-d6f137e53247511a6447673a20b4f508_js.html">css-d6f137e53247511a6447673a20b4f508.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/cypher-52595e31bc0d2bcdc343639fae81e57b_js.html">cypher-52595e31bc0d2bcdc343639fae81e57b.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/d-8d49e590cd72cdb37401e9f5caaae4aa_js.html">d-8d49e590cd72cdb37401e9f5caaae4aa.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/dart-dad40ddce69151430fe7a1d30aaae112_js.html">dart-dad40ddce69151430fe7a1d30aaae112.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/diff-24419f1e6d2cccb17767c3c46fef45db_js.html">diff-24419f1e6d2cccb17767c3c46fef45db.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/django-bcbaee07ca88330949cef75e46dd8895_js.html">django-bcbaee07ca88330949cef75e46dd8895.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/dockerfile-ba3a1ea832be6d7a01636853731e9850_js.html">dockerfile-ba3a1ea832be6d7a01636853731e9850.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/dtd-6664f0c3f26702782fc42f45f32f57f7_js.html">dtd-6664f0c3f26702782fc42f45f32f57f7.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/dylan-dd33c785142fe8e4cebbb87a43ec8a51_js.html">dylan-dd33c785142fe8e4cebbb87a43ec8a51.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/ebnf-b587ca10cf752074276ab896493234c4_js.html">ebnf-b587ca10cf752074276ab896493234c4.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/ecl-a44092000d3ba1792837ea11de699f80_js.html">ecl-a44092000d3ba1792837ea11de699f80.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/eiffel-96ce61130e899bac4f8833918ac43150_js.html">eiffel-96ce61130e899bac4f8833918ac43150.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/erlang-02e45f3c14741ed7945064d273748556_js.html">erlang-02e45f3c14741ed7945064d273748556.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/forth-ce732c2dfc889ed98abbb2604410a35f_js.html">forth-ce732c2dfc889ed98abbb2604410a35f.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/fortran-49be7bef723bfa7aa4b1b47b1826b0ae_js.html">fortran-49be7bef723bfa7aa4b1b47b1826b0ae.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/gas-301479eff233f9f08f943d93606bb2d6_js.html">gas-301479eff233f9f08f943d93606bb2d6.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/gfm-fabbc6f81b243d68cf2663e93ee38168_js.html">gfm-fabbc6f81b243d68cf2663e93ee38168.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/gherkin-62d5ddf2412bd08ce9af953388f5ed9c_js.html">gherkin-62d5ddf2412bd08ce9af953388f5ed9c.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/go-9efc00cd27cc731d80ea365dd29beac6_js.html">go-9efc00cd27cc731d80ea365dd29beac6.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/groovy-f41d4912c691b0d00edb55f91dbb08b1_js.html">groovy-f41d4912c691b0d00edb55f91dbb08b1.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/haml-b1d671d174c989404fc1c9e97c8d86ba_js.html">haml-b1d671d174c989404fc1c9e97c8d86ba.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/haskell-773c44dc25d86d380f0491d01ae5b919_js.html">haskell-773c44dc25d86d380f0491d01ae5b919.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/haxe-c77b9faaced29de0855cdd42c275c39e_js.html">haxe-c77b9faaced29de0855cdd42c275c39e.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/htmlembedded-e7c0c6f7379adfc78a327b5b3f124576_js.html">htmlembedded-e7c0c6f7379adfc78a327b5b3f124576.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/htmlmixed-5763eef6d8ae36afec1d36c184558dd7_js.html">htmlmixed-5763eef6d8ae36afec1d36c184558dd7.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/http-2dd41fedf8c2245612b5677158c33b93_js.html">http-2dd41fedf8c2245612b5677158c33b93.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/idl-1106151445ec373d9596be89d3d1483c_js.html">idl-1106151445ec373d9596be89d3d1483c.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/jade-c748d430a2200fd7cc36b0fdd38b4125_js.html">jade-c748d430a2200fd7cc36b0fdd38b4125.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/javascript-eec36c9e0e979a86ca67c5d33a35d96c_js.html">javascript-eec36c9e0e979a86ca67c5d33a35d96c.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/jinja2-7935531d9ca1926ec1f50b9ded5d2960_js.html">jinja2-7935531d9ca1926ec1f50b9ded5d2960.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/julia-672a007433dd638f10f8137b0f9d2bae_js.html">julia-672a007433dd638f10f8137b0f9d2bae.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/kotlin-6839faf7aa7e116e86ac227fb7835082_js.html">kotlin-6839faf7aa7e116e86ac227fb7835082.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/livescript-47a8261363c6ce69d95af0be131bccb8_js.html">livescript-47a8261363c6ce69d95af0be131bccb8.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/lua-7942b9ae1de5b3983292ff431853aa75_js.html">lua-7942b9ae1de5b3983292ff431853aa75.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/markdown-c548f6497533e0673323982a30be1db9_js.html">markdown-c548f6497533e0673323982a30be1db9.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/mirc-35048c6531751e9b87060ea4903d4c33_js.html">mirc-35048c6531751e9b87060ea4903d4c33.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/mllike-9727e11b08e4ce2827f702a90b5b20e8_js.html">mllike-9727e11b08e4ce2827f702a90b5b20e8.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/modelica-7e139274b00d4bf51f4da732d43e4014_js.html">modelica-7e139274b00d4bf51f4da732d43e4014.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/nginx-515eabd6d2386f01e8467ad717edb52c_js.html">nginx-515eabd6d2386f01e8467ad717edb52c.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/ntriples-ebad0e67cc311190f0e6c54baa63226c_js.html">ntriples-ebad0e67cc311190f0e6c54baa63226c.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/octave-d6de4340e6535533c123d16c39478e80_js.html">octave-d6de4340e6535533c123d16c39478e80.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/pascal-b7ec31561200e4eb168cd0bd5945fd41_js.html">pascal-b7ec31561200e4eb168cd0bd5945fd41.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/pegjs-d12d78b5274ba8456e0a5eb8f31bc159_js.html">pegjs-d12d78b5274ba8456e0a5eb8f31bc159.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/perl-682ab62bde099150b0515b57f827fee9_js.html">perl-682ab62bde099150b0515b57f827fee9.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/php-9c0ef807e499d5913461712d9f38d370_js.html">php-9c0ef807e499d5913461712d9f38d370.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/pig-31824101d8c8b87cccb2b93d7aada60d_js.html">pig-31824101d8c8b87cccb2b93d7aada60d.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/properties-4b4a27c99027c27b3b501b9d9ea926ff_js.html">properties-4b4a27c99027c27b3b501b9d9ea926ff.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/puppet-3057c8bc0f2e752104322bc925e5ce7c_js.html">puppet-3057c8bc0f2e752104322bc925e5ce7c.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/python-35db376751f259cbaa148c88dc6389f8_js.html">python-35db376751f259cbaa148c88dc6389f8.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/q-c06c99f809dfbd3229165e44e5e47ecd_js.html">q-c06c99f809dfbd3229165e44e5e47ecd.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/r-365c62cc541ee987cbfcf1f3a953c489_js.html">r-365c62cc541ee987cbfcf1f3a953c489.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/rpm-df57985d7723d09b9f9a5a7f403413b8_js.html">rpm-df57985d7723d09b9f9a5a7f403413b8.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/rst-d3a124e7d5c161a6a4d6d326f8a9d6a0_js.html">rst-d3a124e7d5c161a6a4d6d326f8a9d6a0.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/ruby-efb58cf3520958047a50f8e48eb06f90_js.html">ruby-efb58cf3520958047a50f8e48eb06f90.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/rust-b66412e10cd2f05f354a1896a310e3e7_js.html">rust-b66412e10cd2f05f354a1896a310e3e7.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/sass-16c07079a46a97be07d69facd339e4ae_js.html">sass-16c07079a46a97be07d69facd339e4ae.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/scheme-5177467bf30cbe44a2edcb47a85532c9_js.html">scheme-5177467bf30cbe44a2edcb47a85532c9.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/shell-4fdca1f99ebc7506085b6d1daaa37864_js.html">shell-4fdca1f99ebc7506085b6d1daaa37864.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/sieve-e122bf9e0bb9d153f8d81352b833a3be_js.html">sieve-e122bf9e0bb9d153f8d81352b833a3be.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/slim-5851417914661ee0d8877887ffe48e13_js.html">slim-5851417914661ee0d8877887ffe48e13.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/smalltalk-125460536bf7e2cae34b06e8b30bfa5f_js.html">smalltalk-125460536bf7e2cae34b06e8b30bfa5f.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/smarty-cfb844aa23a5a473ab5cc212ed8417f1_js.html">smarty-cfb844aa23a5a473ab5cc212ed8417f1.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/smartymixed-19b188bb1eaf620dcb3a9b05b0a0746c_js.html">smartymixed-19b188bb1eaf620dcb3a9b05b0a0746c.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/solr-fb08d0c01851dc7be0a576edc7037117_js.html">solr-fb08d0c01851dc7be0a576edc7037117.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/soy-6e1535afbe8bc5e10850ec5cfd6f2b1f_js.html">soy-6e1535afbe8bc5e10850ec5cfd6f2b1f.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/sparql-68e67c045f473aeb87506a598c65b70c_js.html">sparql-68e67c045f473aeb87506a598c65b70c.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/spreadsheet-1bc87d7e7581e37b3d7a373fe14a5e28_js.html">spreadsheet-1bc87d7e7581e37b3d7a373fe14a5e28.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/sql-55db71424fee09c2658aef4d49db3209_js.html">sql-55db71424fee09c2658aef4d49db3209.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/stex-af46969a7a276265a4ca3a1b5645898f_js.html">stex-af46969a7a276265a4ca3a1b5645898f.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/stylus-66873457a3af3551367a64d624edda90_js.html">stylus-66873457a3af3551367a64d624edda90.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/tcl-0f3af8f408e6937489eba05cd9c2a383_js.html">tcl-0f3af8f408e6937489eba05cd9c2a383.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/textile-1d42b1f3be1448c9f46d6cccf4dba598_js.html">textile-1d42b1f3be1448c9f46d6cccf4dba598.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/tiddlywiki-ae975dcea9f9226b6130d75b6329287f_js.html">tiddlywiki-ae975dcea9f9226b6130d75b6329287f.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/tiddlywiki-b5ed9228eab4bb09a1a315c161bb2438_css.html">tiddlywiki-b5ed9228eab4bb09a1a315c161bb2438.css</a>
  
    <li><a href="../../public/assets/codemirror/modes/tiki-5506a8fcb7c6fb0ce4d5a231f5b981f3_css.html">tiki-5506a8fcb7c6fb0ce4d5a231f5b981f3.css</a>
  
    <li><a href="../../public/assets/codemirror/modes/tiki-72ac8dfbe5dd0c8886000ca3df14f773_js.html">tiki-72ac8dfbe5dd0c8886000ca3df14f773.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/toml-7ad2108fb6f27f40e7bd8b1afe994c3a_js.html">toml-7ad2108fb6f27f40e7bd8b1afe994c3a.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/tornado-df99fb233f4c388945778ce26fdb42c1_js.html">tornado-df99fb233f4c388945778ce26fdb42c1.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/turtle-7fc4ab2c263f39a6c6e3ace37c0b458a_js.html">turtle-7fc4ab2c263f39a6c6e3ace37c0b458a.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/vb-429f38821657cf84bc2fb9f5dd43c1ed_js.html">vb-429f38821657cf84bc2fb9f5dd43c1ed.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/vbscript-9f3d823d70659b3e0b3586518c7d8105_js.html">vbscript-9f3d823d70659b3e0b3586518c7d8105.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/velocity-f7606a9dfae062d59a59bfc9a51b56ee_js.html">velocity-f7606a9dfae062d59a59bfc9a51b56ee.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/verilog-d1d20041701b6ce917b667a3fe326fe8_js.html">verilog-d1d20041701b6ce917b667a3fe326fe8.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/xml-d33ed75e084f6bda52b9eacc67a63088_js.html">xml-d33ed75e084f6bda52b9eacc67a63088.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/xquery-760435c710143b082eed283bdf559efd_js.html">xquery-760435c710143b082eed283bdf559efd.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/yaml-2679030f80e9050591e91a853cf3f10a_js.html">yaml-2679030f80e9050591e91a853cf3f10a.js</a>
  
    <li><a href="../../public/assets/codemirror/modes/z80-80f9a3f196d4e66c839befdce1cc5771_js.html">z80-80f9a3f196d4e66c839befdce1cc5771.js</a>
  
    <li><a href="../../public/assets/codemirror/themes/3024-day-f7b5b08405a5db14649527de4dff638e_css.html">3024-day-f7b5b08405a5db14649527de4dff638e.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/3024-night-707d4ef837b0b6bfa81b804b3520f994_css.html">3024-night-707d4ef837b0b6bfa81b804b3520f994.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/ambiance-161449aaf05c862b5a5da63f20ce1b8f_css.html">ambiance-161449aaf05c862b5a5da63f20ce1b8f.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/ambiance-mobile-946e076ba1bc07a68c47d55635851ffd_css.html">ambiance-mobile-946e076ba1bc07a68c47d55635851ffd.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/base16-dark-43c6f9630b0fc435e3844234cec4d1c5_css.html">base16-dark-43c6f9630b0fc435e3844234cec4d1c5.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/base16-light-7e7917a938227cc6a64a8bf2beb533d1_css.html">base16-light-7e7917a938227cc6a64a8bf2beb533d1.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/blackboard-5e23d398938a89f5a3fe597c1496e694_css.html">blackboard-5e23d398938a89f5a3fe597c1496e694.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/cobalt-d499b5587129e8d6a7c93abe08af70d8_css.html">cobalt-d499b5587129e8d6a7c93abe08af70d8.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/colorforth-5cccd2c5c70bc41154185f7af68a771c_css.html">colorforth-5cccd2c5c70bc41154185f7af68a771c.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/eclipse-f4878379783c7d038e528f40a7ffa889_css.html">eclipse-f4878379783c7d038e528f40a7ffa889.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/elegant-c913d5b6462c00f01d06bcee5c25bc81_css.html">elegant-c913d5b6462c00f01d06bcee5c25bc81.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/erlang-dark-7fc7dbf7a17b1d2f4151845613e72a9f_css.html">erlang-dark-7fc7dbf7a17b1d2f4151845613e72a9f.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/lesser-dark-f6cfa084dce90ef374a6c9e324874d86_css.html">lesser-dark-f6cfa084dce90ef374a6c9e324874d86.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/mbo-a5b62254afd483b1a965212bc7dabeea_css.html">mbo-a5b62254afd483b1a965212bc7dabeea.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/mdn-like-c6cf8bcb3f56f3a3265f7c3714d88859_css.html">mdn-like-c6cf8bcb3f56f3a3265f7c3714d88859.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/midnight-c2fd34a486b7e811ad8d5a862812f9c9_css.html">midnight-c2fd34a486b7e811ad8d5a862812f9c9.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/monokai-725c138989c959ec93c02cbf07b9a671_css.html">monokai-725c138989c959ec93c02cbf07b9a671.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/neat-3ef3689ff95aa77eecd5c94e47c37967_css.html">neat-3ef3689ff95aa77eecd5c94e47c37967.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/neo-f8d88636fe23d6003819ffad0ecb30bd_css.html">neo-f8d88636fe23d6003819ffad0ecb30bd.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/night-45825bb2c36a5afb5b5d7d3743dd9c4f_css.html">night-45825bb2c36a5afb5b5d7d3743dd9c4f.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/paraiso-dark-cd90eef4d76e3dc99c19aca9eace8c8c_css.html">paraiso-dark-cd90eef4d76e3dc99c19aca9eace8c8c.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/paraiso-light-8e623543644d66856f8adf4eaa5e99ca_css.html">paraiso-light-8e623543644d66856f8adf4eaa5e99ca.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/pastel-on-dark-c0d4a8e1be8c0d51ecd8ff22003b8779_css.html">pastel-on-dark-c0d4a8e1be8c0d51ecd8ff22003b8779.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/rubyblue-35fa7c42279087b8709729353d40e473_css.html">rubyblue-35fa7c42279087b8709729353d40e473.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/solarized-80250756ba1ba559fade2b19e7438074_css.html">solarized-80250756ba1ba559fade2b19e7438074.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/the-matrix-2e13f9554390ff0f581772cc531e48d2_css.html">the-matrix-2e13f9554390ff0f581772cc531e48d2.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/tomorrow-night-bright-1f7da0323ba270566d4295e4e239b6f4_css.html">tomorrow-night-bright-1f7da0323ba270566d4295e4e239b6f4.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/tomorrow-night-eighties-fb70f8adddc918ccb6af4513d1bbd674_css.html">tomorrow-night-eighties-fb70f8adddc918ccb6af4513d1bbd674.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/twilight-71004c1ba8d95754171dab5855b3a4b1_css.html">twilight-71004c1ba8d95754171dab5855b3a4b1.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/vibrant-ink-d51ece9facacc0b02d8f8ae44bad5c29_css.html">vibrant-ink-d51ece9facacc0b02d8f8ae44bad5c29.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/xq-dark-211ceb83c1ac3b55d087c6080da88897_css.html">xq-dark-211ceb83c1ac3b55d087c6080da88897.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/xq-light-5ae6130b27f90b31d2cd7a734b3fe481_css.html">xq-light-5ae6130b27f90b31d2cd7a734b3fe481.css</a>
  
    <li><a href="../../public/assets/codemirror/themes/zenburn-511a0053c4e7729cdf0d8494c0a36e17_css.html">zenburn-511a0053c4e7729cdf0d8494c0a36e17.css</a>
  
    <li><a href="../../public/assets/crypto_zq-min-5e1f86c534aa3bce269a012e672c64724e723d45ac661ee89c818ada35aaecaf_js.html">crypto_zq-min-5e1f86c534aa3bce269a012e672c64724e723d45ac661ee89c818ada35aaecaf.js</a>
  
    <li><a href="../../public/assets/crypto_zq-min-99708aacabb31af5ba8bd1393342863290b56c1ff64866428a1f5ae2c257f533_js.html">crypto_zq-min-99708aacabb31af5ba8bd1393342863290b56c1ff64866428a1f5ae2c257f533.js</a>
  
    <li><a href="../../public/assets/css/bootstrap-table_min-1002e7a799cf93a7482156a16d310615e4d31b54c7948afbdeee2b9018dbca84_css.html">bootstrap-table.min-1002e7a799cf93a7482156a16d310615e4d31b54c7948afbdeee2b9018dbca84.css</a>
  
    <li><a href="../../public/assets/css/bootstrap-table_min-3f39b76b01c215df5b73e0af4744f6b82654fe7baabbf9b25a9b355b3caffa73_css.html">bootstrap-table.min-3f39b76b01c215df5b73e0af4744f6b82654fe7baabbf9b25a9b355b3caffa73.css</a>
  
    <li><a href="../../public/assets/css/bootstrap_min-0c387d4121d11818d5243106d683103d7f3f68d3539bf9cf6c85002430661c9f_css.html">bootstrap.min-0c387d4121d11818d5243106d683103d7f3f68d3539bf9cf6c85002430661c9f.css</a>
  
    <li><a href="../../public/assets/css/bootstrap_min-3ef8c2c2cf9e67972253cc5b1cd21cf6b6ebed0312bb7452f2767019e77b61f3_css.html">bootstrap.min-3ef8c2c2cf9e67972253cc5b1cd21cf6b6ebed0312bb7452f2767019e77b61f3.css</a>
  
    <li><a href="../../public/assets/css/bootstrap_min-8d1bc6ac8d04f7fa275862efae3b751b7f5dcb775e859589e6fd042c3df7cce7_css.html">bootstrap.min-8d1bc6ac8d04f7fa275862efae3b751b7f5dcb775e859589e6fd042c3df7cce7.css</a>
  
    <li><a href="../../public/assets/css/bootstrap_min-de76d3a1a4ea855121ec02c11e3569d8c30cc66bbe78a520ecd380c231a215ed_css.html">bootstrap.min-de76d3a1a4ea855121ec02c11e3569d8c30cc66bbe78a520ecd380c231a215ed.css</a>
  
    <li><a href="../../public/assets/css/bootstrap_min-f76130ad566d6ac851e4d140ddd543a9390636f35cb24d15da65f47e88a31b20_css.html">bootstrap.min-f76130ad566d6ac851e4d140ddd543a9390636f35cb24d15da65f47e88a31b20.css</a>
  
    <li><a href="../../public/assets/css/button-104d368b49c29f6671542431d7bac4b48c785e13467e3900e2f2701c09f4987d_css.html">button-104d368b49c29f6671542431d7bac4b48c785e13467e3900e2f2701c09f4987d.css</a>
  
    <li><a href="../../public/assets/css/button-158948f67286a4bac4e3045691213a6798119c4fc687e1b22be71c77cdee566d_css.html">button-158948f67286a4bac4e3045691213a6798119c4fc687e1b22be71c77cdee566d.css</a>
  
    <li><a href="../../public/assets/css/daterangepicker-bs3-3b33ccede2f9014b66e575e505aaca9b62155a79a243672032bf3b567b8e03a3_css.html">daterangepicker-bs3-3b33ccede2f9014b66e575e505aaca9b62155a79a243672032bf3b567b8e03a3.css</a>
  
    <li><a href="../../public/assets/css/daterangepicker-bs3-fdd683278d6ec34758be799478333e78768ab7f83767945dbe33ff5aeb611721_css.html">daterangepicker-bs3-fdd683278d6ec34758be799478333e78768ab7f83767945dbe33ff5aeb611721.css</a>
  
    <li><a href="../../public/assets/css/jquery-ui-c3ca7a017458c1c1198719f5d7bc072deded15362e2db28295cba4fc7bec2b36_css.html">jquery-ui-c3ca7a017458c1c1198719f5d7bc072deded15362e2db28295cba4fc7bec2b36.css</a>
  
    <li><a href="../../public/assets/css/jquery-ui-c3f6a5c469447ce59c3f24f4eaabcc921ff5f76c19ec320854b6eb27f83c0666_css.html">jquery-ui-c3f6a5c469447ce59c3f24f4eaabcc921ff5f76c19ec320854b6eb27f83c0666.css</a>
  
    <li><a href="../../public/assets/css/styles-03de4e5b20e2c6c3dc3f4fa23d176595d02bc69d60c5ebc892a67e2e165170f3_css.html">styles-03de4e5b20e2c6c3dc3f4fa23d176595d02bc69d60c5ebc892a67e2e165170f3.css</a>
  
    <li><a href="../../public/assets/css/styles-047f9f2950b8da7c74f053a9cdaeefd634fceb2090cfa8cbb456382a89239677_css.html">styles-047f9f2950b8da7c74f053a9cdaeefd634fceb2090cfa8cbb456382a89239677.css</a>
  
    <li><a href="../../public/assets/css/styles-363495eff9f5ab96721c508f89f15a748af3730ea432db729dff81ec8987756d_css.html">styles-363495eff9f5ab96721c508f89f15a748af3730ea432db729dff81ec8987756d.css</a>
  
    <li><a href="../../public/assets/css/styles-ca865bc53bc360ccd9e31dd281b8285d8f76c46ffbf4175d884a4058249a097f_css.html">styles-ca865bc53bc360ccd9e31dd281b8285d8f76c46ffbf4175d884a4058249a097f.css</a>
  
    <li><a href="../../public/assets/css/wdatepicker-2bedc5a16a52ebbe0b3d17664d82f5f2b60d073f07f49d4f68303524bded16f1_css.html">wdatepicker-2bedc5a16a52ebbe0b3d17664d82f5f2b60d073f07f49d4f68303524bded16f1.css</a>
  
    <li><a href="../../public/assets/css/wdatepicker-4388922c425be778e11cc56c70f65c45a1b427f25c81bba0c26b1064e002a465_css.html">wdatepicker-4388922c425be778e11cc56c70f65c45a1b427f25c81bba0c26b1064e002a465.css</a>
  
    <li><a href="../../public/assets/dataTables/extras/as3/ZeroClipboard-a521ebd7f76dffcd7e8e9e2a07bc49450954a43984690290087ac4d5cbc9ad95_as.html">ZeroClipboard-a521ebd7f76dffcd7e8e9e2a07bc49450954a43984690290087ac4d5cbc9ad95.as</a>
  
    <li><a href="../../public/assets/dataTables/extras/as3/ZeroClipboardPdf-8a5273937213fe6902728d322e0f9e4f17d0743a1f457010ec36413cc6e9537b_as.html">ZeroClipboardPdf-8a5273937213fe6902728d322e0f9e4f17d0743a1f457010ec36413cc6e9537b.as</a>
  
    <li><a href="../../public/assets/datepicker/My97DatePicker-928980da30881453e8ee8fe6e70715b41ac4833428cfff800dd3a06ee14a7827_html.html">My97DatePicker-928980da30881453e8ee8fe6e70715b41ac4833428cfff800dd3a06ee14a7827.html</a>
  
    <li><a href="../../public/assets/datepicker/WdatePicker-1e920680cd3401cda6c8c8df0a3a041456d2885319e4953016598dfe4c2bdc25_js.html">WdatePicker-1e920680cd3401cda6c8c8df0a3a041456d2885319e4953016598dfe4c2bdc25.js</a>
  
    <li><a href="../../public/assets/daterangepicker-3346148bc6a072616786ba99ffd8140f3fa99d8129f208257d7a4ea3e99d98bb_js.html">daterangepicker-3346148bc6a072616786ba99ffd8140f3fa99d8129f208257d7a4ea3e99d98bb.js</a>
  
    <li><a href="../../public/assets/daterangepicker-d792fdc0d3c0739d6aac537897d93429f9eea63b5b24f6f0892385c923f32abb_js.html">daterangepicker-d792fdc0d3c0739d6aac537897d93429f9eea63b5b24f6f0892385c923f32abb.js</a>
  
    <li><a href="../../public/assets/daterangepicker-decbd6a8aad5407ad479575da41106451909f5c4363539678f6d380ae3e70458_js.html">daterangepicker-decbd6a8aad5407ad479575da41106451909f5c4363539678f6d380ae3e70458.js</a>
  
    <li><a href="../../public/assets/jquery-ui-datepicker-28168331d598e58ec42ad2f174d1f733442f17458f9baf40705a0a32736f47ac_js.html">jquery-ui-datepicker-28168331d598e58ec42ad2f174d1f733442f17458f9baf40705a0a32736f47ac.js</a>
  
    <li><a href="../../public/assets/jquery-ui-datepicker-441cc0373dcc7061f9894d477ba7d8cc2dd4040bb8474e384be8244496f3a6e0_js.html">jquery-ui-datepicker-441cc0373dcc7061f9894d477ba7d8cc2dd4040bb8474e384be8244496f3a6e0.js</a>
  
    <li><a href="../../public/assets/jquery-ui-datepicker-de5c4c369ddebc3592e363ffe88a384a5b7a723a310430bbc21547ad3bec815c_js.html">jquery-ui-datepicker-de5c4c369ddebc3592e363ffe88a384a5b7a723a310430bbc21547ad3bec815c.js</a>
  
    <li><a href="../../public/assets/jquery_min-11cf16f9fa47f38ff39b9db8c53ebbeba67b045f87f6bfdb655cc618bcf31445_js.html">jquery.min-11cf16f9fa47f38ff39b9db8c53ebbeba67b045f87f6bfdb655cc618bcf31445.js</a>
  
    <li><a href="../../public/assets/jquery_min-1a3976f9e8f3e374c215a5d50779e317409557d2c0436a6c10f32f85dd381569_js.html">jquery.min-1a3976f9e8f3e374c215a5d50779e317409557d2c0436a6c10f32f85dd381569.js</a>
  
    <li><a href="../../public/assets/jquery_min-75a7ab7a2393071fa9a809d9c4329ef09f8d7f39137780a57c7864a79438462b_js.html">jquery.min-75a7ab7a2393071fa9a809d9c4329ef09f8d7f39137780a57c7864a79438462b.js</a>
  
    <li><a href="../../public/assets/map-17cc40415e36d8dbb659d885dbbade1e0baf41a564d75699be07a2de5ab400f9_js.html">map-17cc40415e36d8dbb659d885dbbade1e0baf41a564d75699be07a2de5ab400f9.js</a>
  
    <li><a href="../../public/assets/map-1dbf25e2c6d8e87d0750d4f7059ef437266c075820a3cd2bd395de158e00c0b1_css.html">map-1dbf25e2c6d8e87d0750d4f7059ef437266c075820a3cd2bd395de158e00c0b1.css</a>
  
    <li><a href="../../public/assets/map-5e5dbd00a68e51c2ae58c332ce5469d8f529d9258e0f3593cc339c678064287c_css.html">map-5e5dbd00a68e51c2ae58c332ce5469d8f529d9258e0f3593cc339c678064287c.css</a>
  
    <li><a href="../../public/assets/map-aed13921b76c0d6b890c21bfcb1c4d004e68936944ef13594d746f9b5fda1891_js.html">map-aed13921b76c0d6b890c21bfcb1c4d004e68936944ef13594d746f9b5fda1891.js</a>
  
    <li><a href="../../public/assets/map_welcome-11a25d8d7b20099d0080959805de23fecb34080ab3e7fc795804ad804c9c3a48_js.html">map_welcome-11a25d8d7b20099d0080959805de23fecb34080ab3e7fc795804ad804c9c3a48.js</a>
  
    <li><a href="../../public/assets/map_welcome-91c74170f8940cd10e5361fd6bc03daeec7f405bbffc8fcb2ffc26feab8e1e2a_js.html">map_welcome-91c74170f8940cd10e5361fd6bc03daeec7f405bbffc8fcb2ffc26feab8e1e2a.js</a>
  
    <li><a href="../../public/assets/map_welcome-f20302ed53383276138f4613b756c519778b21eb1efeee906d78cc0682c29972_js.html">map_welcome-f20302ed53383276138f4613b756c519778b21eb1efeee906d78cc0682c29972.js</a>
  
    <li><a href="../../public/assets/moment-5df342599ecc6334717e56d6e4ed11aa302477929ff30084551867d2c07d23aa_js.html">moment-5df342599ecc6334717e56d6e4ed11aa302477929ff30084551867d2c07d23aa.js</a>
  
    <li><a href="../../public/assets/moment-ab8bc322645d39924a80f18518990c24a2b752e878fbba9e973c4ff254ed23ab_js.html">moment-ab8bc322645d39924a80f18518990c24a2b752e878fbba9e973c4ff254ed23ab.js</a>
  
    <li><a href="../../public/assets/moment-e7a2882452cfda2f2cf35b6544a60a198070026ab981097f330a60e254153a08_js.html">moment-e7a2882452cfda2f2cf35b6544a60a198070026ab981097f330a60e254153a08.js</a>
  
    <li><a href="../../public/assets/respond-3a6b651290577f11fcfbfb414f918ff6c08e03dd2d59467d19be2a584d893d2d_js.html">respond-3a6b651290577f11fcfbfb414f918ff6c08e03dd2d59467d19be2a584d893d2d.js</a>
  
    <li><a href="../../public/assets/respond-bb3e192a29a6c897c0964210aeae45c48971c5765771e77f6eb9a64bf0457dec_js.html">respond-bb3e192a29a6c897c0964210aeae45c48971c5765771e77f6eb9a64bf0457dec.js</a>
  
    <li><a href="../../public/assets/vendor/BMap/BMap_js.html">BMap.js</a>
  
    <li><a href="../../public/assets/vendor/BMap/main_js.html">main.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart_js.html">chart.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/bar_js.html">bar.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/base_js.html">base.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/chord_js.html">chord.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/eventRiver_js.html">eventRiver.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/force_js.html">force.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/funnel_js.html">funnel.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/gauge_js.html">gauge.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/island_js.html">island.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/k_js.html">k.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/line_js.html">line.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/map_js.html">map.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/pie_js.html">pie.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/radar_js.html">radar.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/chart/scatter_js.html">scatter.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component_js.html">component.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/axis_js.html">axis.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/base_js.html">base.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/categoryAxis_js.html">categoryAxis.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/dataRange_js.html">dataRange.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/dataView_js.html">dataView.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/dataZoom_js.html">dataZoom.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/grid_js.html">grid.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/legend_js.html">legend.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/polar_js.html">polar.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/roamController_js.html">roamController.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/timeline_js.html">timeline.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/title_js.html">title.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/toolbox_js.html">toolbox.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/tooltip_js.html">tooltip.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/component/valueAxis_js.html">valueAxis.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/config_js.html">config.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/data/Graph_js.html">Graph.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/data/KDTree_js.html">KDTree.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/data/Tree_js.html">Tree.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/data/quickSelect_js.html">quickSelect.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/echarts-all_js.html">echarts-all.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/echarts_js.html">echarts.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/layout/Chord_js.html">Chord.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/layout/EdgeBundling_js.html">EdgeBundling.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/layout/Force_js.html">Force.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/layout/Tree_js.html">Tree.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/layout/eventRiver_js.html">eventRiver.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/layout/forceLayoutWorker_js.html">forceLayoutWorker.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/theme/default_js.html">default.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/theme/infographic_js.html">infographic.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/theme/macarons_js.html">macarons.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/accMath_js.html">accMath.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/coordinates_js.html">coordinates.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/date_js.html">date.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/ecAnimation_js.html">ecAnimation.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/ecData_js.html">ecData.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/ecEffect_js.html">ecEffect.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/ecQuery_js.html">ecQuery.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/kwargs_js.html">kwargs.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoCoord_js.html">geoCoord.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/an_hui_geo_js.html">an_hui_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/ao_men_geo_js.html">ao_men_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/bei_jing_geo_js.html">bei_jing_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/china_geo_js.html">china_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/chong_qing_geo_js.html">chong_qing_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/fu_jian_geo_js.html">fu_jian_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/gan_su_geo_js.html">gan_su_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/guang_dong_geo_js.html">guang_dong_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/guang_xi_geo_js.html">guang_xi_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/gui_zhou_geo_js.html">gui_zhou_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/hai_nan_geo_js.html">hai_nan_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/he_bei_geo_js.html">he_bei_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/he_nan_geo_js.html">he_nan_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/hei_long_jiang_geo_js.html">hei_long_jiang_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/hu_bei_geo_js.html">hu_bei_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/hu_nan_geo_js.html">hu_nan_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/ji_lin_geo_js.html">ji_lin_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/jiang_su_geo_js.html">jiang_su_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/jiang_xi_geo_js.html">jiang_xi_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/liao_ning_geo_js.html">liao_ning_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/nei_meng_gu_geo_js.html">nei_meng_gu_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/ning_xia_geo_js.html">ning_xia_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/qing_hai_geo_js.html">qing_hai_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/shan_dong_geo_js.html">shan_dong_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/shan_xi_1_geo_js.html">shan_xi_1_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/shan_xi_2_geo_js.html">shan_xi_2_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/shang_hai_geo_js.html">shang_hai_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/si_chuan_geo_js.html">si_chuan_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/tai_wan_geo_js.html">tai_wan_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/tian_jin_geo_js.html">tian_jin_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/world_geo_js.html">world_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/xi_zang_geo_js.html">xi_zang_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/xiang_gang_geo_js.html">xiang_gang_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/xin_jiang_geo_js.html">xin_jiang_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/yun_nan_geo_js.html">yun_nan_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/geoJson/zhe_jiang_geo_js.html">zhe_jiang_geo.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/params_js.html">params.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/encode_js.html">encode.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/an_hui_geo-2c5a9278b4a882277b0663d42c6f2cb8e6d0db34d00a33bab23d2622a4c02dbe_json.html">an_hui_geo-2c5a9278b4a882277b0663d42c6f2cb8e6d0db34d00a33bab23d2622a4c02dbe.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/an_hui_geo-d982dd7ae04a2f68830c75febb465671_json.html">an_hui_geo-d982dd7ae04a2f68830c75febb465671.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/an_hui_geo_json.html">an_hui_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/ao_men_geo-8aaa706d1b74927810f2e6c281e26ab6_json.html">ao_men_geo-8aaa706d1b74927810f2e6c281e26ab6.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/ao_men_geo-e0bb0943039c1ad800d0eac551c6f3bb0ff6a0d98c6043c67596d82e9f220ca7_json.html">ao_men_geo-e0bb0943039c1ad800d0eac551c6f3bb0ff6a0d98c6043c67596d82e9f220ca7.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/ao_men_geo_json.html">ao_men_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/bei_jing_geo-615e0b165cde739b5c0cd61f34aa95ef_json.html">bei_jing_geo-615e0b165cde739b5c0cd61f34aa95ef.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/bei_jing_geo-df37738fc84ad0239e7180f7384bbec5ec5ace3615c1aac4f0105a22a4819177_json.html">bei_jing_geo-df37738fc84ad0239e7180f7384bbec5ec5ace3615c1aac4f0105a22a4819177.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/bei_jing_geo_json.html">bei_jing_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/china_city-02a3eea2ff946ee11b98456851b537b2_json.html">china_city-02a3eea2ff946ee11b98456851b537b2.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/china_city-89eacd1618deaaae4fd6abe9eb3748dfa93097668e9abdd98fae2fc26e6ee0dd_json.html">china_city-89eacd1618deaaae4fd6abe9eb3748dfa93097668e9abdd98fae2fc26e6ee0dd.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/china_city_json.html">china_city.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/china_geo-28d06d61896f33d4124168e862196c8ffacaa2ef5004d0fc65ee669ee4f06a8f_json.html">china_geo-28d06d61896f33d4124168e862196c8ffacaa2ef5004d0fc65ee669ee4f06a8f.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/china_geo-c1e79854f11e26d1885d42d223475ccf_json.html">china_geo-c1e79854f11e26d1885d42d223475ccf.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/china_geo_json.html">china_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/chong_qing_geo-365d47fbc8e4057f04feb452835d5ca52eeaa64b75da9e9bd920c1dc1020066f_json.html">chong_qing_geo-365d47fbc8e4057f04feb452835d5ca52eeaa64b75da9e9bd920c1dc1020066f.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/chong_qing_geo-ff30eab61b4b7aa96c5f595ba6575271_json.html">chong_qing_geo-ff30eab61b4b7aa96c5f595ba6575271.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/chong_qing_geo_json.html">chong_qing_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/fu_jian_geo-737387527b1814d0d7ba6ea7d9080a6a_json.html">fu_jian_geo-737387527b1814d0d7ba6ea7d9080a6a.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/fu_jian_geo-7db8b9f71413fab6c9ccc46182d628867bdfed8ce1d388114dbf662d84767840_json.html">fu_jian_geo-7db8b9f71413fab6c9ccc46182d628867bdfed8ce1d388114dbf662d84767840.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/fu_jian_geo_json.html">fu_jian_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/gan_su_geo-0d3957d2893f85d4bac0be1d13f44242618faa7ad77fa506e6655a057c58a186_json.html">gan_su_geo-0d3957d2893f85d4bac0be1d13f44242618faa7ad77fa506e6655a057c58a186.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/gan_su_geo-2f435060ab5dbb9940532c9d58e8d3b9_json.html">gan_su_geo-2f435060ab5dbb9940532c9d58e8d3b9.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/gan_su_geo_json.html">gan_su_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/guang_dong_geo-17265768c9ef508f74c284e596d804246e30424b444b5847ff34fe603a617912_json.html">guang_dong_geo-17265768c9ef508f74c284e596d804246e30424b444b5847ff34fe603a617912.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/guang_dong_geo-281b5723a9b9f082b6eb3b818fbf5ac7_json.html">guang_dong_geo-281b5723a9b9f082b6eb3b818fbf5ac7.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/guang_dong_geo_json.html">guang_dong_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/guang_xi_geo-690518364938980141bb41a31c30115b74e267dbad20f00e910c8946300a559f_json.html">guang_xi_geo-690518364938980141bb41a31c30115b74e267dbad20f00e910c8946300a559f.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/guang_xi_geo-d66b697f3715daf4ee1e65c2b5057e38_json.html">guang_xi_geo-d66b697f3715daf4ee1e65c2b5057e38.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/guang_xi_geo_json.html">guang_xi_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/gui_zhou_geo-11f9c2e947d4100c7192342fbb329b9a_json.html">gui_zhou_geo-11f9c2e947d4100c7192342fbb329b9a.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/gui_zhou_geo-5b25d5968687d7f8e66b0a9e0374586663d8406d88560e00e090157fb68edf19_json.html">gui_zhou_geo-5b25d5968687d7f8e66b0a9e0374586663d8406d88560e00e090157fb68edf19.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/gui_zhou_geo_json.html">gui_zhou_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hai_nan_geo-6e761d13f119d2660b02cab5a0ec619503f1081f185765cb86133517b45923d3_json.html">hai_nan_geo-6e761d13f119d2660b02cab5a0ec619503f1081f185765cb86133517b45923d3.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hai_nan_geo-ff5f241cf6125b05e1d0f0b9ebe24b0d_json.html">hai_nan_geo-ff5f241cf6125b05e1d0f0b9ebe24b0d.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hai_nan_geo_json.html">hai_nan_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/he_bei_geo-1574921d8f0823e1ff7d59a1f7ef14ce_json.html">he_bei_geo-1574921d8f0823e1ff7d59a1f7ef14ce.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/he_bei_geo-52720fea36ecdf33efc7dbd357b0f046baa3e69e3a4aa2735e832a6a5d26448d_json.html">he_bei_geo-52720fea36ecdf33efc7dbd357b0f046baa3e69e3a4aa2735e832a6a5d26448d.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/he_bei_geo_json.html">he_bei_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/he_nan_geo-7eabb814e936b40ab18c02ba93a92853_json.html">he_nan_geo-7eabb814e936b40ab18c02ba93a92853.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/he_nan_geo-dac481d114c60164cbdd5f62d57fcbe498fa5577a5528c1a159455ff3a6bb52b_json.html">he_nan_geo-dac481d114c60164cbdd5f62d57fcbe498fa5577a5528c1a159455ff3a6bb52b.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/he_nan_geo_json.html">he_nan_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hei_long_jiang_geo-853e47cbfe060afd2b47ebe624e6e581_json.html">hei_long_jiang_geo-853e47cbfe060afd2b47ebe624e6e581.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hei_long_jiang_geo-a3a81770d75c7a40ba966ad4c217e8c8452ba36e3d2b4717ad5f3f90c518f2d3_json.html">hei_long_jiang_geo-a3a81770d75c7a40ba966ad4c217e8c8452ba36e3d2b4717ad5f3f90c518f2d3.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hei_long_jiang_geo_json.html">hei_long_jiang_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hu_bei_geo-6799ab02dbae329522fd6cff8bab0fd9b4739775e674ff341fc53ea5adac0d6a_json.html">hu_bei_geo-6799ab02dbae329522fd6cff8bab0fd9b4739775e674ff341fc53ea5adac0d6a.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hu_bei_geo-8b72d6dde63c8720c17fcd914fe389e0_json.html">hu_bei_geo-8b72d6dde63c8720c17fcd914fe389e0.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hu_bei_geo_json.html">hu_bei_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hu_nan_geo-5eabbe9f8ccb01de94299d670b5422cd482e8c49e3bc053bc46ef393e190784b_json.html">hu_nan_geo-5eabbe9f8ccb01de94299d670b5422cd482e8c49e3bc053bc46ef393e190784b.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hu_nan_geo-e38f0b70da5b82298d1b7b3b2bfe7e64_json.html">hu_nan_geo-e38f0b70da5b82298d1b7b3b2bfe7e64.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/hu_nan_geo_json.html">hu_nan_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/ji_lin_geo-736b6e5bd5ac4dec35c25bea83381057_json.html">ji_lin_geo-736b6e5bd5ac4dec35c25bea83381057.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/ji_lin_geo-8b1e7a893b89b14a25c98f4e2a82f6c66f2ef3a9ef60a79d8b0bdd61c6d58e2a_json.html">ji_lin_geo-8b1e7a893b89b14a25c98f4e2a82f6c66f2ef3a9ef60a79d8b0bdd61c6d58e2a.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/ji_lin_geo_json.html">ji_lin_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/jiang_su_geo-95c817f991b03aa2d6d33e194a1ff37cfa196cd16358523e5b1ad282a2911c69_json.html">jiang_su_geo-95c817f991b03aa2d6d33e194a1ff37cfa196cd16358523e5b1ad282a2911c69.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/jiang_su_geo-e79f691fedbfcf71f63a305a5c6fc39e_json.html">jiang_su_geo-e79f691fedbfcf71f63a305a5c6fc39e.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/jiang_su_geo_json.html">jiang_su_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/jiang_xi_geo-189a7140e8a7d94362a34cb39a4435c1_json.html">jiang_xi_geo-189a7140e8a7d94362a34cb39a4435c1.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/jiang_xi_geo-fa0ed13106c35c2341bd477bcd17f000ad4353a0b77a2463c117cabd1ebc5514_json.html">jiang_xi_geo-fa0ed13106c35c2341bd477bcd17f000ad4353a0b77a2463c117cabd1ebc5514.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/jiang_xi_geo_json.html">jiang_xi_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/liao_ning_geo-3b69e0f7985aeb2be1b32542f4ad1f5f_json.html">liao_ning_geo-3b69e0f7985aeb2be1b32542f4ad1f5f.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/liao_ning_geo-88484edcdb7f856db2d18e9c41254c7e93a85d5a42015884661999406ae126f8_json.html">liao_ning_geo-88484edcdb7f856db2d18e9c41254c7e93a85d5a42015884661999406ae126f8.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/liao_ning_geo_json.html">liao_ning_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/nei_meng_gu_geo-127c59ad61663a69fbddef379e9044bb_json.html">nei_meng_gu_geo-127c59ad61663a69fbddef379e9044bb.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/nei_meng_gu_geo-1b8d03b7d4bf906e2b070c888dd640962850d1e171727bf9ac1a09309e4b9d7c_json.html">nei_meng_gu_geo-1b8d03b7d4bf906e2b070c888dd640962850d1e171727bf9ac1a09309e4b9d7c.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/nei_meng_gu_geo_json.html">nei_meng_gu_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/ning_xia_geo-66d524fdfd5990c534acaf14b3ef1006fd46d04fe81002e9b45c42f4016e3e54_json.html">ning_xia_geo-66d524fdfd5990c534acaf14b3ef1006fd46d04fe81002e9b45c42f4016e3e54.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/ning_xia_geo-8fa78d424b8369ad7895b784baf1c921_json.html">ning_xia_geo-8fa78d424b8369ad7895b784baf1c921.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/ning_xia_geo_json.html">ning_xia_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/qing_hai_geo-a92874f8cdfdff44206a4837e4c0abe9_json.html">qing_hai_geo-a92874f8cdfdff44206a4837e4c0abe9.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/qing_hai_geo-e22e910cef9449669a603a39c85f23e3d7b9aacfb57fa93f9df88b0d41cde032_json.html">qing_hai_geo-e22e910cef9449669a603a39c85f23e3d7b9aacfb57fa93f9df88b0d41cde032.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/qing_hai_geo_json.html">qing_hai_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shan_dong_geo-8642713d0d602a878c4fa19371e8436b_json.html">shan_dong_geo-8642713d0d602a878c4fa19371e8436b.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shan_dong_geo-92e051412294c5d4ecf48f4597cb087bb32d1cf841190ae20fe548197ed67081_json.html">shan_dong_geo-92e051412294c5d4ecf48f4597cb087bb32d1cf841190ae20fe548197ed67081.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shan_dong_geo_json.html">shan_dong_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shan_xi_1_geo-86f8c0b5d92e73b47b3d57da0193e3bc_json.html">shan_xi_1_geo-86f8c0b5d92e73b47b3d57da0193e3bc.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shan_xi_1_geo-ba3b828c2a23611b1d742324794ae5e121410baf9b8177e08a7e2313128b4f64_json.html">shan_xi_1_geo-ba3b828c2a23611b1d742324794ae5e121410baf9b8177e08a7e2313128b4f64.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shan_xi_1_geo_json.html">shan_xi_1_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shan_xi_2_geo-14a3e270b53831b531162cd20b91ec7a_json.html">shan_xi_2_geo-14a3e270b53831b531162cd20b91ec7a.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shan_xi_2_geo-29f9bcd09a370ecd5050c9d77c184a176fb8f62235ee9f206fd87a6a14bc2637_json.html">shan_xi_2_geo-29f9bcd09a370ecd5050c9d77c184a176fb8f62235ee9f206fd87a6a14bc2637.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shan_xi_2_geo_json.html">shan_xi_2_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shang_hai_geo-90f94949831f68ff1f5ba671852a6bea_json.html">shang_hai_geo-90f94949831f68ff1f5ba671852a6bea.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shang_hai_geo-e9d44622be2bc8b4e217284644f7da5d0957b9679f0d33ea8c0cbce008582d9e_json.html">shang_hai_geo-e9d44622be2bc8b4e217284644f7da5d0957b9679f0d33ea8c0cbce008582d9e.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/shang_hai_geo_json.html">shang_hai_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/si_chuan_geo-219c88084ace469c800cf6101697a9904b20f580eefce622b602030582d3015c_json.html">si_chuan_geo-219c88084ace469c800cf6101697a9904b20f580eefce622b602030582d3015c.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/si_chuan_geo-63ab465a90a2e32be8411973296fb832_json.html">si_chuan_geo-63ab465a90a2e32be8411973296fb832.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/si_chuan_geo_json.html">si_chuan_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/tai_wan_geo-d3a138a28570fcc804567458d2aed78c78928f48afe4f51146177bfe2d7339e6_json.html">tai_wan_geo-d3a138a28570fcc804567458d2aed78c78928f48afe4f51146177bfe2d7339e6.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/tai_wan_geo-e3b99670353ffe533f42c4104c4287b9_json.html">tai_wan_geo-e3b99670353ffe533f42c4104c4287b9.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/tai_wan_geo_json.html">tai_wan_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/tian_jin_geo-1a190311a5f8cf71e004f9da60411d67_json.html">tian_jin_geo-1a190311a5f8cf71e004f9da60411d67.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/tian_jin_geo-e118f049fd28619a24540352c32a9746a872b624a3aee9c6e3f2d291060c4b99_json.html">tian_jin_geo-e118f049fd28619a24540352c32a9746a872b624a3aee9c6e3f2d291060c4b99.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/tian_jin_geo_json.html">tian_jin_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/world_geo-169e0fe54e06be78decf5b668a365c3e3db50db35729ad488e546c8d42bcbe22_json.html">world_geo-169e0fe54e06be78decf5b668a365c3e3db50db35729ad488e546c8d42bcbe22.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/world_geo-34b1abad6861cf1079f5ffac8cc40b8a_json.html">world_geo-34b1abad6861cf1079f5ffac8cc40b8a.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/world_geo_json.html">world_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/xi_zang_geo-6ccbcdb166183acd4adc4113d74320d7_json.html">xi_zang_geo-6ccbcdb166183acd4adc4113d74320d7.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/xi_zang_geo-e0d33f4877cf1b57a43aa33f721b2123cbf82d6a33e83f468bdcc97e73fba062_json.html">xi_zang_geo-e0d33f4877cf1b57a43aa33f721b2123cbf82d6a33e83f468bdcc97e73fba062.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/xi_zang_geo_json.html">xi_zang_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/xiang_gang_geo-604c285fea46be803a4b8f5582f92875_json.html">xiang_gang_geo-604c285fea46be803a4b8f5582f92875.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/xiang_gang_geo-7daefd1b9e107116cae8475c1bc8aa6232bff40104d92d6f2d17dd461a448230_json.html">xiang_gang_geo-7daefd1b9e107116cae8475c1bc8aa6232bff40104d92d6f2d17dd461a448230.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/xiang_gang_geo_json.html">xiang_gang_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/xin_jiang_geo-5b25f6830d9bf6b40b33267de00fbb3a_json.html">xin_jiang_geo-5b25f6830d9bf6b40b33267de00fbb3a.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/xin_jiang_geo-7be7af1c5080a14df9846d0a27a113a7b6edfba809e3f1b431255cd09cda8e53_json.html">xin_jiang_geo-7be7af1c5080a14df9846d0a27a113a7b6edfba809e3f1b431255cd09cda8e53.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/xin_jiang_geo_json.html">xin_jiang_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/yun_nan_geo-a20ef5022f0cbbd4b47b52f139009325_json.html">yun_nan_geo-a20ef5022f0cbbd4b47b52f139009325.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/yun_nan_geo-b46730f795eba219743212565ae74441d3d31cfc0662ebdb978eef4db9fd78f8_json.html">yun_nan_geo-b46730f795eba219743212565ae74441d3d31cfc0662ebdb978eef4db9fd78f8.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/yun_nan_geo_json.html">yun_nan_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/zhe_jiang_geo-10ee32fed979c9b37e734555d2b1c591d02efc5bbf3cbc281ce01e7284434e18_json.html">zhe_jiang_geo-10ee32fed979c9b37e734555d2b1c591d02efc5bbf3cbc281ce01e7284434e18.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/zhe_jiang_geo-3ac39066879822f86f23d81647d6e243_json.html">zhe_jiang_geo-3ac39066879822f86f23d81647d6e243.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/rawData/geoJson/zhe_jiang_geo_json.html">zhe_jiang_geo.json</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/mapData/textFixed_js.html">textFixed.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/ndarray_js.html">ndarray.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/number_js.html">number.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/projection/albers_js.html">albers.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/projection/mercator_js.html">mercator.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/projection/normal_js.html">normal.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/projection/svg_js.html">svg.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/Candle_js.html">Candle.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/Chain_js.html">Chain.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/Cross_js.html">Cross.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/GaugePointer_js.html">GaugePointer.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/HalfSmoothPolygon_js.html">HalfSmoothPolygon.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/HandlePolygon_js.html">HandlePolygon.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/Icon_js.html">Icon.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/MarkLine_js.html">MarkLine.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/Ribbon_js.html">Ribbon.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/Symbol_js.html">Symbol.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/shape/normalIsCover_js.html">normalIsCover.js</a>
  
    <li><a href="../../public/assets/vendor/echarts/util/smartSteps_js.html">smartSteps.js</a>
  
    <li><a href="../../public/assets/vendor/echartshart/base_js.html">base.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/Group_js.html">Group.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/Handler_js.html">Handler.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/Layer_js.html">Layer.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/Painter_js.html">Painter.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/Storage_js.html">Storage.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/animation/Animation_js.html">Animation.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/animation/Clip_js.html">Clip.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/animation/easing_js.html">easing.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/config_js.html">config.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/dep/excanvas_js.html">excanvas.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/dep/excanvas2_js.html">excanvas2.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/dep/excanvas3_js.html">excanvas3.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/loadingEffect/Bar_js.html">Bar.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/loadingEffect/Base_js.html">Base.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/loadingEffect/Bubble_js.html">Bubble.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/loadingEffect/DynamicLine_js.html">DynamicLine.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/loadingEffect/Ring_js.html">Ring.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/loadingEffect/Spin_js.html">Spin.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/loadingEffect/Whirling_js.html">Whirling.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/mixin/Eventful_js.html">Eventful.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/mixin/Transformable_js.html">Transformable.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Base_js.html">Base.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/BezierCurve_js.html">BezierCurve.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Circle_js.html">Circle.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Droplet_js.html">Droplet.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Ellipse_js.html">Ellipse.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Heart_js.html">Heart.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Image_js.html">Image.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Isogon_js.html">Isogon.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Line_js.html">Line.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Path_js.html">Path.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Polygon_js.html">Polygon.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Polyline_js.html">Polyline.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Rectangle_js.html">Rectangle.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Ring_js.html">Ring.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Rose_js.html">Rose.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Sector_js.html">Sector.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/ShapeBundle_js.html">ShapeBundle.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Star_js.html">Star.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Text_js.html">Text.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/Trochoid_js.html">Trochoid.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/util/PathProxy_js.html">PathProxy.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/util/dashedLineTo_js.html">dashedLineTo.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/util/smoothBezier_js.html">smoothBezier.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/shape/util/smoothSpline_js.html">smoothSpline.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/area_js.html">area.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/color_js.html">color.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/computeBoundingBox_js.html">computeBoundingBox.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/curve_js.html">curve.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/env_js.html">env.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/event_js.html">event.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/guid_js.html">guid.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/http_js.html">http.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/log_js.html">log.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/math_js.html">math.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/matrix_js.html">matrix.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/util_js.html">util.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/tool/vector_js.html">vector.js</a>
  
    <li><a href="../../public/assets/vendor/zrender/zrender_js.html">zrender.js</a>
  
    <li><a href="../../public/favicon_ico.html">favicon.ico</a>
  
    <li><a href="../../public/robots_txt.html">robots</a>
  
    <li><a href="../../restart_txt.html">restart</a>
  
    <li><a href="../../runfix15_sh.html">runfix15.sh</a>
  
    <li><a href="../../runfix25_sh.html">runfix25.sh</a>
  
    <li><a href="../../runfix9_sh.html">runfix9.sh</a>
  
    <li><a href="../../runfixLF_sh.html">runfixLF.sh</a>
  
    <li><a href="../../runfixrank74_sh.html">runfixrank74.sh</a>
  
    <li><a href="../../send_mails_sh.html">send_mails.sh</a>
  
    <li><a href="../../send_mails_zqq_sh.html">send_mails_zqq.sh</a>
  
    <li><a href="../../subindex_html.html">subindex.html</a>
  
    <li><a href="../../vendor/1.html">1</a>
  
    <li><a href="../../vendor/2.html">2</a>
  
    <li><a href="../../vendor/Meteoinfo/baoding_txt.html">baoding</a>
  
    <li><a href="../../vendor/Meteoinfo/beijing_txt.html">beijing</a>
  
    <li><a href="../../vendor/Meteoinfo/cangzhou_txt.html">cangzhou</a>
  
    <li><a href="../../vendor/Meteoinfo/chengde_txt.html">chengde</a>
  
    <li><a href="../../vendor/Meteoinfo/handan_txt.html">handan</a>
  
    <li><a href="../../vendor/Meteoinfo/hengshui_txt.html">hengshui</a>
  
    <li><a href="../../vendor/Meteoinfo/langfang_txt.html">langfang</a>
  
    <li><a href="../../vendor/Meteoinfo/qinhuangdao_txt.html">qinhuangdao</a>
  
    <li><a href="../../vendor/Meteoinfo/shijiazhuang_txt.html">shijiazhuang</a>
  
    <li><a href="../../vendor/Meteoinfo/tangshan_txt.html">tangshan</a>
  
    <li><a href="../../vendor/Meteoinfo/tianjin_txt.html">tianjin</a>
  
    <li><a href="../../vendor/Meteoinfo/xingtai_txt.html">xingtai</a>
  
    <li><a href="../../vendor/Meteoinfo/zhangjiakou_txt.html">zhangjiakou</a>
  
    <li><a href="../../vendor/getdata/citykey_txt.html">citykey</a>
  
    <li><a href="../../vendor/getdata/common_rb_bak.html">common.rb.bak</a>
  
    <li><a href="../../vendor/hn_txt.html">hn</a>
  
    <li><a href="../../vendor/map/hebei_city1_prj.html">hebei_city1.prj</a>
  
    <li><a href="../../vendor/map/heibei_prj.html">heibei.prj</a>
  
    <li><a href="../../vendor/map/poly_region_prj.html">poly_region.prj</a>
  
    <li><a href="../../vendor/rm_qcity_in_city_table_EXT.html">rm_qcity_in_city_table.EXT</a>
  
    <li><a href="../../vendor/station_EXT.html">station.EXT</a>
  
    <li><a href="../../vendor/station_EXT_9km.html">station.EXT_9km</a>
  
    <li><a href="../../vendor/station_EXT_bak.html">station.EXT_bak</a>
  
    <li><a href="../../vendor/station_EXT_lb.html">station.EXT_lb</a>
  
    <li><a href="../../vendor/station_EXT_old.html">station.EXT_old</a>
  
    <li><a href="../../vendor/station_60_EXT.html">station_60.EXT</a>
  
    <li><a href="../../vendor/station_bd_EXT.html">station_bd.EXT</a>
  
    <li><a href="../../vendor/station_hb_EXT.html">station_hb.EXT</a>
  
    <li><a href="../../vendor/station_hb_EXT_bak.html">station_hb.EXT_bak</a>
  
    <li><a href="../../vendor/station_hn_EXT.html">station_hn.EXT</a>
  
    <li><a href="../../vendor/test_txt.html">test</a>
  
    <li><a href="../../vendor/tydata.html">tydata</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page public/assets/application-156c0c51078c74a6f4a4e9b64a78597df2f9d7704c6e446ca7029a516189ff9c.js">

<pre>!
 jQuery JavaScript Library v1.11.1
 http://jquery.com/

 Includes Sizzle.js
 http://sizzlejs.com/

 Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 Released under the MIT license
 http://jquery.org/license

 Date: 2014-05-01T17:42Z</pre>

<p>(function( global, factory ) {</p>

<pre>if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) {
        // For CommonJS and CommonJS-like environments where a proper window is present,
        // execute the factory and get jQuery
        // For environments that do not inherently posses a window with a document
        // (such as Node.js), expose a jQuery-making factory as module.exports
        // This accentuates the need for the creation of a real window
        // e.g. var jQuery = require(&quot;jquery&quot;)(window);
        // See ticket #14549 for more info
        module.exports = global.document ?
                factory( global, true ) :
                function( w ) {
                        if ( !w.document ) {
                                throw new Error( &quot;jQuery requires a window with a document&quot; );
                        }
                        return factory( w );
                };
} else {
        factory( global );
}</pre>

<p>// Pass this if window is not defined yet }(typeof window !== undefined ?
window : this, function( window, noGlobal ) {</p>

<p>// Can&#39;t do this because several apps including ASP.NET trace // the
stack via arguments.caller.callee and Firefox dies if // you try to trace
through use strict call chains. (#13335) // Support: Firefox 18+ //</p>

<p>var deletedIds = [];</p>

<p>var slice = deletedIds.slice;</p>

<p>var concat = deletedIds.concat;</p>

<p>var push = deletedIds.push;</p>

<p>var indexOf = deletedIds.indexOf;</p>

<p>var class2type = {};</p>

<p>var toString = class2type.toString;</p>

<p>var hasOwn = class2type.hasOwnProperty;</p>

<p>var support = {};</p>

<p>var</p>

<pre>version = &quot;1.11.1&quot;,

// Define a local copy of jQuery
jQuery = function( selector, context ) {
        // The jQuery object is actually just the init constructor &#39;enhanced&#39;
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init( selector, context );
},

// Support: Android&lt;4.1, IE&lt;9
// Make sure we trim BOM and NBSP
rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

// Matches dashed string for camelizing
rmsPrefix = /^-ms-/,
rdashAlpha = /-([\da-z])/gi,

// Used by jQuery.camelCase as callback to replace()
fcamelCase = function( all, letter ) {
        return letter.toUpperCase();
};</pre>

<p>jQuery.fn = jQuery.prototype = {</p>

<pre>// The current version of jQuery being used
jquery: version,

constructor: jQuery,

// Start with an empty selector
selector: &quot;&quot;,

// The default length of a jQuery object is 0
length: 0,

toArray: function() {
        return slice.call( this );
},

// Get the Nth element in the matched element set OR
// Get the whole matched element set as a clean array
get: function( num ) {
        return num != null ?

                // Return just the one element from the set
                ( num &lt; 0 ? this[ num + this.length ] : this[ num ] ) :

                // Return all the elements in a clean array
                slice.call( this );
},

// Take an array of elements and push it onto the stack
// (returning the new matched element set)
pushStack: function( elems ) {

        // Build a new jQuery matched element set
        var ret = jQuery.merge( this.constructor(), elems );

        // Add the old object onto the stack (as a reference)
        ret.prevObject = this;
        ret.context = this.context;

        // Return the newly-formed element set
        return ret;
},

// Execute a callback for every element in the matched set.
// (You can seed the arguments with an array of args, but this is
// only used internally.)
each: function( callback, args ) {
        return jQuery.each( this, callback, args );
},

map: function( callback ) {
        return this.pushStack( jQuery.map(this, function( elem, i ) {
                return callback.call( elem, i, elem );
        }));
},

slice: function() {
        return this.pushStack( slice.apply( this, arguments ) );
},

first: function() {
        return this.eq( 0 );
},

last: function() {
        return this.eq( -1 );
},

eq: function( i ) {
        var len = this.length,
                j = +i + ( i &lt; 0 ? len : 0 );
        return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] );
},

end: function() {
        return this.prevObject || this.constructor(null);
},

// For internal use only.
// Behaves like an Array&#39;s method, not like a jQuery method.
push: push,
sort: deletedIds.sort,
splice: deletedIds.splice</pre>

<p>};</p>

<p>jQuery.extend = jQuery.fn.extend = function() {</p>

<pre>var src, copyIsArray, copy, name, options, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

// Handle a deep copy situation
if ( typeof target === &quot;boolean&quot; ) {
        deep = target;

        // skip the boolean and the target
        target = arguments[ i ] || {};
        i++;
}

// Handle case when target is a string or something (possible in deep copy)
if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) {
        target = {};
}

// extend jQuery itself if only one argument is passed
if ( i === length ) {
        target = this;
        i--;
}

for ( ; i &lt; length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                        src = target[ name ];
                        copy = options[ name ];

                        // Prevent never-ending loop
                        if ( target === copy ) {
                                continue;
                        }

                        // Recurse if we&#39;re merging plain objects or arrays
                        if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                                if ( copyIsArray ) {
                                        copyIsArray = false;
                                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];

                                } else {
                                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don&#39;t bring in undefined values
                        } else if ( copy !== undefined ) {
                                target[ name ] = copy;
                        }
                }
        }
}

// Return the modified object
return target;</pre>

<p>};</p>

<p>jQuery.extend({</p>

<pre>// Unique for each copy of jQuery on the page
expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),

// Assume jQuery is ready without the ready module
isReady: true,

error: function( msg ) {
        throw new Error( msg );
},

noop: function() {},

// See test/unit/core.js for details concerning isFunction.
// Since version 1.3, DOM methods and functions like alert
// aren&#39;t supported. They return false on IE (#2968).
isFunction: function( obj ) {
        return jQuery.type(obj) === &quot;function&quot;;
},

isArray: Array.isArray || function( obj ) {
        return jQuery.type(obj) === &quot;array&quot;;
},

isWindow: function( obj ) {
           jshint eqeqeq: false   
        return obj != null &amp;&amp; obj == obj.window;
},

isNumeric: function( obj ) {
        // parseFloat NaNs numeric-cast false positives (null|true|false|&quot;&quot;)
        // ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)
        // subtraction forces infinities to NaN
        return !jQuery.isArray( obj ) &amp;&amp; obj - parseFloat( obj ) &gt;= 0;
},

isEmptyObject: function( obj ) {
        var name;
        for ( name in obj ) {
                return false;
        }
        return true;
},

isPlainObject: function( obj ) {
        var key;

        // Must be an Object.
        // Because of IE, we also have to check the presence of the constructor property.
        // Make sure that DOM nodes and window objects don&#39;t pass through, as well
        if ( !obj || jQuery.type(obj) !== &quot;object&quot; || obj.nodeType || jQuery.isWindow( obj ) ) {
                return false;
        }

        try {
                // Not own constructor property must be Object
                if ( obj.constructor &amp;&amp;
                        !hasOwn.call(obj, &quot;constructor&quot;) &amp;&amp;
                        !hasOwn.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;) ) {
                        return false;
                }
        } catch ( e ) {
                // IE8,9 Will throw exceptions on certain host objects #9897
                return false;
        }

        // Support: IE&lt;9
        // Handle iteration over inherited properties before own properties.
        if ( support.ownLast ) {
                for ( key in obj ) {
                        return hasOwn.call( obj, key );
                }
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.
        for ( key in obj ) {}

        return key === undefined || hasOwn.call( obj, key );
},

type: function( obj ) {
        if ( obj == null ) {
                return obj + &quot;&quot;;
        }
        return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
                class2type[ toString.call(obj) ] || &quot;object&quot; :
                typeof obj;
},

// Evaluates a script in a global context
// Workarounds based on findings by Jim Driscoll
// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
globalEval: function( data ) {
        if ( data &amp;&amp; jQuery.trim( data ) ) {
                // We use execScript on Internet Explorer
                // We use an anonymous function so that context is window
                // rather than jQuery in Firefox
                ( window.execScript || function( data ) {
                        window[ &quot;eval&quot; ].call( window, data );
                } )( data );
        }
},

// Convert dashed to camelCase; used by the css and data modules
// Microsoft forgot to hump their vendor prefix (#9572)
camelCase: function( string ) {
        return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );
},

nodeName: function( elem, name ) {
        return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
},

// args is for internal usage only
each: function( obj, callback, args ) {
        var value,
                i = 0,
                length = obj.length,
                isArray = isArraylike( obj );

        if ( args ) {
                if ( isArray ) {
                        for ( ; i &lt; length; i++ ) {
                                value = callback.apply( obj[ i ], args );

                                if ( value === false ) {
                                        break;
                                }
                        }
                } else {
                        for ( i in obj ) {
                                value = callback.apply( obj[ i ], args );

                                if ( value === false ) {
                                        break;
                                }
                        }
                }

        // A special, fast, case for the most common use of each
        } else {
                if ( isArray ) {
                        for ( ; i &lt; length; i++ ) {
                                value = callback.call( obj[ i ], i, obj[ i ] );

                                if ( value === false ) {
                                        break;
                                }
                        }
                } else {
                        for ( i in obj ) {
                                value = callback.call( obj[ i ], i, obj[ i ] );

                                if ( value === false ) {
                                        break;
                                }
                        }
                }
        }

        return obj;
},

// Support: Android&lt;4.1, IE&lt;9
trim: function( text ) {
        return text == null ?
                &quot;&quot; :
                ( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
},

// results is for internal usage only
makeArray: function( arr, results ) {
        var ret = results || [];

        if ( arr != null ) {
                if ( isArraylike( Object(arr) ) ) {
                        jQuery.merge( ret,
                                typeof arr === &quot;string&quot; ?
                                [ arr ] : arr
                        );
                } else {
                        push.call( ret, arr );
                }
        }

        return ret;
},

inArray: function( elem, arr, i ) {
        var len;

        if ( arr ) {
                if ( indexOf ) {
                        return indexOf.call( arr, elem, i );
                }

                len = arr.length;
                i = i ? i &lt; 0 ? Math.max( 0, len + i ) : i : 0;

                for ( ; i &lt; len; i++ ) {
                        // Skip accessing in sparse arrays
                        if ( i in arr &amp;&amp; arr[ i ] === elem ) {
                                return i;
                        }
                }
        }

        return -1;
},

merge: function( first, second ) {
        var len = +second.length,
                j = 0,
                i = first.length;

        while ( j &lt; len ) {
                first[ i++ ] = second[ j++ ];
        }

        // Support: IE&lt;9
        // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
        if ( len !== len ) {
                while ( second[j] !== undefined ) {
                        first[ i++ ] = second[ j++ ];
                }
        }

        first.length = i;

        return first;
},

grep: function( elems, callback, invert ) {
        var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

        // Go through the array, only saving the items
        // that pass the validator function
        for ( ; i &lt; length; i++ ) {
                callbackInverse = !callback( elems[ i ], i );
                if ( callbackInverse !== callbackExpect ) {
                        matches.push( elems[ i ] );
                }
        }

        return matches;
},

// arg is for internal usage only
map: function( elems, callback, arg ) {
        var value,
                i = 0,
                length = elems.length,
                isArray = isArraylike( elems ),
                ret = [];

        // Go through the array, translating each of the items to their new values
        if ( isArray ) {
                for ( ; i &lt; length; i++ ) {
                        value = callback( elems[ i ], i, arg );

                        if ( value != null ) {
                                ret.push( value );
                        }
                }

        // Go through every key on the object,
        } else {
                for ( i in elems ) {
                        value = callback( elems[ i ], i, arg );

                        if ( value != null ) {
                                ret.push( value );
                        }
                }
        }

        // Flatten any nested arrays
        return concat.apply( [], ret );
},

// A global GUID counter for objects
guid: 1,

// Bind a function to a context, optionally partially applying any
// arguments.
proxy: function( fn, context ) {
        var args, proxy, tmp;

        if ( typeof context === &quot;string&quot; ) {
                tmp = fn[ context ];
                context = fn;
                fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if ( !jQuery.isFunction( fn ) ) {
                return undefined;
        }

        // Simulated bind
        args = slice.call( arguments, 2 );
        proxy = function() {
                return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
},

now: function() {
        return +( new Date() );
},

// jQuery.support is not used in Core but other projects attach their
// properties to it so it needs to exist.
support: support</pre>

<p>});</p>

<p>// Populate the class2type map jQuery.each(Boolean Number String Function
Array Date RegExp <a href="../../Object.html">Object</a> Error.split( ),
function(i, name) {</p>

<pre class="ruby"><span class="ruby-identifier">class2type</span>[ <span class="ruby-string">&quot;[object &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;]&quot;</span> ] = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">toLowerCase</span>();
</pre>

<p>});</p>

<p>function isArraylike( obj ) {</p>

<pre>var length = obj.length,
        type = jQuery.type( obj );

if ( type === &quot;function&quot; || jQuery.isWindow( obj ) ) {
        return false;
}

if ( obj.nodeType === 1 &amp;&amp; length ) {
        return true;
}

return type === &quot;array&quot; || length === 0 ||
        typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;</pre>

<p>} var Sizzle = /*!</p>

<pre> Sizzle CSS Selector Engine v1.10.19
 http://sizzlejs.com/

 Copyright 2013 jQuery Foundation, Inc. and other contributors
 Released under the MIT license
 http://jquery.org/license

 Date: 2014-04-18
/</pre>

<p>(function( window ) {</p>

<p>var i,</p>

<pre>support,
Expr,
getText,
isXML,
tokenize,
compile,
select,
outermostContext,
sortInput,
hasDuplicate,

// Local document vars
setDocument,
document,
docElem,
documentIsHTML,
rbuggyQSA,
rbuggyMatches,
matches,
contains,

// Instance-specific data
expando = &quot;sizzle&quot; + -(new Date()),
preferredDoc = window.document,
dirruns = 0,
done = 0,
classCache = createCache(),
tokenCache = createCache(),
compilerCache = createCache(),
sortOrder = function( a, b ) {
        if ( a === b ) {
                hasDuplicate = true;
        }
        return 0;
},

// General-purpose constants
strundefined = typeof undefined,
MAX_NEGATIVE = 1 &lt;&lt; 31,

// Instance methods
hasOwn = ({}).hasOwnProperty,
arr = [],
pop = arr.pop,
push_native = arr.push,
push = arr.push,
slice = arr.slice,
// Use a stripped-down indexOf if we can&#39;t use a native one
indexOf = arr.indexOf || function( elem ) {
        var i = 0,
                len = this.length;
        for ( ; i &lt; len; i++ ) {
                if ( this[i] === elem ) {
                        return i;
                }
        }
        return -1;
},

booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,

// Regular expressions

// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,
// http://www.w3.org/TR/css3-syntax/#characters
characterEncoding = &quot;(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+&quot;,

// Loosely modeled on CSS identifier characters
// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
identifier = characterEncoding.replace( &quot;w&quot;, &quot;w#&quot; ),

// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + characterEncoding + &quot;)(?:&quot; + whitespace +
        // Operator (capture 2)
        &quot;*([*^$|!~]?=)&quot; + whitespace +
        // &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;
        &quot;*(?:&#39;((?:\\\\.|[^\\\\&#39;])*)&#39;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;|(&quot; + identifier + &quot;))|)&quot; + whitespace +
        &quot;*\\]&quot;,

pseudos = &quot;:(&quot; + characterEncoding + &quot;)(?:\\((&quot; +
        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        &quot;(&#39;((?:\\\\.|[^\\\\&#39;])*)&#39;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;)|&quot; +
        // 2. simple (capture 6)
        &quot;((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes + &quot;)*)|&quot; +
        // 3. anything else (capture 2)
        &quot;.*&quot; +
        &quot;)\\)|)&quot;,

// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),

rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace + &quot;)&quot; + whitespace + &quot;*&quot; ),

rattributeQuotes = new RegExp( &quot;=&quot; + whitespace + &quot;*([^\\]&#39;\&quot;]*?)&quot; + whitespace + &quot;*\\]&quot;, &quot;g&quot; ),

rpseudo = new RegExp( pseudos ),
ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),

matchExpr = {
        &quot;ID&quot;: new RegExp( &quot;^#(&quot; + characterEncoding + &quot;)&quot; ),
        &quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + characterEncoding + &quot;)&quot; ),
        &quot;TAG&quot;: new RegExp( &quot;^(&quot; + characterEncoding.replace( &quot;w&quot;, &quot;w*&quot; ) + &quot;)&quot; ),
        &quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
        &quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
        &quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
                &quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
                &quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
        &quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        &quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
                whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
},

rinputs = /^(?:input|select|textarea|button)$/i,
rheader = /^h\d$/i,

rnative = /^[^{]+\{\s*\[native \w/,

// Easily-parseable/retrievable ID or TAG or CLASS selectors
rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

rsibling = /[+~]/,
rescape = /&#39;|\\/g,

// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
funescape = function( _, escaped, escapedWhitespace ) {
        var high = &quot;0x&quot; + escaped - 0x10000;
        // NaN means non-codepoint
        // Support: Firefox&lt;24
        // Workaround erroneous numeric interpretation of +&quot;0x&quot;
        return high !== high || escapedWhitespace ?
                escaped :
                high &lt; 0 ?
                        // BMP codepoint
                        String.fromCharCode( high + 0x10000 ) :
                        // Supplemental Plane codepoint (surrogate pair)
                        String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
};</pre>

<p>// Optimize for push.apply( _, NodeList ) try {</p>

<pre>push.apply(
        (arr = slice.call( preferredDoc.childNodes )),
        preferredDoc.childNodes
);
// Support: Android&lt;4.0
// Detect silently failing push.apply
arr[ preferredDoc.childNodes.length ].nodeType;</pre>

<p>} catch ( e ) {</p>

<pre>push = { apply: arr.length ?

        // Leverage slice if possible
        function( target, els ) {
                push_native.apply( target, slice.call(els) );
        } :

        // Support: IE&lt;9
        // Otherwise append directly
        function( target, els ) {
                var j = target.length,
                        i = 0;
                // Can&#39;t trust NodeList.length
                while ( (target[j++] = els[i++]) ) {}
                target.length = j - 1;
        }
};</pre>

<p>}</p>

<p>function Sizzle( selector, context, results, seed ) {</p>

<pre>var match, elem, m, nodeType,
        // QSA vars
        i, groups, old, nid, newContext, newSelector;

if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
        setDocument( context );
}

context = context || document;
results = results || [];

if ( !selector || typeof selector !== &quot;string&quot; ) {
        return results;
}

if ( (nodeType = context.nodeType) !== 1 &amp;&amp; nodeType !== 9 ) {
        return [];
}

if ( documentIsHTML &amp;&amp; !seed ) {

        // Shortcuts
        if ( (match = rquickExpr.exec( selector )) ) {
                // Speed-up: Sizzle(&quot;#ID&quot;)
                if ( (m = match[1]) ) {
                        if ( nodeType === 9 ) {
                                elem = context.getElementById( m );
                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document (jQuery #6963)
                                if ( elem &amp;&amp; elem.parentNode ) {
                                        // Handle the case where IE, Opera, and Webkit return items
                                        // by name instead of ID
                                        if ( elem.id === m ) {
                                                results.push( elem );
                                                return results;
                                        }
                                } else {
                                        return results;
                                }
                        } else {
                                // Context is not a document
                                if ( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp;
                                        contains( context, elem ) &amp;&amp; elem.id === m ) {
                                        results.push( elem );
                                        return results;
                                }
                        }

                // Speed-up: Sizzle(&quot;TAG&quot;)
                } else if ( match[2] ) {
                        push.apply( results, context.getElementsByTagName( selector ) );
                        return results;

                // Speed-up: Sizzle(&quot;.CLASS&quot;)
                } else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp; context.getElementsByClassName ) {
                        push.apply( results, context.getElementsByClassName( m ) );
                        return results;
                }
        }

        // QSA path
        if ( support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
                nid = old = expando;
                newContext = context;
                newSelector = nodeType === 9 &amp;&amp; selector;

                // qSA works strangely on Element-rooted queries
                // We can work around this by specifying an extra ID on the root
                // and working up from there (Thanks to Andrew Dupont for the technique)
                // IE 8 doesn&#39;t work on object elements
                if ( nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot; ) {
                        groups = tokenize( selector );

                        if ( (old = context.getAttribute(&quot;id&quot;)) ) {
                                nid = old.replace( rescape, &quot;\\$&amp;&quot; );
                        } else {
                                context.setAttribute( &quot;id&quot;, nid );
                        }
                        nid = &quot;[id=&#39;&quot; + nid + &quot;&#39;] &quot;;

                        i = groups.length;
                        while ( i-- ) {
                                groups[i] = nid + toSelector( groups[i] );
                        }
                        newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context;
                        newSelector = groups.join(&quot;,&quot;);
                }

                if ( newSelector ) {
                        try {
                                push.apply( results,
                                        newContext.querySelectorAll( newSelector )
                                );
                                return results;
                        } catch(qsaError) {
                        } finally {
                                if ( !old ) {
                                        context.removeAttribute(&quot;id&quot;);
                                }
                        }
                }
        }
}

// All others
return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );</pre>

<p>}</p>

<p>/**</p>

<pre> Create key-value caches of limited size
 @returns {Function(string, Object)} Returns the Object data after storing it on itself with
      property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
      deleting the oldest entry
/</pre>

<p>function createCache() {</p>

<pre>var keys = [];

function cache( key, value ) {
        // Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
        if ( keys.push( key + &quot; &quot; ) &gt; Expr.cacheLength ) {
                // Only keep the most recent entries
                delete cache[ keys.shift() ];
        }
        return (cache[ key + &quot; &quot; ] = value);
}
return cache;</pre>

<p>}</p>

<p>/**</p>

<pre> Mark a function for special use by Sizzle
 @param {Function} fn The function to mark
/</pre>

<p>function markFunction( fn ) {</p>

<pre class="ruby"><span class="ruby-identifier">fn</span>[ <span class="ruby-identifier">expando</span> ] = <span class="ruby-keyword">true</span>;
<span class="ruby-keyword">return</span> <span class="ruby-identifier">fn</span>;
</pre>

<p>}</p>

<p>/**</p>

<pre> Support testing using an element
 @param {Function} fn Passed the created div and expects a boolean result
/</pre>

<p>function assert( fn ) {</p>

<pre>var div = document.createElement(&quot;div&quot;);

try {
        return !!fn( div );
} catch (e) {
        return false;
} finally {
        // Remove from its parent by default
        if ( div.parentNode ) {
                div.parentNode.removeChild( div );
        }
        // release memory in IE
        div = null;
}</pre>

<p>}</p>

<p>/**</p>

<pre> Adds the same handler for all of the specified attrs
 @param {String} attrs Pipe-separated list of attributes
 @param {Function} handler The method that will be applied
/</pre>

<p>function addHandle( attrs, handler ) {</p>

<pre>var arr = attrs.split(&quot;|&quot;),
        i = attrs.length;

while ( i-- ) {
        Expr.attrHandle[ arr[i] ] = handler;
}</pre>

<p>}</p>

<p>/**</p>

<pre> Checks document order of two siblings
 @param {Element} a
 @param {Element} b
 @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
/</pre>

<p>function siblingCheck( a, b ) {</p>

<pre>var cur = b &amp;&amp; a,
        diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
                ( ~b.sourceIndex || MAX_NEGATIVE ) -
                ( ~a.sourceIndex || MAX_NEGATIVE );

// Use IE sourceIndex if available on both nodes
if ( diff ) {
        return diff;
}

// Check if b follows a
if ( cur ) {
        while ( (cur = cur.nextSibling) ) {
                if ( cur === b ) {
                        return -1;
                }
        }
}

return a ? 1 : -1;</pre>

<p>}</p>

<p>/**</p>

<pre> Returns a function to use in pseudos for input types
 @param {String} type
/</pre>

<p>function createInputPseudo( type ) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">function</span>( <span class="ruby-identifier">elem</span> ) {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">name</span> = <span class="ruby-identifier">elem</span>.<span class="ruby-identifier">nodeName</span>.<span class="ruby-identifier">toLowerCase</span>();
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">===</span> <span class="ruby-string">&quot;input&quot;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">elem</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">type</span>;
};
</pre>

<p>}</p>

<p>/**</p>

<pre> Returns a function to use in pseudos for buttons
 @param {String} type
/</pre>

<p>function createButtonPseudo( type ) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">function</span>( <span class="ruby-identifier">elem</span> ) {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">name</span> = <span class="ruby-identifier">elem</span>.<span class="ruby-identifier">nodeName</span>.<span class="ruby-identifier">toLowerCase</span>();
        <span class="ruby-keyword">return</span> (<span class="ruby-identifier">name</span> <span class="ruby-operator">===</span> <span class="ruby-string">&quot;input&quot;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">===</span> <span class="ruby-string">&quot;button&quot;</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">elem</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">type</span>;
};
</pre>

<p>}</p>

<p>/**</p>

<pre> Returns a function to use in pseudos for positionals
 @param {Function} fn
/</pre>

<p>function createPositionalPseudo( fn ) {</p>

<pre>return markFunction(function( argument ) {
        argument = +argument;
        return markFunction(function( seed, matches ) {
                var j,
                        matchIndexes = fn( [], seed.length, argument ),
                        i = matchIndexes.length;

                // Match elements found at the specified indexes
                while ( i-- ) {
                        if ( seed[ (j = matchIndexes[i]) ] ) {
                                seed[j] = !(matches[j] = seed[j]);
                        }
                }
        });
});</pre>

<p>}</p>

<p>/**</p>

<pre> Checks a node for validity as a Sizzle context
 @param {Element|Object=} context
 @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
/</pre>

<p>function testContext( context ) {</p>

<pre>return context &amp;&amp; typeof context.getElementsByTagName !== strundefined &amp;&amp; context;</pre>

<p>}</p>

<p>// Expose support vars for convenience support = Sizzle.support = {};</p>

<p>/**</p>

<pre> Detects XML nodes
 @param {Element|Object} elem An element or a document
 @returns {Boolean} True iff elem is a non-HTML XML node
/</pre>

<p>isXML = Sizzle.isXML = function( elem ) {</p>

<pre>// documentElement is verified for cases where it doesn&#39;t yet exist
// (such as loading iframes in IE - #4833)
var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;</pre>

<p>};</p>

<p>/**</p>

<pre> Sets document-related variables once based on the current document
 @param {Element|Object} [doc] An element or document object to use to set the document
 @returns {Object} Returns the current document
/</pre>

<p>setDocument = Sizzle.setDocument = function( node ) {</p>

<pre>var hasCompare,
        doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;

// If no document and documentElement is available, return
if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
        return document;
}

// Set our document
document = doc;
docElem = doc.documentElement;

// Support tests
documentIsHTML = !isXML( doc );

// Support: IE&gt;8
// If iframe document is assigned to &quot;document&quot; variable and if iframe has been reloaded,
// IE will throw &quot;permission denied&quot; error when accessing &quot;document&quot; variable, see jQuery #13936
// IE6-8 do not support the defaultView property so parent will be undefined
if ( parent &amp;&amp; parent !== parent.top ) {
        // IE11 does not have attachEvent, so all must suffer
        if ( parent.addEventListener ) {
                parent.addEventListener( &quot;unload&quot;, function() {
                        setDocument();
                }, false );
        } else if ( parent.attachEvent ) {
                parent.attachEvent( &quot;onunload&quot;, function() {
                        setDocument();
                });
        }
}

/* Attributes
---------------------------------------------------------------------- */

// Support: IE&lt;8
// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
support.attributes = assert(function( div ) {
        div.className = &quot;i&quot;;
        return !div.getAttribute(&quot;className&quot;);
});

/* getElement(s)By*
---------------------------------------------------------------------- */

// Check if getElementsByTagName(&quot;*&quot;) returns only elements
support.getElementsByTagName = assert(function( div ) {
        div.appendChild( doc.createComment(&quot;&quot;) );
        return !div.getElementsByTagName(&quot;*&quot;).length;
});

// Check if getElementsByClassName can be trusted
support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) &amp;&amp; assert(function( div ) {
        div.innerHTML = &quot;&lt;div class=&#39;a&#39;&gt;&lt;/div&gt;&lt;div class=&#39;a i&#39;&gt;&lt;/div&gt;&quot;;

        // Support: Safari&lt;4
        // Catch class over-caching
        div.firstChild.className = &quot;i&quot;;
        // Support: Opera&lt;10
        // Catch gEBCN failure to find non-leading classes
        return div.getElementsByClassName(&quot;i&quot;).length === 2;
});

// Support: IE&lt;10
// Check if getElementById returns elements by name
// The broken getElementById methods don&#39;t pick up programatically-set names,
// so use a roundabout getElementsByName test
support.getById = assert(function( div ) {
        docElem.appendChild( div ).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
});

// ID find and filter
if ( support.getById ) {
        Expr.find[&quot;ID&quot;] = function( id, context ) {
                if ( typeof context.getElementById !== strundefined &amp;&amp; documentIsHTML ) {
                        var m = context.getElementById( id );
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m &amp;&amp; m.parentNode ? [ m ] : [];
                }
        };
        Expr.filter[&quot;ID&quot;] = function( id ) {
                var attrId = id.replace( runescape, funescape );
                return function( elem ) {
                        return elem.getAttribute(&quot;id&quot;) === attrId;
                };
        };
} else {
        // Support: IE6/7
        // getElementById is not reliable as a find shortcut
        delete Expr.find[&quot;ID&quot;];

        Expr.filter[&quot;ID&quot;] =  function( id ) {
                var attrId = id.replace( runescape, funescape );
                return function( elem ) {
                        var node = typeof elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(&quot;id&quot;);
                        return node &amp;&amp; node.value === attrId;
                };
        };
}

// Tag
Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ?
        function( tag, context ) {
                if ( typeof context.getElementsByTagName !== strundefined ) {
                        return context.getElementsByTagName( tag );
                }
        } :
        function( tag, context ) {
                var elem,
                        tmp = [],
                        i = 0,
                        results = context.getElementsByTagName( tag );

                // Filter out possible comments
                if ( tag === &quot;*&quot; ) {
                        while ( (elem = results[i++]) ) {
                                if ( elem.nodeType === 1 ) {
                                        tmp.push( elem );
                                }
                        }

                        return tmp;
                }
                return results;
        };

// Class
Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function( className, context ) {
        if ( typeof context.getElementsByClassName !== strundefined &amp;&amp; documentIsHTML ) {
                return context.getElementsByClassName( className );
        }
};

/* QSA/matchesSelector
---------------------------------------------------------------------- */

// QSA and matchesSelector support

// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
rbuggyMatches = [];

// qSa(:focus) reports false when true (Chrome 21)
// We allow this because of a bug in IE8/9 that throws an error
// whenever `document.activeElement` is accessed on an iframe
// So, we allow :focus to pass through QSA all the time to avoid the IE error
// See http://bugs.jquery.com/ticket/13378
rbuggyQSA = [];

if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function( div ) {
                // Select is set to empty string on purpose
                // This is to test IE&#39;s treatment of not explicitly
                // setting a boolean content attribute,
                // since its presence should be enough
                // http://bugs.jquery.com/ticket/12359
                div.innerHTML = &quot;&lt;select msallowclip=&#39;&#39;&gt;&lt;option selected=&#39;&#39;&gt;&lt;/option&gt;&lt;/select&gt;&quot;;

                // Support: IE8, Opera 11-12.16
                // Nothing should be selected when empty strings follow ^= or $= or *=
                // The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT
                // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                if ( div.querySelectorAll(&quot;[msallowclip^=&#39;&#39;]&quot;).length ) {
                        rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:&#39;&#39;|\&quot;\&quot;)&quot; );
                }

                // Support: IE8
                // Boolean attributes and &quot;value&quot; are not treated correctly
                if ( !div.querySelectorAll(&quot;[selected]&quot;).length ) {
                        rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; );
                }

                // Webkit/Opera - :checked should return selected option elements
                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                // IE8 throws error here and will not see later tests
                if ( !div.querySelectorAll(&quot;:checked&quot;).length ) {
                        rbuggyQSA.push(&quot;:checked&quot;);
                }
        });

        assert(function( div ) {
                // Support: Windows 8 Native Apps
                // The type and name attributes are restricted during .innerHTML assignment
                var input = doc.createElement(&quot;input&quot;);
                input.setAttribute( &quot;type&quot;, &quot;hidden&quot; );
                div.appendChild( input ).setAttribute( &quot;name&quot;, &quot;D&quot; );

                // Support: IE8
                // Enforce case-sensitivity of name attribute
                if ( div.querySelectorAll(&quot;[name=d]&quot;).length ) {
                        rbuggyQSA.push( &quot;name&quot; + whitespace + &quot;*[*^$|!~]?=&quot; );
                }

                // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                // IE8 throws error here and will not see later tests
                if ( !div.querySelectorAll(&quot;:enabled&quot;).length ) {
                        rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
                }

                // Opera 10-11 does not throw on post-comma invalid pseudos
                div.querySelectorAll(&quot;*,:x&quot;);
                rbuggyQSA.push(&quot;,.*:&quot;);
        });
}

if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
        docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector) )) ) {

        assert(function( div ) {
                // Check to see if it&#39;s possible to do matchesSelector
                // on a disconnected node (IE 9)
                support.disconnectedMatch = matches.call( div, &quot;div&quot; );

                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches.call( div, &quot;[s!=&#39;&#39;]:x&quot; );
                rbuggyMatches.push( &quot;!=&quot;, pseudos );
        });
}

rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) );
rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );

/* Contains
---------------------------------------------------------------------- */
hasCompare = rnative.test( docElem.compareDocumentPosition );

// Element contains another
// Purposefully does not implement inclusive descendent
// As in, an element does not contain itself
contains = hasCompare || rnative.test( docElem.contains ) ?
        function( a, b ) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                        bup = b &amp;&amp; b.parentNode;
                return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
                        adown.contains ?
                                adown.contains( bup ) :
                                a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
                ));
        } :
        function( a, b ) {
                if ( b ) {
                        while ( (b = b.parentNode) ) {
                                if ( b === a ) {
                                        return true;
                                }
                        }
                }
                return false;
        };

/* Sorting
---------------------------------------------------------------------- */

// Document order sorting
sortOrder = hasCompare ?
function( a, b ) {

        // Flag for duplicate removal
        if ( a === b ) {
                hasDuplicate = true;
                return 0;
        }

        // Sort on method existence if only one input has compareDocumentPosition
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if ( compare ) {
                return compare;
        }

        // Calculate position if both inputs belong to the same document
        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                a.compareDocumentPosition( b ) :

                // Otherwise we know they are disconnected
                1;

        // Disconnected nodes
        if ( compare &amp; 1 ||
                (!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {

                // Choose the first element that is related to our preferred document
                if ( a === doc || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) {
                        return -1;
                }
                if ( b === doc || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) {
                        return 1;
                }

                // Maintain original order
                return sortInput ?
                        ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                        0;
        }

        return compare &amp; 4 ? -1 : 1;
} :
function( a, b ) {
        // Exit early if the nodes are identical
        if ( a === b ) {
                hasDuplicate = true;
                return 0;
        }

        var cur,
                i = 0,
                aup = a.parentNode,
                bup = b.parentNode,
                ap = [ a ],
                bp = [ b ];

        // Parentless nodes are either documents or disconnected
        if ( !aup || !bup ) {
                return a === doc ? -1 :
                        b === doc ? 1 :
                        aup ? -1 :
                        bup ? 1 :
                        sortInput ?
                        ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                        0;

        // If the nodes are siblings, we can do a quick check
        } else if ( aup === bup ) {
                return siblingCheck( a, b );
        }

        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while ( (cur = cur.parentNode) ) {
                ap.unshift( cur );
        }
        cur = b;
        while ( (cur = cur.parentNode) ) {
                bp.unshift( cur );
        }

        // Walk down the tree looking for a discrepancy
        while ( ap[i] === bp[i] ) {
                i++;
        }

        return i ?
                // Do a sibling check if the nodes have a common ancestor
                siblingCheck( ap[i], bp[i] ) :

                // Otherwise nodes in our document sort first
                ap[i] === preferredDoc ? -1 :
                bp[i] === preferredDoc ? 1 :
                0;
};

return doc;</pre>

<p>};</p>

<p>Sizzle.matches = function( expr, elements ) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">Sizzle</span>( <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">null</span>, <span class="ruby-identifier">null</span>, <span class="ruby-identifier">elements</span> );
</pre>

<p>};</p>

<p>Sizzle.matchesSelector = function( elem, expr ) {</p>

<pre>// Set document vars if needed
if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
}

// Make sure that attribute selectors are quoted
expr = expr.replace( rattributeQuotes, &quot;=&#39;$1&#39;]&quot; );

if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

        try {
                var ret = matches.call( elem, expr );

                // IE 9&#39;s matchesSelector returns false on disconnected nodes
                if ( ret || support.disconnectedMatch ||
                                // As well, disconnected nodes are said to be in a document
                                // fragment in IE 9
                                elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
                        return ret;
                }
        } catch(e) {}
}

return Sizzle( expr, document, null, [ elem ] ).length &gt; 0;</pre>

<p>};</p>

<p>Sizzle.contains = function( context, elem ) {</p>

<pre>// Set document vars if needed
if ( ( context.ownerDocument || context ) !== document ) {
        setDocument( context );
}
return contains( context, elem );</pre>

<p>};</p>

<p>Sizzle.attr = function( elem, name ) {</p>

<pre>// Set document vars if needed
if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
}

var fn = Expr.attrHandle[ name.toLowerCase() ],
        // Don&#39;t get fooled by Object.prototype properties (jQuery #13807)
        val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                fn( elem, name, !documentIsHTML ) :
                undefined;

return val !== undefined ?
        val :
        support.attributes || !documentIsHTML ?
                elem.getAttribute( name ) :
                (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
                        val.value :
                        null;</pre>

<p>};</p>

<p>Sizzle.error = function( msg ) {</p>

<pre class="ruby"><span class="ruby-identifier">throw</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Error</span>( <span class="ruby-string">&quot;Syntax error, unrecognized expression: &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">msg</span> );
</pre>

<p>};</p>

<p>/**</p>

<pre> Document sorting and removing duplicates
 @param {ArrayLike} results
/</pre>

<p>Sizzle.uniqueSort = function( results ) {</p>

<pre>var elem,
        duplicates = [],
        j = 0,
        i = 0;

// Unless we *know* we can detect duplicates, assume their presence
hasDuplicate = !support.detectDuplicates;
sortInput = !support.sortStable &amp;&amp; results.slice( 0 );
results.sort( sortOrder );

if ( hasDuplicate ) {
        while ( (elem = results[i++]) ) {
                if ( elem === results[ i ] ) {
                        j = duplicates.push( i );
                }
        }
        while ( j-- ) {
                results.splice( duplicates[ j ], 1 );
        }
}

// Clear input after sorting to release objects
// See https://github.com/jquery/sizzle/pull/225
sortInput = null;

return results;</pre>

<p>};</p>

<p>/**</p>

<pre> Utility function for retrieving the text value of an array of DOM nodes
 @param {Array|Element} elem
/</pre>

<p>getText = Sizzle.getText = function( elem ) {</p>

<pre>var node,
        ret = &quot;&quot;,
        i = 0,
        nodeType = elem.nodeType;

if ( !nodeType ) {
        // If no nodeType, this is expected to be an array
        while ( (node = elem[i++]) ) {
                // Do not traverse comment nodes
                ret += getText( node );
        }
} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if ( typeof elem.textContent === &quot;string&quot; ) {
                return elem.textContent;
        } else {
                // Traverse its children
                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                        ret += getText( elem );
                }
        }
} else if ( nodeType === 3 || nodeType === 4 ) {
        return elem.nodeValue;
}
// Do not include comment or processing instruction nodes

return ret;</pre>

<p>};</p>

<p>Expr = Sizzle.selectors = {</p>

<pre>    // Can be adjusted by the user
    cacheLength: 50,

    createPseudo: markFunction,

    match: matchExpr,

    attrHandle: {},

    find: {},

    relative: {
            &quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
            &quot; &quot;: { dir: &quot;parentNode&quot; },
            &quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
            &quot;~&quot;: { dir: &quot;previousSibling&quot; }
    },

    preFilter: {
            &quot;ATTR&quot;: function( match ) {
                    match[1] = match[1].replace( runescape, funescape );

                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = ( match[3] || match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );

                    if ( match[2] === &quot;~=&quot; ) {
                            match[3] = &quot; &quot; + match[3] + &quot; &quot;;
                    }

                    return match.slice( 0, 4 );
            },

            &quot;CHILD&quot;: function( match ) {
                    /* matches from matchExpr[&quot;CHILD&quot;]
                            1 type (only|nth|...)
                            2 what (child|of-type)
                            3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                            4 xn-component of xn+y argument ([+-]?\d*n|)
                            5 sign of xn-component
                            6 x of xn-component
                            7 sign of y-component
                            8 y of y-component
/
                    match[1] = match[1].toLowerCase();

                    if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) {
                            // nth-* requires argument
                            if ( !match[3] ) {
                                    Sizzle.error( match[0] );
                            }

                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) );
                            match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; );

                    // other types prohibit arguments
                    } else if ( match[3] ) {
                            Sizzle.error( match[0] );
                    }

                    return match;
            },

            &quot;PSEUDO&quot;: function( match ) {
                    var excess,
                            unquoted = !match[6] &amp;&amp; match[2];

                    if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
                            return null;
                    }

                    // Accept quoted arguments as-is
                    if ( match[3] ) {
                            match[2] = match[4] || match[5] || &quot;&quot;;

                    // Strip excess characters from unquoted arguments
                    } else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
                            // Get excess from tokenize (recursively)
                            (excess = tokenize( unquoted, true )) &amp;&amp;
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {

                            // excess is a negative index
                            match[0] = match[0].slice( 0, excess );
                            match[2] = unquoted.slice( 0, excess );
                    }

                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice( 0, 3 );
            }
    },

    filter: {

            &quot;TAG&quot;: function( nodeNameSelector ) {
                    var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                    return nodeNameSelector === &quot;*&quot; ?
                            function() { return true; } :
                            function( elem ) {
                                    return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
                            };
            },

            &quot;CLASS&quot;: function( className ) {
                    var pattern = classCache[ className + &quot; &quot; ];

                    return pattern ||
                            (pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
                            classCache( className, function( elem ) {
                                    return pattern.test( typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; );
                            });
            },

            &quot;ATTR&quot;: function( name, operator, check ) {
                    return function( elem ) {
                            var result = Sizzle.attr( elem, name );

                            if ( result == null ) {
                                    return operator === &quot;!=&quot;;
                            }
                            if ( !operator ) {
                                    return true;
                            }

                            result += &quot;&quot;;

                            return operator === &quot;=&quot; ? result === check :
                                    operator === &quot;!=&quot; ? result !== check :
                                    operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
                                    operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
                                    operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check :
                                    operator === &quot;~=&quot; ? ( &quot; &quot; + result + &quot; &quot; ).indexOf( check ) &gt; -1 :
                                    operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; :
                                    false;
                    };
            },

            &quot;CHILD&quot;: function( type, what, argument, first, last ) {
                    var simple = type.slice( 0, 3 ) !== &quot;nth&quot;,
                            forward = type.slice( -4 ) !== &quot;last&quot;,
                            ofType = what === &quot;of-type&quot;;

                    return first === 1 &amp;&amp; last === 0 ?

                            // Shortcut for :nth-*(n)
                            function( elem ) {
                                    return !!elem.parentNode;
                            } :

                            function( elem, context, xml ) {
                                    var cache, outerCache, node, diff, nodeIndex, start,
                                            dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
                                            parent = elem.parentNode,
                                            name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
                                            useCache = !xml &amp;&amp; !ofType;

                                    if ( parent ) {

                                            // :(first|last|only)-(child|of-type)
                                            if ( simple ) {
                                                    while ( dir ) {
                                                            node = elem;
                                                            while ( (node = node[ dir ]) ) {
                                                                    if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                                                            return false;
                                                                    }
                                                            }
                                                            // Reverse direction for :only-* (if we haven&#39;t yet done so)
                                                            start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
                                                    }
                                                    return true;
                                            }

                                            start = [ forward ? parent.firstChild : parent.lastChild ];

                                            // non-xml :nth-child(...) stores cache data on `parent`
                                            if ( forward &amp;&amp; useCache ) {
                                                    // Seek `elem` from a previously-cached index
                                                    outerCache = parent[ expando ] || (parent[ expando ] = {});
                                                    cache = outerCache[ type ] || [];
                                                    nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
                                                    diff = cache[0] === dirruns &amp;&amp; cache[2];
                                                    node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];

                                                    while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||

                                                            // Fallback to seeking `elem` from the start
                                                            (diff = nodeIndex = 0) || start.pop()) ) {

                                                            // When found, cache indexes on `parent` and break
                                                            if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {
                                                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                                    break;
                                                            }
                                                    }

                                            // Use previously-cached element index if available
                                            } else if ( useCache &amp;&amp; (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) &amp;&amp; cache[0] === dirruns ) {
                                                    diff = cache[1];

                                            // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                            } else {
                                                    // Use the same loop as above to seek `elem` from the start
                                                    while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
                                                            (diff = nodeIndex = 0) || start.pop()) ) {

                                                            if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) &amp;&amp; ++diff ) {
                                                                    // Cache the index of each encountered element
                                                                    if ( useCache ) {
                                                                            (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                                                    }

                                                                    if ( node === elem ) {
                                                                            break;
                                                                    }
                                                            }
                                                    }
                                            }

                                            // Incorporate the offset, then check against cycle size
                                            diff -= last;
                                            return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
                                    }
                            };
            },

            &quot;PSEUDO&quot;: function( pseudo, argument ) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args,
                            fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                    Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );

                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if ( fn[ expando ] ) {
                            return fn( argument );
                    }

                    // But maintain support for old signatures
                    if ( fn.length &gt; 1 ) {
                            args = [ pseudo, pseudo, &quot;&quot;, argument ];
                            return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                    markFunction(function( seed, matches ) {
                                            var idx,
                                                    matched = fn( seed, argument ),
                                                    i = matched.length;
                                            while ( i-- ) {
                                                    idx = indexOf.call( seed, matched[i] );
                                                    seed[ idx ] = !( matches[ idx ] = matched[i] );
                                            }
                                    }) :
                                    function( elem ) {
                                            return fn( elem, 0, args );
                                    };
                    }

                    return fn;
            }
    },

    pseudos: {
            // Potentially complex pseudos
            &quot;not&quot;: markFunction(function( selector ) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [],
                            results = [],
                            matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );

                    return matcher[ expando ] ?
                            markFunction(function( seed, matches, context, xml ) {
                                    var elem,
                                            unmatched = matcher( seed, null, xml, [] ),
                                            i = seed.length;

                                    // Match elements unmatched by `matcher`
                                    while ( i-- ) {
                                            if ( (elem = unmatched[i]) ) {
                                                    seed[i] = !(matches[i] = elem);
                                            }
                                    }
                            }) :
                            function( elem, context, xml ) {
                                    input[0] = elem;
                                    matcher( input, null, xml, results );
                                    return !results.pop();
                            };
            }),

            &quot;has&quot;: markFunction(function( selector ) {
                    return function( elem ) {
                            return Sizzle( selector, elem ).length &gt; 0;
                    };
            }),

            &quot;contains&quot;: markFunction(function( text ) {
                    return function( elem ) {
                            return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
                    };
            }),

            // &quot;Whether an element is represented by a :lang() selector
            // is based solely on the element&#39;s language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by &quot;-&quot;.
            // The matching of C against the element&#39;s language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name.&quot;
            // http://www.w3.org/TR/selectors/#lang-pseudo
            &quot;lang&quot;: markFunction( function( lang ) {
                    // lang value must be a valid identifier
                    if ( !ridentifier.test(lang || &quot;&quot;) ) {
                            Sizzle.error( &quot;unsupported lang: &quot; + lang );
                    }
                    lang = lang.replace( runescape, funescape ).toLowerCase();
                    return function( elem ) {
                            var elemLang;
                            do {
                                    if ( (elemLang = documentIsHTML ?
                                            elem.lang :
                                            elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) {

                                            elemLang = elemLang.toLowerCase();
                                            return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0;
                                    }
                            } while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );
                            return false;
                    };
            }),

            // Miscellaneous
            &quot;target&quot;: function( elem ) {
                    var hash = window.location &amp;&amp; window.location.hash;
                    return hash &amp;&amp; hash.slice( 1 ) === elem.id;
            },

            &quot;root&quot;: function( elem ) {
                    return elem === docElem;
            },

            &quot;focus&quot;: function( elem ) {
                    return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
            },

            // Boolean properties
            &quot;enabled&quot;: function( elem ) {
                    return elem.disabled === false;
            },

            &quot;disabled&quot;: function( elem ) {
                    return elem.disabled === true;
            },

            &quot;checked&quot;: function( elem ) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
            },

            &quot;selected&quot;: function( elem ) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if ( elem.parentNode ) {
                            elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
            },

            // Contents
            &quot;empty&quot;: function( elem ) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType &lt; 6 works because attributes (2) do not appear as children
                    for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                            if ( elem.nodeType &lt; 6 ) {
                                    return false;
                            }
                    }
                    return true;
            },

            &quot;parent&quot;: function( elem ) {
                    return !Expr.pseudos[&quot;empty&quot;]( elem );
            },

            // Element/input types
            &quot;header&quot;: function( elem ) {
                    return rheader.test( elem.nodeName );
            },

            &quot;input&quot;: function( elem ) {
                    return rinputs.test( elem.nodeName );
            },

            &quot;button&quot;: function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
            },

            &quot;text&quot;: function( elem ) {
                    var attr;
                    return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
                            elem.type === &quot;text&quot; &amp;&amp;

                            // Support: IE&lt;8
                            // New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;
                            ( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === &quot;text&quot; );
            },

            // Position-in-collection
            &quot;first&quot;: createPositionalPseudo(function() {
                    return [ 0 ];
            }),

            &quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
                    return [ length - 1 ];
            }),

            &quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
                    return [ argument &lt; 0 ? argument + length : argument ];
            }),

            &quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
                    var i = 0;
                    for ( ; i &lt; length; i += 2 ) {
                            matchIndexes.push( i );
                    }
                    return matchIndexes;
            }),

            &quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
                    var i = 1;
                    for ( ; i &lt; length; i += 2 ) {
                            matchIndexes.push( i );
                    }
                    return matchIndexes;
            }),

            &quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
                    var i = argument &lt; 0 ? argument + length : argument;
                    for ( ; --i &gt;= 0; ) {
                            matchIndexes.push( i );
                    }
                    return matchIndexes;
            }),

            &quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
                    var i = argument &lt; 0 ? argument + length : argument;
                    for ( ; ++i &lt; length; ) {
                            matchIndexes.push( i );
                    }
                    return matchIndexes;
            })
    }</pre>

<p>};</p>

<p><a href=""nth"">Expr.pseudos</a> = <a href=""eq"">Expr.pseudos</a>;</p>

<p>// Add button/input type pseudos for ( i in { radio: true, checkbox: true,
file: true, password: true, image: true } ) {</p>

<pre class="ruby"><span class="ruby-constant">Expr</span>.<span class="ruby-identifier">pseudos</span>[ <span class="ruby-identifier">i</span> ] = <span class="ruby-identifier">createInputPseudo</span>( <span class="ruby-identifier">i</span> );
</pre>

<p>} for ( i in { submit: true, reset: true } ) {</p>

<pre class="ruby"><span class="ruby-constant">Expr</span>.<span class="ruby-identifier">pseudos</span>[ <span class="ruby-identifier">i</span> ] = <span class="ruby-identifier">createButtonPseudo</span>( <span class="ruby-identifier">i</span> );
</pre>

<p>}</p>

<p>// Easy API for creating new setFilters function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos; Expr.setFilters = new
setFilters();</p>

<p>tokenize = Sizzle.tokenize = function( selector, parseOnly ) {</p>

<pre>var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[ selector + &quot; &quot; ];

if ( cached ) {
        return parseOnly ? 0 : cached.slice( 0 );
}

soFar = selector;
groups = [];
preFilters = Expr.preFilter;

while ( soFar ) {

        // Comma and first run
        if ( !matched || (match = rcomma.exec( soFar )) ) {
                if ( match ) {
                        // Don&#39;t consume trailing commas as valid
                        soFar = soFar.slice( match[0].length ) || soFar;
                }
                groups.push( (tokens = []) );
        }

        matched = false;

        // Combinators
        if ( (match = rcombinators.exec( soFar )) ) {
                matched = match.shift();
                tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace( rtrim, &quot; &quot; )
                });
                soFar = soFar.slice( matched.length );
        }

        // Filters
        for ( type in Expr.filter ) {
                if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
                        (match = preFilters[ type ]( match ))) ) {
                        matched = match.shift();
                        tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                        });
                        soFar = soFar.slice( matched.length );
                }
        }

        if ( !matched ) {
                break;
        }
}

// Return the length of the invalid excess
// if we&#39;re just parsing
// Otherwise, throw an error or return tokens
return parseOnly ?
        soFar.length :
        soFar ?
                Sizzle.error( selector ) :
                // Cache the tokens
                tokenCache( selector, groups ).slice( 0 );</pre>

<p>};</p>

<p>function toSelector( tokens ) {</p>

<pre>var i = 0,
        len = tokens.length,
        selector = &quot;&quot;;
for ( ; i &lt; len; i++ ) {
        selector += tokens[i].value;
}
return selector;</pre>

<p>}</p>

<p>function addCombinator( matcher, combinator, base ) {</p>

<pre>var dir = combinator.dir,
        checkNonElements = base &amp;&amp; dir === &quot;parentNode&quot;,
        doneName = done++;

return combinator.first ?
        // Check against closest ancestor/preceding element
        function( elem, context, xml ) {
                while ( (elem = elem[ dir ]) ) {
                        if ( elem.nodeType === 1 || checkNonElements ) {
                                return matcher( elem, context, xml );
                        }
                }
        } :

        // Check against all ancestor/preceding elements
        function( elem, context, xml ) {
                var oldCache, outerCache,
                        newCache = [ dirruns, doneName ];

                // We can&#39;t set arbitrary data on XML nodes, so they don&#39;t benefit from dir caching
                if ( xml ) {
                        while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                        if ( matcher( elem, context, xml ) ) {
                                                return true;
                                        }
                                }
                        }
                } else {
                        while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                        outerCache = elem[ expando ] || (elem[ expando ] = {});
                                        if ( (oldCache = outerCache[ dir ]) &amp;&amp;
                                                oldCache[ 0 ] === dirruns &amp;&amp; oldCache[ 1 ] === doneName ) {

                                                // Assign to newCache so results back-propagate to previous elements
                                                return (newCache[ 2 ] = oldCache[ 2 ]);
                                        } else {
                                                // Reuse newcache so results back-propagate to previous elements
                                                outerCache[ dir ] = newCache;

                                                // A match means we&#39;re done; a fail means we have to keep checking
                                                if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                                        return true;
                                                }
                                        }
                                }
                        }
                }
        };</pre>

<p>}</p>

<p>function elementMatcher( matchers ) {</p>

<pre>return matchers.length &gt; 1 ?
        function( elem, context, xml ) {
                var i = matchers.length;
                while ( i-- ) {
                        if ( !matchers[i]( elem, context, xml ) ) {
                                return false;
                        }
                }
                return true;
        } :
        matchers[0];</pre>

<p>}</p>

<p>function multipleContexts( selector, contexts, results ) {</p>

<pre>var i = 0,
        len = contexts.length;
for ( ; i &lt; len; i++ ) {
        Sizzle( selector, contexts[i], results );
}
return results;</pre>

<p>}</p>

<p>function condense( unmatched, map, filter, context, xml ) {</p>

<pre>var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

for ( ; i &lt; len; i++ ) {
        if ( (elem = unmatched[i]) ) {
                if ( !filter || filter( elem, context, xml ) ) {
                        newUnmatched.push( elem );
                        if ( mapped ) {
                                map.push( i );
                        }
                }
        }
}

return newUnmatched;</pre>

<p>}</p>

<p>function setMatcher( preFilter, selector, matcher, postFilter, postFinder,
postSelector ) {</p>

<pre>if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
        postFilter = setMatcher( postFilter );
}
if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
        postFinder = setMatcher( postFinder, postSelector );
}
return markFunction(function( seed, results, context, xml ) {
        var temp, i, elem,
                preMap = [],
                postMap = [],
                preexisting = results.length,

                // Get initial elements from seed or context
                elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),

                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
                        condense( elems, preMap, preFilter, context, xml ) :
                        elems,

                matcherOut = matcher ?
                        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                        postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                        matcherIn;

        // Find primary matches
        if ( matcher ) {
                matcher( matcherIn, matcherOut, context, xml );
        }

        // Apply postFilter
        if ( postFilter ) {
                temp = condense( matcherOut, postMap );
                postFilter( temp, [], context, xml );

                // Un-match failing elements by moving them back to matcherIn
                i = temp.length;
                while ( i-- ) {
                        if ( (elem = temp[i]) ) {
                                matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                        }
                }
        }

        if ( seed ) {
                if ( postFinder || preFilter ) {
                        if ( postFinder ) {
                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while ( i-- ) {
                                        if ( (elem = matcherOut[i]) ) {
                                                // Restore matcherIn since elem is not yet a final match
                                                temp.push( (matcherIn[i] = elem) );
                                        }
                                }
                                postFinder( null, (matcherOut = []), temp, xml );
                        }

                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while ( i-- ) {
                                if ( (elem = matcherOut[i]) &amp;&amp;
                                        (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) &gt; -1 ) {

                                        seed[temp] = !(results[temp] = elem);
                                }
                        }
                }

        // Add elements to results, through postFinder if defined
        } else {
                matcherOut = condense(
                        matcherOut === results ?
                                matcherOut.splice( preexisting, matcherOut.length ) :
                                matcherOut
                );
                if ( postFinder ) {
                        postFinder( null, results, matcherOut, xml );
                } else {
                        push.apply( results, matcherOut );
                }
        }
});</pre>

<p>}</p>

<p>function matcherFromTokens( tokens ) {</p>

<pre>var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[ tokens[0].type ],
        implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator( function( elem ) {
                return elem === checkContext;
        }, implicitRelative, true ),
        matchAnyContext = addCombinator( function( elem ) {
                return indexOf.call( checkContext, elem ) &gt; -1;
        }, implicitRelative, true ),
        matchers = [ function( elem, context, xml ) {
                return ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
                        (checkContext = context).nodeType ?
                                matchContext( elem, context, xml ) :
                                matchAnyContext( elem, context, xml ) );
        } ];

for ( ; i &lt; len; i++ ) {
        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
        } else {
                matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

                // Return special upon seeing a positional matcher
                if ( matcher[ expando ] ) {
                        // Find the next relative operator (if any) for proper handling
                        j = ++i;
                        for ( ; j &lt; len; j++ ) {
                                if ( Expr.relative[ tokens[j].type ] ) {
                                        break;
                                }
                        }
                        return setMatcher(
                                i &gt; 1 &amp;&amp; elementMatcher( matchers ),
                                i &gt; 1 &amp;&amp; toSelector(
                                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
                                ).replace( rtrim, &quot;$1&quot; ),
                                matcher,
                                i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
                                j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
                                j &lt; len &amp;&amp; toSelector( tokens )
                        );
                }
                matchers.push( matcher );
        }
}

return elementMatcher( matchers );</pre>

<p>}</p>

<p>function matcherFromGroupMatchers( elementMatchers, setMatchers ) {</p>

<pre>var bySet = setMatchers.length &gt; 0,
        byElement = elementMatchers.length &gt; 0,
        superMatcher = function( seed, context, xml, results, outermost ) {
                var elem, j, matcher,
                        matchedCount = 0,
                        i = &quot;0&quot;,
                        unmatched = seed &amp;&amp; [],
                        setMatched = [],
                        contextBackup = outermostContext,
                        // We must always have either seed elements or outermost context
                        elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, outermost ),
                        // Use integer dirruns iff this is the outermost matcher
                        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                        len = elems.length;

                if ( outermost ) {
                        outermostContext = context !== document &amp;&amp; context;
                }

                // Add elements passing elementMatchers directly to results
                // Keep `i` a string if there are no elements so `matchedCount` will be &quot;00&quot; below
                // Support: IE&lt;9, Safari
                // Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id
                for ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) {
                        if ( byElement &amp;&amp; elem ) {
                                j = 0;
                                while ( (matcher = elementMatchers[j++]) ) {
                                        if ( matcher( elem, context, xml ) ) {
                                                results.push( elem );
                                                break;
                                        }
                                }
                                if ( outermost ) {
                                        dirruns = dirrunsUnique;
                                }
                        }

                        // Track unmatched elements for set filters
                        if ( bySet ) {
                                // They will have gone through all possible matchers
                                if ( (elem = !matcher &amp;&amp; elem) ) {
                                        matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if ( seed ) {
                                        unmatched.push( elem );
                                }
                        }
                }

                // Apply set filters to unmatched elements
                matchedCount += i;
                if ( bySet &amp;&amp; i !== matchedCount ) {
                        j = 0;
                        while ( (matcher = setMatchers[j++]) ) {
                                matcher( unmatched, setMatched, context, xml );
                        }

                        if ( seed ) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if ( matchedCount &gt; 0 ) {
                                        while ( i-- ) {
                                                if ( !(unmatched[i] || setMatched[i]) ) {
                                                        setMatched[i] = pop.call( results );
                                                }
                                        }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense( setMatched );
                        }

                        // Add matches to results
                        push.apply( results, setMatched );

                        // Seedless set matches succeeding multiple successful matchers stipulate sorting
                        if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
                                ( matchedCount + setMatchers.length ) &gt; 1 ) {

                                Sizzle.uniqueSort( results );
                        }
                }

                // Override manipulation of globals by nested matchers
                if ( outermost ) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                }

                return unmatched;
        };

return bySet ?
        markFunction( superMatcher ) :
        superMatcher;</pre>

<p>}</p>

<p>compile = Sizzle.compile = function( selector, match /* Internal Use Only
*/ ) {</p>

<pre>var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[ selector + &quot; &quot; ];

if ( !cached ) {
        // Generate a function of recursive functions that can be used to check each element
        if ( !match ) {
                match = tokenize( selector );
        }
        i = match.length;
        while ( i-- ) {
                cached = matcherFromTokens( match[i] );
                if ( cached[ expando ] ) {
                        setMatchers.push( cached );
                } else {
                        elementMatchers.push( cached );
                }
        }

        // Cache the compiled function
        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

        // Save selector and tokenization
        cached.selector = selector;
}
return cached;</pre>

<p>};</p>

<p>/**</p>

<pre> A low-level selection function that works with Sizzle&#39;s compiled
  selector functions
 @param {String|Function} selector A selector or a pre-compiled
  selector function built with Sizzle.compile
 @param {Element} context
 @param {Array} [results]
 @param {Array} [seed] A set of elements to match against
/</pre>

<p>select = Sizzle.select = function( selector, context, results, seed ) {</p>

<pre>var i, tokens, token, type, find,
        compiled = typeof selector === &quot;function&quot; &amp;&amp; selector,
        match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) );

results = results || [];

// Try to minimize operations if there is no seed and only one group
if ( match.length === 1 ) {

        // Take a shortcut and set the context if the root selector is an ID
        tokens = match[0] = match[0].slice( 0 );
        if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
                        support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp;
                        Expr.relative[ tokens[1].type ] ) {

                context = ( Expr.find[&quot;ID&quot;]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                if ( !context ) {
                        return results;

                // Precompiled matchers will still verify ancestry, so step up a level
                } else if ( compiled ) {
                        context = context.parentNode;
                }

                selector = selector.slice( tokens.shift().value.length );
        }

        // Fetch a seed set for right-to-left matching
        i = matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length;
        while ( i-- ) {
                token = tokens[i];

                // Abort if we hit a combinator
                if ( Expr.relative[ (type = token.type) ] ) {
                        break;
                }
                if ( (find = Expr.find[ type ]) ) {
                        // Search, expanding context for leading sibling combinators
                        if ( (seed = find(
                                token.matches[0].replace( runescape, funescape ),
                                rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context
                        )) ) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice( i, 1 );
                                selector = seed.length &amp;&amp; toSelector( tokens );
                                if ( !selector ) {
                                        push.apply( results, seed );
                                        return results;
                                }

                                break;
                        }
                }
        }
}

// Compile and execute a filtering function if one is not provided
// Provide `match` to avoid retokenization if we modified the selector above
( compiled || compile( selector, match ) )(
        seed,
        context,
        !documentIsHTML,
        results,
        rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context
);
return results;</pre>

<p>};</p>

<p>// One-time assignments</p>

<p>// Sort stability support.sortStable = expando.split().sort( sortOrder
).join() === expando;</p>

<p>// Support: Chrome&lt;14 // Always assume duplicates if they aren&#39;t
passed to the comparison function support.detectDuplicates =
!!hasDuplicate;</p>

<p>// Initialize against the default document setDocument();</p>

<p>// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other* support.sortDetached =
assert(function( div1 ) {</p>

<pre>// Should return 1, but returns 4 (following)
return div1.compareDocumentPosition( document.createElement(&quot;div&quot;) ) &amp; 1;</pre>

<p>});</p>

<p>// Support: IE&lt;8 // Prevent attribute/property interpolation // <a
href="http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx">msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</a>
if ( !assert(function( div ) {</p>

<pre class="ruby"><span class="ruby-identifier">div</span>.<span class="ruby-identifier">innerHTML</span> = <span class="ruby-node">&quot;&lt;a href=&#39;#&#39;&gt;&lt;/a&gt;&quot;</span>;
<span class="ruby-keyword">return</span> <span class="ruby-identifier">div</span>.<span class="ruby-identifier">firstChild</span>.<span class="ruby-identifier">getAttribute</span>(<span class="ruby-string">&quot;href&quot;</span>) <span class="ruby-operator">===</span> <span class="ruby-node">&quot;#&quot;</span> ;
</pre>

<p>}) ) {</p>

<pre>addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) {
        if ( !isXML ) {
                return elem.getAttribute( name, name.toLowerCase() === &quot;type&quot; ? 1 : 2 );
        }
});</pre>

<p>}</p>

<p>// Support: IE&lt;9 // Use defaultValue in place of getAttribute(value)
if ( !support.attributes || !assert(function( div ) {</p>

<pre class="ruby"><span class="ruby-identifier">div</span>.<span class="ruby-identifier">innerHTML</span> = <span class="ruby-string">&quot;&lt;input/&gt;&quot;</span>;
<span class="ruby-identifier">div</span>.<span class="ruby-identifier">firstChild</span>.<span class="ruby-identifier">setAttribute</span>( <span class="ruby-string">&quot;value&quot;</span>, <span class="ruby-string">&quot;&quot;</span> );
<span class="ruby-keyword">return</span> <span class="ruby-identifier">div</span>.<span class="ruby-identifier">firstChild</span>.<span class="ruby-identifier">getAttribute</span>( <span class="ruby-string">&quot;value&quot;</span> ) <span class="ruby-operator">===</span> <span class="ruby-string">&quot;&quot;</span>;
</pre>

<p>}) ) {</p>

<pre>addHandle( &quot;value&quot;, function( elem, name, isXML ) {
        if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot; ) {
                return elem.defaultValue;
        }
});</pre>

<p>}</p>

<p>// Support: IE&lt;9 // Use getAttributeNode to fetch booleans when
getAttribute lies if ( !assert(function( div ) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">div</span>.<span class="ruby-identifier">getAttribute</span>(<span class="ruby-string">&quot;disabled&quot;</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>;
</pre>

<p>}) ) {</p>

<pre>addHandle( booleans, function( elem, name, isXML ) {
        var val;
        if ( !isXML ) {
                return elem[ name ] === true ? name.toLowerCase() :
                                (val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?
                                val.value :
                        null;
        }
});</pre>

<p>}</p>

<p>return Sizzle;</p>

<p>})( window );</p>

<p>jQuery.find = Sizzle; jQuery.expr = Sizzle.selectors; <a
href="":"">jQuery.expr</a> = jQuery.expr.pseudos; jQuery.unique =
Sizzle.uniqueSort; jQuery.text = Sizzle.getText; jQuery.isXMLDoc =
Sizzle.isXML; jQuery.contains = Sizzle.contains;</p>

<p>var rneedsContext = jQuery.expr.match.needsContext;</p>

<p>var rsingleTag = (/^&lt;(w+)s*/?&gt;(?:&lt;/1&gt;|)$/);</p>

<p>var risSimple = /^.[^:#[.,]*$/;</p>

<p>// Implement the identical functionality for filter and not function
winnow( elements, qualifier, not ) {</p>

<pre>if ( jQuery.isFunction( qualifier ) ) {
        return jQuery.grep( elements, function( elem, i ) {
                /* jshint -W018 */
                return !!qualifier.call( elem, i, elem ) !== not;
        });

}

if ( qualifier.nodeType ) {
        return jQuery.grep( elements, function( elem ) {
                return ( elem === qualifier ) !== not;
        });

}

if ( typeof qualifier === &quot;string&quot; ) {
        if ( risSimple.test( qualifier ) ) {
                return jQuery.filter( qualifier, elements, not );
        }

        qualifier = jQuery.filter( qualifier, elements );
}

return jQuery.grep( elements, function( elem ) {
        return ( jQuery.inArray( elem, qualifier ) &gt;= 0 ) !== not;
});</pre>

<p>}</p>

<p>jQuery.filter = function( expr, elems, not ) {</p>

<pre>var elem = elems[ 0 ];

if ( not ) {
        expr = &quot;:not(&quot; + expr + &quot;)&quot;;
}

return elems.length === 1 &amp;&amp; elem.nodeType === 1 ?
        jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
        jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                return elem.nodeType === 1;
        }));</pre>

<p>};</p>

<p>jQuery.fn.extend({</p>

<pre>find: function( selector ) {
        var i,
                ret = [],
                self = this,
                len = self.length;

        if ( typeof selector !== &quot;string&quot; ) {
                return this.pushStack( jQuery( selector ).filter(function() {
                        for ( i = 0; i &lt; len; i++ ) {
                                if ( jQuery.contains( self[ i ], this ) ) {
                                        return true;
                                }
                        }
                }) );
        }

        for ( i = 0; i &lt; len; i++ ) {
                jQuery.find( selector, self[ i ], ret );
        }

        // Needed because $( selector, context ) becomes $( context ).find( selector )
        ret = this.pushStack( len &gt; 1 ? jQuery.unique( ret ) : ret );
        ret.selector = this.selector ? this.selector + &quot; &quot; + selector : selector;
        return ret;
},
filter: function( selector ) {
        return this.pushStack( winnow(this, selector || [], false) );
},
not: function( selector ) {
        return this.pushStack( winnow(this, selector || [], true) );
},
is: function( selector ) {
        return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won&#39;t return true for a doc with two &quot;p&quot;.
                typeof selector === &quot;string&quot; &amp;&amp; rneedsContext.test( selector ) ?
                        jQuery( selector ) :
                        selector || [],
                false
        ).length;
}</pre>

<p>});</p>

<p>// Initialize a jQuery object</p>

<p>// A central reference to the root jQuery(document) var rootjQuery,</p>

<pre>// Use the correct document accordingly with window argument (sandbox)
document = window.document,

// A simple way to check for HTML strings
// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)
// Strict HTML recognition (#11290: must start with &lt;)
rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/,

init = jQuery.fn.init = function( selector, context ) {
        var match, elem;

        // HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)
        if ( !selector ) {
                return this;
        }

        // Handle HTML strings
        if ( typeof selector === &quot;string&quot; ) {
                if ( selector.charAt(0) === &quot;&lt;&quot; &amp;&amp; selector.charAt( selector.length - 1 ) === &quot;&gt;&quot; &amp;&amp; selector.length &gt;= 3 ) {
                        // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
                        match = [ null, selector, null ];

                } else {
                        match = rquickExpr.exec( selector );
                }

                // Match html or make sure no context is specified for #id
                if ( match &amp;&amp; (match[1] || !context) ) {

                        // HANDLE: $(html) -&gt; $(array)
                        if ( match[1] ) {
                                context = context instanceof jQuery ? context[0] : context;

                                // scripts is true for back-compat
                                // Intentionally let the error be thrown if parseHTML is not present
                                jQuery.merge( this, jQuery.parseHTML(
                                        match[1],
                                        context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
                                        true
                                ) );

                                // HANDLE: $(html, props)
                                if ( rsingleTag.test( match[1] ) &amp;&amp; jQuery.isPlainObject( context ) ) {
                                        for ( match in context ) {
                                                // Properties of context are called as methods if possible
                                                if ( jQuery.isFunction( this[ match ] ) ) {
                                                        this[ match ]( context[ match ] );

                                                // ...and otherwise set as attributes
                                                } else {
                                                        this.attr( match, context[ match ] );
                                                }
                                        }
                                }

                                return this;

                        // HANDLE: $(#id)
                        } else {
                                elem = document.getElementById( match[2] );

                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                if ( elem &amp;&amp; elem.parentNode ) {
                                        // Handle the case where IE and Opera return items
                                        // by name instead of ID
                                        if ( elem.id !== match[2] ) {
                                                return rootjQuery.find( selector );
                                        }

                                        // Otherwise, we inject the element directly into the jQuery object
                                        this.length = 1;
                                        this[0] = elem;
                                }

                                this.context = document;
                                this.selector = selector;
                                return this;
                        }

                // HANDLE: $(expr, $(...))
                } else if ( !context || context.jquery ) {
                        return ( context || rootjQuery ).find( selector );

                // HANDLE: $(expr, context)
                // (which is just equivalent to: $(context).find(expr)
                } else {
                        return this.constructor( context ).find( selector );
                }

        // HANDLE: $(DOMElement)
        } else if ( selector.nodeType ) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;

        // HANDLE: $(function)
        // Shortcut for document ready
        } else if ( jQuery.isFunction( selector ) ) {
                return typeof rootjQuery.ready !== &quot;undefined&quot; ?
                        rootjQuery.ready( selector ) :
                        // Execute immediately if ready is not present
                        selector( jQuery );
        }

        if ( selector.selector !== undefined ) {
                this.selector = selector.selector;
                this.context = selector.context;
        }

        return jQuery.makeArray( selector, this );
};</pre>

<p>// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;</p>

<p>// Initialize central reference rootjQuery = jQuery( document );</p>

<p>var rparentsprev = /^(?:parents|prev(?:Until|All))/,</p>

<pre>// methods guaranteed to produce a unique set when starting from a unique set
guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
};</pre>

<p>jQuery.extend({</p>

<pre>dir: function( elem, dir, until ) {
        var matched = [],
                cur = elem[ dir ];

        while ( cur &amp;&amp; cur.nodeType !== 9 &amp;&amp; (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
                if ( cur.nodeType === 1 ) {
                        matched.push( cur );
                }
                cur = cur[dir];
        }
        return matched;
},

sibling: function( n, elem ) {
        var r = [];

        for ( ; n; n = n.nextSibling ) {
                if ( n.nodeType === 1 &amp;&amp; n !== elem ) {
                        r.push( n );
                }
        }

        return r;
}</pre>

<p>});</p>

<p>jQuery.fn.extend({</p>

<pre>has: function( target ) {
        var i,
                targets = jQuery( target, this ),
                len = targets.length;

        return this.filter(function() {
                for ( i = 0; i &lt; len; i++ ) {
                        if ( jQuery.contains( this, targets[i] ) ) {
                                return true;
                        }
                }
        });
},

closest: function( selectors, context ) {
        var cur,
                i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test( selectors ) || typeof selectors !== &quot;string&quot; ?
                        jQuery( selectors, context || this.context ) :
                        0;

        for ( ; i &lt; l; i++ ) {
                for ( cur = this[i]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) {
                        // Always skip document fragments
                        if ( cur.nodeType &lt; 11 &amp;&amp; (pos ?
                                pos.index(cur) &gt; -1 :

                                // Don&#39;t pass non-elements to Sizzle
                                cur.nodeType === 1 &amp;&amp;
                                        jQuery.find.matchesSelector(cur, selectors)) ) {

                                matched.push( cur );
                                break;
                        }
                }
        }

        return this.pushStack( matched.length &gt; 1 ? jQuery.unique( matched ) : matched );
},

// Determine the position of an element within
// the matched set of elements
index: function( elem ) {

        // No argument, return index in parent
        if ( !elem ) {
                return ( this[0] &amp;&amp; this[0].parentNode ) ? this.first().prevAll().length : -1;
        }

        // index in selector
        if ( typeof elem === &quot;string&quot; ) {
                return jQuery.inArray( this[0], jQuery( elem ) );
        }

        // Locate the position of the desired element
        return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem, this );
},

add: function( selector, context ) {
        return this.pushStack(
                jQuery.unique(
                        jQuery.merge( this.get(), jQuery( selector, context ) )
                )
        );
},

addBack: function( selector ) {
        return this.add( selector == null ?
                this.prevObject : this.prevObject.filter(selector)
        );
}</pre>

<p>});</p>

<p>function sibling( cur, dir ) {</p>

<pre>do {
        cur = cur[ dir ];
} while ( cur &amp;&amp; cur.nodeType !== 1 );

return cur;</pre>

<p>}</p>

<p>jQuery.each({</p>

<pre>parent: function( elem ) {
        var parent = elem.parentNode;
        return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
},
parents: function( elem ) {
        return jQuery.dir( elem, &quot;parentNode&quot; );
},
parentsUntil: function( elem, i, until ) {
        return jQuery.dir( elem, &quot;parentNode&quot;, until );
},
next: function( elem ) {
        return sibling( elem, &quot;nextSibling&quot; );
},
prev: function( elem ) {
        return sibling( elem, &quot;previousSibling&quot; );
},
nextAll: function( elem ) {
        return jQuery.dir( elem, &quot;nextSibling&quot; );
},
prevAll: function( elem ) {
        return jQuery.dir( elem, &quot;previousSibling&quot; );
},
nextUntil: function( elem, i, until ) {
        return jQuery.dir( elem, &quot;nextSibling&quot;, until );
},
prevUntil: function( elem, i, until ) {
        return jQuery.dir( elem, &quot;previousSibling&quot;, until );
},
siblings: function( elem ) {
        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
},
children: function( elem ) {
        return jQuery.sibling( elem.firstChild );
},
contents: function( elem ) {
        return jQuery.nodeName( elem, &quot;iframe&quot; ) ?
                elem.contentDocument || elem.contentWindow.document :
                jQuery.merge( [], elem.childNodes );
}</pre>

<p>}, function( name, fn ) {</p>

<pre>jQuery.fn[ name ] = function( until, selector ) {
        var ret = jQuery.map( this, fn, until );

        if ( name.slice( -5 ) !== &quot;Until&quot; ) {
                selector = until;
        }

        if ( selector &amp;&amp; typeof selector === &quot;string&quot; ) {
                ret = jQuery.filter( selector, ret );
        }

        if ( this.length &gt; 1 ) {
                // Remove duplicates
                if ( !guaranteedUnique[ name ] ) {
                        ret = jQuery.unique( ret );
                }

                // Reverse order for parents* and prev-derivatives
                if ( rparentsprev.test( name ) ) {
                        ret = ret.reverse();
                }
        }

        return this.pushStack( ret );
};</pre>

<p>}); var rnotwhite = (/S+/g);</p>

<p>// String to <a href="../../Object.html">Object</a> options format cache
var optionsCache = {};</p>

<p>// Convert String-formatted options into Object-formatted ones and store in
cache function createOptions( options ) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">object</span> = <span class="ruby-identifier">optionsCache</span>[ <span class="ruby-identifier">options</span> ] = {};
<span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">each</span>( <span class="ruby-identifier">options</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">rnotwhite</span> ) <span class="ruby-operator">||</span> [], <span class="ruby-identifier">function</span>( <span class="ruby-identifier">_</span>, <span class="ruby-identifier">flag</span> ) {
        <span class="ruby-identifier">object</span>[ <span class="ruby-identifier">flag</span> ] = <span class="ruby-keyword">true</span>;
});
<span class="ruby-keyword">return</span> <span class="ruby-identifier">object</span>;
</pre>

<p>}</p>

<p>/*</p>

<pre> Create a callback list using the following parameters:

      options: an optional list of space-separated options that will change how
                      the callback list behaves or a more traditional option object

 By default a callback list will act like an event callback list and can be
 &quot;fired&quot; multiple times.

 Possible options:

      once:                   will ensure the callback list can only be fired once (like a Deferred)

      memory:                 will keep track of previous values and will call any callback added
                                      after the list has been fired right away with the latest &quot;memorized&quot;
                                      values (like a Deferred)

      unique:                 will ensure a callback can only be added once (no duplicate in the list)

      stopOnFalse:    interrupt callings when a callback returns false

/</pre>

<p>jQuery.Callbacks = function( options ) {</p>

<pre>// Convert options from String-formatted to Object-formatted if needed
// (we check in cache first)
options = typeof options === &quot;string&quot; ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery.extend( {}, options );

var // Flag to know if list is currently firing
        firing,
        // Last fire value (for non-forgettable lists)
        memory,
        // Flag to know if list was already fired
        fired,
        // End of the loop when firing
        firingLength,
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,
        // First callback to fire (used internally by add and fireWith)
        firingStart,
        // Actual callback list
        list = [],
        // Stack of fire calls for repeatable lists
        stack = !options.once &amp;&amp; [],
        // Fire callbacks
        fire = function( data ) {
                memory = options.memory &amp;&amp; data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {
                        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {
                                memory = false; // To prevent further calls using add
                                break;
                        }
                }
                firing = false;
                if ( list ) {
                        if ( stack ) {
                                if ( stack.length ) {
                                        fire( stack.shift() );
                                }
                        } else if ( memory ) {
                                list = [];
                        } else {
                                self.disable();
                        }
                }
        },
        // Actual Callbacks object
        self = {
                // Add a callback or a collection of callbacks to the list
                add: function() {
                        if ( list ) {
                                // First, we save the current length
                                var start = list.length;
                                (function add( args ) {
                                        jQuery.each( args, function( _, arg ) {
                                                var type = jQuery.type( arg );
                                                if ( type === &quot;function&quot; ) {
                                                        if ( !options.unique || !self.has( arg ) ) {
                                                                list.push( arg );
                                                        }
                                                } else if ( arg &amp;&amp; arg.length &amp;&amp; type !== &quot;string&quot; ) {
                                                        // Inspect recursively
                                                        add( arg );
                                                }
                                        });
                                })( arguments );
                                // Do we need to add the callbacks to the
                                // current firing batch?
                                if ( firing ) {
                                        firingLength = list.length;
                                // With memory, if we&#39;re not firing then
                                // we should call right away
                                } else if ( memory ) {
                                        firingStart = start;
                                        fire( memory );
                                }
                        }
                        return this;
                },
                // Remove a callback from the list
                remove: function() {
                        if ( list ) {
                                jQuery.each( arguments, function( _, arg ) {
                                        var index;
                                        while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
                                                list.splice( index, 1 );
                                                // Handle firing indexes
                                                if ( firing ) {
                                                        if ( index &lt;= firingLength ) {
                                                                firingLength--;
                                                        }
                                                        if ( index &lt;= firingIndex ) {
                                                                firingIndex--;
                                                        }
                                                }
                                        }
                                });
                        }
                        return this;
                },
                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function( fn ) {
                        return fn ? jQuery.inArray( fn, list ) &gt; -1 : !!( list &amp;&amp; list.length );
                },
                // Remove all callbacks from the list
                empty: function() {
                        list = [];
                        firingLength = 0;
                        return this;
                },
                // Have the list do nothing anymore
                disable: function() {
                        list = stack = memory = undefined;
                        return this;
                },
                // Is it disabled?
                disabled: function() {
                        return !list;
                },
                // Lock the list in its current state
                lock: function() {
                        stack = undefined;
                        if ( !memory ) {
                                self.disable();
                        }
                        return this;
                },
                // Is it locked?
                locked: function() {
                        return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function( context, args ) {
                        if ( list &amp;&amp; ( !fired || stack ) ) {
                                args = args || [];
                                args = [ context, args.slice ? args.slice() : args ];
                                if ( firing ) {
                                        stack.push( args );
                                } else {
                                        fire( args );
                                }
                        }
                        return this;
                },
                // Call all the callbacks with the given arguments
                fire: function() {
                        self.fireWith( this, arguments );
                        return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function() {
                        return !!fired;
                }
        };

return self;</pre>

<p>};</p>

<p>jQuery.extend({</p>

<pre>Deferred: function( func ) {
        var tuples = [
                        // action, add listener, listener list, final state
                        [ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ],
                        [ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ],
                        [ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ]
                ],
                state = &quot;pending&quot;,
                promise = {
                        state: function() {
                                return state;
                        },
                        always: function() {
                                deferred.done( arguments ).fail( arguments );
                                return this;
                        },
                        then: function( /* fnDone, fnFail, fnProgress */ ) {
                                var fns = arguments;
                                return jQuery.Deferred(function( newDefer ) {
                                        jQuery.each( tuples, function( i, tuple ) {
                                                var fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ];
                                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                                deferred[ tuple[1] ](function() {
                                                        var returned = fn &amp;&amp; fn.apply( this, arguments );
                                                        if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {
                                                                returned.promise()
                                                                        .done( newDefer.resolve )
                                                                        .fail( newDefer.reject )
                                                                        .progress( newDefer.notify );
                                                        } else {
                                                                newDefer[ tuple[ 0 ] + &quot;With&quot; ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                                        }
                                                });
                                        });
                                        fns = null;
                                }).promise();
                        },
                        // Get a promise for this deferred
                        // If obj is provided, the promise aspect is added to the object
                        promise: function( obj ) {
                                return obj != null ? jQuery.extend( obj, promise ) : promise;
                        }
                },
                deferred = {};

        // Keep pipe for back-compat
        promise.pipe = promise.then;

        // Add list-specific methods
        jQuery.each( tuples, function( i, tuple ) {
                var list = tuple[ 2 ],
                        stateString = tuple[ 3 ];

                // promise[ done | fail | progress ] = list.add
                promise[ tuple[1] ] = list.add;

                // Handle state
                if ( stateString ) {
                        list.add(function() {
                                // state = [ resolved | rejected ]
                                state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                        }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                }

                // deferred[ resolve | reject | notify ]
                deferred[ tuple[0] ] = function() {
                        deferred[ tuple[0] + &quot;With&quot; ]( this === deferred ? promise : this, arguments );
                        return this;
                };
                deferred[ tuple[0] + &quot;With&quot; ] = list.fireWith;
        });

        // Make the deferred a promise
        promise.promise( deferred );

        // Call given func if any
        if ( func ) {
                func.call( deferred, deferred );
        }

        // All done!
        return deferred;
},

// Deferred helper
when: function( subordinate /* , ..., subordinateN */ ) {
        var i = 0,
                resolveValues = slice.call( arguments ),
                length = resolveValues.length,

                // the count of uncompleted subordinates
                remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0,

                // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                // Update function for both resolve and progress values
                updateFunc = function( i, contexts, values ) {
                        return function( value ) {
                                contexts[ i ] = this;
                                values[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;
                                if ( values === progressValues ) {
                                        deferred.notifyWith( contexts, values );

                                } else if ( !(--remaining) ) {
                                        deferred.resolveWith( contexts, values );
                                }
                        };
                },

                progressValues, progressContexts, resolveContexts;

        // add listeners to Deferred subordinates; treat others as resolved
        if ( length &gt; 1 ) {
                progressValues = new Array( length );
                progressContexts = new Array( length );
                resolveContexts = new Array( length );
                for ( ; i &lt; length; i++ ) {
                        if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) {
                                resolveValues[ i ].promise()
                                        .done( updateFunc( i, resolveContexts, resolveValues ) )
                                        .fail( deferred.reject )
                                        .progress( updateFunc( i, progressContexts, progressValues ) );
                        } else {
                                --remaining;
                        }
                }
        }

        // if we&#39;re not waiting on anything, resolve the master
        if ( !remaining ) {
                deferred.resolveWith( resolveContexts, resolveValues );
        }

        return deferred.promise();
}</pre>

<p>});</p>

<p>// The deferred used on DOM ready var readyList;</p>

<p>jQuery.fn.ready = function( fn ) {</p>

<pre>// Add the callback
jQuery.ready.promise().done( fn );

return this;</pre>

<p>};</p>

<p>jQuery.extend({</p>

<pre>// Is the DOM ready to be used? Set to true once it occurs.
isReady: false,

// A counter to track how many items to wait for before
// the ready event fires. See #6781
readyWait: 1,

// Hold (or release) the ready event
holdReady: function( hold ) {
        if ( hold ) {
                jQuery.readyWait++;
        } else {
                jQuery.ready( true );
        }
},

// Handle when the DOM is ready
ready: function( wait ) {

        // Abort if there are pending holds or we&#39;re already ready
        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                return;
        }

        // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
        if ( !document.body ) {
                return setTimeout( jQuery.ready );
        }

        // Remember that the DOM is ready
        jQuery.isReady = true;

        // If a normal DOM Ready event fired, decrement, and wait if need be
        if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
                return;
        }

        // If there are functions bound, to execute
        readyList.resolveWith( document, [ jQuery ] );

        // Trigger any bound ready events
        if ( jQuery.fn.triggerHandler ) {
                jQuery( document ).triggerHandler( &quot;ready&quot; );
                jQuery( document ).off( &quot;ready&quot; );
        }
}</pre>

<p>});</p>

<p>/**</p>

<pre> Clean-up method for dom ready events
/</pre>

<p>function detach() {</p>

<pre>if ( document.addEventListener ) {
        document.removeEventListener( &quot;DOMContentLoaded&quot;, completed, false );
        window.removeEventListener( &quot;load&quot;, completed, false );

} else {
        document.detachEvent( &quot;onreadystatechange&quot;, completed );
        window.detachEvent( &quot;onload&quot;, completed );
}</pre>

<p>}</p>

<p>/**</p>

<pre> The ready event handler and self cleanup method
/</pre>

<p>function completed() {</p>

<pre>// readyState === &quot;complete&quot; is good enough for us to call the dom ready in oldIE
if ( document.addEventListener || event.type === &quot;load&quot; || document.readyState === &quot;complete&quot; ) {
        detach();
        jQuery.ready();
}</pre>

<p>}</p>

<p>jQuery.ready.promise = function( obj ) {</p>

<pre>if ( !readyList ) {

        readyList = jQuery.Deferred();

        // Catch cases where $(document).ready() is called after the browser event has already occurred.
        // we once tried to use readyState &quot;interactive&quot; here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
        if ( document.readyState === &quot;complete&quot; ) {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout( jQuery.ready );

        // Standards-based browsers support DOMContentLoaded
        } else if ( document.addEventListener ) {
                // Use the handy event callback
                document.addEventListener( &quot;DOMContentLoaded&quot;, completed, false );

                // A fallback to window.onload, that will always work
                window.addEventListener( &quot;load&quot;, completed, false );

        // If IE event model is used
        } else {
                // Ensure firing before onload, maybe late but safe also for iframes
                document.attachEvent( &quot;onreadystatechange&quot;, completed );

                // A fallback to window.onload, that will always work
                window.attachEvent( &quot;onload&quot;, completed );

                // If IE and not a frame
                // continually check to see if the document is ready
                var top = false;

                try {
                        top = window.frameElement == null &amp;&amp; document.documentElement;
                } catch(e) {}

                if ( top &amp;&amp; top.doScroll ) {
                        (function doScrollCheck() {
                                if ( !jQuery.isReady ) {

                                        try {
                                                // Use the trick by Diego Perini
                                                // http://javascript.nwbox.com/IEContentLoaded/
                                                top.doScroll(&quot;left&quot;);
                                        } catch(e) {
                                                return setTimeout( doScrollCheck, 50 );
                                        }

                                        // detach all dom ready events
                                        detach();

                                        // and execute any waiting functions
                                        jQuery.ready();
                                }
                        })();
                }
        }
}
return readyList.promise( obj );</pre>

<p>};</p>

<p>var strundefined = typeof undefined;</p>

<p>// Support: IE&lt;9 // Iteration over object&#39;s inherited properties
before its own var i; for ( i in jQuery( support ) ) {</p>

<pre>break;</pre>

<p>} support.ownLast = i !== 0;</p>

<p>// Note: most support tests are defined in their respective modules. //
false until the test is run support.inlineBlockNeedsLayout = false;</p>

<p>// Execute ASAP in case we need to set body.style.zoom jQuery(function() {</p>

<pre>// Minified: var a,b,c,d
var val, div, body, container;

body = document.getElementsByTagName( &quot;body&quot; )[ 0 ];
if ( !body || !body.style ) {
        // Return for frameset docs that don&#39;t have a body
        return;
}

// Setup
div = document.createElement( &quot;div&quot; );
container = document.createElement( &quot;div&quot; );
container.style.cssText = &quot;position:absolute;border:0;width:0;height:0;top:0;left:-9999px&quot;;
body.appendChild( container ).appendChild( div );

if ( typeof div.style.zoom !== strundefined ) {
        // Support: IE&lt;8
        // Check if natively block-level elements act like inline-block
        // elements when setting their display to &#39;inline&#39; and giving
        // them layout
        div.style.cssText = &quot;display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1&quot;;

        support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
        if ( val ) {
                // Prevent IE 6 from affecting layout for positioned elements #11048
                // Prevent IE from shrinking the body in IE 7 mode #12869
                // Support: IE&lt;8
                body.style.zoom = 1;
        }
}

body.removeChild( container );</pre>

<p>});</p>

<p>(function() {</p>

<pre>var div = document.createElement( &quot;div&quot; );

// Execute the test only if not already executed in another module.
if (support.deleteExpando == null) {
        // Support: IE&lt;9
        support.deleteExpando = true;
        try {
                delete div.test;
        } catch( e ) {
                support.deleteExpando = false;
        }
}

// Null elements to avoid leaks in IE.
div = null;</pre>

<p>})();</p>

<p>/**</p>

<pre> Determines whether an object can have data
/</pre>

<p>jQuery.acceptData = function( elem ) {</p>

<pre>var noData = jQuery.noData[ (elem.nodeName + &quot; &quot;).toLowerCase() ],
        nodeType = +elem.nodeType || 1;

// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
return nodeType !== 1 &amp;&amp; nodeType !== 9 ?
        false :

        // Nodes accept data unless otherwise specified; rejection can be conditional
        !noData || noData !== true &amp;&amp; elem.getAttribute(&quot;classid&quot;) === noData;</pre>

<p>};</p>

<p>var rbrace = /^(?:{[wW]*}|[[wW]*])$/,</p>

<pre>rmultiDash = /([A-Z])/g;</pre>

<p>function dataAttr( elem, key, data ) {</p>

<pre>// If nothing was found internally, try to fetch any
// data from the HTML5 data-* attribute
if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {

        var name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$1&quot; ).toLowerCase();

        data = elem.getAttribute( name );

        if ( typeof data === &quot;string&quot; ) {
                try {
                        data = data === &quot;true&quot; ? true :
                                data === &quot;false&quot; ? false :
                                data === &quot;null&quot; ? null :
                                // Only convert to a number if it doesn&#39;t change the string
                                +data + &quot;&quot; === data ? +data :
                                rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                data;
                } catch( e ) {}

                // Make sure we set the data so it isn&#39;t changed later
                jQuery.data( elem, key, data );

        } else {
                data = undefined;
        }
}

return data;</pre>

<p>}</p>

<p>// checks a cache object for emptiness function isEmptyDataObject( obj ) {</p>

<pre>var name;
for ( name in obj ) {

        // if the public data object is empty, the private is still empty
        if ( name === &quot;data&quot; &amp;&amp; jQuery.isEmptyObject( obj[name] ) ) {
                continue;
        }
        if ( name !== &quot;toJSON&quot; ) {
                return false;
        }
}

return true;</pre>

<p>}</p>

<p>function internalData( elem, name, data, pvt /* Internal Use Only */ ) {</p>

<pre>if ( !jQuery.acceptData( elem ) ) {
        return;
}

var ret, thisCache,
        internalKey = jQuery.expando,

        // We have to handle DOM nodes and JS objects differently because IE6-7
        // can&#39;t GC object references properly across the DOM-JS boundary
        isNode = elem.nodeType,

        // Only DOM nodes need the global jQuery cache; JS object data is
        // attached directly to the object so GC can occur automatically
        cache = isNode ? jQuery.cache : elem,

        // Only defining an ID for JS objects if its cache already exists allows
        // the code to shortcut on the same path as a DOM node with no cache
        id = isNode ? elem[ internalKey ] : elem[ internalKey ] &amp;&amp; internalKey;

// Avoid doing any more work than we need to when trying to get data on an
// object that has no data at all
if ( (!id || !cache[id] || (!pvt &amp;&amp; !cache[id].data)) &amp;&amp; data === undefined &amp;&amp; typeof name === &quot;string&quot; ) {
        return;
}

if ( !id ) {
        // Only DOM nodes need a new unique ID for each element since their data
        // ends up in the global cache
        if ( isNode ) {
                id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
        } else {
                id = internalKey;
        }
}

if ( !cache[ id ] ) {
        // Avoid exposing jQuery metadata on plain JS objects when the object
        // is serialized using JSON.stringify
        cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
}

// An object can be passed to jQuery.data instead of a key/value pair; this gets
// shallow copied over onto the existing cache
if ( typeof name === &quot;object&quot; || typeof name === &quot;function&quot; ) {
        if ( pvt ) {
                cache[ id ] = jQuery.extend( cache[ id ], name );
        } else {
                cache[ id ].data = jQuery.extend( cache[ id ].data, name );
        }
}

thisCache = cache[ id ];

// jQuery data() is stored in a separate object inside the object&#39;s internal data
// cache in order to avoid key collisions between internal data and user-defined
// data.
if ( !pvt ) {
        if ( !thisCache.data ) {
                thisCache.data = {};
        }

        thisCache = thisCache.data;
}

if ( data !== undefined ) {
        thisCache[ jQuery.camelCase( name ) ] = data;
}

// Check for both converted-to-camel and non-converted data property names
// If a data property was specified
if ( typeof name === &quot;string&quot; ) {

        // First Try to find as-is property data
        ret = thisCache[ name ];

        // Test for null|undefined property data
        if ( ret == null ) {

                // Try to find the camelCased property
                ret = thisCache[ jQuery.camelCase( name ) ];
        }
} else {
        ret = thisCache;
}

return ret;</pre>

<p>}</p>

<p>function internalRemoveData( elem, name, pvt ) {</p>

<pre>if ( !jQuery.acceptData( elem ) ) {
        return;
}

var thisCache, i,
        isNode = elem.nodeType,

        // See jQuery.data for more information
        cache = isNode ? jQuery.cache : elem,
        id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

// If there is already no cache entry for this object, there is no
// purpose in continuing
if ( !cache[ id ] ) {
        return;
}

if ( name ) {

        thisCache = pvt ? cache[ id ] : cache[ id ].data;

        if ( thisCache ) {

                // Support array or space separated string names for data keys
                if ( !jQuery.isArray( name ) ) {

                        // try the string as a key before any manipulation
                        if ( name in thisCache ) {
                                name = [ name ];
                        } else {

                                // split the camel cased version by spaces unless a key with the spaces exists
                                name = jQuery.camelCase( name );
                                if ( name in thisCache ) {
                                        name = [ name ];
                                } else {
                                        name = name.split(&quot; &quot;);
                                }
                        }
                } else {
                        // If &quot;name&quot; is an array of keys...
                        // When data is initially created, via (&quot;key&quot;, &quot;val&quot;) signature,
                        // keys will be converted to camelCase.
                        // Since there is no way to tell _how_ a key was added, remove
                        // both plain key and camelCase key. #12786
                        // This will only penalize the array argument path.
                        name = name.concat( jQuery.map( name, jQuery.camelCase ) );
                }

                i = name.length;
                while ( i-- ) {
                        delete thisCache[ name[i] ];
                }

                // If there is no data left in the cache, we want to continue
                // and let the cache object itself get destroyed
                if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
                        return;
                }
        }
}

// See jQuery.data for more information
if ( !pvt ) {
        delete cache[ id ].data;

        // Don&#39;t destroy the parent cache unless the internal data object
        // had been the only thing left in it
        if ( !isEmptyDataObject( cache[ id ] ) ) {
                return;
        }
}

// Destroy the cache
if ( isNode ) {
        jQuery.cleanData( [ elem ], true );

// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
/* jshint eqeqeq: false */
} else if ( support.deleteExpando || cache != cache.window ) {
        /* jshint eqeqeq: true */
        delete cache[ id ];

// When all else fails, null
} else {
        cache[ id ] = null;
}</pre>

<p>}</p>

<p>jQuery.extend({</p>

<pre>cache: {},

// The following elements (space-suffixed to avoid Object.prototype collisions)
// throw uncatchable exceptions if you attempt to set expando properties
noData: {
        &quot;applet &quot;: true,
        &quot;embed &quot;: true,
        // ...but Flash objects (which have this classid) *can* handle expandos
        &quot;object &quot;: &quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;
},

hasData: function( elem ) {
        elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
        return !!elem &amp;&amp; !isEmptyDataObject( elem );
},

data: function( elem, name, data ) {
        return internalData( elem, name, data );
},

removeData: function( elem, name ) {
        return internalRemoveData( elem, name );
},

// For internal use only.
_data: function( elem, name, data ) {
        return internalData( elem, name, data, true );
},

_removeData: function( elem, name ) {
        return internalRemoveData( elem, name, true );
}</pre>

<p>});</p>

<p>jQuery.fn.extend({</p>

<pre>data: function( key, value ) {
        var i, name, data,
                elem = this[0],
                attrs = elem &amp;&amp; elem.attributes;

        // Special expections of .data basically thwart jQuery.access,
        // so implement the relevant behavior ourselves

        // Gets all values
        if ( key === undefined ) {
                if ( this.length ) {
                        data = jQuery.data( elem );

                        if ( elem.nodeType === 1 &amp;&amp; !jQuery._data( elem, &quot;parsedAttrs&quot; ) ) {
                                i = attrs.length;
                                while ( i-- ) {

                                        // Support: IE11+
                                        // The attrs elements can be null (#14894)
                                        if ( attrs[ i ] ) {
                                                name = attrs[ i ].name;
                                                if ( name.indexOf( &quot;data-&quot; ) === 0 ) {
                                                        name = jQuery.camelCase( name.slice(5) );
                                                        dataAttr( elem, name, data[ name ] );
                                                }
                                        }
                                }
                                jQuery._data( elem, &quot;parsedAttrs&quot;, true );
                        }
                }

                return data;
        }

        // Sets multiple values
        if ( typeof key === &quot;object&quot; ) {
                return this.each(function() {
                        jQuery.data( this, key );
                });
        }

        return arguments.length &gt; 1 ?

                // Sets one value
                this.each(function() {
                        jQuery.data( this, key, value );
                }) :

                // Gets one value
                // Try to fetch any internally stored data first
                elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
},

removeData: function( key ) {
        return this.each(function() {
                jQuery.removeData( this, key );
        });
}</pre>

<p>});</p>

<p>jQuery.extend({</p>

<pre>queue: function( elem, type, data ) {
        var queue;

        if ( elem ) {
                type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
                queue = jQuery._data( elem, type );

                // Speed up dequeue by getting out quickly if this is just a lookup
                if ( data ) {
                        if ( !queue || jQuery.isArray(data) ) {
                                queue = jQuery._data( elem, type, jQuery.makeArray(data) );
                        } else {
                                queue.push( data );
                        }
                }
                return queue || [];
        }
},

dequeue: function( elem, type ) {
        type = type || &quot;fx&quot;;

        var queue = jQuery.queue( elem, type ),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks( elem, type ),
                next = function() {
                        jQuery.dequeue( elem, type );
                };

        // If the fx queue is dequeued, always remove the progress sentinel
        if ( fn === &quot;inprogress&quot; ) {
                fn = queue.shift();
                startLength--;
        }

        if ( fn ) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if ( type === &quot;fx&quot; ) {
                        queue.unshift( &quot;inprogress&quot; );
                }

                // clear up the last queue stop function
                delete hooks.stop;
                fn.call( elem, next, hooks );
        }

        if ( !startLength &amp;&amp; hooks ) {
                hooks.empty.fire();
        }
},

// not intended for public consumption - generates a queueHooks object, or returns the current one
_queueHooks: function( elem, type ) {
        var key = type + &quot;queueHooks&quot;;
        return jQuery._data( elem, key ) || jQuery._data( elem, key, {
                empty: jQuery.Callbacks(&quot;once memory&quot;).add(function() {
                        jQuery._removeData( elem, type + &quot;queue&quot; );
                        jQuery._removeData( elem, key );
                })
        });
}</pre>

<p>});</p>

<p>jQuery.fn.extend({</p>

<pre>queue: function( type, data ) {
        var setter = 2;

        if ( typeof type !== &quot;string&quot; ) {
                data = type;
                type = &quot;fx&quot;;
                setter--;
        }

        if ( arguments.length &lt; setter ) {
                return jQuery.queue( this[0], type );
        }

        return data === undefined ?
                this :
                this.each(function() {
                        var queue = jQuery.queue( this, type, data );

                        // ensure a hooks for this queue
                        jQuery._queueHooks( this, type );

                        if ( type === &quot;fx&quot; &amp;&amp; queue[0] !== &quot;inprogress&quot; ) {
                                jQuery.dequeue( this, type );
                        }
                });
},
dequeue: function( type ) {
        return this.each(function() {
                jQuery.dequeue( this, type );
        });
},
clearQueue: function( type ) {
        return this.queue( type || &quot;fx&quot;, [] );
},
// Get a promise resolved when queues of a certain type
// are emptied (fx is the type by default)
promise: function( type, obj ) {
        var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                        if ( !( --count ) ) {
                                defer.resolveWith( elements, [ elements ] );
                        }
                };

        if ( typeof type !== &quot;string&quot; ) {
                obj = type;
                type = undefined;
        }
        type = type || &quot;fx&quot;;

        while ( i-- ) {
                tmp = jQuery._data( elements[ i ], type + &quot;queueHooks&quot; );
                if ( tmp &amp;&amp; tmp.empty ) {
                        count++;
                        tmp.empty.add( resolve );
                }
        }
        resolve();
        return defer.promise( obj );
}</pre>

<p>}); var pnum = (/[+-]?(?:<a href=eE>d*.|)d+(?:</a>[+-]?d+|)/).source;</p>

<p>var cssExpand = [ Top, Right, Bottom, Left ];</p>

<p>var isHidden = function( elem, el ) {</p>

<pre>        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css( elem, &quot;display&quot; ) === &quot;none&quot; || !jQuery.contains( elem.ownerDocument, elem );
};</pre>

<p>// Multifunctional method to get and set values of a collection // The
value/s can optionally be executed if it&#39;s a function var access =
jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw )
{</p>

<pre>var i = 0,
        length = elems.length,
        bulk = key == null;

// Sets many values
if ( jQuery.type( key ) === &quot;object&quot; ) {
        chainable = true;
        for ( i in key ) {
                jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
        }

// Sets one value
} else if ( value !== undefined ) {
        chainable = true;

        if ( !jQuery.isFunction( value ) ) {
                raw = true;
        }

        if ( bulk ) {
                // Bulk operations run against the entire set
                if ( raw ) {
                        fn.call( elems, value );
                        fn = null;

                // ...except when executing function values
                } else {
                        bulk = fn;
                        fn = function( elem, key, value ) {
                                return bulk.call( jQuery( elem ), value );
                        };
                }
        }

        if ( fn ) {
                for ( ; i &lt; length; i++ ) {
                        fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
                }
        }
}

return chainable ?
        elems :

        // Gets
        bulk ?
                fn.call( elems ) :
                length ? fn( elems[0], key ) : emptyGet;</pre>

<p>}; var rcheckableType = (/^(?:checkbox|radio)$/i);</p>

<p>(function() {</p>

<pre>// Minified: var a,b,c
var input = document.createElement( &quot;input&quot; ),
        div = document.createElement( &quot;div&quot; ),
        fragment = document.createDocumentFragment();

// Setup
div.innerHTML = &quot;  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href=&#39;/a&#39;&gt;a&lt;/a&gt;&lt;input type=&#39;checkbox&#39;/&gt;&quot;;

// IE strips leading whitespace when .innerHTML is used
support.leadingWhitespace = div.firstChild.nodeType === 3;

// Make sure that tbody elements aren&#39;t automatically inserted
// IE will insert them into empty tables
support.tbody = !div.getElementsByTagName( &quot;tbody&quot; ).length;

// Make sure that link elements get serialized correctly by innerHTML
// This requires a wrapper element in IE
support.htmlSerialize = !!div.getElementsByTagName( &quot;link&quot; ).length;

// Makes sure cloning an html5 element does not cause problems
// Where outerHTML is undefined, this still works
support.html5Clone =
        document.createElement( &quot;nav&quot; ).cloneNode( true ).outerHTML !== &quot;&lt;:nav&gt;&lt;/:nav&gt;&quot;;

// Check if a disconnected checkbox will retain its checked
// value of true after appended to the DOM (IE6/7)
input.type = &quot;checkbox&quot;;
input.checked = true;
fragment.appendChild( input );
support.appendChecked = input.checked;

// Make sure textarea (and checkbox) defaultValue is properly cloned
// Support: IE6-IE11+
div.innerHTML = &quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;;
support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

// #11217 - WebKit loses check when the name is after the checked attribute
fragment.appendChild( div );
div.innerHTML = &quot;&lt;input type=&#39;radio&#39; checked=&#39;checked&#39; name=&#39;t&#39;/&gt;&quot;;

// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
// old WebKit doesn&#39;t clone checked state correctly in fragments
support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

// Support: IE&lt;9
// Opera does not clone events (and typeof div.attachEvent === undefined).
// IE9-10 clones events bound via attachEvent, but they don&#39;t trigger with .click()
support.noCloneEvent = true;
if ( div.attachEvent ) {
        div.attachEvent( &quot;onclick&quot;, function() {
                support.noCloneEvent = false;
        });

        div.cloneNode( true ).click();
}

// Execute the test only if not already executed in another module.
if (support.deleteExpando == null) {
        // Support: IE&lt;9
        support.deleteExpando = true;
        try {
                delete div.test;
        } catch( e ) {
                support.deleteExpando = false;
        }
}</pre>

<p>})();</p>

<p>(function() {</p>

<pre>var i, eventName,
        div = document.createElement( &quot;div&quot; );

// Support: IE&lt;9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
for ( i in { submit: true, change: true, focusin: true }) {
        eventName = &quot;on&quot; + i;

        if ( !(support[ i + &quot;Bubbles&quot; ] = eventName in window) ) {
                // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
                div.setAttribute( eventName, &quot;t&quot; );
                support[ i + &quot;Bubbles&quot; ] = div.attributes[ eventName ].expando === false;
        }
}

// Null elements to avoid leaks in IE.
div = null;</pre>

<p>})();</p>

<p>var rformElems = /^(?:input|select|textarea)$/i,</p>

<pre class="ruby"><span class="ruby-identifier">rkeyEvent</span> = <span class="ruby-regexp">/^key/</span>,
<span class="ruby-identifier">rmouseEvent</span> = <span class="ruby-regexp">/^(?:mouse|pointer|contextmenu)|click/</span>,
<span class="ruby-identifier">rfocusMorph</span> = <span class="ruby-regexp">/^(?:focusinfocus|focusoutblur)$/</span>,
<span class="ruby-identifier">rtypenamespace</span> = <span class="ruby-regexp">/^([^.]*)(?:\.(.+)|)$/</span>;
</pre>

<p>function returnTrue() {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
</pre>

<p>}</p>

<p>function returnFalse() {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
</pre>

<p>}</p>

<p>function safeActiveElement() {</p>

<pre>try {
        return document.activeElement;
} catch ( err ) { }</pre>

<p>}</p>

<p>/*</p>

<pre> Helper functions for managing events -- not part of the public interface.
 Props to Dean Edwards&#39; addEvent library for many of the ideas.
/</pre>

<p>jQuery.event = {</p>

<pre>global: {},

add: function( elem, types, handler, data, selector ) {
        var tmp, events, t, handleObjIn,
                special, eventHandle, handleObj,
                handlers, type, namespaces, origType,
                elemData = jQuery._data( elem );

        // Don&#39;t attach events to noData or text/comment nodes (but allow plain objects)
        if ( !elemData ) {
                return;
        }

        // Caller can pass in an object of custom data in lieu of the handler
        if ( handler.handler ) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
        }

        // Make sure that the handler has a unique ID, used to find/remove it later
        if ( !handler.guid ) {
                handler.guid = jQuery.guid++;
        }

        // Init the element&#39;s event structure and main handler, if this is the first
        if ( !(events = elemData.events) ) {
                events = elemData.events = {};
        }
        if ( !(eventHandle = elemData.handle) ) {
                eventHandle = elemData.handle = function( e ) {
                        // Discard the second event of a jQuery.event.trigger() and
                        // when an event is called after a page has unloaded
                        return typeof jQuery !== strundefined &amp;&amp; (!e || jQuery.event.triggered !== e.type) ?
                                jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                                undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
        }

        // Handle multiple events separated by a space
        types = ( types || &quot;&quot; ).match( rnotwhite ) || [ &quot;&quot; ];
        t = types.length;
        while ( t-- ) {
                tmp = rtypenamespace.exec( types[t] ) || [];
                type = origType = tmp[1];
                namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();

                // There *must* be a type, no attaching namespace-only handlers
                if ( !type ) {
                        continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[ type ] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = ( selector ? special.delegateType : special.bindType ) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[ type ] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
                        namespace: namespaces.join(&quot;.&quot;)
                }, handleObjIn );

                // Init the event handler queue if we&#39;re the first
                if ( !(handlers = events[ type ]) ) {
                        handlers = events[ type ] = [];
                        handlers.delegateCount = 0;

                        // Only use addEventListener/attachEvent if the special events handler returns false
                        if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                                // Bind the global event handler to the element
                                if ( elem.addEventListener ) {
                                        elem.addEventListener( type, eventHandle, false );

                                } else if ( elem.attachEvent ) {
                                        elem.attachEvent( &quot;on&quot; + type, eventHandle );
                                }
                        }
                }

                if ( special.add ) {
                        special.add.call( elem, handleObj );

                        if ( !handleObj.handler.guid ) {
                                handleObj.handler.guid = handler.guid;
                        }
                }

                // Add to the element&#39;s handler list, delegates in front
                if ( selector ) {
                        handlers.splice( handlers.delegateCount++, 0, handleObj );
                } else {
                        handlers.push( handleObj );
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[ type ] = true;
        }

        // Nullify elem to prevent memory leaks in IE
        elem = null;
},

// Detach an event or set of events from an element
remove: function( elem, types, handler, selector, mappedTypes ) {
        var j, handleObj, tmp,
                origCount, t, events,
                special, handlers, type,
                namespaces, origType,
                elemData = jQuery.hasData( elem ) &amp;&amp; jQuery._data( elem );

        if ( !elemData || !(events = elemData.events) ) {
                return;
        }

        // Once for each type.namespace in types; type may be omitted
        types = ( types || &quot;&quot; ).match( rnotwhite ) || [ &quot;&quot; ];
        t = types.length;
        while ( t-- ) {
                tmp = rtypenamespace.exec( types[t] ) || [];
                type = origType = tmp[1];
                namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();

                // Unbind all events (on this namespace, if provided) for the element
                if ( !type ) {
                        for ( type in events ) {
                                jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                        }
                        continue;
                }

                special = jQuery.event.special[ type ] || {};
                type = ( selector ? special.delegateType : special.bindType ) || type;
                handlers = events[ type ] || [];
                tmp = tmp[2] &amp;&amp; new RegExp( &quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot; );

                // Remove matching events
                origCount = j = handlers.length;
                while ( j-- ) {
                        handleObj = handlers[ j ];

                        if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
                                ( !handler || handler.guid === handleObj.guid ) &amp;&amp;
                                ( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
                                ( !selector || selector === handleObj.selector || selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
                                handlers.splice( j, 1 );

                                if ( handleObj.selector ) {
                                        handlers.delegateCount--;
                                }
                                if ( special.remove ) {
                                        special.remove.call( elem, handleObj );
                                }
                        }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if ( origCount &amp;&amp; !handlers.length ) {
                        if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                                jQuery.removeEvent( elem, type, elemData.handle );
                        }

                        delete events[ type ];
                }
        }

        // Remove the expando if it&#39;s no longer used
        if ( jQuery.isEmptyObject( events ) ) {
                delete elemData.handle;

                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery._removeData( elem, &quot;events&quot; );
        }
},

trigger: function( event, data, elem, onlyHandlers ) {
        var handle, ontype, cur,
                bubbleType, special, tmp, i,
                eventPath = [ elem || document ],
                type = hasOwn.call( event, &quot;type&quot; ) ? event.type : event,
                namespaces = hasOwn.call( event, &quot;namespace&quot; ) ? event.namespace.split(&quot;.&quot;) : [];

        cur = tmp = elem = elem || document;

        // Don&#39;t do events on text and comment nodes
        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                return;
        }

        // focus/blur morphs to focusin/out; ensure we&#39;re not firing them right now
        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                return;
        }

        if ( type.indexOf(&quot;.&quot;) &gt;= 0 ) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(&quot;.&quot;);
                type = namespaces.shift();
                namespaces.sort();
        }
        ontype = type.indexOf(&quot;:&quot;) &lt; 0 &amp;&amp; &quot;on&quot; + type;

        // Caller can pass in a jQuery.Event object, Object, or just an event type string
        event = event[ jQuery.expando ] ?
                event :
                new jQuery.Event( type, typeof event === &quot;object&quot; &amp;&amp; event );

        // Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(&quot;.&quot;);
        event.namespace_re = event.namespace ?
                new RegExp( &quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot; ) :
                null;

        // Clean up the event in case it is being reused
        event.result = undefined;
        if ( !event.target ) {
                event.target = elem;
        }

        // Clone any incoming data and prepend the event, creating the handler arg list
        data = data == null ?
                [ event ] :
                jQuery.makeArray( data, [ event ] );

        // Allow special events to draw outside the lines
        special = jQuery.event.special[ type ] || {};
        if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
                return;
        }

        // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
        if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {

                bubbleType = special.delegateType || type;
                if ( !rfocusMorph.test( bubbleType + type ) ) {
                        cur = cur.parentNode;
                }
                for ( ; cur; cur = cur.parentNode ) {
                        eventPath.push( cur );
                        tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if ( tmp === (elem.ownerDocument || document) ) {
                        eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                }
        }

        // Fire handlers on the event path
        i = 0;
        while ( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) {

                event.type = i &gt; 1 ?
                        bubbleType :
                        special.bindType || type;

                // jQuery handler
                handle = ( jQuery._data( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp; jQuery._data( cur, &quot;handle&quot; );
                if ( handle ) {
                        handle.apply( cur, data );
                }

                // Native handler
                handle = ontype &amp;&amp; cur[ ontype ];
                if ( handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData( cur ) ) {
                        event.result = handle.apply( cur, data );
                        if ( event.result === false ) {
                                event.preventDefault();
                        }
                }
        }
        event.type = type;

        // If nobody prevented the default action, do it now
        if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {

                if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &amp;&amp;
                        jQuery.acceptData( elem ) ) {

                        // Call a native DOM method on the target with the same name name as the event.
                        // Can&#39;t use an .isFunction() check here because IE6/7 fails that test.
                        // Don&#39;t do default actions on window, that&#39;s where global variables be (#6170)
                        if ( ontype &amp;&amp; elem[ type ] &amp;&amp; !jQuery.isWindow( elem ) ) {

                                // Don&#39;t re-trigger an onFOO event when we call its FOO() method
                                tmp = elem[ ontype ];

                                if ( tmp ) {
                                        elem[ ontype ] = null;
                                }

                                // Prevent re-triggering of the same event, since we already bubbled it above
                                jQuery.event.triggered = type;
                                try {
                                        elem[ type ]();
                                } catch ( e ) {
                                        // IE&lt;9 dies on focus/blur to hidden element (#1486,#12518)
                                        // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                                }
                                jQuery.event.triggered = undefined;

                                if ( tmp ) {
                                        elem[ ontype ] = tmp;
                                }
                        }
                }
        }

        return event.result;
},

dispatch: function( event ) {

        // Make a writable jQuery.Event from the native event object
        event = jQuery.event.fix( event );

        var i, ret, handleObj, matched, j,
                handlerQueue = [],
                args = slice.call( arguments ),
                handlers = ( jQuery._data( this, &quot;events&quot; ) || {} )[ event.type ] || [],
                special = jQuery.event.special[ event.type ] || {};

        // Use the fix-ed jQuery.Event rather than the (read-only) native event
        args[0] = event;
        event.delegateTarget = this;

        // Call the preDispatch hook for the mapped type, and let it bail if desired
        if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
                return;
        }

        // Determine handlers
        handlerQueue = jQuery.event.handlers.call( this, event, handlers );

        // Run delegates first; they may want to stop propagation beneath us
        i = 0;
        while ( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) {
                event.currentTarget = matched.elem;

                j = 0;
                while ( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !event.isImmediatePropagationStopped() ) {

                        // Triggered event must either 1) have no namespace, or
                        // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                        if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

                                event.handleObj = handleObj;
                                event.data = handleObj.data;

                                ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                                                .apply( matched.elem, args );

                                if ( ret !== undefined ) {
                                        if ( (event.result = ret) === false ) {
                                                event.preventDefault();
                                                event.stopPropagation();
                                        }
                                }
                        }
                }
        }

        // Call the postDispatch hook for the mapped type
        if ( special.postDispatch ) {
                special.postDispatch.call( this, event );
        }

        return event.result;
},

handlers: function( event, handlers ) {
        var sel, handleObj, matches, i,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

        // Find delegate handlers
        // Black-hole SVG &lt;use&gt; instance trees (#13180)
        // Avoid non-left-click bubbling in Firefox (#3861)
        if ( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== &quot;click&quot;) ) {

                /* jshint eqeqeq: false */
                for ( ; cur != this; cur = cur.parentNode || this ) {
                        /* jshint eqeqeq: true */

                        // Don&#39;t check non-elements (#13208)
                        // Don&#39;t process clicks on disabled elements (#6911, #8165, #11382, #11764)
                        if ( cur.nodeType === 1 &amp;&amp; (cur.disabled !== true || event.type !== &quot;click&quot;) ) {
                                matches = [];
                                for ( i = 0; i &lt; delegateCount; i++ ) {
                                        handleObj = handlers[ i ];

                                        // Don&#39;t conflict with Object.prototype properties (#13203)
                                        sel = handleObj.selector + &quot; &quot;;

                                        if ( matches[ sel ] === undefined ) {
                                                matches[ sel ] = handleObj.needsContext ?
                                                        jQuery( sel, this ).index( cur ) &gt;= 0 :
                                                        jQuery.find( sel, this, null, [ cur ] ).length;
                                        }
                                        if ( matches[ sel ] ) {
                                                matches.push( handleObj );
                                        }
                                }
                                if ( matches.length ) {
                                        handlerQueue.push({ elem: cur, handlers: matches });
                                }
                        }
                }
        }

        // Add the remaining (directly-bound) handlers
        if ( delegateCount &lt; handlers.length ) {
                handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
        }

        return handlerQueue;
},

fix: function( event ) {
        if ( event[ jQuery.expando ] ) {
                return event;
        }

        // Create a writable copy of the event object and normalize some properties
        var i, prop, copy,
                type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[ type ];

        if ( !fixHook ) {
                this.fixHooks[ type ] = fixHook =
                        rmouseEvent.test( type ) ? this.mouseHooks :
                        rkeyEvent.test( type ) ? this.keyHooks :
                        {};
        }
        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

        event = new jQuery.Event( originalEvent );

        i = copy.length;
        while ( i-- ) {
                prop = copy[ i ];
                event[ prop ] = originalEvent[ prop ];
        }

        // Support: IE&lt;9
        // Fix target property (#1925)
        if ( !event.target ) {
                event.target = originalEvent.srcElement || document;
        }

        // Support: Chrome 23+, Safari?
        // Target should not be a text node (#504, #13143)
        if ( event.target.nodeType === 3 ) {
                event.target = event.target.parentNode;
        }

        // Support: IE&lt;9
        // For mouse/key events, metaKey==false if it&#39;s undefined (#3368, #11328)
        event.metaKey = !!event.metaKey;

        return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
},

// Includes some event props shared by KeyEvent and MouseEvent
props: &quot;altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&quot;.split(&quot; &quot;),

fixHooks: {},

keyHooks: {
        props: &quot;char charCode key keyCode&quot;.split(&quot; &quot;),
        filter: function( event, original ) {

                // Add which for key events
                if ( event.which == null ) {
                        event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
        }
},

mouseHooks: {
        props: &quot;button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement&quot;.split(&quot; &quot;),
        filter: function( event, original ) {
                var body, eventDoc, doc,
                        button = original.button,
                        fromElement = original.fromElement;

                // Calculate pageX/Y if missing and clientX/Y available
                if ( event.pageX == null &amp;&amp; original.clientX != null ) {
                        eventDoc = event.target.ownerDocument || document;
                        doc = eventDoc.documentElement;
                        body = eventDoc.body;

                        event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );
                        event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );
                }

                // Add relatedTarget, if necessary
                if ( !event.relatedTarget &amp;&amp; fromElement ) {
                        event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don&#39;t use it
                if ( !event.which &amp;&amp; button !== undefined ) {
                        event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );
                }

                return event;
        }
},

special: {
        load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
        },
        focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                        if ( this !== safeActiveElement() &amp;&amp; this.focus ) {
                                try {
                                        this.focus();
                                        return false;
                                } catch ( e ) {
                                        // Support: IE&lt;9
                                        // If we error on focus to hidden element (#1486, #12518),
                                        // let .trigger() run the handlers
                                }
                        }
                },
                delegateType: &quot;focusin&quot;
        },
        blur: {
                trigger: function() {
                        if ( this === safeActiveElement() &amp;&amp; this.blur ) {
                                this.blur();
                                return false;
                        }
                },
                delegateType: &quot;focusout&quot;
        },
        click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                        if ( jQuery.nodeName( this, &quot;input&quot; ) &amp;&amp; this.type === &quot;checkbox&quot; &amp;&amp; this.click ) {
                                this.click();
                                return false;
                        }
                },

                // For cross-browser consistency, don&#39;t fire native .click() on links
                _default: function( event ) {
                        return jQuery.nodeName( event.target, &quot;a&quot; );
                }
        },

        beforeunload: {
                postDispatch: function( event ) {

                        // Support: Firefox 20+
                        // Firefox doesn&#39;t alert if the returnValue field is not set.
                        if ( event.result !== undefined &amp;&amp; event.originalEvent ) {
                                event.originalEvent.returnValue = event.result;
                        }
                }
        }
},

simulate: function( type, elem, event, bubble ) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor&#39;s stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                        type: type,
                        isSimulated: true,
                        originalEvent: {}
                }
        );
        if ( bubble ) {
                jQuery.event.trigger( e, null, elem );
        } else {
                jQuery.event.dispatch.call( elem, e );
        }
        if ( e.isDefaultPrevented() ) {
                event.preventDefault();
        }
}</pre>

<p>};</p>

<p>jQuery.removeEvent = document.removeEventListener ?</p>

<pre>function( elem, type, handle ) {
        if ( elem.removeEventListener ) {
                elem.removeEventListener( type, handle, false );
        }
} :
function( elem, type, handle ) {
        var name = &quot;on&quot; + type;

        if ( elem.detachEvent ) {

                // #8545, #7054, preventing memory leaks for custom events in IE6-8
                // detachEvent needed property on element, by name of that event, to properly expose it to GC
                if ( typeof elem[ name ] === strundefined ) {
                        elem[ name ] = null;
                }

                elem.detachEvent( name, handle );
        }
};</pre>

<p>jQuery.Event = function( src, props ) {</p>

<pre>// Allow instantiation without the &#39;new&#39; keyword
if ( !(this instanceof jQuery.Event) ) {
        return new jQuery.Event( src, props );
}

// Event object
if ( src &amp;&amp; src.type ) {
        this.originalEvent = src;
        this.type = src.type;

        // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.
        this.isDefaultPrevented = src.defaultPrevented ||
                        src.defaultPrevented === undefined &amp;&amp;
                        // Support: IE &lt; 9, Android &lt; 4.0
                        src.returnValue === false ?
                returnTrue :
                returnFalse;

// Event type
} else {
        this.type = src;
}

// Put explicitly provided properties onto the event object
if ( props ) {
        jQuery.extend( this, props );
}

// Create a timestamp if incoming event doesn&#39;t have one
this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();

// Mark it as fixed
this[ jQuery.expando ] = true;</pre>

<p>};</p>

<p>// jQuery.Event is based on DOM3 Events as specified by the ECMAScript
Language Binding // <a
href="http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html">www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html</a>
jQuery.Event.prototype = {</p>

<pre>isDefaultPrevented: returnFalse,
isPropagationStopped: returnFalse,
isImmediatePropagationStopped: returnFalse,

preventDefault: function() {
        var e = this.originalEvent;

        this.isDefaultPrevented = returnTrue;
        if ( !e ) {
                return;
        }

        // If preventDefault exists, run it on the original event
        if ( e.preventDefault ) {
                e.preventDefault();

        // Support: IE
        // Otherwise set the returnValue property of the original event to false
        } else {
                e.returnValue = false;
        }
},
stopPropagation: function() {
        var e = this.originalEvent;

        this.isPropagationStopped = returnTrue;
        if ( !e ) {
                return;
        }
        // If stopPropagation exists, run it on the original event
        if ( e.stopPropagation ) {
                e.stopPropagation();
        }

        // Support: IE
        // Set the cancelBubble property of the original event to true
        e.cancelBubble = true;
},
stopImmediatePropagation: function() {
        var e = this.originalEvent;

        this.isImmediatePropagationStopped = returnTrue;

        if ( e &amp;&amp; e.stopImmediatePropagation ) {
                e.stopImmediatePropagation();
        }

        this.stopPropagation();
}</pre>

<p>};</p>

<p>// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({</p>

<pre>mouseenter: &quot;mouseover&quot;,
mouseleave: &quot;mouseout&quot;,
pointerenter: &quot;pointerover&quot;,
pointerleave: &quot;pointerout&quot;</pre>

<p>}, function( orig, fix ) {</p>

<pre>jQuery.event.special[ orig ] = {
        delegateType: fix,
        bindType: fix,

        handle: function( event ) {
                var ret,
                        target = this,
                        related = event.relatedTarget,
                        handleObj = event.handleObj;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {
                        event.type = handleObj.origType;
                        ret = handleObj.handler.apply( this, arguments );
                        event.type = fix;
                }
                return ret;
        }
};</pre>

<p>});</p>

<p>// IE submit delegation if ( !support.submitBubbles ) {</p>

<pre>jQuery.event.special.submit = {
        setup: function() {
                // Only need this for delegated form submit events
                if ( jQuery.nodeName( this, &quot;form&quot; ) ) {
                        return false;
                }

                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add( this, &quot;click._submit keypress._submit&quot;, function( e ) {
                        // Node name check avoids a VML-related crash in IE (#9807)
                        var elem = e.target,
                                form = jQuery.nodeName( elem, &quot;input&quot; ) || jQuery.nodeName( elem, &quot;button&quot; ) ? elem.form : undefined;
                        if ( form &amp;&amp; !jQuery._data( form, &quot;submitBubbles&quot; ) ) {
                                jQuery.event.add( form, &quot;submit._submit&quot;, function( event ) {
                                        event._submit_bubble = true;
                                });
                                jQuery._data( form, &quot;submitBubbles&quot;, true );
                        }
                });
                // return undefined since we don&#39;t need an event listener
        },

        postDispatch: function( event ) {
                // If form was submitted by the user, bubble the event up the tree
                if ( event._submit_bubble ) {
                        delete event._submit_bubble;
                        if ( this.parentNode &amp;&amp; !event.isTrigger ) {
                                jQuery.event.simulate( &quot;submit&quot;, this.parentNode, event, true );
                        }
                }
        },

        teardown: function() {
                // Only need this for delegated form submit events
                if ( jQuery.nodeName( this, &quot;form&quot; ) ) {
                        return false;
                }

                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove( this, &quot;._submit&quot; );
        }
};</pre>

<p>}</p>

<p>// IE change delegation and checkbox/radio fix if ( !support.changeBubbles
) {</p>

<pre>jQuery.event.special.change = {

        setup: function() {

                if ( rformElems.test( this.nodeName ) ) {
                        // IE doesn&#39;t fire change on a check/radio until blur; trigger it on click
                        // after a propertychange. Eat the blur-change in special.change.handle.
                        // This still fires onchange a second time for check/radio after blur.
                        if ( this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot; ) {
                                jQuery.event.add( this, &quot;propertychange._change&quot;, function( event ) {
                                        if ( event.originalEvent.propertyName === &quot;checked&quot; ) {
                                                this._just_changed = true;
                                        }
                                });
                                jQuery.event.add( this, &quot;click._change&quot;, function( event ) {
                                        if ( this._just_changed &amp;&amp; !event.isTrigger ) {
                                                this._just_changed = false;
                                        }
                                        // Allow triggered, simulated change events (#11500)
                                        jQuery.event.simulate( &quot;change&quot;, this, event, true );
                                });
                        }
                        return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add( this, &quot;beforeactivate._change&quot;, function( e ) {
                        var elem = e.target;

                        if ( rformElems.test( elem.nodeName ) &amp;&amp; !jQuery._data( elem, &quot;changeBubbles&quot; ) ) {
                                jQuery.event.add( elem, &quot;change._change&quot;, function( event ) {
                                        if ( this.parentNode &amp;&amp; !event.isSimulated &amp;&amp; !event.isTrigger ) {
                                                jQuery.event.simulate( &quot;change&quot;, this.parentNode, event, true );
                                        }
                                });
                                jQuery._data( elem, &quot;changeBubbles&quot;, true );
                        }
                });
        },

        handle: function( event ) {
                var elem = event.target;

                // Swallow native change events from checkbox/radio, we already triggered them above
                if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== &quot;radio&quot; &amp;&amp; elem.type !== &quot;checkbox&quot;) ) {
                        return event.handleObj.handler.apply( this, arguments );
                }
        },

        teardown: function() {
                jQuery.event.remove( this, &quot;._change&quot; );

                return !rformElems.test( this.nodeName );
        }
};</pre>

<p>}</p>

<p>// Create bubbling focus and blur events if ( !support.focusinBubbles ) {</p>

<pre>jQuery.each({ focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {

        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function( event ) {
                        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
                };

        jQuery.event.special[ fix ] = {
                setup: function() {
                        var doc = this.ownerDocument || this,
                                attaches = jQuery._data( doc, fix );

                        if ( !attaches ) {
                                doc.addEventListener( orig, handler, true );
                        }
                        jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
                },
                teardown: function() {
                        var doc = this.ownerDocument || this,
                                attaches = jQuery._data( doc, fix ) - 1;

                        if ( !attaches ) {
                                doc.removeEventListener( orig, handler, true );
                                jQuery._removeData( doc, fix );
                        } else {
                                jQuery._data( doc, fix, attaches );
                        }
                }
        };
});</pre>

<p>}</p>

<p>jQuery.fn.extend({</p>

<pre>on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
        var type, origFn;

        // Types can be a map of types/handlers
        if ( typeof types === &quot;object&quot; ) {
                // ( types-Object, selector, data )
                if ( typeof selector !== &quot;string&quot; ) {
                        // ( types-Object, data )
                        data = data || selector;
                        selector = undefined;
                }
                for ( type in types ) {
                        this.on( type, selector, data, types[ type ], one );
                }
                return this;
        }

        if ( data == null &amp;&amp; fn == null ) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
        } else if ( fn == null ) {
                if ( typeof selector === &quot;string&quot; ) {
                        // ( types, selector, fn )
                        fn = data;
                        data = undefined;
                } else {
                        // ( types, data, fn )
                        fn = data;
                        data = selector;
                        selector = undefined;
                }
        }
        if ( fn === false ) {
                fn = returnFalse;
        } else if ( !fn ) {
                return this;
        }

        if ( one === 1 ) {
                origFn = fn;
                fn = function( event ) {
                        // Can use an empty set, since event contains the info
                        jQuery().off( event );
                        return origFn.apply( this, arguments );
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return this.each( function() {
                jQuery.event.add( this, types, fn, data, selector );
        });
},
one: function( types, selector, data, fn ) {
        return this.on( types, selector, data, fn, 1 );
},
off: function( types, selector, fn ) {
        var handleObj, type;
        if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery( types.delegateTarget ).off(
                        handleObj.namespace ? handleObj.origType + &quot;.&quot; + handleObj.namespace : handleObj.origType,
                        handleObj.selector,
                        handleObj.handler
                );
                return this;
        }
        if ( typeof types === &quot;object&quot; ) {
                // ( types-object [, selector] )
                for ( type in types ) {
                        this.off( type, selector, types[ type ] );
                }
                return this;
        }
        if ( selector === false || typeof selector === &quot;function&quot; ) {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
        }
        if ( fn === false ) {
                fn = returnFalse;
        }
        return this.each(function() {
                jQuery.event.remove( this, types, fn, selector );
        });
},

trigger: function( type, data ) {
        return this.each(function() {
                jQuery.event.trigger( type, data, this );
        });
},
triggerHandler: function( type, data ) {
        var elem = this[0];
        if ( elem ) {
                return jQuery.event.trigger( type, data, elem, true );
        }
}</pre>

<p>});</p>

<p>function createSafeFragment( document ) {</p>

<pre>var list = nodeNames.split( &quot;|&quot; ),
        safeFrag = document.createDocumentFragment();

if ( safeFrag.createElement ) {
        while ( list.length ) {
                safeFrag.createElement(
                        list.pop()
                );
        }
}
return safeFrag;</pre>

<p>}</p>

<p>var nodeNames =
abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|
+</p>

<pre>        &quot;header|hgroup|mark|meter|nav|output|progress|section|summary|time|video&quot;,
rinlinejQuery = / jQuery\d+=&quot;(?:null|\d+)&quot;/g,
rnoshimcache = new RegExp(&quot;&lt;(?:&quot; + nodeNames + &quot;)[\\s/&gt;]&quot;, &quot;i&quot;),
rleadingWhitespace = /^\s+/,
rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi,
rtagName = /&lt;([\w:]+)/,
rtbody = /&lt;tbody/i,
rhtml = /&lt;|&amp;#?\w+;/,
rnoInnerhtml = /&lt;(?:script|style|link)/i,
// checked=&quot;checked&quot; or checked
rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
rscriptType = /^$|\/(?:java|ecma)script/i,
rscriptTypeMasked = /^true\/(.*)/,
rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g,

// We have to close these tags to support XHTML (#13200)
wrapMap = {
        option: [ 1, &quot;&lt;select multiple=&#39;multiple&#39;&gt;&quot;, &quot;&lt;/select&gt;&quot; ],
        legend: [ 1, &quot;&lt;fieldset&gt;&quot;, &quot;&lt;/fieldset&gt;&quot; ],
        area: [ 1, &quot;&lt;map&gt;&quot;, &quot;&lt;/map&gt;&quot; ],
        param: [ 1, &quot;&lt;object&gt;&quot;, &quot;&lt;/object&gt;&quot; ],
        thead: [ 1, &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
        tr: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
        col: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; ],
        td: [ 3, &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;, &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; ],

        // IE6-8 can&#39;t serialize link, script, style, or any html5 (NoScope) tags,
        // unless wrapped in a div with non-breaking characters in front of it.
        _default: support.htmlSerialize ? [ 0, &quot;&quot;, &quot;&quot; ] : [ 1, &quot;X&lt;div&gt;&quot;, &quot;&lt;/div&gt;&quot;  ]
},
safeFragment = createSafeFragment( document ),
fragmentDiv = safeFragment.appendChild( document.createElement(&quot;div&quot;) );</pre>

<p>wrapMap.optgroup = wrapMap.option; wrapMap.tbody = wrapMap.tfoot =
wrapMap.colgroup = wrapMap.caption = wrapMap.thead; wrapMap.th =
wrapMap.td;</p>

<p>function getAll( context, tag ) {</p>

<pre>var elems, elem,
        i = 0,
        found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || &quot;*&quot; ) :
                typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || &quot;*&quot; ) :
                undefined;

if ( !found ) {
        for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
                if ( !tag || jQuery.nodeName( elem, tag ) ) {
                        found.push( elem );
                } else {
                        jQuery.merge( found, getAll( elem, tag ) );
                }
        }
}

return tag === undefined || tag &amp;&amp; jQuery.nodeName( context, tag ) ?
        jQuery.merge( [ context ], found ) :
        found;</pre>

<p>}</p>

<p>// Used in buildFragment, fixes the defaultChecked property function
fixDefaultChecked( elem ) {</p>

<pre>if ( rcheckableType.test( elem.type ) ) {
        elem.defaultChecked = elem.checked;
}</pre>

<p>}</p>

<p>// Support: IE&lt;8 // Manipulating tables requires a tbody function
manipulationTarget( elem, content ) {</p>

<pre>return jQuery.nodeName( elem, &quot;table&quot; ) &amp;&amp;
        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, &quot;tr&quot; ) ?

        elem.getElementsByTagName(&quot;tbody&quot;)[0] ||
                elem.appendChild( elem.ownerDocument.createElement(&quot;tbody&quot;) ) :
        elem;</pre>

<p>}</p>

<p>// Replace/restore the type attribute of script elements for safe DOM
manipulation function disableScript( elem ) {</p>

<pre>elem.type = (jQuery.find.attr( elem, &quot;type&quot; ) !== null) + &quot;/&quot; + elem.type;
return elem;</pre>

<p>} function restoreScript( elem ) {</p>

<pre>var match = rscriptTypeMasked.exec( elem.type );
if ( match ) {
        elem.type = match[1];
} else {
        elem.removeAttribute(&quot;type&quot;);
}
return elem;</pre>

<p>}</p>

<p>// Mark scripts as having already been evaluated function setGlobalEval(
elems, refElements ) {</p>

<pre>var elem,
        i = 0;
for ( ; (elem = elems[i]) != null; i++ ) {
        jQuery._data( elem, &quot;globalEval&quot;, !refElements || jQuery._data( refElements[i], &quot;globalEval&quot; ) );
}</pre>

<p>}</p>

<p>function cloneCopyEvent( src, dest ) {</p>

<pre>if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
        return;
}

var type, i, l,
        oldData = jQuery._data( src ),
        curData = jQuery._data( dest, oldData ),
        events = oldData.events;

if ( events ) {
        delete curData.handle;
        curData.events = {};

        for ( type in events ) {
                for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {
                        jQuery.event.add( dest, type, events[ type ][ i ] );
                }
        }
}

// make the cloned public data object a copy from the original
if ( curData.data ) {
        curData.data = jQuery.extend( {}, curData.data );
}</pre>

<p>}</p>

<p>function fixCloneNodeIssues( src, dest ) {</p>

<pre>var nodeName, e, data;

// We do not need to do anything for non-Elements
if ( dest.nodeType !== 1 ) {
        return;
}

nodeName = dest.nodeName.toLowerCase();

// IE6-8 copies events bound via attachEvent when using cloneNode.
if ( !support.noCloneEvent &amp;&amp; dest[ jQuery.expando ] ) {
        data = jQuery._data( dest );

        for ( e in data.events ) {
                jQuery.removeEvent( dest, e, data.handle );
        }

        // Event data gets referenced instead of copied if the expando gets copied too
        dest.removeAttribute( jQuery.expando );
}

// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
if ( nodeName === &quot;script&quot; &amp;&amp; dest.text !== src.text ) {
        disableScript( dest ).text = src.text;
        restoreScript( dest );

// IE6-10 improperly clones children of object elements using classid.
// IE10 throws NoModificationAllowedError if parent is null, #12132.
} else if ( nodeName === &quot;object&quot; ) {
        if ( dest.parentNode ) {
                dest.outerHTML = src.outerHTML;
        }

        // This path appears unavoidable for IE9. When cloning an object
        // element in IE9, the outerHTML strategy above is not sufficient.
        // If the src has innerHTML and the destination does not,
        // copy the src.innerHTML into the dest.innerHTML. #10324
        if ( support.html5Clone &amp;&amp; ( src.innerHTML &amp;&amp; !jQuery.trim(dest.innerHTML) ) ) {
                dest.innerHTML = src.innerHTML;
        }

} else if ( nodeName === &quot;input&quot; &amp;&amp; rcheckableType.test( src.type ) ) {
        // IE6-8 fails to persist the checked state of a cloned checkbox
        // or radio button. Worse, IE6-7 fail to give the cloned element
        // a checked appearance if the defaultChecked value isn&#39;t also set

        dest.defaultChecked = dest.checked = src.checked;

        // IE6-7 get confused and end up setting the value of a cloned
        // checkbox/radio button to an empty string instead of &quot;on&quot;
        if ( dest.value !== src.value ) {
                dest.value = src.value;
        }

// IE6-8 fails to return the selected option to the default selected
// state when cloning options
} else if ( nodeName === &quot;option&quot; ) {
        dest.defaultSelected = dest.selected = src.defaultSelected;

// IE6-8 fails to set the defaultValue to the correct value when
// cloning other types of input fields
} else if ( nodeName === &quot;input&quot; || nodeName === &quot;textarea&quot; ) {
        dest.defaultValue = src.defaultValue;
}</pre>

<p>}</p>

<p>jQuery.extend({</p>

<pre>clone: function( elem, dataAndEvents, deepDataAndEvents ) {
        var destElements, node, clone, i, srcElements,
                inPage = jQuery.contains( elem.ownerDocument, elem );

        if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( &quot;&lt;&quot; + elem.nodeName + &quot;&gt;&quot; ) ) {
                clone = elem.cloneNode( true );

        // IE&lt;=8 does not properly clone detached, unknown element nodes
        } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
        }

        if ( (!support.noCloneEvent || !support.noCloneChecked) &amp;&amp;
                        (elem.nodeType === 1 || elem.nodeType === 11) &amp;&amp; !jQuery.isXMLDoc(elem) ) {

                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll( clone );
                srcElements = getAll( elem );

                // Fix all IE cloning issues
                for ( i = 0; (node = srcElements[i]) != null; ++i ) {
                        // Ensure that the destination node is not null; Fixes #9587
                        if ( destElements[i] ) {
                                fixCloneNodeIssues( node, destElements[i] );
                        }
                }
        }

        // Copy the events from the original to the clone
        if ( dataAndEvents ) {
                if ( deepDataAndEvents ) {
                        srcElements = srcElements || getAll( elem );
                        destElements = destElements || getAll( clone );

                        for ( i = 0; (node = srcElements[i]) != null; i++ ) {
                                cloneCopyEvent( node, destElements[i] );
                        }
                } else {
                        cloneCopyEvent( elem, clone );
                }
        }

        // Preserve script evaluation history
        destElements = getAll( clone, &quot;script&quot; );
        if ( destElements.length &gt; 0 ) {
                setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, &quot;script&quot; ) );
        }

        destElements = srcElements = node = null;

        // Return the cloned set
        return clone;
},

buildFragment: function( elems, context, scripts, selection ) {
        var j, elem, contains,
                tmp, tag, tbody, wrap,
                l = elems.length,

                // Ensure a safe fragment
                safe = createSafeFragment( context ),

                nodes = [],
                i = 0;

        for ( ; i &lt; l; i++ ) {
                elem = elems[ i ];

                if ( elem || elem === 0 ) {

                        // Add nodes directly
                        if ( jQuery.type( elem ) === &quot;object&quot; ) {
                                jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                        // Convert non-html into a text node
                        } else if ( !rhtml.test( elem ) ) {
                                nodes.push( context.createTextNode( elem ) );

                        // Convert html into DOM nodes
                        } else {
                                tmp = tmp || safe.appendChild( context.createElement(&quot;div&quot;) );

                                // Deserialize a standard representation
                                tag = (rtagName.exec( elem ) || [ &quot;&quot;, &quot;&quot; ])[ 1 ].toLowerCase();
                                wrap = wrapMap[ tag ] || wrapMap._default;

                                tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; ) + wrap[2];

                                // Descend through wrappers to the right content
                                j = wrap[0];
                                while ( j-- ) {
                                        tmp = tmp.lastChild;
                                }

                                // Manually add leading whitespace removed by IE
                                if ( !support.leadingWhitespace &amp;&amp; rleadingWhitespace.test( elem ) ) {
                                        nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
                                }

                                // Remove IE&#39;s autoinserted &lt;tbody&gt; from table fragments
                                if ( !support.tbody ) {

                                        // String was a &lt;table&gt;, *may* have spurious &lt;tbody&gt;
                                        elem = tag === &quot;table&quot; &amp;&amp; !rtbody.test( elem ) ?
                                                tmp.firstChild :

                                                // String was a bare &lt;thead&gt; or &lt;tfoot&gt;
                                                wrap[1] === &quot;&lt;table&gt;&quot; &amp;&amp; !rtbody.test( elem ) ?
                                                        tmp :
                                                        0;

                                        j = elem &amp;&amp; elem.childNodes.length;
                                        while ( j-- ) {
                                                if ( jQuery.nodeName( (tbody = elem.childNodes[j]), &quot;tbody&quot; ) &amp;&amp; !tbody.childNodes.length ) {
                                                        elem.removeChild( tbody );
                                                }
                                        }
                                }

                                jQuery.merge( nodes, tmp.childNodes );

                                // Fix #12392 for WebKit and IE &gt; 9
                                tmp.textContent = &quot;&quot;;

                                // Fix #12392 for oldIE
                                while ( tmp.firstChild ) {
                                        tmp.removeChild( tmp.firstChild );
                                }

                                // Remember the top-level container for proper cleanup
                                tmp = safe.lastChild;
                        }
                }
        }

        // Fix #11356: Clear elements from fragment
        if ( tmp ) {
                safe.removeChild( tmp );
        }

        // Reset defaultChecked for any radios and checkboxes
        // about to be appended to the DOM in IE 6/7 (#8060)
        if ( !support.appendChecked ) {
                jQuery.grep( getAll( nodes, &quot;input&quot; ), fixDefaultChecked );
        }

        i = 0;
        while ( (elem = nodes[ i++ ]) ) {

                // #4087 - If origin and destination elements are the same, and this is
                // that element, do not do anything
                if ( selection &amp;&amp; jQuery.inArray( elem, selection ) !== -1 ) {
                        continue;
                }

                contains = jQuery.contains( elem.ownerDocument, elem );

                // Append to fragment
                tmp = getAll( safe.appendChild( elem ), &quot;script&quot; );

                // Preserve script evaluation history
                if ( contains ) {
                        setGlobalEval( tmp );
                }

                // Capture executables
                if ( scripts ) {
                        j = 0;
                        while ( (elem = tmp[ j++ ]) ) {
                                if ( rscriptType.test( elem.type || &quot;&quot; ) ) {
                                        scripts.push( elem );
                                }
                        }
                }
        }

        tmp = null;

        return safe;
},

cleanData: function( elems, /* internal */ acceptData ) {
        var elem, type, id, data,
                i = 0,
                internalKey = jQuery.expando,
                cache = jQuery.cache,
                deleteExpando = support.deleteExpando,
                special = jQuery.event.special;

        for ( ; (elem = elems[i]) != null; i++ ) {
                if ( acceptData || jQuery.acceptData( elem ) ) {

                        id = elem[ internalKey ];
                        data = id &amp;&amp; cache[ id ];

                        if ( data ) {
                                if ( data.events ) {
                                        for ( type in data.events ) {
                                                if ( special[ type ] ) {
                                                        jQuery.event.remove( elem, type );

                                                // This is a shortcut to avoid jQuery.event.remove&#39;s overhead
                                                } else {
                                                        jQuery.removeEvent( elem, type, data.handle );
                                                }
                                        }
                                }

                                // Remove cache only if it was not already removed by jQuery.event.remove
                                if ( cache[ id ] ) {

                                        delete cache[ id ];

                                        // IE does not allow us to delete expando properties from nodes,
                                        // nor does it have a removeAttribute function on Document nodes;
                                        // we must handle all of these cases
                                        if ( deleteExpando ) {
                                                delete elem[ internalKey ];

                                        } else if ( typeof elem.removeAttribute !== strundefined ) {
                                                elem.removeAttribute( internalKey );

                                        } else {
                                                elem[ internalKey ] = null;
                                        }

                                        deletedIds.push( id );
                                }
                        }
                }
        }
}</pre>

<p>});</p>

<p>jQuery.fn.extend({</p>

<pre>text: function( value ) {
        return access( this, function( value ) {
                return value === undefined ?
                        jQuery.text( this ) :
                        this.empty().append( ( this[0] &amp;&amp; this[0].ownerDocument || document ).createTextNode( value ) );
        }, null, value, arguments.length );
},

append: function() {
        return this.domManip( arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                        var target = manipulationTarget( this, elem );
                        target.appendChild( elem );
                }
        });
},

prepend: function() {
        return this.domManip( arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                        var target = manipulationTarget( this, elem );
                        target.insertBefore( elem, target.firstChild );
                }
        });
},

before: function() {
        return this.domManip( arguments, function( elem ) {
                if ( this.parentNode ) {
                        this.parentNode.insertBefore( elem, this );
                }
        });
},

after: function() {
        return this.domManip( arguments, function( elem ) {
                if ( this.parentNode ) {
                        this.parentNode.insertBefore( elem, this.nextSibling );
                }
        });
},

remove: function( selector, keepData /* Internal Use Only */ ) {
        var elem,
                elems = selector ? jQuery.filter( selector, this ) : this,
                i = 0;

        for ( ; (elem = elems[i]) != null; i++ ) {

                if ( !keepData &amp;&amp; elem.nodeType === 1 ) {
                        jQuery.cleanData( getAll( elem ) );
                }

                if ( elem.parentNode ) {
                        if ( keepData &amp;&amp; jQuery.contains( elem.ownerDocument, elem ) ) {
                                setGlobalEval( getAll( elem, &quot;script&quot; ) );
                        }
                        elem.parentNode.removeChild( elem );
                }
        }

        return this;
},

empty: function() {
        var elem,
                i = 0;

        for ( ; (elem = this[i]) != null; i++ ) {
                // Remove element nodes and prevent memory leaks
                if ( elem.nodeType === 1 ) {
                        jQuery.cleanData( getAll( elem, false ) );
                }

                // Remove any remaining nodes
                while ( elem.firstChild ) {
                        elem.removeChild( elem.firstChild );
                }

                // If this is a select, ensure that it displays empty (#12336)
                // Support: IE&lt;9
                if ( elem.options &amp;&amp; jQuery.nodeName( elem, &quot;select&quot; ) ) {
                        elem.options.length = 0;
                }
        }

        return this;
},

clone: function( dataAndEvents, deepDataAndEvents ) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

        return this.map(function() {
                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
        });
},

html: function( value ) {
        return access( this, function( value ) {
                var elem = this[ 0 ] || {},
                        i = 0,
                        l = this.length;

                if ( value === undefined ) {
                        return elem.nodeType === 1 ?
                                elem.innerHTML.replace( rinlinejQuery, &quot;&quot; ) :
                                undefined;
                }

                // See if we can take a shortcut and just use innerHTML
                if ( typeof value === &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;
                        ( support.htmlSerialize || !rnoshimcache.test( value )  ) &amp;&amp;
                        ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &amp;&amp;
                        !wrapMap[ (rtagName.exec( value ) || [ &quot;&quot;, &quot;&quot; ])[ 1 ].toLowerCase() ] ) {

                        value = value.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );

                        try {
                                for (; i &lt; l; i++ ) {
                                        // Remove element nodes and prevent memory leaks
                                        elem = this[i] || {};
                                        if ( elem.nodeType === 1 ) {
                                                jQuery.cleanData( getAll( elem, false ) );
                                                elem.innerHTML = value;
                                        }
                                }

                                elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                        } catch(e) {}
                }

                if ( elem ) {
                        this.empty().append( value );
                }
        }, null, value, arguments.length );
},

replaceWith: function() {
        var arg = arguments[ 0 ];

        // Make the changes, replacing each context element with the new content
        this.domManip( arguments, function( elem ) {
                arg = this.parentNode;

                jQuery.cleanData( getAll( this ) );

                if ( arg ) {
                        arg.replaceChild( elem, this );
                }
        });

        // Force removal if there was no new content (e.g., from empty arguments)
        return arg &amp;&amp; (arg.length || arg.nodeType) ? this : this.remove();
},

detach: function( selector ) {
        return this.remove( selector, true );
},

domManip: function( args, callback ) {

        // Flatten any nested arrays
        args = concat.apply( [], args );

        var first, node, hasScripts,
                scripts, doc, fragment,
                i = 0,
                l = this.length,
                set = this,
                iNoClone = l - 1,
                value = args[0],
                isFunction = jQuery.isFunction( value );

        // We can&#39;t cloneNode fragments that contain checked, in WebKit
        if ( isFunction ||
                        ( l &gt; 1 &amp;&amp; typeof value === &quot;string&quot; &amp;&amp;
                                !support.checkClone &amp;&amp; rchecked.test( value ) ) ) {
                return this.each(function( index ) {
                        var self = set.eq( index );
                        if ( isFunction ) {
                                args[0] = value.call( this, index, self.html() );
                        }
                        self.domManip( args, callback );
                });
        }

        if ( l ) {
                fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
                first = fragment.firstChild;

                if ( fragment.childNodes.length === 1 ) {
                        fragment = first;
                }

                if ( first ) {
                        scripts = jQuery.map( getAll( fragment, &quot;script&quot; ), disableScript );
                        hasScripts = scripts.length;

                        // Use the original fragment for the last item instead of the first because it can end up
                        // being emptied incorrectly in certain situations (#8070).
                        for ( ; i &lt; l; i++ ) {
                                node = fragment;

                                if ( i !== iNoClone ) {
                                        node = jQuery.clone( node, true, true );

                                        // Keep references to cloned scripts for later restoration
                                        if ( hasScripts ) {
                                                jQuery.merge( scripts, getAll( node, &quot;script&quot; ) );
                                        }
                                }

                                callback.call( this[i], node, i );
                        }

                        if ( hasScripts ) {
                                doc = scripts[ scripts.length - 1 ].ownerDocument;

                                // Reenable scripts
                                jQuery.map( scripts, restoreScript );

                                // Evaluate executable scripts on first document insertion
                                for ( i = 0; i &lt; hasScripts; i++ ) {
                                        node = scripts[ i ];
                                        if ( rscriptType.test( node.type || &quot;&quot; ) &amp;&amp;
                                                !jQuery._data( node, &quot;globalEval&quot; ) &amp;&amp; jQuery.contains( doc, node ) ) {

                                                if ( node.src ) {
                                                        // Optional AJAX dependency, but won&#39;t run scripts if not present
                                                        if ( jQuery._evalUrl ) {
                                                                jQuery._evalUrl( node.src );
                                                        }
                                                } else {
                                                        jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || &quot;&quot; ).replace( rcleanScript, &quot;&quot; ) );
                                                }
                                        }
                                }
                        }

                        // Fix #11809: Avoid leaking memory
                        fragment = first = null;
                }
        }

        return this;
}</pre>

<p>});</p>

<p>jQuery.each({</p>

<pre>appendTo: &quot;append&quot;,
prependTo: &quot;prepend&quot;,
insertBefore: &quot;before&quot;,
insertAfter: &quot;after&quot;,
replaceAll: &quot;replaceWith&quot;</pre>

<p>}, function( name, original ) {</p>

<pre>jQuery.fn[ name ] = function( selector ) {
        var elems,
                i = 0,
                ret = [],
                insert = jQuery( selector ),
                last = insert.length - 1;

        for ( ; i &lt;= last; i++ ) {
                elems = i === last ? this : this.clone(true);
                jQuery( insert[i] )[ original ]( elems );

                // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
                push.apply( ret, elems.get() );
        }

        return this.pushStack( ret );
};</pre>

<p>});</p>

<p>var iframe,</p>

<pre class="ruby"><span class="ruby-identifier">elemdisplay</span> = {};
</pre>

<p>/**</p>

<pre> Retrieve the actual display of a element
 @param {String} name nodeName of the element
 @param {Object} doc Document object
/</pre>

<p>// Called only from within defaultDisplay function actualDisplay( name, doc
) {</p>

<pre>var style,
        elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

        // getDefaultComputedStyle might be reliably used only on attached element
        display = window.getDefaultComputedStyle &amp;&amp; ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

                // Use of this method is a temporary fix (more like optmization) until something better comes along,
                // since it was removed from specification and supported only in FF
                style.display : jQuery.css( elem[ 0 ], &quot;display&quot; );

// We don&#39;t have any data stored on the element,
// so use &quot;detach&quot; method as fast way to get rid of the element
elem.detach();

return display;</pre>

<p>}</p>

<p>/**</p>

<pre> Try to determine the default display value of an element
 @param {String} nodeName
/</pre>

<p>function defaultDisplay( nodeName ) {</p>

<pre>var doc = document,
        display = elemdisplay[ nodeName ];

if ( !display ) {
        display = actualDisplay( nodeName, doc );

        // If the simple way fails, read from inside an iframe
        if ( display === &quot;none&quot; || !display ) {

                // Use the already-created iframe if possible
                iframe = (iframe || jQuery( &quot;&lt;iframe frameborder=&#39;0&#39; width=&#39;0&#39; height=&#39;0&#39;/&gt;&quot; )).appendTo( doc.documentElement );

                // Always write a new HTML skeleton so Webkit and Firefox don&#39;t choke on reuse
                doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

                // Support: IE
                doc.write();
                doc.close();

                display = actualDisplay( nodeName, doc );
                iframe.detach();
        }

        // Store the correct default display
        elemdisplay[ nodeName ] = display;
}

return display;</pre>

<p>}</p>

<p>(function() {</p>

<pre>var shrinkWrapBlocksVal;

support.shrinkWrapBlocks = function() {
        if ( shrinkWrapBlocksVal != null ) {
                return shrinkWrapBlocksVal;
        }

        // Will be changed later if needed.
        shrinkWrapBlocksVal = false;

        // Minified: var b,c,d
        var div, body, container;

        body = document.getElementsByTagName( &quot;body&quot; )[ 0 ];
        if ( !body || !body.style ) {
                // Test fired too early or in an unsupported environment, exit.
                return;
        }

        // Setup
        div = document.createElement( &quot;div&quot; );
        container = document.createElement( &quot;div&quot; );
        container.style.cssText = &quot;position:absolute;border:0;width:0;height:0;top:0;left:-9999px&quot;;
        body.appendChild( container ).appendChild( div );

        // Support: IE6
        // Check if elements with layout shrink-wrap their children
        if ( typeof div.style.zoom !== strundefined ) {
                // Reset CSS: box-sizing; display; margin; border
                div.style.cssText =
                        // Support: Firefox&lt;29, Android 2.3
                        // Vendor-prefix box-sizing
                        &quot;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;&quot; +
                        &quot;box-sizing:content-box;display:block;margin:0;border:0;&quot; +
                        &quot;padding:1px;width:1px;zoom:1&quot;;
                div.appendChild( document.createElement( &quot;div&quot; ) ).style.width = &quot;5px&quot;;
                shrinkWrapBlocksVal = div.offsetWidth !== 3;
        }

        body.removeChild( container );

        return shrinkWrapBlocksVal;
};</pre>

<p>})(); var rmargin = (/^margin/);</p>

<p>var rnumnonpx = new RegExp( ^( + pnum + )(?!<a href="a-z%">px)</a>+$,
i );</p>

<p>var getStyles, curCSS,</p>

<pre class="ruby"><span class="ruby-identifier">rposition</span> = <span class="ruby-regexp">/^(top|right|bottom|left)$/</span>;
</pre>

<p>if ( window.getComputedStyle ) {</p>

<pre>getStyles = function( elem ) {
        return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
};

curCSS = function( elem, name, computed ) {
        var width, minWidth, maxWidth, ret,
                style = elem.style;

        computed = computed || getStyles( elem );

        // getPropertyValue is only needed for .css(&#39;filter&#39;) in IE9, see #12537
        ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

        if ( computed ) {

                if ( ret === &quot;&quot; &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) {
                        ret = jQuery.style( elem, name );
                }

                // A tribute to the &quot;awesome hack by Dean Edwards&quot;
                // Chrome &lt; 17 and Safari 5.0 uses &quot;computed value&quot; instead of &quot;used value&quot; for margin-right
                // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                if ( rnumnonpx.test( ret ) &amp;&amp; rmargin.test( name ) ) {

                        // Remember the original values
                        width = style.width;
                        minWidth = style.minWidth;
                        maxWidth = style.maxWidth;

                        // Put in the new values to get a computed value out
                        style.minWidth = style.maxWidth = style.width = ret;
                        ret = computed.width;

                        // Revert the changed values
                        style.width = width;
                        style.minWidth = minWidth;
                        style.maxWidth = maxWidth;
                }
        }

        // Support: IE
        // IE returns zIndex value as an integer.
        return ret === undefined ?
                ret :
                ret + &quot;&quot;;
};</pre>

<p>} else if ( document.documentElement.currentStyle ) {</p>

<pre>getStyles = function( elem ) {
        return elem.currentStyle;
};

curCSS = function( elem, name, computed ) {
        var left, rs, rsLeft, ret,
                style = elem.style;

        computed = computed || getStyles( elem );
        ret = computed ? computed[ name ] : undefined;

        // Avoid setting ret to empty string here
        // so we don&#39;t default to auto
        if ( ret == null &amp;&amp; style &amp;&amp; style[ name ] ) {
                ret = style[ name ];
        }

        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we&#39;re not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels
        // but not position css attributes, as those are proportional to the parent element instead
        // and we can&#39;t measure the parent instead because it might trigger a &quot;stacking dolls&quot; problem
        if ( rnumnonpx.test( ret ) &amp;&amp; !rposition.test( name ) ) {

                // Remember the original values
                left = style.left;
                rs = elem.runtimeStyle;
                rsLeft = rs &amp;&amp; rs.left;

                // Put in the new values to get a computed value out
                if ( rsLeft ) {
                        rs.left = elem.currentStyle.left;
                }
                style.left = name === &quot;fontSize&quot; ? &quot;1em&quot; : ret;
                ret = style.pixelLeft + &quot;px&quot;;

                // Revert the changed values
                style.left = left;
                if ( rsLeft ) {
                        rs.left = rsLeft;
                }
        }

        // Support: IE
        // IE returns zIndex value as an integer.
        return ret === undefined ?
                ret :
                ret + &quot;&quot; || &quot;auto&quot;;
};</pre>

<p>}</p>

<p>function addGetHookIf( conditionFn, hookFn ) {</p>

<pre>// Define the hook, we&#39;ll check on the first run if it&#39;s really needed.
return {
        get: function() {
                var condition = conditionFn();

                if ( condition == null ) {
                        // The test was not ready at this point; screw the hook this time
                        // but check again when needed next time.
                        return;
                }

                if ( condition ) {
                        // Hook not needed (or it&#39;s not possible to use it due to missing dependency),
                        // remove it.
                        // Since there are no other hooks for marginRight, remove the whole object.
                        delete this.get;
                        return;
                }

                // Hook needed; redefine it so that the support test is not executed again.

                return (this.get = hookFn).apply( this, arguments );
        }
};</pre>

<p>}</p>

<p>(function() {</p>

<pre>// Minified: var b,c,d,e,f,g, h,i
var div, style, a, pixelPositionVal, boxSizingReliableVal,
        reliableHiddenOffsetsVal, reliableMarginRightVal;

// Setup
div = document.createElement( &quot;div&quot; );
div.innerHTML = &quot;  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href=&#39;/a&#39;&gt;a&lt;/a&gt;&lt;input type=&#39;checkbox&#39;/&gt;&quot;;
a = div.getElementsByTagName( &quot;a&quot; )[ 0 ];
style = a &amp;&amp; a.style;

// Finish early in limited (non-browser) environments
if ( !style ) {
        return;
}

style.cssText = &quot;float:left;opacity:.5&quot;;

// Support: IE&lt;9
// Make sure that element opacity exists (as opposed to filter)
support.opacity = style.opacity === &quot;0.5&quot;;

// Verify style float existence
// (IE uses styleFloat instead of cssFloat)
support.cssFloat = !!style.cssFloat;

div.style.backgroundClip = &quot;content-box&quot;;
div.cloneNode( true ).style.backgroundClip = &quot;&quot;;
support.clearCloneStyle = div.style.backgroundClip === &quot;content-box&quot;;

// Support: Firefox&lt;29, Android 2.3
// Vendor-prefix box-sizing
support.boxSizing = style.boxSizing === &quot;&quot; || style.MozBoxSizing === &quot;&quot; ||
        style.WebkitBoxSizing === &quot;&quot;;

jQuery.extend(support, {
        reliableHiddenOffsets: function() {
                if ( reliableHiddenOffsetsVal == null ) {
                        computeStyleTests();
                }
                return reliableHiddenOffsetsVal;
        },

        boxSizingReliable: function() {
                if ( boxSizingReliableVal == null ) {
                        computeStyleTests();
                }
                return boxSizingReliableVal;
        },

        pixelPosition: function() {
                if ( pixelPositionVal == null ) {
                        computeStyleTests();
                }
                return pixelPositionVal;
        },

        // Support: Android 2.3
        reliableMarginRight: function() {
                if ( reliableMarginRightVal == null ) {
                        computeStyleTests();
                }
                return reliableMarginRightVal;
        }
});

function computeStyleTests() {
        // Minified: var b,c,d,j
        var div, body, container, contents;

        body = document.getElementsByTagName( &quot;body&quot; )[ 0 ];
        if ( !body || !body.style ) {
                // Test fired too early or in an unsupported environment, exit.
                return;
        }

        // Setup
        div = document.createElement( &quot;div&quot; );
        container = document.createElement( &quot;div&quot; );
        container.style.cssText = &quot;position:absolute;border:0;width:0;height:0;top:0;left:-9999px&quot;;
        body.appendChild( container ).appendChild( div );

        div.style.cssText =
                // Support: Firefox&lt;29, Android 2.3
                // Vendor-prefix box-sizing
                &quot;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;&quot; +
                &quot;box-sizing:border-box;display:block;margin-top:1%;top:1%;&quot; +
                &quot;border:1px;padding:1px;width:4px;position:absolute&quot;;

        // Support: IE&lt;9
        // Assume reasonable values in the absence of getComputedStyle
        pixelPositionVal = boxSizingReliableVal = false;
        reliableMarginRightVal = true;

        // Check for getComputedStyle so that this code is not run in IE&lt;9.
        if ( window.getComputedStyle ) {
                pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== &quot;1%&quot;;
                boxSizingReliableVal =
                        ( window.getComputedStyle( div, null ) || { width: &quot;4px&quot; } ).width === &quot;4px&quot;;

                // Support: Android 2.3
                // Div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container (#3333)
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                contents = div.appendChild( document.createElement( &quot;div&quot; ) );

                // Reset CSS: box-sizing; display; margin; border; padding
                contents.style.cssText = div.style.cssText =
                        // Support: Firefox&lt;29, Android 2.3
                        // Vendor-prefix box-sizing
                        &quot;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;&quot; +
                        &quot;box-sizing:content-box;display:block;margin:0;border:0;padding:0&quot;;
                contents.style.marginRight = contents.style.width = &quot;0&quot;;
                div.style.width = &quot;1px&quot;;

                reliableMarginRightVal =
                        !parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );
        }

        // Support: IE8
        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        div.innerHTML = &quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;;
        contents = div.getElementsByTagName( &quot;td&quot; );
        contents[ 0 ].style.cssText = &quot;margin:0;border:0;padding:0;display:none&quot;;
        reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
        if ( reliableHiddenOffsetsVal ) {
                contents[ 0 ].style.display = &quot;&quot;;
                contents[ 1 ].style.display = &quot;none&quot;;
                reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
        }

        body.removeChild( container );
}</pre>

<p>})();</p>

<p>// A method for quickly swapping in/out CSS properties to get correct
calculations. jQuery.swap = function( elem, options, callback, args ) {</p>

<pre>var ret, name,
        old = {};

// Remember the old values, and insert the new ones
for ( name in options ) {
        old[ name ] = elem.style[ name ];
        elem.style[ name ] = options[ name ];
}

ret = callback.apply( elem, args || [] );

// Revert the old values
for ( name in options ) {
        elem.style[ name ] = old[ name ];
}

return ret;</pre>

<p>};</p>

<p>var</p>

<pre>        ralpha = /alpha\([^)]*\)/i,
ropacity = /opacity\s*=\s*([^)]*)/,

// swappable if display is none or starts with table except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;
// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
rdisplayswap = /^(none|table(?!-c[ea]).+)/,
rnumsplit = new RegExp( &quot;^(&quot; + pnum + &quot;)(.*)$&quot;, &quot;i&quot; ),
rrelNum = new RegExp( &quot;^([+-])=(&quot; + pnum + &quot;)&quot;, &quot;i&quot; ),

cssShow = { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; },
cssNormalTransform = {
        letterSpacing: &quot;0&quot;,
        fontWeight: &quot;400&quot;
},

cssPrefixes = [ &quot;Webkit&quot;, &quot;O&quot;, &quot;Moz&quot;, &quot;ms&quot; ];</pre>

<p>// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {</p>

<pre>// shortcut for names that are not vendor prefixed
if ( name in style ) {
        return name;
}

// check for vendor prefixed names
var capName = name.charAt(0).toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;

while ( i-- ) {
        name = cssPrefixes[ i ] + capName;
        if ( name in style ) {
                return name;
        }
}

return origName;</pre>

<p>}</p>

<p>function showHide( elements, show ) {</p>

<pre>var display, elem, hidden,
        values = [],
        index = 0,
        length = elements.length;

for ( ; index &lt; length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
                continue;
        }

        values[ index ] = jQuery._data( elem, &quot;olddisplay&quot; );
        display = elem.style.display;
        if ( show ) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if ( !values[ index ] &amp;&amp; display === &quot;none&quot; ) {
                        elem.style.display = &quot;&quot;;
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if ( elem.style.display === &quot;&quot; &amp;&amp; isHidden( elem ) ) {
                        values[ index ] = jQuery._data( elem, &quot;olddisplay&quot;, defaultDisplay(elem.nodeName) );
                }
        } else {
                hidden = isHidden( elem );

                if ( display &amp;&amp; display !== &quot;none&quot; || !hidden ) {
                        jQuery._data( elem, &quot;olddisplay&quot;, hidden ? display : jQuery.css( elem, &quot;display&quot; ) );
                }
        }
}

// Set the display of most of the elements in a second loop
// to avoid the constant reflow
for ( index = 0; index &lt; length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
                continue;
        }
        if ( !show || elem.style.display === &quot;none&quot; || elem.style.display === &quot;&quot; ) {
                elem.style.display = show ? values[ index ] || &quot;&quot; : &quot;none&quot;;
        }
}

return elements;</pre>

<p>}</p>

<p>function setPositiveNumber( elem, value, subtract ) {</p>

<pre>var matches = rnumsplit.exec( value );
return matches ?
        // Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks
        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || &quot;px&quot; ) :
        value;</pre>

<p>}</p>

<p>function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {</p>

<pre>var i = extra === ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ?
        // If we already have the right measurement, avoid augmentation
        4 :
        // Otherwise initialize for horizontal or vertical properties
        name === &quot;width&quot; ? 1 : 0,

        val = 0;

for ( ; i &lt; 4; i += 2 ) {
        // both box models exclude margin, so add it if we want it
        if ( extra === &quot;margin&quot; ) {
                val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
        }

        if ( isBorderBox ) {
                // border-box includes padding, so remove it if we want content
                if ( extra === &quot;content&quot; ) {
                        val -= jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
                }

                // at this point, extra isn&#39;t border nor margin, so remove border
                if ( extra !== &quot;margin&quot; ) {
                        val -= jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
                }
        } else {
                // at this point, extra isn&#39;t content, so add padding
                val += jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );

                // at this point, extra isn&#39;t content nor padding, so add border
                if ( extra !== &quot;padding&quot; ) {
                        val += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
                }
        }
}

return val;</pre>

<p>}</p>

<p>function getWidthOrHeight( elem, name, extra ) {</p>

<pre>// Start with offset property, which is equivalent to the border-box value
var valueIsBorderBox = true,
        val = name === &quot;width&quot; ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles( elem ),
        isBorderBox = support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;;

// some non-html elements return undefined for offsetWidth, so check for null/undefined
// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
if ( val &lt;= 0 || val == null ) {
        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name, styles );
        if ( val &lt; 0 || val == null ) {
                val = elem.style[ name ];
        }

        // Computed unit is not pixels. Stop here and return.
        if ( rnumnonpx.test(val) ) {
                return val;
        }

        // we need the check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = isBorderBox &amp;&amp; ( support.boxSizingReliable() || val === elem.style[ name ] );

        // Normalize &quot;&quot;, auto, and prepare for extra
        val = parseFloat( val ) || 0;
}

// use the active box-sizing model to add/subtract irrelevant styles
return ( val +
        augmentWidthOrHeight(
                elem,
                name,
                extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ),
                valueIsBorderBox,
                styles
        )
) + &quot;px&quot;;</pre>

<p>}</p>

<p>jQuery.extend({</p>

<pre>// Add in style property hooks for overriding the default
// behavior of getting and setting a style property
cssHooks: {
        opacity: {
                get: function( elem, computed ) {
                        if ( computed ) {
                                // We should always get a number back from opacity
                                var ret = curCSS( elem, &quot;opacity&quot; );
                                return ret === &quot;&quot; ? &quot;1&quot; : ret;
                        }
                }
        }
},

// Don&#39;t automatically add &quot;px&quot; to these possibly-unitless properties
cssNumber: {
        &quot;columnCount&quot;: true,
        &quot;fillOpacity&quot;: true,
        &quot;flexGrow&quot;: true,
        &quot;flexShrink&quot;: true,
        &quot;fontWeight&quot;: true,
        &quot;lineHeight&quot;: true,
        &quot;opacity&quot;: true,
        &quot;order&quot;: true,
        &quot;orphans&quot;: true,
        &quot;widows&quot;: true,
        &quot;zIndex&quot;: true,
        &quot;zoom&quot;: true
},

// Add in properties whose names you wish to fix before
// setting or getting the value
cssProps: {
        // normalize float css property
        &quot;float&quot;: support.cssFloat ? &quot;cssFloat&quot; : &quot;styleFloat&quot;
},

// Get and set the style property on a DOM Node
style: function( elem, name, value, extra ) {
        // Don&#39;t set styles on text and comment nodes
        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                return;
        }

        // Make sure that we&#39;re working with the right name
        var ret, type, hooks,
                origName = jQuery.camelCase( name ),
                style = elem.style;

        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // Check if we&#39;re setting a value
        if ( value !== undefined ) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if ( type === &quot;string&quot; &amp;&amp; (ret = rrelNum.exec( value )) ) {
                        value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                        // Fixes bug #9237
                        type = &quot;number&quot;;
                }

                // Make sure that null and NaN values aren&#39;t set. See: #7116
                if ( value == null || value !== value ) {
                        return;
                }

                // If a number was passed in, add &#39;px&#39; to the (except for certain CSS properties)
                if ( type === &quot;number&quot; &amp;&amp; !jQuery.cssNumber[ origName ] ) {
                        value += &quot;px&quot;;
                }

                // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
                // but it would mean to define eight (for every problematic property) identical functions
                if ( !support.clearCloneStyle &amp;&amp; value === &quot;&quot; &amp;&amp; name.indexOf(&quot;background&quot;) === 0 ) {
                        style[ name ] = &quot;inherit&quot;;
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if ( !hooks || !(&quot;set&quot; in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

                        // Support: IE
                        // Swallow errors from &#39;invalid&#39; CSS values (#5509)
                        try {
                                style[ name ] = value;
                        } catch(e) {}
                }

        } else {
                // If a hook was provided get the non-computed value from there
                if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, false, extra )) !== undefined ) {
                        return ret;
                }

                // Otherwise just get the value from the style object
                return style[ name ];
        }
},

css: function( elem, name, extra, styles ) {
        var num, val, hooks,
                origName = jQuery.camelCase( name );

        // Make sure that we&#39;re working with the right name
        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // If a hook was provided get the computed value from there
        if ( hooks &amp;&amp; &quot;get&quot; in hooks ) {
                val = hooks.get( elem, true, extra );
        }

        // Otherwise, if a way to get the computed value exists, use that
        if ( val === undefined ) {
                val = curCSS( elem, name, styles );
        }

        //convert &quot;normal&quot; to computed value
        if ( val === &quot;normal&quot; &amp;&amp; name in cssNormalTransform ) {
                val = cssNormalTransform[ name ];
        }

        // Return, converting to number if forced or a qualifier was provided and val looks numeric
        if ( extra === &quot;&quot; || extra ) {
                num = parseFloat( val );
                return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
        }
        return val;
}</pre>

<p>});</p>

<p>jQuery.each([ height, width ], function( i, name ) {</p>

<pre>jQuery.cssHooks[ name ] = {
        get: function( elem, computed, extra ) {
                if ( computed ) {
                        // certain elements can have dimension info if we invisibly show them
                        // however, it must have a current display style that would benefit from this
                        return rdisplayswap.test( jQuery.css( elem, &quot;display&quot; ) ) &amp;&amp; elem.offsetWidth === 0 ?
                                jQuery.swap( elem, cssShow, function() {
                                        return getWidthOrHeight( elem, name, extra );
                                }) :
                                getWidthOrHeight( elem, name, extra );
                }
        },

        set: function( elem, value, extra ) {
                var styles = extra &amp;&amp; getStyles( elem );
                return setPositiveNumber( elem, value, extra ?
                        augmentWidthOrHeight(
                                elem,
                                name,
                                extra,
                                support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;,
                                styles
                        ) : 0
                );
        }
};</pre>

<p>});</p>

<p>if ( !support.opacity ) {</p>

<pre>jQuery.cssHooks.opacity = {
        get: function( elem, computed ) {
                // IE uses filters for opacity
                return ropacity.test( (computed &amp;&amp; elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || &quot;&quot; ) ?
                        ( 0.01 * parseFloat( RegExp.$1 ) ) + &quot;&quot; :
                        computed ? &quot;1&quot; : &quot;&quot;;
        },

        set: function( elem, value ) {
                var style = elem.style,
                        currentStyle = elem.currentStyle,
                        opacity = jQuery.isNumeric( value ) ? &quot;alpha(opacity=&quot; + value * 100 + &quot;)&quot; : &quot;&quot;,
                        filter = currentStyle &amp;&amp; currentStyle.filter || style.filter || &quot;&quot;;

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                // if value === &quot;&quot;, then remove inline opacity #12685
                if ( ( value &gt;= 1 || value === &quot;&quot; ) &amp;&amp;
                                jQuery.trim( filter.replace( ralpha, &quot;&quot; ) ) === &quot;&quot; &amp;&amp;
                                style.removeAttribute ) {

                        // Setting style.filter to null, &quot;&quot; &amp; &quot; &quot; still leave &quot;filter:&quot; in the cssText
                        // if &quot;filter:&quot; is present at all, clearType is disabled, we want to avoid this
                        // style.removeAttribute is IE Only, but so apparently is this code path...
                        style.removeAttribute( &quot;filter&quot; );

                        // if there is no filter style applied in a css rule or unset inline opacity, we are done
                        if ( value === &quot;&quot; || currentStyle &amp;&amp; !currentStyle.filter ) {
                                return;
                        }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test( filter ) ?
                        filter.replace( ralpha, opacity ) :
                        filter + &quot; &quot; + opacity;
        }
};</pre>

<p>}</p>

<p>jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,</p>

<pre>function( elem, computed ) {
        if ( computed ) {
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                // Work around by temporarily setting element display to inline-block
                return jQuery.swap( elem, { &quot;display&quot;: &quot;inline-block&quot; },
                        curCSS, [ elem, &quot;marginRight&quot; ] );
        }
}</pre>

<p>);</p>

<p>// These hooks are used by animate to expand properties jQuery.each({</p>

<pre>margin: &quot;&quot;,
padding: &quot;&quot;,
border: &quot;Width&quot;</pre>

<p>}, function( prefix, suffix ) {</p>

<pre>jQuery.cssHooks[ prefix + suffix ] = {
        expand: function( value ) {
                var i = 0,
                        expanded = {},

                        // assumes a single number if not a string
                        parts = typeof value === &quot;string&quot; ? value.split(&quot; &quot;) : [ value ];

                for ( ; i &lt; 4; i++ ) {
                        expanded[ prefix + cssExpand[ i ] + suffix ] =
                                parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                }

                return expanded;
        }
};

if ( !rmargin.test( prefix ) ) {
        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
}</pre>

<p>});</p>

<p>jQuery.fn.extend({</p>

<pre>css: function( name, value ) {
        return access( this, function( elem, name, value ) {
                var styles, len,
                        map = {},
                        i = 0;

                if ( jQuery.isArray( name ) ) {
                        styles = getStyles( elem );
                        len = name.length;

                        for ( ; i &lt; len; i++ ) {
                                map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                        }

                        return map;
                }

                return value !== undefined ?
                        jQuery.style( elem, name, value ) :
                        jQuery.css( elem, name );
        }, name, value, arguments.length &gt; 1 );
},
show: function() {
        return showHide( this, true );
},
hide: function() {
        return showHide( this );
},
toggle: function( state ) {
        if ( typeof state === &quot;boolean&quot; ) {
                return state ? this.show() : this.hide();
        }

        return this.each(function() {
                if ( isHidden( this ) ) {
                        jQuery( this ).show();
                } else {
                        jQuery( this ).hide();
                }
        });
}</pre>

<p>});</p>

<p>function Tween( elem, options, prop, end, easing ) {</p>

<pre>return new Tween.prototype.init( elem, options, prop, end, easing );</pre>

<p>} jQuery.Tween = Tween;</p>

<p>Tween.prototype = {</p>

<pre>constructor: Tween,
init: function( elem, options, prop, end, easing, unit ) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || &quot;swing&quot;;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; );
},
cur: function() {
        var hooks = Tween.propHooks[ this.prop ];

        return hooks &amp;&amp; hooks.get ?
                hooks.get( this ) :
                Tween.propHooks._default.get( this );
},
run: function( percent ) {
        var eased,
                hooks = Tween.propHooks[ this.prop ];

        if ( this.options.duration ) {
                this.pos = eased = jQuery.easing[ this.easing ](
                        percent, this.options.duration * percent, 0, 1, this.options.duration
                );
        } else {
                this.pos = eased = percent;
        }
        this.now = ( this.end - this.start ) * eased + this.start;

        if ( this.options.step ) {
                this.options.step.call( this.elem, this.now, this );
        }

        if ( hooks &amp;&amp; hooks.set ) {
                hooks.set( this );
        } else {
                Tween.propHooks._default.set( this );
        }
        return this;
}</pre>

<p>};</p>

<p>Tween.prototype.init.prototype = Tween.prototype;</p>

<p>Tween.propHooks = {</p>

<pre>_default: {
        get: function( tween ) {
                var result;

                if ( tween.elem[ tween.prop ] != null &amp;&amp;
                        (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                        return tween.elem[ tween.prop ];
                }

                // passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails
                // so, simple values such as &quot;10px&quot; are parsed to Float.
                // complex values such as &quot;rotate(1rad)&quot; are returned as is.
                result = jQuery.css( tween.elem, tween.prop, &quot;&quot; );
                // Empty strings, null, undefined and &quot;auto&quot; are converted to 0.
                return !result || result === &quot;auto&quot; ? 0 : result;
        },
        set: function( tween ) {
                // use step hook for back compat - use cssHook if its there - use .style if its
                // available and use plain properties where available
                if ( jQuery.fx.step[ tween.prop ] ) {
                        jQuery.fx.step[ tween.prop ]( tween );
                } else if ( tween.elem.style &amp;&amp; ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                        jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                } else {
                        tween.elem[ tween.prop ] = tween.now;
                }
        }
}</pre>

<p>};</p>

<p>// Support: IE &lt;=9 // Panic based approach to setting things on
disconnected nodes</p>

<p>Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {</p>

<pre>set: function( tween ) {
        if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {
                tween.elem[ tween.prop ] = tween.now;
        }
}</pre>

<p>};</p>

<p>jQuery.easing = {</p>

<pre>linear: function( p ) {
        return p;
},
swing: function( p ) {
        return 0.5 - Math.cos( p * Math.PI ) / 2;
}</pre>

<p>};</p>

<p>jQuery.fx = Tween.prototype.init;</p>

<p>// Back Compat &lt;1.8 extension point jQuery.fx.step = {};</p>

<p>var</p>

<pre>fxNow, timerId,
rfxtypes = /^(?:toggle|show|hide)$/,
rfxnum = new RegExp( &quot;^(?:([+-])=|)(&quot; + pnum + &quot;)([a-z%]*)$&quot;, &quot;i&quot; ),
rrun = /queueHooks$/,
animationPrefilters = [ defaultPrefilter ],
tweeners = {
        &quot;*&quot;: [ function( prop, value ) {
                var tween = this.createTween( prop, value ),
                        target = tween.cur(),
                        parts = rfxnum.exec( value ),
                        unit = parts &amp;&amp; parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; ),

                        // Starting value computation is required for potential unit mismatches
                        start = ( jQuery.cssNumber[ prop ] || unit !== &quot;px&quot; &amp;&amp; +target ) &amp;&amp;
                                rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                        scale = 1,
                        maxIterations = 20;

                if ( start &amp;&amp; start[ 3 ] !== unit ) {
                        // Trust units reported by jQuery.css
                        unit = unit || start[ 3 ];

                        // Make sure we update the tween properties later on
                        parts = parts || [];

                        // Iteratively approximate from a nonzero starting point
                        start = +target || 1;

                        do {
                                // If previous iteration zeroed out, double until we get *something*
                                // Use a string for doubling factor so we don&#39;t accidentally see scale as unchanged below
                                scale = scale || &quot;.5&quot;;

                                // Adjust and apply
                                start = start / scale;
                                jQuery.style( tween.elem, prop, start + unit );

                        // Update scale, tolerating zero or NaN from tween.cur()
                        // And breaking the loop if scale is unchanged or perfect, or if we&#39;ve just had enough
                        } while ( scale !== (scale = tween.cur() / target) &amp;&amp; scale !== 1 &amp;&amp; --maxIterations );
                }

                // Update tween properties
                if ( parts ) {
                        start = tween.start = +start || +target || 0;
                        tween.unit = unit;
                        // If a +=/-= token was provided, we&#39;re doing a relative animation
                        tween.end = parts[ 1 ] ?
                                start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                                +parts[ 2 ];
                }

                return tween;
        } ]
};</pre>

<p>// Animations created synchronously will run synchronously function
createFxNow() {</p>

<pre class="ruby"><span class="ruby-identifier">setTimeout</span>(<span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">fxNow</span> = <span class="ruby-identifier">undefined</span>;
});
<span class="ruby-keyword">return</span> ( <span class="ruby-identifier">fxNow</span> = <span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">now</span>() );
</pre>

<p>}</p>

<p>// Generate parameters to create a standard animation function genFx( type,
includeWidth ) {</p>

<pre>var which,
        attrs = { height: type },
        i = 0;

// if we include width, step value is 1 to do all cssExpand values,
// if we don&#39;t include width, step value is 2 to skip over Left and Right
includeWidth = includeWidth ? 1 : 0;
for ( ; i &lt; 4 ; i += 2 - includeWidth ) {
        which = cssExpand[ i ];
        attrs[ &quot;margin&quot; + which ] = attrs[ &quot;padding&quot; + which ] = type;
}

if ( includeWidth ) {
        attrs.opacity = attrs.width = type;
}

return attrs;</pre>

<p>}</p>

<p>function createTween( value, prop, animation ) {</p>

<pre>var tween,
        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ &quot;*&quot; ] ),
        index = 0,
        length = collection.length;
for ( ; index &lt; length; index++ ) {
        if ( (tween = collection[ index ].call( animation, prop, value )) ) {

                // we&#39;re done with this property
                return tween;
        }
}</pre>

<p>}</p>

<p>function defaultPrefilter( elem, props, opts ) {</p>

<pre>/* jshint validthis: true */
var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType &amp;&amp; isHidden( elem ),
        dataShow = jQuery._data( elem, &quot;fxshow&quot; );

// handle queue: false promises
if ( !opts.queue ) {
        hooks = jQuery._queueHooks( elem, &quot;fx&quot; );
        if ( hooks.unqueued == null ) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                        if ( !hooks.unqueued ) {
                                oldfire();
                        }
                };
        }
        hooks.unqueued++;

        anim.always(function() {
                // doing this makes sure that the complete handler will be called
                // before this completes
                anim.always(function() {
                        hooks.unqueued--;
                        if ( !jQuery.queue( elem, &quot;fx&quot; ).length ) {
                                hooks.empty.fire();
                        }
                });
        });
}

// height/width overflow pass
if ( elem.nodeType === 1 &amp;&amp; ( &quot;height&quot; in props || &quot;width&quot; in props ) ) {
        // Make sure that nothing sneaks out
        // Record all 3 overflow attributes because IE does not
        // change the overflow attribute when overflowX and
        // overflowY are set to the same value
        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

        // Set display property to inline-block for height/width
        // animations on inline elements that are having width/height animated
        display = jQuery.css( elem, &quot;display&quot; );

        // Test default display if display is currently &quot;none&quot;
        checkDisplay = display === &quot;none&quot; ?
                jQuery._data( elem, &quot;olddisplay&quot; ) || defaultDisplay( elem.nodeName ) : display;

        if ( checkDisplay === &quot;inline&quot; &amp;&amp; jQuery.css( elem, &quot;float&quot; ) === &quot;none&quot; ) {

                // inline-level elements accept inline-block;
                // block-level elements need to be inline with layout
                if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === &quot;inline&quot; ) {
                        style.display = &quot;inline-block&quot;;
                } else {
                        style.zoom = 1;
                }
        }
}

if ( opts.overflow ) {
        style.overflow = &quot;hidden&quot;;
        if ( !support.shrinkWrapBlocks() ) {
                anim.always(function() {
                        style.overflow = opts.overflow[ 0 ];
                        style.overflowX = opts.overflow[ 1 ];
                        style.overflowY = opts.overflow[ 2 ];
                });
        }
}

// show/hide pass
for ( prop in props ) {
        value = props[ prop ];
        if ( rfxtypes.exec( value ) ) {
                delete props[ prop ];
                toggle = toggle || value === &quot;toggle&quot;;
                if ( value === ( hidden ? &quot;hide&quot; : &quot;show&quot; ) ) {

                        // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                        if ( value === &quot;show&quot; &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) {
                                hidden = true;
                        } else {
                                continue;
                        }
                }
                orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop );

        // Any non-fx value stops us from restoring the original display value
        } else {
                display = undefined;
        }
}

if ( !jQuery.isEmptyObject( orig ) ) {
        if ( dataShow ) {
                if ( &quot;hidden&quot; in dataShow ) {
                        hidden = dataShow.hidden;
                }
        } else {
                dataShow = jQuery._data( elem, &quot;fxshow&quot;, {} );
        }

        // store state if its toggle - enables .stop().toggle() to &quot;reverse&quot;
        if ( toggle ) {
                dataShow.hidden = !hidden;
        }
        if ( hidden ) {
                jQuery( elem ).show();
        } else {
                anim.done(function() {
                        jQuery( elem ).hide();
                });
        }
        anim.done(function() {
                var prop;
                jQuery._removeData( elem, &quot;fxshow&quot; );
                for ( prop in orig ) {
                        jQuery.style( elem, prop, orig[ prop ] );
                }
        });
        for ( prop in orig ) {
                tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

                if ( !( prop in dataShow ) ) {
                        dataShow[ prop ] = tween.start;
                        if ( hidden ) {
                                tween.end = tween.start;
                                tween.start = prop === &quot;width&quot; || prop === &quot;height&quot; ? 1 : 0;
                        }
                }
        }

// If this is a noop like .hide().hide(), restore an overwritten display value
} else if ( (display === &quot;none&quot; ? defaultDisplay( elem.nodeName ) : display) === &quot;inline&quot; ) {
        style.display = display;
}</pre>

<p>}</p>

<p>function propFilter( props, specialEasing ) {</p>

<pre>var index, name, easing, value, hooks;

// camelCase, specialEasing and expand cssHook pass
for ( index in props ) {
        name = jQuery.camelCase( index );
        easing = specialEasing[ name ];
        value = props[ index ];
        if ( jQuery.isArray( value ) ) {
                easing = value[ 1 ];
                value = props[ index ] = value[ 0 ];
        }

        if ( index !== name ) {
                props[ name ] = value;
                delete props[ index ];
        }

        hooks = jQuery.cssHooks[ name ];
        if ( hooks &amp;&amp; &quot;expand&quot; in hooks ) {
                value = hooks.expand( value );
                delete props[ name ];

                // not quite $.extend, this wont overwrite keys already present.
                // also - reusing &#39;index&#39; from above because we have the correct &quot;name&quot;
                for ( index in value ) {
                        if ( !( index in props ) ) {
                                props[ index ] = value[ index ];
                                specialEasing[ index ] = easing;
                        }
                }
        } else {
                specialEasing[ name ] = easing;
        }
}</pre>

<p>}</p>

<p>function Animation( elem, properties, options ) {</p>

<pre>var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always( function() {
                // don&#39;t match elem in the :animated selector
                delete tick.elem;
        }),
        tick = function() {
                if ( stopped ) {
                        return false;
                }
                var currentTime = fxNow || createFxNow(),
                        remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                        // archaic crash bug won&#39;t allow us to use 1 - ( 0.5 || 0 ) (#12497)
                        temp = remaining / animation.duration || 0,
                        percent = 1 - temp,
                        index = 0,
                        length = animation.tweens.length;

                for ( ; index &lt; length ; index++ ) {
                        animation.tweens[ index ].run( percent );
                }

                deferred.notifyWith( elem, [ animation, percent, remaining ]);

                if ( percent &lt; 1 &amp;&amp; length ) {
                        return remaining;
                } else {
                        deferred.resolveWith( elem, [ animation ] );
                        return false;
                }
        },
        animation = deferred.promise({
                elem: elem,
                props: jQuery.extend( {}, properties ),
                opts: jQuery.extend( true, { specialEasing: {} }, options ),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function( prop, end ) {
                        var tween = jQuery.Tween( elem, animation.opts, prop, end,
                                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                        animation.tweens.push( tween );
                        return tween;
                },
                stop: function( gotoEnd ) {
                        var index = 0,
                                // if we are going to the end, we want to run all the tweens
                                // otherwise we skip this part
                                length = gotoEnd ? animation.tweens.length : 0;
                        if ( stopped ) {
                                return this;
                        }
                        stopped = true;
                        for ( ; index &lt; length ; index++ ) {
                                animation.tweens[ index ].run( 1 );
                        }

                        // resolve when we played the last frame
                        // otherwise, reject
                        if ( gotoEnd ) {
                                deferred.resolveWith( elem, [ animation, gotoEnd ] );
                        } else {
                                deferred.rejectWith( elem, [ animation, gotoEnd ] );
                        }
                        return this;
                }
        }),
        props = animation.props;

propFilter( props, animation.opts.specialEasing );

for ( ; index &lt; length ; index++ ) {
        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
        if ( result ) {
                return result;
        }
}

jQuery.map( props, createTween, animation );

if ( jQuery.isFunction( animation.opts.start ) ) {
        animation.opts.start.call( elem, animation );
}

jQuery.fx.timer(
        jQuery.extend( tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
        })
);

// attach callbacks from options
return animation.progress( animation.opts.progress )
        .done( animation.opts.done, animation.opts.complete )
        .fail( animation.opts.fail )
        .always( animation.opts.always );</pre>

<p>}</p>

<p>jQuery.Animation = jQuery.extend( Animation, {</p>

<pre>tweener: function( props, callback ) {
        if ( jQuery.isFunction( props ) ) {
                callback = props;
                props = [ &quot;*&quot; ];
        } else {
                props = props.split(&quot; &quot;);
        }

        var prop,
                index = 0,
                length = props.length;

        for ( ; index &lt; length ; index++ ) {
                prop = props[ index ];
                tweeners[ prop ] = tweeners[ prop ] || [];
                tweeners[ prop ].unshift( callback );
        }
},

prefilter: function( callback, prepend ) {
        if ( prepend ) {
                animationPrefilters.unshift( callback );
        } else {
                animationPrefilters.push( callback );
        }
}</pre>

<p>});</p>

<p>jQuery.speed = function( speed, easing, fn ) {</p>

<pre>var opt = speed &amp;&amp; typeof speed === &quot;object&quot; ? jQuery.extend( {}, speed ) : {
        complete: fn || !fn &amp;&amp; easing ||
                jQuery.isFunction( speed ) &amp;&amp; speed,
        duration: speed,
        easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing
};

opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === &quot;number&quot; ? opt.duration :
        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

// normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;
if ( opt.queue == null || opt.queue === true ) {
        opt.queue = &quot;fx&quot;;
}

// Queueing
opt.old = opt.complete;

opt.complete = function() {
        if ( jQuery.isFunction( opt.old ) ) {
                opt.old.call( this );
        }

        if ( opt.queue ) {
                jQuery.dequeue( this, opt.queue );
        }
};

return opt;</pre>

<p>};</p>

<p>jQuery.fn.extend({</p>

<pre>fadeTo: function( speed, to, easing, callback ) {

        // show any hidden elements after setting opacity to 0
        return this.filter( isHidden ).css( &quot;opacity&quot;, 0 ).show()

                // animate to the value specified
                .end().animate({ opacity: to }, speed, easing, callback );
},
animate: function( prop, speed, easing, callback ) {
        var empty = jQuery.isEmptyObject( prop ),
                optall = jQuery.speed( speed, easing, callback ),
                doAnimation = function() {
                        // Operate on a copy of prop so per-property easing won&#39;t be lost
                        var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                        // Empty animations, or finishing resolves immediately
                        if ( empty || jQuery._data( this, &quot;finish&quot; ) ) {
                                anim.stop( true );
                        }
                };
                doAnimation.finish = doAnimation;

        return empty || optall.queue === false ?
                this.each( doAnimation ) :
                this.queue( optall.queue, doAnimation );
},
stop: function( type, clearQueue, gotoEnd ) {
        var stopQueue = function( hooks ) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop( gotoEnd );
        };

        if ( typeof type !== &quot;string&quot; ) {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
        }
        if ( clearQueue &amp;&amp; type !== false ) {
                this.queue( type || &quot;fx&quot;, [] );
        }

        return this.each(function() {
                var dequeue = true,
                        index = type != null &amp;&amp; type + &quot;queueHooks&quot;,
                        timers = jQuery.timers,
                        data = jQuery._data( this );

                if ( index ) {
                        if ( data[ index ] &amp;&amp; data[ index ].stop ) {
                                stopQueue( data[ index ] );
                        }
                } else {
                        for ( index in data ) {
                                if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {
                                        stopQueue( data[ index ] );
                                }
                        }
                }

                for ( index = timers.length; index--; ) {
                        if ( timers[ index ].elem === this &amp;&amp; (type == null || timers[ index ].queue === type) ) {
                                timers[ index ].anim.stop( gotoEnd );
                                dequeue = false;
                                timers.splice( index, 1 );
                        }
                }

                // start the next in the queue if the last step wasn&#39;t forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if ( dequeue || !gotoEnd ) {
                        jQuery.dequeue( this, type );
                }
        });
},
finish: function( type ) {
        if ( type !== false ) {
                type = type || &quot;fx&quot;;
        }
        return this.each(function() {
                var index,
                        data = jQuery._data( this ),
                        queue = data[ type + &quot;queue&quot; ],
                        hooks = data[ type + &quot;queueHooks&quot; ],
                        timers = jQuery.timers,
                        length = queue ? queue.length : 0;

                // enable finishing flag on private data
                data.finish = true;

                // empty the queue first
                jQuery.queue( this, type, [] );

                if ( hooks &amp;&amp; hooks.stop ) {
                        hooks.stop.call( this, true );
                }

                // look for any active animations, and finish them
                for ( index = timers.length; index--; ) {
                        if ( timers[ index ].elem === this &amp;&amp; timers[ index ].queue === type ) {
                                timers[ index ].anim.stop( true );
                                timers.splice( index, 1 );
                        }
                }

                // look for any animations in the old queue and finish them
                for ( index = 0; index &lt; length; index++ ) {
                        if ( queue[ index ] &amp;&amp; queue[ index ].finish ) {
                                queue[ index ].finish.call( this );
                        }
                }

                // turn off finishing flag
                delete data.finish;
        });
}</pre>

<p>});</p>

<p>jQuery.each([ toggle, show, hide ], function( i, name ) {</p>

<pre>var cssFn = jQuery.fn[ name ];
jQuery.fn[ name ] = function( speed, easing, callback ) {
        return speed == null || typeof speed === &quot;boolean&quot; ?
                cssFn.apply( this, arguments ) :
                this.animate( genFx( name, true ), speed, easing, callback );
};</pre>

<p>});</p>

<p>// Generate shortcuts for custom animations jQuery.each({</p>

<pre>slideDown: genFx(&quot;show&quot;),
slideUp: genFx(&quot;hide&quot;),
slideToggle: genFx(&quot;toggle&quot;),
fadeIn: { opacity: &quot;show&quot; },
fadeOut: { opacity: &quot;hide&quot; },
fadeToggle: { opacity: &quot;toggle&quot; }</pre>

<p>}, function( name, props ) {</p>

<pre class="ruby"><span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">fn</span>[ <span class="ruby-identifier">name</span> ] = <span class="ruby-identifier">function</span>( <span class="ruby-identifier">speed</span>, <span class="ruby-identifier">easing</span>, <span class="ruby-identifier">callback</span> ) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">animate</span>( <span class="ruby-identifier">props</span>, <span class="ruby-identifier">speed</span>, <span class="ruby-identifier">easing</span>, <span class="ruby-identifier">callback</span> );
};
</pre>

<p>});</p>

<p>jQuery.timers = []; jQuery.fx.tick = function() {</p>

<pre>var timer,
        timers = jQuery.timers,
        i = 0;

fxNow = jQuery.now();

for ( ; i &lt; timers.length; i++ ) {
        timer = timers[ i ];
        // Checks the timer has not already been removed
        if ( !timer() &amp;&amp; timers[ i ] === timer ) {
                timers.splice( i--, 1 );
        }
}

if ( !timers.length ) {
        jQuery.fx.stop();
}
fxNow = undefined;</pre>

<p>};</p>

<p>jQuery.fx.timer = function( timer ) {</p>

<pre>jQuery.timers.push( timer );
if ( timer() ) {
        jQuery.fx.start();
} else {
        jQuery.timers.pop();
}</pre>

<p>};</p>

<p>jQuery.fx.interval = 13;</p>

<p>jQuery.fx.start = function() {</p>

<pre>if ( !timerId ) {
        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
}</pre>

<p>};</p>

<p>jQuery.fx.stop = function() {</p>

<pre class="ruby"><span class="ruby-identifier">clearInterval</span>( <span class="ruby-identifier">timerId</span> );
<span class="ruby-identifier">timerId</span> = <span class="ruby-identifier">null</span>;
</pre>

<p>};</p>

<p>jQuery.fx.speeds = {</p>

<pre>slow: 600,
fast: 200,
// Default speed
_default: 400</pre>

<p>};</p>

<p>// Based off of the plugin by Clint Helfers, with permission. // <a
href="http://blindsignals.com/index.php/2009/07/jquery-delay">blindsignals.com/index.php/2009/07/jquery-delay</a>/
jQuery.fn.delay = function( time, type ) {</p>

<pre>time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
type = type || &quot;fx&quot;;

return this.queue( type, function( next, hooks ) {
        var timeout = setTimeout( next, time );
        hooks.stop = function() {
                clearTimeout( timeout );
        };
});</pre>

<p>};</p>

<p>(function() {</p>

<pre>// Minified: var a,b,c,d,e
var input, div, select, a, opt;

// Setup
div = document.createElement( &quot;div&quot; );
div.setAttribute( &quot;className&quot;, &quot;t&quot; );
div.innerHTML = &quot;  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href=&#39;/a&#39;&gt;a&lt;/a&gt;&lt;input type=&#39;checkbox&#39;/&gt;&quot;;
a = div.getElementsByTagName(&quot;a&quot;)[ 0 ];

// First batch of tests.
select = document.createElement(&quot;select&quot;);
opt = select.appendChild( document.createElement(&quot;option&quot;) );
input = div.getElementsByTagName(&quot;input&quot;)[ 0 ];

a.style.cssText = &quot;top:1px&quot;;

// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
support.getSetAttribute = div.className !== &quot;t&quot;;

// Get the style information from getAttribute
// (IE uses .cssText instead)
support.style = /top/.test( a.getAttribute(&quot;style&quot;) );

// Make sure that URLs aren&#39;t manipulated
// (IE normalizes it by default)
support.hrefNormalized = a.getAttribute(&quot;href&quot;) === &quot;/a&quot;;

// Check the default checkbox/radio value (&quot;&quot; on WebKit; &quot;on&quot; elsewhere)
support.checkOn = !!input.value;

// Make sure that a selected-by-default option has a working selected property.
// (WebKit defaults to false instead of true, IE too, if it&#39;s in an optgroup)
support.optSelected = opt.selected;

// Tests for enctype support on a form (#6743)
support.enctype = !!document.createElement(&quot;form&quot;).enctype;

// Make sure that the options inside disabled selects aren&#39;t marked as disabled
// (WebKit marks them as disabled)
select.disabled = true;
support.optDisabled = !opt.disabled;

// Support: IE8 only
// Check if we can trust getAttribute(&quot;value&quot;)
input = document.createElement( &quot;input&quot; );
input.setAttribute( &quot;value&quot;, &quot;&quot; );
support.input = input.getAttribute( &quot;value&quot; ) === &quot;&quot;;

// Check if an input maintains its value after becoming a radio
input.value = &quot;t&quot;;
input.setAttribute( &quot;type&quot;, &quot;radio&quot; );
support.radioValue = input.value === &quot;t&quot;;</pre>

<p>})();</p>

<p>var rreturn = /r/g;</p>

<p>jQuery.fn.extend({</p>

<pre>val: function( value ) {
        var hooks, ret, isFunction,
                elem = this[0];

        if ( !arguments.length ) {
                if ( elem ) {
                        hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                        if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, &quot;value&quot; )) !== undefined ) {
                                return ret;
                        }

                        ret = elem.value;

                        return typeof ret === &quot;string&quot; ?
                                // handle most common string cases
                                ret.replace(rreturn, &quot;&quot;) :
                                // handle cases where value is null/undef or number
                                ret == null ? &quot;&quot; : ret;
                }

                return;
        }

        isFunction = jQuery.isFunction( value );

        return this.each(function( i ) {
                var val;

                if ( this.nodeType !== 1 ) {
                        return;
                }

                if ( isFunction ) {
                        val = value.call( this, i, jQuery( this ).val() );
                } else {
                        val = value;
                }

                // Treat null/undefined as &quot;&quot;; convert numbers to string
                if ( val == null ) {
                        val = &quot;&quot;;
                } else if ( typeof val === &quot;number&quot; ) {
                        val += &quot;&quot;;
                } else if ( jQuery.isArray( val ) ) {
                        val = jQuery.map( val, function( value ) {
                                return value == null ? &quot;&quot; : value + &quot;&quot;;
                        });
                }

                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                // If set returns undefined, fall back to normal setting
                if ( !hooks || !(&quot;set&quot; in hooks) || hooks.set( this, val, &quot;value&quot; ) === undefined ) {
                        this.value = val;
                }
        });
}</pre>

<p>});</p>

<p>jQuery.extend({</p>

<pre>valHooks: {
        option: {
                get: function( elem ) {
                        var val = jQuery.find.attr( elem, &quot;value&quot; );
                        return val != null ?
                                val :
                                // Support: IE10-11+
                                // option.text throws exceptions (#14686, #14858)
                                jQuery.trim( jQuery.text( elem ) );
                }
        },
        select: {
                get: function( elem ) {
                        var value, option,
                                options = elem.options,
                                index = elem.selectedIndex,
                                one = elem.type === &quot;select-one&quot; || index &lt; 0,
                                values = one ? null : [],
                                max = one ? index + 1 : options.length,
                                i = index &lt; 0 ?
                                        max :
                                        one ? index : 0;

                        // Loop through all the selected options
                        for ( ; i &lt; max; i++ ) {
                                option = options[ i ];

                                // oldIE doesn&#39;t update selected after form reset (#2551)
                                if ( ( option.selected || i === index ) &amp;&amp;
                                                // Don&#39;t return options that are disabled or in a disabled optgroup
                                                ( support.optDisabled ? !option.disabled : option.getAttribute(&quot;disabled&quot;) === null ) &amp;&amp;
                                                ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, &quot;optgroup&quot; ) ) ) {

                                        // Get the specific value for the option
                                        value = jQuery( option ).val();

                                        // We don&#39;t need an array for one selects
                                        if ( one ) {
                                                return value;
                                        }

                                        // Multi-Selects return an array
                                        values.push( value );
                                }
                        }

                        return values;
                },

                set: function( elem, value ) {
                        var optionSet, option,
                                options = elem.options,
                                values = jQuery.makeArray( value ),
                                i = options.length;

                        while ( i-- ) {
                                option = options[ i ];

                                if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) &gt;= 0 ) {

                                        // Support: IE6
                                        // When new option element is added to select box we need to
                                        // force reflow of newly added node in order to workaround delay
                                        // of initialization properties
                                        try {
                                                option.selected = optionSet = true;

                                        } catch ( _ ) {

                                                // Will be executed only in IE6
                                                option.scrollHeight;
                                        }

                                } else {
                                        option.selected = false;
                                }
                        }

                        // Force browsers to behave consistently when non-matching value is set
                        if ( !optionSet ) {
                                elem.selectedIndex = -1;
                        }

                        return options;
                }
        }
}</pre>

<p>});</p>

<p>// Radios and checkboxes getter/setter jQuery.each([ radio, checkbox ],
function() {</p>

<pre>jQuery.valHooks[ this ] = {
        set: function( elem, value ) {
                if ( jQuery.isArray( value ) ) {
                        return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) &gt;= 0 );
                }
        }
};
if ( !support.checkOn ) {
        jQuery.valHooks[ this ].get = function( elem ) {
                // Support: Webkit
                // &quot;&quot; is returned instead of &quot;on&quot; if a value isn&#39;t specified
                return elem.getAttribute(&quot;value&quot;) === null ? &quot;on&quot; : elem.value;
        };
}</pre>

<p>});</p>

<p>var nodeHook, boolHook,</p>

<pre class="ruby"><span class="ruby-identifier">attrHandle</span> = <span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">expr</span>.<span class="ruby-identifier">attrHandle</span>,
<span class="ruby-identifier">ruseDefault</span> = <span class="ruby-regexp">/^(?:checked|selected)$/i</span>,
<span class="ruby-identifier">getSetAttribute</span> = <span class="ruby-identifier">support</span>.<span class="ruby-identifier">getSetAttribute</span>,
<span class="ruby-identifier">getSetInput</span> = <span class="ruby-identifier">support</span>.<span class="ruby-identifier">input</span>;
</pre>

<p>jQuery.fn.extend({</p>

<pre>attr: function( name, value ) {
        return access( this, jQuery.attr, name, value, arguments.length &gt; 1 );
},

removeAttr: function( name ) {
        return this.each(function() {
                jQuery.removeAttr( this, name );
        });
}</pre>

<p>});</p>

<p>jQuery.extend({</p>

<pre>attr: function( elem, name, value ) {
        var hooks, ret,
                nType = elem.nodeType;

        // don&#39;t get/set attributes on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
        }

        // Fallback to prop when attributes are not supported
        if ( typeof elem.getAttribute === strundefined ) {
                return jQuery.prop( elem, name, value );
        }

        // All attributes are lowercase
        // Grab necessary hook if one is defined
        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[ name ] ||
                        ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
        }

        if ( value !== undefined ) {

                if ( value === null ) {
                        jQuery.removeAttr( elem, name );

                } else if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {
                        return ret;

                } else {
                        elem.setAttribute( name, value + &quot;&quot; );
                        return value;
                }

        } else if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ) {
                return ret;

        } else {
                ret = jQuery.find.attr( elem, name );

                // Non-existent attributes return null, we normalize to undefined
                return ret == null ?
                        undefined :
                        ret;
        }
},

removeAttr: function( elem, value ) {
        var name, propName,
                i = 0,
                attrNames = value &amp;&amp; value.match( rnotwhite );

        if ( attrNames &amp;&amp; elem.nodeType === 1 ) {
                while ( (name = attrNames[i++]) ) {
                        propName = jQuery.propFix[ name ] || name;

                        // Boolean attributes get special treatment (#10870)
                        if ( jQuery.expr.match.bool.test( name ) ) {
                                // Set corresponding property to false
                                if ( getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ) {
                                        elem[ propName ] = false;
                                // Support: IE&lt;9
                                // Also clear defaultChecked/defaultSelected (if appropriate)
                                } else {
                                        elem[ jQuery.camelCase( &quot;default-&quot; + name ) ] =
                                                elem[ propName ] = false;
                                }

                        // See #9699 for explanation of this approach (setting first, then removal)
                        } else {
                                jQuery.attr( elem, name, &quot;&quot; );
                        }

                        elem.removeAttribute( getSetAttribute ? name : propName );
                }
        }
},

attrHooks: {
        type: {
                set: function( elem, value ) {
                        if ( !support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp; jQuery.nodeName(elem, &quot;input&quot;) ) {
                                // Setting the type on a radio button after the value resets the value in IE6-9
                                // Reset value to default in case type is set after value during creation
                                var val = elem.value;
                                elem.setAttribute( &quot;type&quot;, value );
                                if ( val ) {
                                        elem.value = val;
                                }
                                return value;
                        }
                }
        }
}</pre>

<p>});</p>

<p>// Hook for boolean attributes boolHook = {</p>

<pre>set: function( elem, value, name ) {
        if ( value === false ) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr( elem, name );
        } else if ( getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ) {
                // IE&lt;8 needs the *property* name
                elem.setAttribute( !getSetAttribute &amp;&amp; jQuery.propFix[ name ] || name, name );

        // Use defaultChecked and defaultSelected for oldIE
        } else {
                elem[ jQuery.camelCase( &quot;default-&quot; + name ) ] = elem[ name ] = true;
        }

        return name;
}</pre>

<p>};</p>

<p>// Retrieve booleans specially jQuery.each(
jQuery.expr.match.bool.source.match( /w+/g ), function( i, name ) {</p>

<pre>var getter = attrHandle[ name ] || jQuery.find.attr;

attrHandle[ name ] = getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ?
        function( elem, name, isXML ) {
                var ret, handle;
                if ( !isXML ) {
                        // Avoid an infinite loop by temporarily removing this function from the getter
                        handle = attrHandle[ name ];
                        attrHandle[ name ] = ret;
                        ret = getter( elem, name, isXML ) != null ?
                                name.toLowerCase() :
                                null;
                        attrHandle[ name ] = handle;
                }
                return ret;
        } :
        function( elem, name, isXML ) {
                if ( !isXML ) {
                        return elem[ jQuery.camelCase( &quot;default-&quot; + name ) ] ?
                                name.toLowerCase() :
                                null;
                }
        };</pre>

<p>});</p>

<p>// fix oldIE attroperties if ( !getSetInput || !getSetAttribute ) {</p>

<pre>jQuery.attrHooks.value = {
        set: function( elem, value, name ) {
                if ( jQuery.nodeName( elem, &quot;input&quot; ) ) {
                        // Does not return so that setAttribute is also used
                        elem.defaultValue = value;
                } else {
                        // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                        return nodeHook &amp;&amp; nodeHook.set( elem, value, name );
                }
        }
};</pre>

<p>}</p>

<p>// IE6/7 do not support getting/setting some attributes with
get/setAttribute if ( !getSetAttribute ) {</p>

<pre>// Use this for any attribute in IE6/7
// This fixes almost every IE6/7 issue
nodeHook = {
        set: function( elem, value, name ) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode( name );
                if ( !ret ) {
                        elem.setAttributeNode(
                                (ret = elem.ownerDocument.createAttribute( name ))
                        );
                }

                ret.value = value += &quot;&quot;;

                // Break association with cloned elements by also using setAttribute (#9646)
                if ( name === &quot;value&quot; || value === elem.getAttribute( name ) ) {
                        return value;
                }
        }
};

// Some attributes are constructed with empty-string values when not defined
attrHandle.id = attrHandle.name = attrHandle.coords =
        function( elem, name, isXML ) {
                var ret;
                if ( !isXML ) {
                        return (ret = elem.getAttributeNode( name )) &amp;&amp; ret.value !== &quot;&quot; ?
                                ret.value :
                                null;
                }
        };

// Fixing value retrieval on a button requires this module
jQuery.valHooks.button = {
        get: function( elem, name ) {
                var ret = elem.getAttributeNode( name );
                if ( ret &amp;&amp; ret.specified ) {
                        return ret.value;
                }
        },
        set: nodeHook.set
};

// Set contenteditable to false on removals(#10429)
// Setting to empty string throws an error as an invalid value
jQuery.attrHooks.contenteditable = {
        set: function( elem, value, name ) {
                nodeHook.set( elem, value === &quot;&quot; ? false : value, name );
        }
};

// Set width and height to auto instead of 0 on empty string( Bug #8150 )
// This is for removals
jQuery.each([ &quot;width&quot;, &quot;height&quot; ], function( i, name ) {
        jQuery.attrHooks[ name ] = {
                set: function( elem, value ) {
                        if ( value === &quot;&quot; ) {
                                elem.setAttribute( name, &quot;auto&quot; );
                                return value;
                        }
                }
        };
});</pre>

<p>}</p>

<p>if ( !support.style ) {</p>

<pre>jQuery.attrHooks.style = {
        get: function( elem ) {
                // Return undefined in the case of empty string
                // Note: IE uppercases css property names, but if we were to .toLowerCase()
                // .cssText, that would destroy case senstitivity in URL&#39;s, like in &quot;background&quot;
                return elem.style.cssText || undefined;
        },
        set: function( elem, value ) {
                return ( elem.style.cssText = value + &quot;&quot; );
        }
};</pre>

<p>}</p>

<p>var rfocusable = /^(?:input|select|textarea|button|object)$/i,</p>

<pre class="ruby"><span class="ruby-identifier">rclickable</span> = <span class="ruby-regexp">/^(?:a|area)$/i</span>;
</pre>

<p>jQuery.fn.extend({</p>

<pre>prop: function( name, value ) {
        return access( this, jQuery.prop, name, value, arguments.length &gt; 1 );
},

removeProp: function( name ) {
        name = jQuery.propFix[ name ] || name;
        return this.each(function() {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                        this[ name ] = undefined;
                        delete this[ name ];
                } catch( e ) {}
        });
}</pre>

<p>});</p>

<p>jQuery.extend({</p>

<pre>propFix: {
        &quot;for&quot;: &quot;htmlFor&quot;,
        &quot;class&quot;: &quot;className&quot;
},

prop: function( elem, name, value ) {
        var ret, hooks, notxml,
                nType = elem.nodeType;

        // don&#39;t get/set properties on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
        }

        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

        if ( notxml ) {
                // Fix name and attach hooks
                name = jQuery.propFix[ name ] || name;
                hooks = jQuery.propHooks[ name ];
        }

        if ( value !== undefined ) {
                return hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ?
                        ret :
                        ( elem[ name ] = value );

        } else {
                return hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ?
                        ret :
                        elem[ name ];
        }
},

propHooks: {
        tabIndex: {
                get: function( elem ) {
                        // elem.tabIndex doesn&#39;t always return the correct value when it hasn&#39;t been explicitly set
                        // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                        // Use proper attribute retrieval(#12072)
                        var tabindex = jQuery.find.attr( elem, &quot;tabindex&quot; );

                        return tabindex ?
                                parseInt( tabindex, 10 ) :
                                rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) &amp;&amp; elem.href ?
                                        0 :
                                        -1;
                }
        }
}</pre>

<p>});</p>

<p>// Some attributes require a special call on IE // <a
href="http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx">msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</a>
if ( !support.hrefNormalized ) {</p>

<pre>// href/src property should get the full normalized URL (#10299/#12915)
jQuery.each([ &quot;href&quot;, &quot;src&quot; ], function( i, name ) {
        jQuery.propHooks[ name ] = {
                get: function( elem ) {
                        return elem.getAttribute( name, 4 );
                }
        };
});</pre>

<p>}</p>

<p>// Support: Safari, IE9+ // mis-reports the default selected property of an
option // Accessing the parent&#39;s selectedIndex property fixes it if (
!support.optSelected ) {</p>

<pre>jQuery.propHooks.selected = {
        get: function( elem ) {
                var parent = elem.parentNode;

                if ( parent ) {
                        parent.selectedIndex;

                        // Make sure that it also works with optgroups, see #5701
                        if ( parent.parentNode ) {
                                parent.parentNode.selectedIndex;
                        }
                }
                return null;
        }
};</pre>

<p>}</p>

<p>jQuery.each([</p>

<pre>&quot;tabIndex&quot;,
&quot;readOnly&quot;,
&quot;maxLength&quot;,
&quot;cellSpacing&quot;,
&quot;cellPadding&quot;,
&quot;rowSpan&quot;,
&quot;colSpan&quot;,
&quot;useMap&quot;,
&quot;frameBorder&quot;,
&quot;contentEditable&quot;</pre>

<p>], function() {</p>

<pre class="ruby"><span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">propFix</span>[ <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toLowerCase</span>() ] = <span class="ruby-identifier">this</span>;
</pre>

<p>});</p>

<p>// IE6/7 call enctype encoding if ( !support.enctype ) {</p>

<pre class="ruby"><span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">propFix</span>.<span class="ruby-identifier">enctype</span> = <span class="ruby-string">&quot;encoding&quot;</span>;
</pre>

<p>}</p>

<p>var rclass = /[trnf]/g;</p>

<p>jQuery.fn.extend({</p>

<pre>addClass: function( value ) {
        var classes, elem, cur, clazz, j, finalValue,
                i = 0,
                len = this.length,
                proceed = typeof value === &quot;string&quot; &amp;&amp; value;

        if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                        jQuery( this ).addClass( value.call( this, j, this.className ) );
                });
        }

        if ( proceed ) {
                // The disjunction here is for better compressibility (see removeClass)
                classes = ( value || &quot;&quot; ).match( rnotwhite ) || [];

                for ( ; i &lt; len; i++ ) {
                        elem = this[ i ];
                        cur = elem.nodeType === 1 &amp;&amp; ( elem.className ?
                                ( &quot; &quot; + elem.className + &quot; &quot; ).replace( rclass, &quot; &quot; ) :
                                &quot; &quot;
                        );

                        if ( cur ) {
                                j = 0;
                                while ( (clazz = classes[j++]) ) {
                                        if ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &lt; 0 ) {
                                                cur += clazz + &quot; &quot;;
                                        }
                                }

                                // only assign if different to avoid unneeded rendering.
                                finalValue = jQuery.trim( cur );
                                if ( elem.className !== finalValue ) {
                                        elem.className = finalValue;
                                }
                        }
                }
        }

        return this;
},

removeClass: function( value ) {
        var classes, elem, cur, clazz, j, finalValue,
                i = 0,
                len = this.length,
                proceed = arguments.length === 0 || typeof value === &quot;string&quot; &amp;&amp; value;

        if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                        jQuery( this ).removeClass( value.call( this, j, this.className ) );
                });
        }
        if ( proceed ) {
                classes = ( value || &quot;&quot; ).match( rnotwhite ) || [];

                for ( ; i &lt; len; i++ ) {
                        elem = this[ i ];
                        // This expression is here for better compressibility (see addClass)
                        cur = elem.nodeType === 1 &amp;&amp; ( elem.className ?
                                ( &quot; &quot; + elem.className + &quot; &quot; ).replace( rclass, &quot; &quot; ) :
                                &quot;&quot;
                        );

                        if ( cur ) {
                                j = 0;
                                while ( (clazz = classes[j++]) ) {
                                        // Remove *all* instances
                                        while ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &gt;= 0 ) {
                                                cur = cur.replace( &quot; &quot; + clazz + &quot; &quot;, &quot; &quot; );
                                        }
                                }

                                // only assign if different to avoid unneeded rendering.
                                finalValue = value ? jQuery.trim( cur ) : &quot;&quot;;
                                if ( elem.className !== finalValue ) {
                                        elem.className = finalValue;
                                }
                        }
                }
        }

        return this;
},

toggleClass: function( value, stateVal ) {
        var type = typeof value;

        if ( typeof stateVal === &quot;boolean&quot; &amp;&amp; type === &quot;string&quot; ) {
                return stateVal ? this.addClass( value ) : this.removeClass( value );
        }

        if ( jQuery.isFunction( value ) ) {
                return this.each(function( i ) {
                        jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
                });
        }

        return this.each(function() {
                if ( type === &quot;string&quot; ) {
                        // toggle individual class names
                        var className,
                                i = 0,
                                self = jQuery( this ),
                                classNames = value.match( rnotwhite ) || [];

                        while ( (className = classNames[ i++ ]) ) {
                                // check each className given, space separated list
                                if ( self.hasClass( className ) ) {
                                        self.removeClass( className );
                                } else {
                                        self.addClass( className );
                                }
                        }

                // Toggle whole class name
                } else if ( type === strundefined || type === &quot;boolean&quot; ) {
                        if ( this.className ) {
                                // store className if set
                                jQuery._data( this, &quot;__className__&quot;, this.className );
                        }

                        // If the element has a class name or if we&#39;re passed &quot;false&quot;,
                        // then remove the whole classname (if there was one, the above saved it).
                        // Otherwise bring back whatever was previously saved (if anything),
                        // falling back to the empty string if nothing was stored.
                        this.className = this.className || value === false ? &quot;&quot; : jQuery._data( this, &quot;__className__&quot; ) || &quot;&quot;;
                }
        });
},

hasClass: function( selector ) {
        var className = &quot; &quot; + selector + &quot; &quot;,
                i = 0,
                l = this.length;
        for ( ; i &lt; l; i++ ) {
                if ( this[i].nodeType === 1 &amp;&amp; (&quot; &quot; + this[i].className + &quot; &quot;).replace(rclass, &quot; &quot;).indexOf( className ) &gt;= 0 ) {
                        return true;
                }
        }

        return false;
}</pre>

<p>});</p>

<p>// Return jQuery for attributes-only inclusion</p>

<p>jQuery.each( (blur focus focusin focusout load resize scroll unload click
dblclick  +</p>

<pre>&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
&quot;change select submit keydown keypress keyup error contextmenu&quot;).split(&quot; &quot;), function( i, name ) {

// Handle event binding
jQuery.fn[ name ] = function( data, fn ) {
        return arguments.length &gt; 0 ?
                this.on( name, null, data, fn ) :
                this.trigger( name );
};</pre>

<p>});</p>

<p>jQuery.fn.extend({</p>

<pre>hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
},

bind: function( types, data, fn ) {
        return this.on( types, null, data, fn );
},
unbind: function( types, fn ) {
        return this.off( types, null, fn );
},

delegate: function( selector, types, data, fn ) {
        return this.on( types, selector, data, fn );
},
undelegate: function( selector, types, fn ) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off( selector, &quot;**&quot; ) : this.off( types, selector || &quot;**&quot;, fn );
}</pre>

<p>});</p>

<p>var nonce = jQuery.now();</p>

<p>var rquery = (/?/);</p>

<p>var rvalidtokens = /(,)|([|{)|(}|])|(?:[^\<a
href=\/bfnrt>rn]|\</a>|\<a href="\da-fA-F">u</a>{4})*<a
href=eE>s*:?|true|false|null|-?(?!0d)d+(?:.d+|)(?:</a>[+-]?d+|)/g;</p>

<p>jQuery.parseJSON = function( data ) {</p>

<pre>// Attempt to parse using the native JSON parser first
if ( window.JSON &amp;&amp; window.JSON.parse ) {
        // Support: Android 2.3
        // Workaround failure to string-cast null input
        return window.JSON.parse( data + &quot;&quot; );
}

var requireNonComma,
        depth = null,
        str = jQuery.trim( data + &quot;&quot; );

// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
// after removing valid tokens
return str &amp;&amp; !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

        // Force termination if we see a misplaced comma
        if ( requireNonComma &amp;&amp; comma ) {
                depth = 0;
        }

        // Perform no more replacements after returning to outermost depth
        if ( depth === 0 ) {
                return token;
        }

        // Commas must not follow &quot;[&quot;, &quot;{&quot;, or &quot;,&quot;
        requireNonComma = open || comma;

        // Determine new depth
        // array/object open (&quot;[&quot; or &quot;{&quot;): depth += true - false (increment)
        // array/object close (&quot;]&quot; or &quot;}&quot;): depth += false - true (decrement)
        // other cases (&quot;,&quot; or primitive): depth += true - true (numeric cast)
        depth += !close - !open;

        // Remove this token
        return &quot;&quot;;
}) ) ?
        ( Function( &quot;return &quot; + str ) )() :
        jQuery.error( &quot;Invalid JSON: &quot; + data );</pre>

<p>};</p>

<p>// Cross-browser xml parsing jQuery.parseXML = function( data ) {</p>

<pre>var xml, tmp;
if ( !data || typeof data !== &quot;string&quot; ) {
        return null;
}
try {
        if ( window.DOMParser ) { // Standard
                tmp = new DOMParser();
                xml = tmp.parseFromString( data, &quot;text/xml&quot; );
        } else { // IE
                xml = new ActiveXObject( &quot;Microsoft.XMLDOM&quot; );
                xml.async = &quot;false&quot;;
                xml.loadXML( data );
        }
} catch( e ) {
        xml = undefined;
}
if ( !xml || !xml.documentElement || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
        jQuery.error( &quot;Invalid XML: &quot; + data );
}
return xml;</pre>

<p>};</p>

<p>var</p>

<pre>     // Document location
     ajaxLocParts,
     ajaxLocation,

     rhash = /#.*$/,
     rts = /([?&amp;])_=[^&amp;]*/,
     rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
     // #7653, #8125, #8152: local protocol detection
     rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
     rnoContent = /^(?:GET|HEAD)$/,
     rprotocol = /^\/\//,
     rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

     /* Prefilters
 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
 2) These are called:
    - BEFORE asking for a transport
    - AFTER param serialization (s.data is a string if s.processData is true)
 3) key is the dataType
 4) the catchall symbol &quot;*&quot; can be used
 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed
/
     prefilters = {},

     /* Transports bindings
 1) key is the dataType
 2) the catchall symbol &quot;*&quot; can be used
 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed
/
     transports = {},

     // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
     allTypes = &quot;*/&quot;.concat(&quot;*&quot;);</pre>

<p>// #8138, IE may throw an exception when accessing // a field from
window.location if document.domain has been set try {</p>

<pre class="ruby"><span class="ruby-identifier">ajaxLocation</span> = <span class="ruby-identifier">location</span>.<span class="ruby-identifier">href</span>;
</pre>

<p>} catch( e ) {</p>

<pre>// Use the href attribute of an A element
// since IE will modify it given document.location
ajaxLocation = document.createElement( &quot;a&quot; );
ajaxLocation.href = &quot;&quot;;
ajaxLocation = ajaxLocation.href;</pre>

<p>}</p>

<p>// Segment location into parts ajaxLocParts = rurl.exec(
ajaxLocation.toLowerCase() ) || [];</p>

<p>// Base constructor for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {</p>

<pre>// dataTypeExpression is optional and defaults to &quot;*&quot;
return function( dataTypeExpression, func ) {

        if ( typeof dataTypeExpression !== &quot;string&quot; ) {
                func = dataTypeExpression;
                dataTypeExpression = &quot;*&quot;;
        }

        var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

        if ( jQuery.isFunction( func ) ) {
                // For each dataType in the dataTypeExpression
                while ( (dataType = dataTypes[i++]) ) {
                        // Prepend if requested
                        if ( dataType.charAt( 0 ) === &quot;+&quot; ) {
                                dataType = dataType.slice( 1 ) || &quot;*&quot;;
                                (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                        // Otherwise append
                        } else {
                                (structure[ dataType ] = structure[ dataType ] || []).push( func );
                        }
                }
        }
};</pre>

<p>}</p>

<p>// Base inspection function for prefilters and transports function
inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR )
{</p>

<pre>var inspected = {},
        seekingTransport = ( structure === transports );

function inspect( dataType ) {
        var selected;
        inspected[ dataType ] = true;
        jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                if ( typeof dataTypeOrTransport === &quot;string&quot; &amp;&amp; !seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {
                        options.dataTypes.unshift( dataTypeOrTransport );
                        inspect( dataTypeOrTransport );
                        return false;
                } else if ( seekingTransport ) {
                        return !( selected = dataTypeOrTransport );
                }
        });
        return selected;
}

return inspect( options.dataTypes[ 0 ] ) || !inspected[ &quot;*&quot; ] &amp;&amp; inspect( &quot;*&quot; );</pre>

<p>}</p>

<p>// A special extend for ajax options // that takes flat options (not to
be deep extended) // Fixes #9887 function ajaxExtend( target, src ) {</p>

<pre>var deep, key,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

for ( key in src ) {
        if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
        }
}
if ( deep ) {
        jQuery.extend( true, target, deep );
}

return target;</pre>

<p>}</p>

<p>/* Handles responses to an ajax request:</p>

<pre> - finds the right dataType (mediates between content-type and expected dataType)
 - returns the corresponding response
/</pre>

<p>function ajaxHandleResponses( s, jqXHR, responses ) {</p>

<pre>var firstDataType, ct, finalDataType, type,
        contents = s.contents,
        dataTypes = s.dataTypes;

// Remove auto dataType and get content-type in the process
while ( dataTypes[ 0 ] === &quot;*&quot; ) {
        dataTypes.shift();
        if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader(&quot;Content-Type&quot;);
        }
}

// Check if we&#39;re dealing with a known content-type
if ( ct ) {
        for ( type in contents ) {
                if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
                        dataTypes.unshift( type );
                        break;
                }
        }
}

// Check to see if we have a response for the expected dataType
if ( dataTypes[ 0 ] in responses ) {
        finalDataType = dataTypes[ 0 ];
} else {
        // Try convertible dataTypes
        for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[0] ] ) {
                        finalDataType = type;
                        break;
                }
                if ( !firstDataType ) {
                        firstDataType = type;
                }
        }
        // Or just use first one
        finalDataType = finalDataType || firstDataType;
}

// If we found a dataType
// We add the dataType to the list if needed
// and return the corresponding response
if ( finalDataType ) {
        if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
        }
        return responses[ finalDataType ];
}</pre>

<p>}</p>

<p>/* Chain conversions given the request and the original response</p>

<pre> Also sets the responseXXX fields on the jqXHR instance
/</pre>

<p>function ajaxConvert( s, response, jqXHR, isSuccess ) {</p>

<pre>var conv2, current, conv, tmp, prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();

// Create converters map with lowercased keys
if ( dataTypes[ 1 ] ) {
        for ( conv in s.converters ) {
                converters[ conv.toLowerCase() ] = s.converters[ conv ];
        }
}

current = dataTypes.shift();

// Convert to each sequential dataType
while ( current ) {

        if ( s.responseFields[ current ] ) {
                jqXHR[ s.responseFields[ current ] ] = response;
        }

        // Apply the dataFilter if provided
        if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {
                response = s.dataFilter( response, s.dataType );
        }

        prev = current;
        current = dataTypes.shift();

        if ( current ) {

                // There&#39;s only work to do if current dataType is non-auto
                if ( current === &quot;*&quot; ) {

                        current = prev;

                // Convert response if prev dataType is non-auto and differs from current
                } else if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) {

                        // Seek a direct converter
                        conv = converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ];

                        // If none found, seek a pair
                        if ( !conv ) {
                                for ( conv2 in converters ) {

                                        // If conv2 outputs current
                                        tmp = conv2.split( &quot; &quot; );
                                        if ( tmp[ 1 ] === current ) {

                                                // If prev can be converted to accepted input
                                                conv = converters[ prev + &quot; &quot; + tmp[ 0 ] ] ||
                                                        converters[ &quot;* &quot; + tmp[ 0 ] ];
                                                if ( conv ) {
                                                        // Condense equivalence converters
                                                        if ( conv === true ) {
                                                                conv = converters[ conv2 ];

                                                        // Otherwise, insert the intermediate dataType
                                                        } else if ( converters[ conv2 ] !== true ) {
                                                                current = tmp[ 0 ];
                                                                dataTypes.unshift( tmp[ 1 ] );
                                                        }
                                                        break;
                                                }
                                        }
                                }
                        }

                        // Apply converter (if not an equivalence)
                        if ( conv !== true ) {

                                // Unless errors are allowed to bubble, catch and return them
                                if ( conv &amp;&amp; s[ &quot;throws&quot; ] ) {
                                        response = conv( response );
                                } else {
                                        try {
                                                response = conv( response );
                                        } catch ( e ) {
                                                return { state: &quot;parsererror&quot;, error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current };
                                        }
                                }
                        }
                }
        }
}

return { state: &quot;success&quot;, data: response };</pre>

<p>}</p>

<p>jQuery.extend({</p>

<pre>     // Counter for holding the number of active queries
     active: 0,

     // Last-Modified header cache for next request
     lastModified: {},
     etag: {},

     ajaxSettings: {
             url: ajaxLocation,
             type: &quot;GET&quot;,
             isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
             global: true,
             processData: true,
             async: true,
             contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
             /*
             timeout: 0,
             data: null,
             dataType: null,
             username: null,
             password: null,
             cache: null,
             throws: false,
             traditional: false,
             headers: {},
/

             accepts: {
                     &quot;*&quot;: allTypes,
                     text: &quot;text/plain&quot;,
                     html: &quot;text/html&quot;,
                     xml: &quot;application/xml, text/xml&quot;,
                     json: &quot;application/json, text/javascript&quot;
             },

             contents: {
                     xml: /xml/,
                     html: /html/,
                     json: /json/
             },

             responseFields: {
                     xml: &quot;responseXML&quot;,
                     text: &quot;responseText&quot;,
                     json: &quot;responseJSON&quot;
             },

             // Data converters
             // Keys separate source (or catchall &quot;*&quot;) and destination types with a single space
             converters: {

                     // Convert anything to text
                     &quot;* text&quot;: String,

                     // Text to html (true = no transformation)
                     &quot;text html&quot;: true,

                     // Evaluate text as a json expression
                     &quot;text json&quot;: jQuery.parseJSON,

                     // Parse text as xml
                     &quot;text xml&quot;: jQuery.parseXML
             },

             // For options that shouldn&#39;t be deep extended:
             // you can add your own custom options here if
             // and when you create one that shouldn&#39;t be
             // deep extended (see ajaxExtend)
             flatOptions: {
                     url: true,
                     context: true
             }
     },

     // Creates a full fledged settings object into target
     // with both ajaxSettings and settings fields.
     // If target is omitted, writes into ajaxSettings.
     ajaxSetup: function( target, settings ) {
             return settings ?

                     // Building a settings object
                     ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

                     // Extending ajaxSettings
                     ajaxExtend( jQuery.ajaxSettings, target );
     },

     ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
     ajaxTransport: addToPrefiltersOrTransports( transports ),

     // Main method
     ajax: function( url, options ) {

             // If url is an object, simulate pre-1.5 signature
             if ( typeof url === &quot;object&quot; ) {
                     options = url;
                     url = undefined;
             }

             // Force options to be an object
             options = options || {};

             var // Cross-domain detection vars
                     parts,
                     // Loop variable
                     i,
                     // URL without anti-cache param
                     cacheURL,
                     // Response headers as string
                     responseHeadersString,
                     // timeout handle
                     timeoutTimer,

                     // To know if global events are to be dispatched
                     fireGlobals,

                     transport,
                     // Response headers
                     responseHeaders,
                     // Create the final options object
                     s = jQuery.ajaxSetup( {}, options ),
                     // Callbacks context
                     callbackContext = s.context || s,
                     // Context for global events is callbackContext if it is a DOM node or jQuery collection
                     globalEventContext = s.context &amp;&amp; ( callbackContext.nodeType || callbackContext.jquery ) ?
                             jQuery( callbackContext ) :
                             jQuery.event,
                     // Deferreds
                     deferred = jQuery.Deferred(),
                     completeDeferred = jQuery.Callbacks(&quot;once memory&quot;),
                     // Status-dependent callbacks
                     statusCode = s.statusCode || {},
                     // Headers (they are sent all at once)
                     requestHeaders = {},
                     requestHeadersNames = {},
                     // The jqXHR state
                     state = 0,
                     // Default abort message
                     strAbort = &quot;canceled&quot;,
                     // Fake xhr
                     jqXHR = {
                             readyState: 0,

                             // Builds headers hashtable if needed
                             getResponseHeader: function( key ) {
                                     var match;
                                     if ( state === 2 ) {
                                             if ( !responseHeaders ) {
                                                     responseHeaders = {};
                                                     while ( (match = rheaders.exec( responseHeadersString )) ) {
                                                             responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                                     }
                                             }
                                             match = responseHeaders[ key.toLowerCase() ];
                                     }
                                     return match == null ? null : match;
                             },

                             // Raw string
                             getAllResponseHeaders: function() {
                                     return state === 2 ? responseHeadersString : null;
                             },

                             // Caches the header
                             setRequestHeader: function( name, value ) {
                                     var lname = name.toLowerCase();
                                     if ( !state ) {
                                             name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                                             requestHeaders[ name ] = value;
                                     }
                                     return this;
                             },

                             // Overrides response content-type header
                             overrideMimeType: function( type ) {
                                     if ( !state ) {
                                             s.mimeType = type;
                                     }
                                     return this;
                             },

                             // Status-dependent callbacks
                             statusCode: function( map ) {
                                     var code;
                                     if ( map ) {
                                             if ( state &lt; 2 ) {
                                                     for ( code in map ) {
                                                             // Lazy-add the new callback in a way that preserves old ones
                                                             statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                                     }
                                             } else {
                                                     // Execute the appropriate callbacks
                                                     jqXHR.always( map[ jqXHR.status ] );
                                             }
                                     }
                                     return this;
                             },

                             // Cancel the request
                             abort: function( statusText ) {
                                     var finalText = statusText || strAbort;
                                     if ( transport ) {
                                             transport.abort( finalText );
                                     }
                                     done( 0, finalText );
                                     return this;
                             }
                     };

             // Attach deferreds
             deferred.promise( jqXHR ).complete = completeDeferred.add;
             jqXHR.success = jqXHR.done;
             jqXHR.error = jqXHR.fail;

             // Remove hash character (#7531: and string promotion)
             // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
             // Handle falsy url in the settings object (#10093: consistency with old signature)
             // We also use the url parameter if available
             s.url = ( ( url || s.url || ajaxLocation ) + &quot;&quot; ).replace( rhash, &quot;&quot; ).replace( rprotocol, ajaxLocParts[ 1 ] + &quot;//&quot; );

             // Alias method option to type as per ticket #12004
             s.type = options.method || options.type || s.method || s.type;

             // Extract dataTypes list
             s.dataTypes = jQuery.trim( s.dataType || &quot;*&quot; ).toLowerCase().match( rnotwhite ) || [ &quot;&quot; ];

             // A cross-domain request is in order when we have a protocol:host:port mismatch
             if ( s.crossDomain == null ) {
                     parts = rurl.exec( s.url.toLowerCase() );
                     s.crossDomain = !!( parts &amp;&amp;
                             ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                                     ( parts[ 3 ] || ( parts[ 1 ] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot; ) ) !==
                                             ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot; ) ) )
                     );
             }

             // Convert data if not already a string
             if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) {
                     s.data = jQuery.param( s.data, s.traditional );
             }

             // Apply prefilters
             inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

             // If request was aborted inside a prefilter, stop there
             if ( state === 2 ) {
                     return jqXHR;
             }

             // We can fire global events as of now if asked to
             fireGlobals = s.global;

             // Watch for a new set of requests
             if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {
                     jQuery.event.trigger(&quot;ajaxStart&quot;);
             }

             // Uppercase the type
             s.type = s.type.toUpperCase();

             // Determine if request has content
             s.hasContent = !rnoContent.test( s.type );

             // Save the URL in case we&#39;re toying with the If-Modified-Since
             // and/or If-None-Match header later on
             cacheURL = s.url;

             // More options handling for requests with no content
             if ( !s.hasContent ) {

                     // If data is available, append data to url
                     if ( s.data ) {
                             cacheURL = ( s.url += ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data );
                             // #9682: remove data so that it&#39;s not used in an eventual retry
                             delete s.data;
                     }

                     // Add anti-cache in url if needed
                     if ( s.cache === false ) {
                             s.url = rts.test( cacheURL ) ?

                                     // If there is already a &#39;_&#39; parameter, set its value
                                     cacheURL.replace( rts, &quot;$1_=&quot; + nonce++ ) :

                                     // Otherwise add one to the end
                                     cacheURL + ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + nonce++;
                     }
             }

             // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
             if ( s.ifModified ) {
                     if ( jQuery.lastModified[ cacheURL ] ) {
                             jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ cacheURL ] );
                     }
                     if ( jQuery.etag[ cacheURL ] ) {
                             jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ cacheURL ] );
                     }
             }

             // Set the correct header, if data is being sent
             if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {
                     jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
             }

             // Set the Accepts header for the server, depending on the dataType
             jqXHR.setRequestHeader(
                     &quot;Accept&quot;,
                     s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ?
                             s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) :
                             s.accepts[ &quot;*&quot; ]
             );

             // Check for headers option
             for ( i in s.headers ) {
                     jqXHR.setRequestHeader( i, s.headers[ i ] );
             }

             // Allow custom headers/mimetypes and early abort
             if ( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                     // Abort if not done already and return
                     return jqXHR.abort();
             }

             // aborting is no longer a cancellation
             strAbort = &quot;abort&quot;;

             // Install callbacks on deferreds
             for ( i in { success: 1, error: 1, complete: 1 } ) {
                     jqXHR[ i ]( s[ i ] );
             }

             // Get transport
             transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

             // If no transport, we auto-abort
             if ( !transport ) {
                     done( -1, &quot;No Transport&quot; );
             } else {
                     jqXHR.readyState = 1;

                     // Send global event
                     if ( fireGlobals ) {
                             globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
                     }
                     // Timeout
                     if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
                             timeoutTimer = setTimeout(function() {
                                     jqXHR.abort(&quot;timeout&quot;);
                             }, s.timeout );
                     }

                     try {
                             state = 1;
                             transport.send( requestHeaders, done );
                     } catch ( e ) {
                             // Propagate exception as error if not done
                             if ( state &lt; 2 ) {
                                     done( -1, e );
                             // Simply rethrow otherwise
                             } else {
                                     throw e;
                             }
                     }
             }

             // Callback for when everything is done
             function done( status, nativeStatusText, responses, headers ) {
                     var isSuccess, success, error, response, modified,
                             statusText = nativeStatusText;

                     // Called once
                     if ( state === 2 ) {
                             return;
                     }

                     // State is &quot;done&quot; now
                     state = 2;

                     // Clear timeout if it exists
                     if ( timeoutTimer ) {
                             clearTimeout( timeoutTimer );
                     }

                     // Dereference transport for early garbage collection
                     // (no matter how long the jqXHR object will be used)
                     transport = undefined;

                     // Cache response headers
                     responseHeadersString = headers || &quot;&quot;;

                     // Set readyState
                     jqXHR.readyState = status &gt; 0 ? 4 : 0;

                     // Determine if successful
                     isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;

                     // Get response data
                     if ( responses ) {
                             response = ajaxHandleResponses( s, jqXHR, responses );
                     }

                     // Convert no matter what (that way responseXXX fields are always set)
                     response = ajaxConvert( s, response, jqXHR, isSuccess );

                     // If successful, handle type chaining
                     if ( isSuccess ) {

                             // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                             if ( s.ifModified ) {
                                     modified = jqXHR.getResponseHeader(&quot;Last-Modified&quot;);
                                     if ( modified ) {
                                             jQuery.lastModified[ cacheURL ] = modified;
                                     }
                                     modified = jqXHR.getResponseHeader(&quot;etag&quot;);
                                     if ( modified ) {
                                             jQuery.etag[ cacheURL ] = modified;
                                     }
                             }

                             // if no content
                             if ( status === 204 || s.type === &quot;HEAD&quot; ) {
                                     statusText = &quot;nocontent&quot;;

                             // if not modified
                             } else if ( status === 304 ) {
                                     statusText = &quot;notmodified&quot;;

                             // If we have data, let&#39;s convert it
                             } else {
                                     statusText = response.state;
                                     success = response.data;
                                     error = response.error;
                                     isSuccess = !error;
                             }
                     } else {
                             // We extract error from statusText
                             // then normalize statusText and status for non-aborts
                             error = statusText;
                             if ( status || !statusText ) {
                                     statusText = &quot;error&quot;;
                                     if ( status &lt; 0 ) {
                                             status = 0;
                                     }
                             }
                     }

                     // Set data for the fake xhr object
                     jqXHR.status = status;
                     jqXHR.statusText = ( nativeStatusText || statusText ) + &quot;&quot;;

                     // Success/Error
                     if ( isSuccess ) {
                             deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                     } else {
                             deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                     }

                     // Status-dependent callbacks
                     jqXHR.statusCode( statusCode );
                     statusCode = undefined;

                     if ( fireGlobals ) {
                             globalEventContext.trigger( isSuccess ? &quot;ajaxSuccess&quot; : &quot;ajaxError&quot;,
                                     [ jqXHR, s, isSuccess ? success : error ] );
                     }

                     // Complete
                     completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                     if ( fireGlobals ) {
                             globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );
                             // Handle the global AJAX counter
                             if ( !( --jQuery.active ) ) {
                                     jQuery.event.trigger(&quot;ajaxStop&quot;);
                             }
                     }
             }

             return jqXHR;
     },

     getJSON: function( url, data, callback ) {
             return jQuery.get( url, data, callback, &quot;json&quot; );
     },

     getScript: function( url, callback ) {
             return jQuery.get( url, undefined, callback, &quot;script&quot; );
     }</pre>

<p>});</p>

<p>jQuery.each( [ get, post ], function( i, method ) {</p>

<pre>jQuery[ method ] = function( url, data, callback, type ) {
        // shift arguments if data argument was omitted
        if ( jQuery.isFunction( data ) ) {
                type = type || callback;
                callback = data;
                data = undefined;
        }

        return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
        });
};</pre>

<p>});</p>

<p>// Attach a bunch of functions for handling common AJAX events jQuery.each(
[ ajaxStart, ajaxStop, ajaxComplete, ajaxError, ajaxSuccess,
ajaxSend ], function( i, type ) {</p>

<pre class="ruby"><span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">fn</span>[ <span class="ruby-identifier">type</span> ] = <span class="ruby-identifier">function</span>( <span class="ruby-identifier">fn</span> ) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">on</span>( <span class="ruby-identifier">type</span>, <span class="ruby-identifier">fn</span> );
};
</pre>

<p>});</p>

<p>jQuery._evalUrl = function( url ) {</p>

<pre>return jQuery.ajax({
        url: url,
        type: &quot;GET&quot;,
        dataType: &quot;script&quot;,
        async: false,
        global: false,
        &quot;throws&quot;: true
});</pre>

<p>};</p>

<p>jQuery.fn.extend({</p>

<pre>wrapAll: function( html ) {
        if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                        jQuery(this).wrapAll( html.call(this, i) );
                });
        }

        if ( this[0] ) {
                // The elements to wrap the target around
                var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

                if ( this[0].parentNode ) {
                        wrap.insertBefore( this[0] );
                }

                wrap.map(function() {
                        var elem = this;

                        while ( elem.firstChild &amp;&amp; elem.firstChild.nodeType === 1 ) {
                                elem = elem.firstChild;
                        }

                        return elem;
                }).append( this );
        }

        return this;
},

wrapInner: function( html ) {
        if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                        jQuery(this).wrapInner( html.call(this, i) );
                });
        }

        return this.each(function() {
                var self = jQuery( this ),
                        contents = self.contents();

                if ( contents.length ) {
                        contents.wrapAll( html );

                } else {
                        self.append( html );
                }
        });
},

wrap: function( html ) {
        var isFunction = jQuery.isFunction( html );

        return this.each(function(i) {
                jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
        });
},

unwrap: function() {
        return this.parent().each(function() {
                if ( !jQuery.nodeName( this, &quot;body&quot; ) ) {
                        jQuery( this ).replaceWith( this.childNodes );
                }
        }).end();
}</pre>

<p>});</p>

<p>jQuery.expr.filters.hidden = function( elem ) {</p>

<pre>// Support: Opera &lt;= 12.12
// Opera reports offsetWidths and offsetHeights less than zero on some elements
return elem.offsetWidth &lt;= 0 &amp;&amp; elem.offsetHeight &lt;= 0 ||
        (!support.reliableHiddenOffsets() &amp;&amp;
                ((elem.style &amp;&amp; elem.style.display) || jQuery.css( elem, &quot;display&quot; )) === &quot;none&quot;);</pre>

<p>};</p>

<p>jQuery.expr.filters.visible = function( elem ) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">expr</span>.<span class="ruby-identifier">filters</span>.<span class="ruby-identifier">hidden</span>( <span class="ruby-identifier">elem</span> );
</pre>

<p>};</p>

<p>var r20 = /%20/g,</p>

<pre>rbracket = /\[\]$/,
rCRLF = /\r?\n/g,
rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
rsubmittable = /^(?:input|select|textarea|keygen)/i;</pre>

<p>function buildParams( prefix, obj, traditional, add ) {</p>

<pre>var name;

if ( jQuery.isArray( obj ) ) {
        // Serialize array item.
        jQuery.each( obj, function( i, v ) {
                if ( traditional || rbracket.test( prefix ) ) {
                        // Treat each array item as a scalar.
                        add( prefix, v );

                } else {
                        // Item is non-scalar (array or object), encode its numeric index.
                        buildParams( prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; ? i : &quot;&quot; ) + &quot;]&quot;, v, traditional, add );
                }
        });

} else if ( !traditional &amp;&amp; jQuery.type( obj ) === &quot;object&quot; ) {
        // Serialize object item.
        for ( name in obj ) {
                buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
        }

} else {
        // Serialize scalar item.
        add( prefix, obj );
}</pre>

<p>}</p>

<p>// Serialize an array of form elements or a set of // key/values into a
query string jQuery.param = function( a, traditional ) {</p>

<pre>var prefix,
        s = [],
        add = function( key, value ) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction( value ) ? value() : ( value == null ? &quot;&quot; : value );
                s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; + encodeURIComponent( value );
        };

// Set traditional to true for jQuery &lt;= 1.3.2 behavior.
if ( traditional === undefined ) {
        traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional;
}

// If an array was passed in, assume that it is an array of form elements.
if ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {
        // Serialize the form elements
        jQuery.each( a, function() {
                add( this.name, this.value );
        });

} else {
        // If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( prefix in a ) {
                buildParams( prefix, a[ prefix ], traditional, add );
        }
}

// Return the resulting serialization
return s.join( &quot;&amp;&quot; ).replace( r20, &quot;+&quot; );</pre>

<p>};</p>

<p>jQuery.fn.extend({</p>

<pre>serialize: function() {
        return jQuery.param( this.serializeArray() );
},
serializeArray: function() {
        return this.map(function() {
                // Can add propHook for &quot;elements&quot; to filter or add form elements
                var elements = jQuery.prop( this, &quot;elements&quot; );
                return elements ? jQuery.makeArray( elements ) : this;
        })
        .filter(function() {
                var type = this.type;
                // Use .is(&quot;:disabled&quot;) so that fieldset[disabled] works
                return this.name &amp;&amp; !jQuery( this ).is( &quot;:disabled&quot; ) &amp;&amp;
                        rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;
                        ( this.checked || !rcheckableType.test( type ) );
        })
        .map(function( i, elem ) {
                var val = jQuery( this ).val();

                return val == null ?
                        null :
                        jQuery.isArray( val ) ?
                                jQuery.map( val, function( val ) {
                                        return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
                                }) :
                                { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
        }).get();
}</pre>

<p>});</p>

<p>// Create the request object // (This is still attached to ajaxSettings for
backward compatibility) jQuery.ajaxSettings.xhr = window.ActiveXObject !==
undefined ?</p>

<pre>// Support: IE6+
function() {

        // XHR cannot access local files, always use ActiveX for that case
        return !this.isLocal &amp;&amp;

                // Support: IE7-8
                // oldIE XHR does not support non-RFC2616 methods (#13240)
                // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
                // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
                // Although this check for six methods instead of eight
                // since IE also does not support &quot;trace&quot; and &quot;connect&quot;
                /^(get|post|head|put|delete|options)$/i.test( this.type ) &amp;&amp;

                createStandardXHR() || createActiveXHR();
} :
// For all other browsers, use the standard XMLHttpRequest object
createStandardXHR;</pre>

<p>var xhrId = 0,</p>

<pre class="ruby"><span class="ruby-identifier">xhrCallbacks</span> = {},
<span class="ruby-identifier">xhrSupported</span> = <span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">ajaxSettings</span>.<span class="ruby-identifier">xhr</span>();
</pre>

<p>// Support: IE&lt;10 // Open requests must be manually aborted on unload
(#5280) if ( window.ActiveXObject ) {</p>

<pre>jQuery( window ).on( &quot;unload&quot;, function() {
        for ( var key in xhrCallbacks ) {
                xhrCallbacks[ key ]( undefined, true );
        }
});</pre>

<p>}</p>

<p>// Determine support properties support.cors = !!xhrSupported &amp;&amp; (
withCredentials in xhrSupported ); xhrSupported = support.ajax =
!!xhrSupported;</p>

<p>// Create transport if the browser can provide an xhr if ( xhrSupported ) {</p>

<pre>jQuery.ajaxTransport(function( options ) {
        // Cross domain only allowed if supported through XMLHttpRequest
        if ( !options.crossDomain || support.cors ) {

                var callback;

                return {
                        send: function( headers, complete ) {
                                var i,
                                        xhr = options.xhr(),
                                        id = ++xhrId;

                                // Open the socket
                                xhr.open( options.type, options.url, options.async, options.username, options.password );

                                // Apply custom fields if provided
                                if ( options.xhrFields ) {
                                        for ( i in options.xhrFields ) {
                                                xhr[ i ] = options.xhrFields[ i ];
                                        }
                                }

                                // Override mime type if needed
                                if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {
                                        xhr.overrideMimeType( options.mimeType );
                                }

                                // X-Requested-With header
                                // For cross-domain requests, seeing as conditions for a preflight are
                                // akin to a jigsaw puzzle, we simply never set it to be sure.
                                // (it can always be set on a per-request basis or even using ajaxSetup)
                                // For same-domain requests, won&#39;t change header if already provided.
                                if ( !options.crossDomain &amp;&amp; !headers[&quot;X-Requested-With&quot;] ) {
                                        headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;
                                }

                                // Set headers
                                for ( i in headers ) {
                                        // Support: IE&lt;9
                                        // IE&#39;s ActiveXObject throws a &#39;Type Mismatch&#39; exception when setting
                                        // request header to a null-value.
                                        //
                                        // To keep consistent with other XHR implementations, cast the value
                                        // to string and ignore `undefined`.
                                        if ( headers[ i ] !== undefined ) {
                                                xhr.setRequestHeader( i, headers[ i ] + &quot;&quot; );
                                        }
                                }

                                // Do send the request
                                // This may raise an exception which is actually
                                // handled in jQuery.ajax (so no try/catch here)
                                xhr.send( ( options.hasContent &amp;&amp; options.data ) || null );

                                // Listener
                                callback = function( _, isAbort ) {
                                        var status, statusText, responses;

                                        // Was never called and is aborted or complete
                                        if ( callback &amp;&amp; ( isAbort || xhr.readyState === 4 ) ) {
                                                // Clean up
                                                delete xhrCallbacks[ id ];
                                                callback = undefined;
                                                xhr.onreadystatechange = jQuery.noop;

                                                // Abort manually if needed
                                                if ( isAbort ) {
                                                        if ( xhr.readyState !== 4 ) {
                                                                xhr.abort();
                                                        }
                                                } else {
                                                        responses = {};
                                                        status = xhr.status;

                                                        // Support: IE&lt;10
                                                        // Accessing binary-data responseText throws an exception
                                                        // (#11426)
                                                        if ( typeof xhr.responseText === &quot;string&quot; ) {
                                                                responses.text = xhr.responseText;
                                                        }

                                                        // Firefox throws an exception when accessing
                                                        // statusText for faulty cross-domain requests
                                                        try {
                                                                statusText = xhr.statusText;
                                                        } catch( e ) {
                                                                // We normalize with Webkit giving an empty statusText
                                                                statusText = &quot;&quot;;
                                                        }

                                                        // Filter status for non standard behaviors

                                                        // If the request is local and we have data: assume a success
                                                        // (success with no data won&#39;t get notified, that&#39;s the best we
                                                        // can do given current implementations)
                                                        if ( !status &amp;&amp; options.isLocal &amp;&amp; !options.crossDomain ) {
                                                                status = responses.text ? 200 : 404;
                                                        // IE - #1450: sometimes returns 1223 when it should be 204
                                                        } else if ( status === 1223 ) {
                                                                status = 204;
                                                        }
                                                }
                                        }

                                        // Call complete if needed
                                        if ( responses ) {
                                                complete( status, statusText, responses, xhr.getAllResponseHeaders() );
                                        }
                                };

                                if ( !options.async ) {
                                        // if we&#39;re in sync mode we fire the callback
                                        callback();
                                } else if ( xhr.readyState === 4 ) {
                                        // (IE6 &amp; IE7) if it&#39;s in cache and has been
                                        // retrieved directly we need to fire the callback
                                        setTimeout( callback );
                                } else {
                                        // Add to the list of active xhr callbacks
                                        xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
                                }
                        },

                        abort: function() {
                                if ( callback ) {
                                        callback( undefined, true );
                                }
                        }
                };
        }
});</pre>

<p>}</p>

<p>// Functions to create xhrs function createStandardXHR() {</p>

<pre>try {
        return new window.XMLHttpRequest();
} catch( e ) {}</pre>

<p>}</p>

<p>function createActiveXHR() {</p>

<pre>try {
        return new window.ActiveXObject( &quot;Microsoft.XMLHTTP&quot; );
} catch( e ) {}</pre>

<p>}</p>

<p>// Install script dataType jQuery.ajaxSetup({</p>

<pre>accepts: {
        script: &quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;
},
contents: {
        script: /(?:java|ecma)script/
},
converters: {
        &quot;text script&quot;: function( text ) {
                jQuery.globalEval( text );
                return text;
        }
}</pre>

<p>});</p>

<p>// Handle cache&#39;s special case and global jQuery.ajaxPrefilter(
script, function( s ) {</p>

<pre>if ( s.cache === undefined ) {
        s.cache = false;
}
if ( s.crossDomain ) {
        s.type = &quot;GET&quot;;
        s.global = false;
}</pre>

<p>});</p>

<p>// Bind script tag hack transport jQuery.ajaxTransport( script,
function(s) {</p>

<pre>// This transport only deals with cross domain requests
if ( s.crossDomain ) {

        var script,
                head = document.head || jQuery(&quot;head&quot;)[0] || document.documentElement;

        return {

                send: function( _, callback ) {

                        script = document.createElement(&quot;script&quot;);

                        script.async = true;

                        if ( s.scriptCharset ) {
                                script.charset = s.scriptCharset;
                        }

                        script.src = s.url;

                        // Attach handlers for all browsers
                        script.onload = script.onreadystatechange = function( _, isAbort ) {

                                if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                                        // Handle memory leak in IE
                                        script.onload = script.onreadystatechange = null;

                                        // Remove the script
                                        if ( script.parentNode ) {
                                                script.parentNode.removeChild( script );
                                        }

                                        // Dereference the script
                                        script = null;

                                        // Callback if not abort
                                        if ( !isAbort ) {
                                                callback( 200, &quot;success&quot; );
                                        }
                                }
                        };

                        // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                        // Use native DOM manipulation to avoid our domManip AJAX trickery
                        head.insertBefore( script, head.firstChild );
                },

                abort: function() {
                        if ( script ) {
                                script.onload( undefined, true );
                        }
                }
        };
}</pre>

<p>});</p>

<p>var oldCallbacks = [],</p>

<pre class="ruby"><span class="ruby-identifier">rjsonp</span> = <span class="ruby-regexp">/(=)\?(?=&amp;|$)|\?\?/</span>;
</pre>

<p>// Default jsonp settings jQuery.ajaxSetup({</p>

<pre>jsonp: &quot;callback&quot;,
jsonpCallback: function() {
        var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
        this[ callback ] = true;
        return callback;
}</pre>

<p>});</p>

<p>// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( json jsonp, function( s, originalSettings, jqXHR )
{</p>

<pre>var callbackName, overwritten, responseContainer,
        jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ?
                &quot;url&quot; :
                typeof s.data === &quot;string&quot; &amp;&amp; !( s.contentType || &quot;&quot; ).indexOf(&quot;application/x-www-form-urlencoded&quot;) &amp;&amp; rjsonp.test( s.data ) &amp;&amp; &quot;data&quot;
        );

// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set
if ( jsonProp || s.dataTypes[ 0 ] === &quot;jsonp&quot; ) {

        // Get callback name, remembering preexisting value associated with it
        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                s.jsonpCallback() :
                s.jsonpCallback;

        // Insert callback into url or form data
        if ( jsonProp ) {
                s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, &quot;$1&quot; + callbackName );
        } else if ( s.jsonp !== false ) {
                s.url += ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;=&quot; + callbackName;
        }

        // Use data converter to retrieve json after script execution
        s.converters[&quot;script json&quot;] = function() {
                if ( !responseContainer ) {
                        jQuery.error( callbackName + &quot; was not called&quot; );
                }
                return responseContainer[ 0 ];
        };

        // force json dataType
        s.dataTypes[ 0 ] = &quot;json&quot;;

        // Install callback
        overwritten = window[ callbackName ];
        window[ callbackName ] = function() {
                responseContainer = arguments;
        };

        // Clean-up function (fires after converters)
        jqXHR.always(function() {
                // Restore preexisting value
                window[ callbackName ] = overwritten;

                // Save back as free
                if ( s[ callbackName ] ) {
                        // make sure that re-using the options doesn&#39;t screw things around
                        s.jsonpCallback = originalSettings.jsonpCallback;

                        // save the callback name for future use
                        oldCallbacks.push( callbackName );
                }

                // Call if it was a function and we have a response
                if ( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) {
                        overwritten( responseContainer[ 0 ] );
                }

                responseContainer = overwritten = undefined;
        });

        // Delegate to script
        return &quot;script&quot;;
}</pre>

<p>});</p>

<p>// data: string of html // context (optional): If specified, the fragment
will be created in this context, defaults to document // keepScripts
(optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {</p>

<pre>if ( !data || typeof data !== &quot;string&quot; ) {
        return null;
}
if ( typeof context === &quot;boolean&quot; ) {
        keepScripts = context;
        context = false;
}
context = context || document;

var parsed = rsingleTag.exec( data ),
        scripts = !keepScripts &amp;&amp; [];

// Single tag
if ( parsed ) {
        return [ context.createElement( parsed[1] ) ];
}

parsed = jQuery.buildFragment( [ data ], context, scripts );

if ( scripts &amp;&amp; scripts.length ) {
        jQuery( scripts ).remove();
}

return jQuery.merge( [], parsed.childNodes );</pre>

<p>};</p>

<p>// Keep a copy of the old load method var _load = jQuery.fn.load;</p>

<p>/**</p>

<pre> Load a url into a page
/</pre>

<p>jQuery.fn.load = function( url, params, callback ) {</p>

<pre>if ( typeof url !== &quot;string&quot; &amp;&amp; _load ) {
        return _load.apply( this, arguments );
}

var selector, response, type,
        self = this,
        off = url.indexOf(&quot; &quot;);

if ( off &gt;= 0 ) {
        selector = jQuery.trim( url.slice( off, url.length ) );
        url = url.slice( 0, off );
}

// If it&#39;s a function
if ( jQuery.isFunction( params ) ) {

        // We assume that it&#39;s the callback
        callback = params;
        params = undefined;

// Otherwise, build a param string
} else if ( params &amp;&amp; typeof params === &quot;object&quot; ) {
        type = &quot;POST&quot;;
}

// If we have elements to modify, make the request
if ( self.length &gt; 0 ) {
        jQuery.ajax({
                url: url,

                // if &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used
                type: type,
                dataType: &quot;html&quot;,
                data: params
        }).done(function( responseText ) {

                // Save response for use in complete callback
                response = arguments;

                self.html( selector ?

                        // If a selector was specified, locate the right elements in a dummy div
                        // Exclude scripts to avoid IE &#39;Permission Denied&#39; errors
                        jQuery(&quot;&lt;div&gt;&quot;).append( jQuery.parseHTML( responseText ) ).find( selector ) :

                        // Otherwise use the full result
                        responseText );

        }).complete( callback &amp;&amp; function( jqXHR, status ) {
                self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
        });
}

return this;</pre>

<p>};</p>

<p>jQuery.expr.filters.animated = function( elem ) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">grep</span>(<span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">timers</span>, <span class="ruby-identifier">function</span>( <span class="ruby-identifier">fn</span> ) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">elem</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">fn</span>.<span class="ruby-identifier">elem</span>;
}).<span class="ruby-identifier">length</span>;
</pre>

<p>};</p>

<p>var docElem = window.document.documentElement;</p>

<p>/**</p>

<pre> Gets a window from an element
/</pre>

<p>function getWindow( elem ) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">jQuery</span>.<span class="ruby-identifier">isWindow</span>( <span class="ruby-identifier">elem</span> ) <span class="ruby-operator">?</span>
        <span class="ruby-identifier">elem</span> <span class="ruby-operator">:</span>
        <span class="ruby-identifier">elem</span>.<span class="ruby-identifier">nodeType</span> <span class="ruby-operator">===</span> <span class="ruby-value">9</span> <span class="ruby-operator">?</span>
                <span class="ruby-identifier">elem</span>.<span class="ruby-identifier">defaultView</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">elem</span>.<span class="ruby-identifier">parentWindow</span> <span class="ruby-operator">:</span>
                <span class="ruby-keyword">false</span>;
</pre>

<p>}</p>

<p>jQuery.offset = {</p>

<pre>setOffset: function( elem, options, i ) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css( elem, &quot;position&quot; ),
                curElem = jQuery( elem ),
                props = {};

        // set position first, in-case top/left are set even on static elem
        if ( position === &quot;static&quot; ) {
                elem.style.position = &quot;relative&quot;;
        }

        curOffset = curElem.offset();
        curCSSTop = jQuery.css( elem, &quot;top&quot; );
        curCSSLeft = jQuery.css( elem, &quot;left&quot; );
        calculatePosition = ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) &amp;&amp;
                jQuery.inArray(&quot;auto&quot;, [ curCSSTop, curCSSLeft ] ) &gt; -1;

        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
        if ( calculatePosition ) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
        } else {
                curTop = parseFloat( curCSSTop ) || 0;
                curLeft = parseFloat( curCSSLeft ) || 0;
        }

        if ( jQuery.isFunction( options ) ) {
                options = options.call( elem, i, curOffset );
        }

        if ( options.top != null ) {
                props.top = ( options.top - curOffset.top ) + curTop;
        }
        if ( options.left != null ) {
                props.left = ( options.left - curOffset.left ) + curLeft;
        }

        if ( &quot;using&quot; in options ) {
                options.using.call( elem, props );
        } else {
                curElem.css( props );
        }
}</pre>

<p>};</p>

<p>jQuery.fn.extend({</p>

<pre>offset: function( options ) {
        if ( arguments.length ) {
                return options === undefined ?
                        this :
                        this.each(function( i ) {
                                jQuery.offset.setOffset( this, options, i );
                        });
        }

        var docElem, win,
                box = { top: 0, left: 0 },
                elem = this[ 0 ],
                doc = elem &amp;&amp; elem.ownerDocument;

        if ( !doc ) {
                return;
        }

        docElem = doc.documentElement;

        // Make sure it&#39;s not a disconnected DOM node
        if ( !jQuery.contains( docElem, elem ) ) {
                return box;
        }

        // If we don&#39;t have gBCR, just use 0,0 rather than error
        // BlackBerry 5, iOS 3 (original iPhone)
        if ( typeof elem.getBoundingClientRect !== strundefined ) {
                box = elem.getBoundingClientRect();
        }
        win = getWindow( doc );
        return {
                top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
                left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
        };
},

position: function() {
        if ( !this[ 0 ] ) {
                return;
        }

        var offsetParent, offset,
                parentOffset = { top: 0, left: 0 },
                elem = this[ 0 ];

        // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
        if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) {
                // we assume that getBoundingClientRect is available when computed position is fixed
                offset = elem.getBoundingClientRect();
        } else {
                // Get *real* offsetParent
                offsetParent = this.offsetParent();

                // Get correct offsets
                offset = this.offset();
                if ( !jQuery.nodeName( offsetParent[ 0 ], &quot;html&quot; ) ) {
                        parentOffset = offsetParent.offset();
                }

                // Add offsetParent borders
                parentOffset.top  += jQuery.css( offsetParent[ 0 ], &quot;borderTopWidth&quot;, true );
                parentOffset.left += jQuery.css( offsetParent[ 0 ], &quot;borderLeftWidth&quot;, true );
        }

        // Subtract parent offsets and element margins
        // note: when an element has margin: auto the offsetLeft and marginLeft
        // are the same in Safari causing offset.left to incorrectly be 0
        return {
                top:  offset.top  - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),
                left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true)
        };
},

offsetParent: function() {
        return this.map(function() {
                var offsetParent = this.offsetParent || docElem;

                while ( offsetParent &amp;&amp; ( !jQuery.nodeName( offsetParent, &quot;html&quot; ) &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) ) {
                        offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
        });
}</pre>

<p>});</p>

<p>// Create scrollLeft and scrollTop methods jQuery.each( { scrollLeft:
pageXOffset, scrollTop: pageYOffset }, function( method, prop ) {</p>

<pre>var top = /Y/.test( prop );

jQuery.fn[ method ] = function( val ) {
        return access( this, function( elem, method, val ) {
                var win = getWindow( elem );

                if ( val === undefined ) {
                        return win ? (prop in win) ? win[ prop ] :
                                win.document.documentElement[ method ] :
                                elem[ method ];
                }

                if ( win ) {
                        win.scrollTo(
                                !top ? val : jQuery( win ).scrollLeft(),
                                top ? val : jQuery( win ).scrollTop()
                        );

                } else {
                        elem[ method ] = val;
                }
        }, method, val, arguments.length, null );
};</pre>

<p>});</p>

<p>// Add the top/left cssHooks using jQuery.fn.position // Webkit bug: <a
href="https://bugs.webkit.org/show_bug.cgi?id=29084">bugs.webkit.org/show_bug.cgi?id=29084</a>
// getComputedStyle returns percent when specified for
top/left/bottom/right // rather than make the css module depend on the
offset module, we just check for it here jQuery.each( [ top, left ],
function( i, prop ) {</p>

<pre>jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
        function( elem, computed ) {
                if ( computed ) {
                        computed = curCSS( elem, prop );
                        // if curCSS returns percentage, fallback to offset
                        return rnumnonpx.test( computed ) ?
                                jQuery( elem ).position()[ prop ] + &quot;px&quot; :
                                computed;
                }
        }
);</pre>

<p>});</p>

<p>// Create innerHeight, innerWidth, height, width, outerHeight and
outerWidth methods jQuery.each( { Height: height, Width: width },
function( name, type ) {</p>

<pre>jQuery.each( { padding: &quot;inner&quot; + name, content: type, &quot;&quot;: &quot;outer&quot; + name }, function( defaultExtra, funcName ) {
        // margin is only for outerHeight, outerWidth
        jQuery.fn[ funcName ] = function( margin, value ) {
                var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== &quot;boolean&quot; ),
                        extra = defaultExtra || ( margin === true || value === true ? &quot;margin&quot; : &quot;border&quot; );

                return access( this, function( elem, type, value ) {
                        var doc;

                        if ( jQuery.isWindow( elem ) ) {
                                // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                // isn&#39;t a whole lot we can do. See pull request at this URL for discussion:
                                // https://github.com/jquery/jquery/pull/764
                                return elem.document.documentElement[ &quot;client&quot; + name ];
                        }

                        // Get document width or height
                        if ( elem.nodeType === 9 ) {
                                doc = elem.documentElement;

                                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                                // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                                return Math.max(
                                        elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ],
                                        elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ],
                                        doc[ &quot;client&quot; + name ]
                                );
                        }

                        return value === undefined ?
                                // Get width or height on the element, requesting but not forcing parseFloat
                                jQuery.css( elem, type, extra ) :

                                // Set width or height on the element
                                jQuery.style( elem, type, value, extra );
                }, type, chainable ? margin : undefined, chainable, null );
        };
});</pre>

<p>});</p>

<p>// The number of elements contained in the matched element set
jQuery.fn.size = function() {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">length</span>;
</pre>

<p>};</p>

<p>jQuery.fn.andSelf = jQuery.fn.addBack;</p>

<p>// Register as a named AMD module, since jQuery can be concatenated with
other // files that may use define, but not via a proper concatenation
script that // understands anonymous AMD modules. A named AMD is safest and
most robust // way to register. Lowercase jquery is used because AMD module
names are // derived from file names, and jQuery is normally delivered in a
lowercase // file name. Do this after creating the global so that if an AMD
module wants // to call noConflict to hide this version of jQuery, it will
work.</p>

<p>// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if
an // AMD loader is present. jQuery is a special case. For more
information, see // <a
href="https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon">github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon</a></p>

<p>if ( typeof define === function &amp;&amp; define.amd ) {</p>

<pre class="ruby"><span class="ruby-identifier">define</span>( <span class="ruby-string">&quot;jquery&quot;</span>, [], <span class="ruby-identifier">function</span>() {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">jQuery</span>;
});
</pre>

<p>}</p>

<p>var</p>

<pre>// Map over jQuery in case of overwrite
_jQuery = window.jQuery,

// Map over the $ in case of overwrite
_$ = window.$;</pre>

<p>jQuery.noConflict = function( deep ) {</p>

<pre>if ( window.$ === jQuery ) {
        window.$ = _$;
}

if ( deep &amp;&amp; window.jQuery === jQuery ) {
        window.jQuery = _jQuery;
}

return jQuery;</pre>

<p>};</p>

<p>// Expose jQuery and $ identifiers, even in // AMD (#7102#comment:10, <a
href="https://github.com/jquery/jquery/pull/557">github.com/jquery/jquery/pull/557</a>)
// and CommonJS for browser emulators (#13566) if ( typeof noGlobal ===
strundefined ) {</p>

<pre>window.jQuery = window.$ = jQuery;</pre>

<p>}</p>

<p>return jQuery;</p>

<p>})); /*!</p>

<pre> jQuery Cookie Plugin v1.4.1
 https://github.com/carhartl/jquery-cookie

 Copyright 2013 Klaus Hartl
 Released under the MIT license
/</pre>

<p>(function (factory) {</p>

<pre>if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
        // AMD
        define([&#39;jquery&#39;], factory);
} else if (typeof exports === &#39;object&#39;) {
        // CommonJS
        factory(require(&#39;jquery&#39;));
} else {
        // Browser globals
        factory(jQuery);
}</pre>

<p>}(function ($) {</p>

<pre>var pluses = /\+/g;

function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
}

function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
}

function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
}

function parseCookieValue(s) {
        if (s.indexOf(&#39;&quot;&#39;) === 0) {
                // This is a quoted cookie as according to RFC2068, unescape...
                s = s.slice(1, -1).replace(/\\&quot;/g, &#39;&quot;&#39;).replace(/\\\\/g, &#39;\\&#39;);
        }

        try {
                // Replace server-side written pluses with spaces.
                // If we can&#39;t decode the cookie, ignore it, it&#39;s unusable.
                // If we can&#39;t parse the cookie, ignore it, it&#39;s unusable.
                s = decodeURIComponent(s.replace(pluses, &#39; &#39;));
                return config.json ? JSON.parse(s) : s;
        } catch(e) {}
}

function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
}

var config = $.cookie = function (key, value, options) {

        // Write

        if (value !== undefined &amp;&amp; !$.isFunction(value)) {
                options = $.extend({}, config.defaults, options);

                if (typeof options.expires === &#39;number&#39;) {
                        var days = options.expires, t = options.expires = new Date();
                        t.setTime(+t + days * 864e+5);
                }

                return (document.cookie = [
                        encode(key), &#39;=&#39;, stringifyCookieValue(value),
                        options.expires ? &#39;; expires=&#39; + options.expires.toUTCString() : &#39;&#39;, // use expires attribute, max-age is not supported by IE
                        options.path    ? &#39;; path=&#39; + options.path : &#39;&#39;,
                        options.domain  ? &#39;; domain=&#39; + options.domain : &#39;&#39;,
                        options.secure  ? &#39;; secure&#39; : &#39;&#39;
                ].join(&#39;&#39;));
        }

        // Read

        var result = key ? undefined : {};

        // To prevent the for loop in the first place assign an empty array
        // in case there are no cookies at all. Also prevents odd result when
        // calling $.cookie().
        var cookies = document.cookie ? document.cookie.split(&#39;; &#39;) : [];

        for (var i = 0, l = cookies.length; i &lt; l; i++) {
                var parts = cookies[i].split(&#39;=&#39;);
                var name = decode(parts.shift());
                var cookie = parts.join(&#39;=&#39;);

                if (key &amp;&amp; key === name) {
                        // If second argument (value) is a function it&#39;s a converter...
                        result = read(cookie, value);
                        break;
                }

                // Prevent storing a cookie that we couldn&#39;t decode.
                if (!key &amp;&amp; (cookie = read(cookie)) !== undefined) {
                        result[name] = cookie;
                }
        }

        return result;
};

config.defaults = {};

$.removeCookie = function (key, options) {
        if ($.cookie(key) === undefined) {
                return false;
        }

        // Must not alter options, thus extending a fresh object...
        $.cookie(key, &#39;&#39;, $.extend({}, options, { expires: -1 }));
        return !$.cookie(key);
};</pre>

<p>})); (function($, undefined) {</p>

<p>/**</p>

<pre> Unobtrusive scripting adapter for jQuery
 https://github.com/rails/jquery-ujs

 Requires jQuery 1.8.0 or later.

 Released under the MIT license

/

// Cut down on the number of issues from people inadvertently including jquery_ujs twice
// by detecting and raising an error when it happens.
if ( $.rails !== undefined ) {
  $.error(&#39;jquery-ujs has already been loaded!&#39;);
}

// Shorthand to make it a little easier to call public rails functions from within rails.js
var rails;
var $document = $(document);

$.rails = rails = {
  // Link elements bound by jquery-ujs
  linkClickSelector: &#39;a[data-confirm], a[data-method], a[data-remote], a[data-disable-with], a[data-disable]&#39;,

  // Button elements bound by jquery-ujs
  buttonClickSelector: &#39;button[data-remote]:not(form button), button[data-confirm]:not(form button)&#39;,

  // Select elements bound by jquery-ujs
  inputChangeSelector: &#39;select[data-remote], input[data-remote], textarea[data-remote]&#39;,

  // Form elements bound by jquery-ujs
  formSubmitSelector: &#39;form&#39;,

  // Form input elements bound by jquery-ujs
  formInputClickSelector: &#39;form input[type=submit], form input[type=image], form button[type=submit], form button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])&#39;,

  // Form input elements disabled during form submission
  disableSelector: &#39;input[data-disable-with]:enabled, button[data-disable-with]:enabled, textarea[data-disable-with]:enabled, input[data-disable]:enabled, button[data-disable]:enabled, textarea[data-disable]:enabled&#39;,

  // Form input elements re-enabled after form submission
  enableSelector: &#39;input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled, input[data-disable]:disabled, button[data-disable]:disabled, textarea[data-disable]:disabled&#39;,

  // Form required input elements
  requiredInputSelector: &#39;input[name][required]:not([disabled]),textarea[name][required]:not([disabled])&#39;,

  // Form file input elements
  fileInputSelector: &#39;input[type=file]&#39;,

  // Link onClick disable selector with possible reenable after remote submission
  linkDisableSelector: &#39;a[data-disable-with], a[data-disable]&#39;,

  // Button onClick disable selector with possible reenable after remote submission
  buttonDisableSelector: &#39;button[data-remote][data-disable-with], button[data-remote][data-disable]&#39;,

  // Make sure that every Ajax request sends the CSRF token
  CSRFProtection: function(xhr) {
    var token = $(&#39;meta[name=&quot;csrf-token&quot;]&#39;).attr(&#39;content&#39;);
    if (token) xhr.setRequestHeader(&#39;X-CSRF-Token&#39;, token);
  },

  // making sure that all forms have actual up-to-date token(cached forms contain old one)
  refreshCSRFTokens: function(){
    var csrfToken = $(&#39;meta[name=csrf-token]&#39;).attr(&#39;content&#39;);
    var csrfParam = $(&#39;meta[name=csrf-param]&#39;).attr(&#39;content&#39;);
    $(&#39;form input[name=&quot;&#39; + csrfParam + &#39;&quot;]&#39;).val(csrfToken);
  },

  // Triggers an event on an element and returns false if the event result is false
  fire: function(obj, name, data) {
    var event = $.Event(name);
    obj.trigger(event, data);
    return event.result !== false;
  },

  // Default confirm dialog, may be overridden with custom confirm dialog in $.rails.confirm
  confirm: function(message) {
    return confirm(message);
  },

  // Default ajax function, may be overridden with custom function in $.rails.ajax
  ajax: function(options) {
    return $.ajax(options);
  },

  // Default way to get an element&#39;s href. May be overridden at $.rails.href.
  href: function(element) {
    return element[0].href;
  },

  // Submits &quot;remote&quot; forms and links with ajax
  handleRemote: function(element) {
    var method, url, data, withCredentials, dataType, options;

    if (rails.fire(element, &#39;ajax:before&#39;)) {
      withCredentials = element.data(&#39;with-credentials&#39;) || null;
      dataType = element.data(&#39;type&#39;) || ($.ajaxSettings &amp;&amp; $.ajaxSettings.dataType);

      if (element.is(&#39;form&#39;)) {
        method = element.attr(&#39;method&#39;);
        url = element.attr(&#39;action&#39;);
        data = element.serializeArray();
        // memoized value from clicked submit button
        var button = element.data(&#39;ujs:submit-button&#39;);
        if (button) {
          data.push(button);
          element.data(&#39;ujs:submit-button&#39;, null);
        }
      } else if (element.is(rails.inputChangeSelector)) {
        method = element.data(&#39;method&#39;);
        url = element.data(&#39;url&#39;);
        data = element.serialize();
        if (element.data(&#39;params&#39;)) data = data + &quot;&amp;&quot; + element.data(&#39;params&#39;);
      } else if (element.is(rails.buttonClickSelector)) {
        method = element.data(&#39;method&#39;) || &#39;get&#39;;
        url = element.data(&#39;url&#39;);
        data = element.serialize();
        if (element.data(&#39;params&#39;)) data = data + &quot;&amp;&quot; + element.data(&#39;params&#39;);
      } else {
        method = element.data(&#39;method&#39;);
        url = rails.href(element);
        data = element.data(&#39;params&#39;) || null;
      }

      options = {
        type: method || &#39;GET&#39;, data: data, dataType: dataType,
        // stopping the &quot;ajax:beforeSend&quot; event will cancel the ajax request
        beforeSend: function(xhr, settings) {
          if (settings.dataType === undefined) {
            xhr.setRequestHeader(&#39;accept&#39;, &#39;*/*;q=0.5, &#39; + settings.accepts.script);
          }
          if (rails.fire(element, &#39;ajax:beforeSend&#39;, [xhr, settings])) {
            element.trigger(&#39;ajax:send&#39;, xhr);
          } else {
            return false;
          }
        },
        success: function(data, status, xhr) {
          element.trigger(&#39;ajax:success&#39;, [data, status, xhr]);
        },
        complete: function(xhr, status) {
          element.trigger(&#39;ajax:complete&#39;, [xhr, status]);
        },
        error: function(xhr, status, error) {
          element.trigger(&#39;ajax:error&#39;, [xhr, status, error]);
        },
        crossDomain: rails.isCrossDomain(url)
      };

      // There is no withCredentials for IE6-8 when
      // &quot;Enable native XMLHTTP support&quot; is disabled
      if (withCredentials) {
        options.xhrFields = {
          withCredentials: withCredentials
        };
      }

      // Only pass url to `ajax` options if not blank
      if (url) { options.url = url; }

      return rails.ajax(options);
    } else {
      return false;
    }
  },

  // Determines if the request is a cross domain request.
  isCrossDomain: function(url) {
    var originAnchor = document.createElement(&quot;a&quot;);
    originAnchor.href = location.href;
    var urlAnchor = document.createElement(&quot;a&quot;);

    try {
      urlAnchor.href = url;
      // This is a workaround to a IE bug.
      urlAnchor.href = urlAnchor.href;

      // If URL protocol is false or is a string containing a single colon
      // *and* host are false, assume it is not a cross-domain request
      // (should only be the case for IE7 and IE compatibility mode).
      // Otherwise, evaluate protocol and host of the URL against the origin
      // protocol and host
      return !(((!urlAnchor.protocol || urlAnchor.protocol === &#39;:&#39;) &amp;&amp; !urlAnchor.host) ||
        (originAnchor.protocol + &quot;//&quot; + originAnchor.host ===
          urlAnchor.protocol + &quot;//&quot; + urlAnchor.host));      //
    } catch (e) {
      // If there is an error parsing the URL, assume it is crossDomain.
      return true;
    }
  },

  // Handles &quot;data-method&quot; on links such as:
  // &lt;a href=&quot;/users/5&quot; data-method=&quot;delete&quot; rel=&quot;nofollow&quot; data-confirm=&quot;Are you sure?&quot;&gt;Delete&lt;/a&gt;
  handleMethod: function(link) {
    var href = rails.href(link),
      method = link.data(&#39;method&#39;),
      target = link.attr(&#39;target&#39;),
      csrfToken = $(&#39;meta[name=csrf-token]&#39;).attr(&#39;content&#39;),
      csrfParam = $(&#39;meta[name=csrf-param]&#39;).attr(&#39;content&#39;),
      form = $(&#39;&lt;form method=&quot;post&quot; action=&quot;&#39; + href + &#39;&quot;&gt;&lt;/form&gt;&#39;),
      metadataInput = &#39;&lt;input name=&quot;_method&quot; value=&quot;&#39; + method + &#39;&quot; type=&quot;hidden&quot; /&gt;&#39;;

    if (csrfParam !== undefined &amp;&amp; csrfToken !== undefined &amp;&amp; !rails.isCrossDomain(href)) {
      metadataInput += &#39;&lt;input name=&quot;&#39; + csrfParam + &#39;&quot; value=&quot;&#39; + csrfToken + &#39;&quot; type=&quot;hidden&quot; /&gt;&#39;;
    }

    if (target) { form.attr(&#39;target&#39;, target); }

    form.hide().append(metadataInput).appendTo(&#39;body&#39;);
    form.submit();
  },

  // Helper function that returns form elements that match the specified CSS selector
  // If form is actually a &quot;form&quot; element this will return associated elements outside the from that have
  // the html form attribute set
  formElements: function(form, selector) {
    return form.is(&#39;form&#39;) ? $(form[0].elements).filter(selector) : form.find(selector);
  },

  /* Disables form elements:
    - Caches element value in &#39;ujs:enable-with&#39; data store
    - Replaces element text with value of &#39;data-disable-with&#39; attribute
    - Sets disabled property to true
   /
  disableFormElements: function(form) {
    rails.formElements(form, rails.disableSelector).each(function() {
      rails.disableFormElement($(this));
    });
  },

  disableFormElement: function(element) {
    var method, replacement;

    method = element.is(&#39;button&#39;) ? &#39;html&#39; : &#39;val&#39;;
    replacement = element.data(&#39;disable-with&#39;);

    element.data(&#39;ujs:enable-with&#39;, element[method]());
    if (replacement !== undefined) {
      element[method](replacement);
    }

    element.prop(&#39;disabled&#39;, true);
  },

  /* Re-enables disabled form elements:
    - Replaces element text with cached value from &#39;ujs:enable-with&#39; data store (created in `disableFormElements`)
    - Sets disabled property to false
   /
  enableFormElements: function(form) {
    rails.formElements(form, rails.enableSelector).each(function() {
      rails.enableFormElement($(this));
    });
  },

  enableFormElement: function(element) {
    var method = element.is(&#39;button&#39;) ? &#39;html&#39; : &#39;val&#39;;
    if (element.data(&#39;ujs:enable-with&#39;)) element[method](element.data(&#39;ujs:enable-with&#39;));
    element.prop(&#39;disabled&#39;, false);
  },

 /* For &#39;data-confirm&#39; attribute:
    - Fires `confirm` event
    - Shows the confirmation dialog
    - Fires the `confirm:complete` event

    Returns `true` if no function stops the chain and user chose yes; `false` otherwise.
    Attaching a handler to the element&#39;s `confirm` event that returns a `falsy` value cancels the confirmation dialog.
    Attaching a handler to the element&#39;s `confirm:complete` event that returns a `falsy` value makes this function
    return false. The `confirm:complete` event is fired whether or not the user answered true or false to the dialog.
  /
  allowAction: function(element) {
    var message = element.data(&#39;confirm&#39;),
        answer = false, callback;
    if (!message) { return true; }

    if (rails.fire(element, &#39;confirm&#39;)) {
      answer = rails.confirm(message);
      callback = rails.fire(element, &#39;confirm:complete&#39;, [answer]);
    }
    return answer &amp;&amp; callback;
  },

  // Helper function which checks for blank inputs in a form that match the specified CSS selector
  blankInputs: function(form, specifiedSelector, nonBlank) {
    var inputs = $(), input, valueToCheck,
        selector = specifiedSelector || &#39;input,textarea&#39;,
        allInputs = form.find(selector);

    allInputs.each(function() {
      input = $(this);
      valueToCheck = input.is(&#39;input[type=checkbox],input[type=radio]&#39;) ? input.is(&#39;:checked&#39;) : input.val();
      // If nonBlank and valueToCheck are both truthy, or nonBlank and valueToCheck are both falsey
      if (!valueToCheck === !nonBlank) {

        // Don&#39;t count unchecked required radio if other radio with same name is checked
        if (input.is(&#39;input[type=radio]&#39;) &amp;&amp; allInputs.filter(&#39;input[type=radio]:checked[name=&quot;&#39; + input.attr(&#39;name&#39;) + &#39;&quot;]&#39;).length) {
          return true; // Skip to next input
        }

        inputs = inputs.add(input);
      }
    });
    return inputs.length ? inputs : false;
  },

  // Helper function which checks for non-blank inputs in a form that match the specified CSS selector
  nonBlankInputs: function(form, specifiedSelector) {
    return rails.blankInputs(form, specifiedSelector, true); // true specifies nonBlank
  },

  // Helper function, needed to provide consistent behavior in IE
  stopEverything: function(e) {
    $(e.target).trigger(&#39;ujs:everythingStopped&#39;);
    e.stopImmediatePropagation();
    return false;
  },

  //  replace element&#39;s html with the &#39;data-disable-with&#39; after storing original html
  //  and prevent clicking on it
  disableElement: function(element) {
    var replacement = element.data(&#39;disable-with&#39;);

    element.data(&#39;ujs:enable-with&#39;, element.html()); // store enabled state
    if (replacement !== undefined) {
      element.html(replacement);
    }

    element.bind(&#39;click.railsDisable&#39;, function(e) { // prevent further clicking
      return rails.stopEverything(e);
    });
  },

  // restore element to its original state which was disabled by &#39;disableElement&#39; above
  enableElement: function(element) {
    if (element.data(&#39;ujs:enable-with&#39;) !== undefined) {
      element.html(element.data(&#39;ujs:enable-with&#39;)); // set to old enabled state
      element.removeData(&#39;ujs:enable-with&#39;); // clean up cache
    }
    element.unbind(&#39;click.railsDisable&#39;); // enable element
  }
};

if (rails.fire($document, &#39;rails:attachBindings&#39;)) {

  $.ajaxPrefilter(function(options, originalOptions, xhr){ if ( !options.crossDomain ) { rails.CSRFProtection(xhr); }});

  $document.delegate(rails.linkDisableSelector, &#39;ajax:complete&#39;, function() {
      rails.enableElement($(this));
  });

  $document.delegate(rails.buttonDisableSelector, &#39;ajax:complete&#39;, function() {
      rails.enableFormElement($(this));
  });

  $document.delegate(rails.linkClickSelector, &#39;click.rails&#39;, function(e) {
    var link = $(this), method = link.data(&#39;method&#39;), data = link.data(&#39;params&#39;), metaClick = e.metaKey || e.ctrlKey;
    if (!rails.allowAction(link)) return rails.stopEverything(e);

    if (!metaClick &amp;&amp; link.is(rails.linkDisableSelector)) rails.disableElement(link);

    if (link.data(&#39;remote&#39;) !== undefined) {
      if (metaClick &amp;&amp; (!method || method === &#39;GET&#39;) &amp;&amp; !data) { return true; }

      var handleRemote = rails.handleRemote(link);
      // response from rails.handleRemote() will either be false or a deferred object promise.
      if (handleRemote === false) {
        rails.enableElement(link);
      } else {
        handleRemote.error( function() { rails.enableElement(link); } );
      }
      return false;

    } else if (link.data(&#39;method&#39;)) {
      rails.handleMethod(link);
      return false;
    }
  });

  $document.delegate(rails.buttonClickSelector, &#39;click.rails&#39;, function(e) {
    var button = $(this);

    if (!rails.allowAction(button)) return rails.stopEverything(e);

    if (button.is(rails.buttonDisableSelector)) rails.disableFormElement(button);

    var handleRemote = rails.handleRemote(button);
    // response from rails.handleRemote() will either be false or a deferred object promise.
    if (handleRemote === false) {
      rails.enableFormElement(button);
    } else {
      handleRemote.error( function() { rails.enableFormElement(button); } );
    }
    return false;
  });

  $document.delegate(rails.inputChangeSelector, &#39;change.rails&#39;, function(e) {
    var link = $(this);
    if (!rails.allowAction(link)) return rails.stopEverything(e);

    rails.handleRemote(link);
    return false;
  });

  $document.delegate(rails.formSubmitSelector, &#39;submit.rails&#39;, function(e) {
    var form = $(this),
      remote = form.data(&#39;remote&#39;) !== undefined,
      blankRequiredInputs,
      nonBlankFileInputs;

    if (!rails.allowAction(form)) return rails.stopEverything(e);

    // skip other logic when required values are missing or file upload is present
    if (form.attr(&#39;novalidate&#39;) == undefined) {
      blankRequiredInputs = rails.blankInputs(form, rails.requiredInputSelector);
      if (blankRequiredInputs &amp;&amp; rails.fire(form, &#39;ajax:aborted:required&#39;, [blankRequiredInputs])) {
        return rails.stopEverything(e);
      }
    }

    if (remote) {
      nonBlankFileInputs = rails.nonBlankInputs(form, rails.fileInputSelector);
      if (nonBlankFileInputs) {
        // slight timeout so that the submit button gets properly serialized
        // (make it easy for event handler to serialize form without disabled values)
        setTimeout(function(){ rails.disableFormElements(form); }, 13);
        var aborted = rails.fire(form, &#39;ajax:aborted:file&#39;, [nonBlankFileInputs]);

        // re-enable form elements if event bindings return false (canceling normal form submission)
        if (!aborted) { setTimeout(function(){ rails.enableFormElements(form); }, 13); }

        return aborted;
      }

      rails.handleRemote(form);
      return false;

    } else {
      // slight timeout so that the submit button gets properly serialized
      setTimeout(function(){ rails.disableFormElements(form); }, 13);
    }
  });

  $document.delegate(rails.formInputClickSelector, &#39;click.rails&#39;, function(event) {
    var button = $(this);

    if (!rails.allowAction(button)) return rails.stopEverything(event);

    // register the pressed submit button
    var name = button.attr(&#39;name&#39;),
      data = name ? {name:name, value:button.val()} : null;

    button.closest(&#39;form&#39;).data(&#39;ujs:submit-button&#39;, data);
  });

  $document.delegate(rails.formSubmitSelector, &#39;ajax:send.rails&#39;, function(event) {
    if (this == event.target) rails.disableFormElements($(this));
  });

  $document.delegate(rails.formSubmitSelector, &#39;ajax:complete.rails&#39;, function(event) {
    if (this == event.target) rails.enableFormElements($(this));
  });

  $(function(){
    rails.refreshCSRFTokens();
  });
}</pre>

<p>})( jQuery ); /*! DataTables 1.10.6</p>

<pre> 2008-2014 SpryMedia Ltd - datatables.net/license
/</pre>

<p>/**</p>

<pre> @summary     DataTables
 @description Paginate, search and order HTML tables
 @version     1.10.6
 @file        jquery.dataTables.js
 @author      SpryMedia Ltd (www.sprymedia.co.uk)
 @contact     www.sprymedia.co.uk/contact
 @copyright   Copyright 2008-2014 SpryMedia Ltd.

 This source file is free software, available under the following license:
   MIT license - http://datatables.net/license

 This source file is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.

 For details please refer to: http://www.datatables.net
/</pre>

<p>/*jslint evil: true, undef: true, browser: true */ /*globals
$,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/</p>

<p>(/** @lends &lt;global&gt; */function( window, document, undefined ) {</p>

<p>(function( factory ) {</p>

<pre>    &quot;use strict&quot;;

    if ( typeof define === &#39;function&#39; &amp;&amp; define.amd ) {
            // Define as an AMD module if possible
            define( &#39;datatables&#39;, [&#39;jquery&#39;], factory );
    }
else if ( typeof exports === &#39;object&#39; ) {
    // Node/CommonJS
    module.exports = factory( require( &#39;jquery&#39; ) );
}
    else if ( jQuery &amp;&amp; !jQuery.fn.dataTable ) {
            // Define using browser globals otherwise
            // Prevent multiple instantiations if the script is loaded twice
            factory( jQuery );
    }</pre>

<p>} (/** @lends &lt;global&gt; */function( $ ) {</p>

<pre>     &quot;use strict&quot;;

     /**
 DataTables is a plug-in for the jQuery Javascript library. It is a highly
 flexible tool, based upon the foundations of progressive enhancement,
 which will add advanced interaction controls to any HTML table. For a
 full list of features please refer to
 [DataTables.net](href=&quot;http://datatables.net).

 Note that the `DataTable` object is not a global variable but is aliased
 to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
 be  accessed.

  @class
  @param {object} [init={}] Configuration object for DataTables. Options
    are defined by {@link DataTable.defaults}
  @requires jQuery 1.7+

  @example
    // Basic initialisation
    $(document).ready( function {
      $(&#39;#example&#39;).dataTable();
    } );

  @example
    // Initialisation with configuration options - in this case, disable
    // pagination and sorting.
    $(document).ready( function {
      $(&#39;#example&#39;).dataTable( {
        &quot;paginate&quot;: false,
        &quot;sort&quot;: false
      } );
    } );
/
     var DataTable;

     /*
 It is useful to have variables which are scoped locally so only the
 DataTables functions can access them and they don&#39;t leak into global space.
 At the same time these functions are often useful over multiple files in the
 core and API, so we list, or at least document, all variables which are used
 by DataTables as private variables here. This also ensures that there is no
 clashing of variable names and that they can easily referenced for reuse.
/

     // Defined else where
     //  _selector_run
     //  _selector_opts
     //  _selector_first
     //  _selector_row_indexes

     var _ext; // DataTable.ext
     var _Api; // DataTable.Api
     var _api_register; // DataTable.Api.register
     var _api_registerPlural; // DataTable.Api.registerPlural

     var _re_dic = {};
     var _re_new_lines = /[\r\n]/g;
     var _re_html = /&lt;.*?&gt;/g;
     var _re_date_start = /^[\w\+\-]/;
     var _re_date_end = /[\w\+\-]$/;

     // Escape regular expression special characters
     var _re_escape_regex = new RegExp( &#39;(\\&#39; + [ &#39;/&#39;, &#39;.&#39;, &#39;*&#39;, &#39;+&#39;, &#39;?&#39;, &#39;|&#39;, &#39;(&#39;, &#39;)&#39;, &#39;[&#39;, &#39;]&#39;, &#39;{&#39;, &#39;}&#39;, &#39;\\&#39;, &#39;$&#39;, &#39;^&#39;, &#39;-&#39; ].join(&#39;|\\&#39;) + &#39;)&#39;, &#39;g&#39; );

     // http://en.wikipedia.org/wiki/Foreign_exchange_market
     // - \u20BD - Russian ruble.
     // - \u20a9 - South Korean Won
     // - \u20BA - Turkish Lira
     // - \u20B9 - Indian Rupee
     // - R - Brazil (R$) and South Africa
     // - fr - Swiss Franc
     // - kr - Swedish krona, Norwegian krone and Danish krone
     // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
     //   standards as thousands separators.
     var _re_formatted_numeric = /[&#39;,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;

     var _empty = function ( d ) {
             return !d || d === true || d === &#39;-&#39; ? true : false;
     };

     var _intVal = function ( s ) {
             var integer = parseInt( s, 10 );
             return !isNaN(integer) &amp;&amp; isFinite(s) ? integer : null;
     };

     // Convert from a formatted number with characters other than `.` as the
     // decimal place, to a Javascript number
     var _numToDecimal = function ( num, decimalPoint ) {
             // Cache created regular expressions for speed as this function is called often
             if ( ! _re_dic[ decimalPoint ] ) {
                     _re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), &#39;g&#39; );
             }
             return typeof num === &#39;string&#39; &amp;&amp; decimalPoint !== &#39;.&#39; ?
                     num.replace( /\./g, &#39;&#39; ).replace( _re_dic[ decimalPoint ], &#39;.&#39; ) :
                     num;
     };

     var _isNumber = function ( d, decimalPoint, formatted ) {
             var strType = typeof d === &#39;string&#39;;

             // If empty return immediately so there must be a number if it is a
             // formatted string (this stops the string &quot;k&quot;, or &quot;kr&quot;, etc being detected
             // as a formatted number for currency
             if ( _empty( d ) ) {
                     return true;
             }

             if ( decimalPoint &amp;&amp; strType ) {
                     d = _numToDecimal( d, decimalPoint );
             }

             if ( formatted &amp;&amp; strType ) {
                     d = d.replace( _re_formatted_numeric, &#39;&#39; );
             }

             return !isNaN( parseFloat(d) ) &amp;&amp; isFinite( d );
     };

     // A string without HTML in it can be considered to be HTML still
     var _isHtml = function ( d ) {
             return _empty( d ) || typeof d === &#39;string&#39;;
     };

     var _htmlNumeric = function ( d, decimalPoint, formatted ) {
             if ( _empty( d ) ) {
                     return true;
             }

             var html = _isHtml( d );
             return ! html ?
                     null :
                     _isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
                             true :
                             null;
     };

     var _pluck = function ( a, prop, prop2 ) {
             var out = [];
             var i=0, ien=a.length;

             // Could have the test in the loop for slightly smaller code, but speed
             // is essential here
             if ( prop2 !== undefined ) {
                     for ( ; i&lt;ien ; i++ ) {
                             if ( a[i] &amp;&amp; a[i][ prop ] ) {
                                     out.push( a[i][ prop ][ prop2 ] );
                             }
                     }
             }
             else {
                     for ( ; i&lt;ien ; i++ ) {
                             if ( a[i] ) {
                                     out.push( a[i][ prop ] );
                             }
                     }
             }

             return out;
     };

     // Basically the same as _pluck, but rather than looping over `a` we use `order`
     // as the indexes to pick from `a`
     var _pluck_order = function ( a, order, prop, prop2 )
     {
             var out = [];
             var i=0, ien=order.length;

             // Could have the test in the loop for slightly smaller code, but speed
             // is essential here
             if ( prop2 !== undefined ) {
                     for ( ; i&lt;ien ; i++ ) {
                             if ( a[ order[i] ][ prop ] ) {
                                     out.push( a[ order[i] ][ prop ][ prop2 ] );
                             }
                     }
             }
             else {
                     for ( ; i&lt;ien ; i++ ) {
                             out.push( a[ order[i] ][ prop ] );
                     }
             }

             return out;
     };

     var _range = function ( len, start )
     {
             var out = [];
             var end;

             if ( start === undefined ) {
                     start = 0;
                     end = len;
             }
             else {
                     end = start;
                     start = len;
             }

             for ( var i=start ; i&lt;end ; i++ ) {
                     out.push( i );
             }

             return out;
     };

     var _removeEmpty = function ( a )
     {
             var out = [];

             for ( var i=0, ien=a.length ; i&lt;ien ; i++ ) {
                     if ( a[i] ) { // careful - will remove all falsy values!
                             out.push( a[i] );
                     }
             }

             return out;
     };

     var _stripHtml = function ( d ) {
             return d.replace( _re_html, &#39;&#39; );
     };

     /**
 Find the unique elements in a source array.

 @param  {array} src Source array
 @return {array} Array of unique items
 @ignore
/
     var _unique = function ( src )
     {
             // A faster unique method is to use object keys to identify used values,
             // but this doesn&#39;t work with arrays or objects, which we must also
             // consider. See jsperf.com/compare-array-unique-versions/4 for more
             // information.
             var
                     out = [],
                     val,
                     i, ien=src.length,
                     j, k=0;

             again: for ( i=0 ; i&lt;ien ; i++ ) {
                     val = src[i];

                     for ( j=0 ; j&lt;k ; j++ ) {
                             if ( out[j] === val ) {
                                     continue again;
                             }
                     }

                     out.push( val );
                     k++;
             }

             return out;
     };

     /**
 Create a mapping object that allows camel case parameters to be looked up
 for their Hungarian counterparts. The mapping is stored in a private
 parameter called `_hungarianMap` which can be accessed on the source object.
  @param {object} o
  @memberof DataTable#oApi
/
     function _fnHungarianMap ( o )
     {
             var
                     hungarian = &#39;a aa ai ao as b fn i m o s &#39;,
                     match,
                     newKey,
                     map = {};

             $.each( o, function (key, val) {
                     match = key.match(/^([^A-Z]+?)([A-Z])/);

                     if ( match &amp;&amp; hungarian.indexOf(match[1]+&#39; &#39;) !== -1 )
                     {
                             newKey = key.replace( match[0], match[2].toLowerCase() );
                             map[ newKey ] = key;

                             if ( match[1] === &#39;o&#39; )
                             {
                                     _fnHungarianMap( o[key] );
                             }
                     }
             } );

             o._hungarianMap = map;
     }

     /**
 Convert from camel case parameters to Hungarian, based on a Hungarian map
 created by _fnHungarianMap.
  @param {object} src The model object which holds all parameters that can be
    mapped.
  @param {object} user The object to convert from camel case to Hungarian.
  @param {boolean} force When set to `true`, properties which already have a
    Hungarian value in the `user` object will be overwritten. Otherwise they
    won&#39;t be.
  @memberof DataTable#oApi
/
     function _fnCamelToHungarian ( src, user, force )
     {
             if ( ! src._hungarianMap ) {
                     _fnHungarianMap( src );
             }

             var hungarianKey;

             $.each( user, function (key, val) {
                     hungarianKey = src._hungarianMap[ key ];

                     if ( hungarianKey !== undefined &amp;&amp; (force || user[hungarianKey] === undefined) )
                     {
                             // For objects, we need to buzz down into the object to copy parameters
                             if ( hungarianKey.charAt(0) === &#39;o&#39; )
                             {
                                     // Copy the camelCase options over to the hungarian
                                     if ( ! user[ hungarianKey ] ) {
                                             user[ hungarianKey ] = {};
                                     }
                                     $.extend( true, user[hungarianKey], user[key] );

                                     _fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
                             }
                             else {
                                     user[hungarianKey] = user[ key ];
                             }
                     }
             } );
     }

     /**
 Language compatibility - when certain options are given, and others aren&#39;t, we
 need to duplicate the values over, in order to provide backwards compatibility
 with older language files.
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnLanguageCompat( lang )
     {
             var defaults = DataTable.defaults.oLanguage;
             var zeroRecords = lang.sZeroRecords;

             /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
  sZeroRecords - assuming that is given.
 /
             if ( ! lang.sEmptyTable &amp;&amp; zeroRecords &amp;&amp;
                     defaults.sEmptyTable === &quot;No data available in table&quot; )
             {
                     _fnMap( lang, lang, &#39;sZeroRecords&#39;, &#39;sEmptyTable&#39; );
             }

             /* Likewise with loading records */
             if ( ! lang.sLoadingRecords &amp;&amp; zeroRecords &amp;&amp;
                     defaults.sLoadingRecords === &quot;Loading...&quot; )
             {
                     _fnMap( lang, lang, &#39;sZeroRecords&#39;, &#39;sLoadingRecords&#39; );
             }

             // Old parameter name of the thousands separator mapped onto the new
             if ( lang.sInfoThousands ) {
                     lang.sThousands = lang.sInfoThousands;
             }

             var decimal = lang.sDecimal;
             if ( decimal ) {
                     _addNumericSort( decimal );
             }
     }

     /**
 Map one parameter onto another
  @param {object} o Object to map
  @param {*} knew The new parameter name
  @param {*} old The old parameter name
/
     var _fnCompatMap = function ( o, knew, old ) {
             if ( o[ knew ] !== undefined ) {
                     o[ old ] = o[ knew ];
             }
     };

     /**
 Provide backwards compatibility for the main DT options. Note that the new
 options are mapped onto the old parameters, so this is an external interface
 change only.
  @param {object} init Object to map
/
     function _fnCompatOpts ( init )
     {
             _fnCompatMap( init, &#39;ordering&#39;,      &#39;bSort&#39; );
             _fnCompatMap( init, &#39;orderMulti&#39;,    &#39;bSortMulti&#39; );
             _fnCompatMap( init, &#39;orderClasses&#39;,  &#39;bSortClasses&#39; );
             _fnCompatMap( init, &#39;orderCellsTop&#39;, &#39;bSortCellsTop&#39; );
             _fnCompatMap( init, &#39;order&#39;,         &#39;aaSorting&#39; );
             _fnCompatMap( init, &#39;orderFixed&#39;,    &#39;aaSortingFixed&#39; );
             _fnCompatMap( init, &#39;paging&#39;,        &#39;bPaginate&#39; );
             _fnCompatMap( init, &#39;pagingType&#39;,    &#39;sPaginationType&#39; );
             _fnCompatMap( init, &#39;pageLength&#39;,    &#39;iDisplayLength&#39; );
             _fnCompatMap( init, &#39;searching&#39;,     &#39;bFilter&#39; );

             // Column search objects are in an array, so it needs to be converted
             // element by element
             var searchCols = init.aoSearchCols;

             if ( searchCols ) {
                     for ( var i=0, ien=searchCols.length ; i&lt;ien ; i++ ) {
                             if ( searchCols[i] ) {
                                     _fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
                             }
                     }
             }
     }

     /**
 Provide backwards compatibility for column options. Note that the new options
 are mapped onto the old parameters, so this is an external interface change
 only.
  @param {object} init Object to map
/
     function _fnCompatCols ( init )
     {
             _fnCompatMap( init, &#39;orderable&#39;,     &#39;bSortable&#39; );
             _fnCompatMap( init, &#39;orderData&#39;,     &#39;aDataSort&#39; );
             _fnCompatMap( init, &#39;orderSequence&#39;, &#39;asSorting&#39; );
             _fnCompatMap( init, &#39;orderDataType&#39;, &#39;sortDataType&#39; );

             // orderData can be given as an integer
             var dataSort = init.aDataSort;
             if ( dataSort &amp;&amp; ! $.isArray( dataSort ) ) {
                     init.aDataSort = [ dataSort ];
             }
     }

     /**
 Browser feature detection for capabilities, quirks
  @param {object} settings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnBrowserDetect( settings )
     {
             var browser = settings.oBrowser;

             // Scrolling feature / quirks detection
             var n = $(&#39;&lt;div/&gt;&#39;)
                     .css( {
                             position: &#39;absolute&#39;,
                             top: 0,
                             left: 0,
                             height: 1,
                             width: 1,
                             overflow: &#39;hidden&#39;
                     } )
                     .append(
                             $(&#39;&lt;div/&gt;&#39;)
                                     .css( {
                                             position: &#39;absolute&#39;,
                                             top: 1,
                                             left: 1,
                                             width: 100,
                                             overflow: &#39;scroll&#39;
                                     } )
                                     .append(
                                             $(&#39;&lt;div class=&quot;test&quot;/&gt;&#39;)
                                                     .css( {
                                                             width: &#39;100%&#39;,
                                                             height: 10
                                                     } )
                                     )
                     )
                     .appendTo( &#39;body&#39; );

             var test = n.find(&#39;.test&#39;);

             // IE6/7 will oversize a width 100% element inside a scrolling element, to
             // include the width of the scrollbar, while other browsers ensure the inner
             // element is contained without forcing scrolling
             browser.bScrollOversize = test[0].offsetWidth === 100;

             // In rtl text layout, some browsers (most, but not all) will place the
             // scrollbar on the left, rather than the right.
             browser.bScrollbarLeft = Math.round( test.offset().left ) !== 1;

             n.remove();
     }

     /**
 Array.prototype reduce[Right] method, used for browsers which don&#39;t support
 JS 1.6. Done this way to reduce code size, since we iterate either way
  @param {object} settings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnReduce ( that, fn, init, start, end, inc )
     {
             var
                     i = start,
                     value,
                     isSet = false;

             if ( init !== undefined ) {
                     value = init;
                     isSet = true;
             }

             while ( i !== end ) {
                     if ( ! that.hasOwnProperty(i) ) {
                             continue;
                     }

                     value = isSet ?
                             fn( value, that[i], i, that ) :
                             that[i];

                     isSet = true;
                     i += inc;
             }

             return value;
     }

     /**
 Add a column to the list used for the table with default values
  @param {object} oSettings dataTables settings object
  @param {node} nTh The th element for this column
  @memberof DataTable#oApi
/
     function _fnAddColumn( oSettings, nTh )
     {
             // Add column to aoColumns array
             var oDefaults = DataTable.defaults.column;
             var iCol = oSettings.aoColumns.length;
             var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
                     &quot;nTh&quot;: nTh ? nTh : document.createElement(&#39;th&#39;),
                     &quot;sTitle&quot;:    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : &#39;&#39;,
                     &quot;aDataSort&quot;: oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
                     &quot;mData&quot;: oDefaults.mData ? oDefaults.mData : iCol,
                     idx: iCol
             } );
             oSettings.aoColumns.push( oCol );

             // Add search object for column specific search. Note that the `searchCols[ iCol ]`
             // passed into extend can be undefined. This allows the user to give a default
             // with only some of the parameters defined, and also not give a default
             var searchCols = oSettings.aoPreSearchCols;
             searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );

             // Use the default column options function to initialise classes etc
             _fnColumnOptions( oSettings, iCol, $(nTh).data() );
     }

     /**
 Apply options for a column
  @param {object} oSettings dataTables settings object
  @param {int} iCol column index to consider
  @param {object} oOptions object with sType, bVisible and bSearchable etc
  @memberof DataTable#oApi
/
     function _fnColumnOptions( oSettings, iCol, oOptions )
     {
             var oCol = oSettings.aoColumns[ iCol ];
             var oClasses = oSettings.oClasses;
             var th = $(oCol.nTh);

             // Try to get width information from the DOM. We can&#39;t get it from CSS
             // as we&#39;d need to parse the CSS stylesheet. `width` option can override
             if ( ! oCol.sWidthOrig ) {
                     // Width attribute
                     oCol.sWidthOrig = th.attr(&#39;width&#39;) || null;

                     // Style attribute
                     var t = (th.attr(&#39;style&#39;) || &#39;&#39;).match(/width:\s*(\d+[pxem%]+)/);
                     if ( t ) {
                             oCol.sWidthOrig = t[1];
                     }
             }

             /* User specified column options */
             if ( oOptions !== undefined &amp;&amp; oOptions !== null )
             {
                     // Backwards compatibility
                     _fnCompatCols( oOptions );

                     // Map camel case parameters to their Hungarian counterparts
                     _fnCamelToHungarian( DataTable.defaults.column, oOptions );

                     /* Backwards compatibility for mDataProp */
                     if ( oOptions.mDataProp !== undefined &amp;&amp; !oOptions.mData )
                     {
                             oOptions.mData = oOptions.mDataProp;
                     }

                     if ( oOptions.sType )
                     {
                             oCol._sManualType = oOptions.sType;
                     }

                     // `class` is a reserved word in Javascript, so we need to provide
                     // the ability to use a valid name for the camel case input
                     if ( oOptions.className &amp;&amp; ! oOptions.sClass )
                     {
                             oOptions.sClass = oOptions.className;
                     }

                     $.extend( oCol, oOptions );
                     _fnMap( oCol, oOptions, &quot;sWidth&quot;, &quot;sWidthOrig&quot; );

                     /* iDataSort to be applied (backwards compatibility), but aDataSort will take
   priority if defined
  /
                     if ( oOptions.iDataSort !== undefined )
                     {
                             oCol.aDataSort = [ oOptions.iDataSort ];
                     }
                     _fnMap( oCol, oOptions, &quot;aDataSort&quot; );
             }

             /* Cache the data get and set functions for speed */
             var mDataSrc = oCol.mData;
             var mData = _fnGetObjectDataFn( mDataSrc );
             var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;

             var attrTest = function( src ) {
                     return typeof src === &#39;string&#39; &amp;&amp; src.indexOf(&#39;@&#39;) !== -1;
             };
             oCol._bAttrSrc = $.isPlainObject( mDataSrc ) &amp;&amp; (
                     attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
             );

             oCol.fnGetData = function (rowData, type, meta) {
                     var innerData = mData( rowData, type, undefined, meta );

                     return mRender &amp;&amp; type ?
                             mRender( innerData, type, rowData, meta ) :
                             innerData;
             };
             oCol.fnSetData = function ( rowData, val, meta ) {
                     return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
             };

             // Indicate if DataTables should read DOM data as an object or array
             // Used in _fnGetRowElements
             if ( typeof mDataSrc !== &#39;number&#39; ) {
                     oSettings._rowReadObject = true;
             }

             /* Feature sorting overrides column specific when off */
             if ( !oSettings.oFeatures.bSort )
             {
                     oCol.bSortable = false;
                     th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn&#39;t called
             }

             /* Check that the class assignment is correct for sorting */
             var bAsc = $.inArray(&#39;asc&#39;, oCol.asSorting) !== -1;
             var bDesc = $.inArray(&#39;desc&#39;, oCol.asSorting) !== -1;
             if ( !oCol.bSortable || (!bAsc &amp;&amp; !bDesc) )
             {
                     oCol.sSortingClass = oClasses.sSortableNone;
                     oCol.sSortingClassJUI = &quot;&quot;;
             }
             else if ( bAsc &amp;&amp; !bDesc )
             {
                     oCol.sSortingClass = oClasses.sSortableAsc;
                     oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
             }
             else if ( !bAsc &amp;&amp; bDesc )
             {
                     oCol.sSortingClass = oClasses.sSortableDesc;
                     oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
             }
             else
             {
                     oCol.sSortingClass = oClasses.sSortable;
                     oCol.sSortingClassJUI = oClasses.sSortJUI;
             }
     }

     /**
 Adjust the table column widths for new data. Note: you would probably want to
 do a redraw after calling this function!
  @param {object} settings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnAdjustColumnSizing ( settings )
     {
             /* Not interested in doing column width calculation if auto-width is disabled */
             if ( settings.oFeatures.bAutoWidth !== false )
             {
                     var columns = settings.aoColumns;

                     _fnCalculateColumnWidths( settings );
                     for ( var i=0 , iLen=columns.length ; i&lt;iLen ; i++ )
                     {
                             columns[i].nTh.style.width = columns[i].sWidth;
                     }
             }

             var scroll = settings.oScroll;
             if ( scroll.sY !== &#39;&#39; || scroll.sX !== &#39;&#39;)
             {
                     _fnScrollDraw( settings );
             }

             _fnCallbackFire( settings, null, &#39;column-sizing&#39;, [settings] );
     }

     /**
 Covert the index of a visible column to the index in the data array (take account
 of hidden columns)
  @param {object} oSettings dataTables settings object
  @param {int} iMatch Visible column index to lookup
  @returns {int} i the data index
  @memberof DataTable#oApi
/
     function _fnVisibleToColumnIndex( oSettings, iMatch )
     {
             var aiVis = _fnGetColumns( oSettings, &#39;bVisible&#39; );

             return typeof aiVis[iMatch] === &#39;number&#39; ?
                     aiVis[iMatch] :
                     null;
     }

     /**
 Covert the index of an index in the data array and convert it to the visible
   column index (take account of hidden columns)
  @param {int} iMatch Column index to lookup
  @param {object} oSettings dataTables settings object
  @returns {int} i the data index
  @memberof DataTable#oApi
/
     function _fnColumnIndexToVisible( oSettings, iMatch )
     {
             var aiVis = _fnGetColumns( oSettings, &#39;bVisible&#39; );
             var iPos = $.inArray( iMatch, aiVis );

             return iPos !== -1 ? iPos : null;
     }

     /**
 Get the number of visible columns
  @param {object} oSettings dataTables settings object
  @returns {int} i the number of visible columns
  @memberof DataTable#oApi
/
     function _fnVisbleColumns( oSettings )
     {
             return _fnGetColumns( oSettings, &#39;bVisible&#39; ).length;
     }

     /**
 Get an array of column indexes that match a given property
  @param {object} oSettings dataTables settings object
  @param {string} sParam Parameter in aoColumns to look for - typically
    bVisible or bSearchable
  @returns {array} Array of indexes with matched properties
  @memberof DataTable#oApi
/
     function _fnGetColumns( oSettings, sParam )
     {
             var a = [];

             $.map( oSettings.aoColumns, function(val, i) {
                     if ( val[sParam] ) {
                             a.push( i );
                     }
             } );

             return a;
     }

     /**
 Calculate the &#39;type&#39; of a column
  @param {object} settings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnColumnTypes ( settings )
     {
             var columns = settings.aoColumns;
             var data = settings.aoData;
             var types = DataTable.ext.type.detect;
             var i, ien, j, jen, k, ken;
             var col, cell, detectedType, cache;

             // For each column, spin over the 
             for ( i=0, ien=columns.length ; i&lt;ien ; i++ ) {
                     col = columns[i];
                     cache = [];

                     if ( ! col.sType &amp;&amp; col._sManualType ) {
                             col.sType = col._sManualType;
                     }
                     else if ( ! col.sType ) {
                             for ( j=0, jen=types.length ; j&lt;jen ; j++ ) {
                                     for ( k=0, ken=data.length ; k&lt;ken ; k++ ) {
                                             // Use a cache array so we only need to get the type data
                                             // from the formatter once (when using multiple detectors)
                                             if ( cache[k] === undefined ) {
                                                     cache[k] = _fnGetCellData( settings, k, i, &#39;type&#39; );
                                             }

                                             detectedType = types[j]( cache[k], settings );

                                             // If null, then this type can&#39;t apply to this column, so
                                             // rather than testing all cells, break out. There is an
                                             // exception for the last type which is `html`. We need to
                                             // scan all rows since it is possible to mix string and HTML
                                             // types
                                             if ( ! detectedType &amp;&amp; j !== types.length-1 ) {
                                                     break;
                                             }

                                             // Only a single match is needed for html type since it is
                                             // bottom of the pile and very similar to string
                                             if ( detectedType === &#39;html&#39; ) {
                                                     break;
                                             }
                                     }

                                     // Type is valid for all data points in the column - use this
                                     // type
                                     if ( detectedType ) {
                                             col.sType = detectedType;
                                             break;
                                     }
                             }

                             // Fall back - if no type was detected, always use string
                             if ( ! col.sType ) {
                                     col.sType = &#39;string&#39;;
                             }
                     }
             }
     }

     /**
 Take the column definitions and static columns arrays and calculate how
 they relate to column indexes. The callback function will then apply the
 definition found for a column to a suitable configuration object.
  @param {object} oSettings dataTables settings object
  @param {array} aoColDefs The aoColumnDefs array that is to be applied
  @param {array} aoCols The aoColumns array that defines columns individually
  @param {function} fn Callback function - takes two parameters, the calculated
    column index and the definition for that column.
  @memberof DataTable#oApi
/
     function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
     {
             var i, iLen, j, jLen, k, kLen, def;
             var columns = oSettings.aoColumns;

             // Column definitions with aTargets
             if ( aoColDefs )
             {
                     /* Loop over the definitions array - loop in reverse so first instance has priority */
                     for ( i=aoColDefs.length-1 ; i&gt;=0 ; i-- )
                     {
                             def = aoColDefs[i];

                             /* Each definition can target multiple columns, as it is an array */
                             var aTargets = def.targets !== undefined ?
                                     def.targets :
                                     def.aTargets;

                             if ( ! $.isArray( aTargets ) )
                             {
                                     aTargets = [ aTargets ];
                             }

                             for ( j=0, jLen=aTargets.length ; j&lt;jLen ; j++ )
                             {
                                     if ( typeof aTargets[j] === &#39;number&#39; &amp;&amp; aTargets[j] &gt;= 0 )
                                     {
                                             /* Add columns that we don&#39;t yet know about */
                                             while( columns.length &lt;= aTargets[j] )
                                             {
                                                     _fnAddColumn( oSettings );
                                             }

                                             /* Integer, basic index */
                                             fn( aTargets[j], def );
                                     }
                                     else if ( typeof aTargets[j] === &#39;number&#39; &amp;&amp; aTargets[j] &lt; 0 )
                                     {
                                             /* Negative integer, right to left column counting */
                                             fn( columns.length+aTargets[j], def );
                                     }
                                     else if ( typeof aTargets[j] === &#39;string&#39; )
                                     {
                                             /* Class name matching on TH element */
                                             for ( k=0, kLen=columns.length ; k&lt;kLen ; k++ )
                                             {
                                                     if ( aTargets[j] == &quot;_all&quot; ||
                                                          $(columns[k].nTh).hasClass( aTargets[j] ) )
                                                     {
                                                             fn( k, def );
                                                     }
                                             }
                                     }
                             }
                     }
             }

             // Statically defined columns array
             if ( aoCols )
             {
                     for ( i=0, iLen=aoCols.length ; i&lt;iLen ; i++ )
                     {
                             fn( i, aoCols[i] );
                     }
             }
     }

     /**
 Add a data array to the table, creating DOM node etc. This is the parallel to
 _fnGatherData, but for adding rows from a Javascript source, rather than a
 DOM source.
  @param {object} oSettings dataTables settings object
  @param {array} aData data array to be added
  @param {node} [nTr] TR element to add to the table - optional. If not given,
    DataTables will create a row automatically
  @param {array} [anTds] Array of TD|TH elements for the row - must be given
    if nTr is.
  @returns {int} &gt;=0 if successful (index of new aoData entry), -1 if failed
  @memberof DataTable#oApi
/
     function _fnAddData ( oSettings, aDataIn, nTr, anTds )
     {
             /* Create the object for storing information about this new row */
             var iRow = oSettings.aoData.length;
             var oData = $.extend( true, {}, DataTable.models.oRow, {
                     src: nTr ? &#39;dom&#39; : &#39;data&#39;
             } );

             oData._aData = aDataIn;
             oSettings.aoData.push( oData );

             /* Create the cells */
             var nTd, sThisType;
             var columns = oSettings.aoColumns;
             for ( var i=0, iLen=columns.length ; i&lt;iLen ; i++ )
             {
                     // When working with a row, the data source object must be populated. In
                     // all other cases, the data source object is already populated, so we
                     // don&#39;t overwrite it, which might break bindings etc
                     if ( nTr ) {
                             _fnSetCellData( oSettings, iRow, i, _fnGetCellData( oSettings, iRow, i ) );
                     }
                     columns[i].sType = null;
             }

             /* Add to the display array */
             oSettings.aiDisplayMaster.push( iRow );

             /* Create the DOM information, or register it if already present */
             if ( nTr || ! oSettings.oFeatures.bDeferRender )
             {
                     _fnCreateTr( oSettings, iRow, nTr, anTds );
             }

             return iRow;
     }

     /**
 Add one or more TR elements to the table. Generally we&#39;d expect to
 use this for reading data from a DOM sourced table, but it could be
 used for an TR element. Note that if a TR is given, it is used (i.e.
 it is not cloned).
  @param {object} settings dataTables settings object
  @param {array|node|jQuery} trs The TR element(s) to add to the table
  @returns {array} Array of indexes for the added rows
  @memberof DataTable#oApi
/
     function _fnAddTr( settings, trs )
     {
             var row;

             // Allow an individual node to be passed in
             if ( ! (trs instanceof $) ) {
                     trs = $(trs);
             }

             return trs.map( function (i, el) {
                     row = _fnGetRowElements( settings, el );
                     return _fnAddData( settings, row.data, el, row.cells );
             } );
     }

     /**
 Take a TR element and convert it to an index in aoData
  @param {object} oSettings dataTables settings object
  @param {node} n the TR element to find
  @returns {int} index if the node is found, null if not
  @memberof DataTable#oApi
/
     function _fnNodeToDataIndex( oSettings, n )
     {
             return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
     }

     /**
 Take a TD element and convert it into a column data index (not the visible index)
  @param {object} oSettings dataTables settings object
  @param {int} iRow The row number the TD/TH can be found in
  @param {node} n The TD/TH element to find
  @returns {int} index if the node is found, -1 if not
  @memberof DataTable#oApi
/
     function _fnNodeToColumnIndex( oSettings, iRow, n )
     {
             return $.inArray( n, oSettings.aoData[ iRow ].anCells );
     }

     /**
 Get the data for a given cell from the internal cache, taking into account data mapping
  @param {object} settings dataTables settings object
  @param {int} rowIdx aoData row id
  @param {int} colIdx Column index
  @param {string} type data get type (&#39;display&#39;, &#39;type&#39; &#39;filter&#39; &#39;sort&#39;)
  @returns {*} Cell data
  @memberof DataTable#oApi
/
     function _fnGetCellData( settings, rowIdx, colIdx, type )
     {
             var draw           = settings.iDraw;
             var col            = settings.aoColumns[colIdx];
             var rowData        = settings.aoData[rowIdx]._aData;
             var defaultContent = col.sDefaultContent;
             var cellData       = col.fnGetData( rowData, type, {
                     settings: settings,
                     row:      rowIdx,
                     col:      colIdx
             } );

             if ( cellData === undefined ) {
                     if ( settings.iDrawError != draw &amp;&amp; defaultContent === null ) {
                             _fnLog( settings, 0, &quot;Requested unknown parameter &quot;+
                                     (typeof col.mData==&#39;function&#39; ? &#39;{function}&#39; : &quot;&#39;&quot;+col.mData+&quot;&#39;&quot;)+
                                     &quot; for row &quot;+rowIdx, 4 );
                             settings.iDrawError = draw;
                     }
                     return defaultContent;
             }

             /* When the data source is null, we can use default column data */
             if ( (cellData === rowData || cellData === null) &amp;&amp; defaultContent !== null ) {
                     cellData = defaultContent;
             }
             else if ( typeof cellData === &#39;function&#39; ) {
                     // If the data source is a function, then we run it and use the return,
                     // executing in the scope of the data object (for instances)
                     return cellData.call( rowData );
             }

             if ( cellData === null &amp;&amp; type == &#39;display&#39; ) {
                     return &#39;&#39;;
             }
             return cellData;
     }

     /**
 Set the value for a specific cell, into the internal data cache
  @param {object} settings dataTables settings object
  @param {int} rowIdx aoData row id
  @param {int} colIdx Column index
  @param {*} val Value to set
  @memberof DataTable#oApi
/
     function _fnSetCellData( settings, rowIdx, colIdx, val )
     {
             var col     = settings.aoColumns[colIdx];
             var rowData = settings.aoData[rowIdx]._aData;

             col.fnSetData( rowData, val, {
                     settings: settings,
                     row:      rowIdx,
                     col:      colIdx
             }  );
     }

     // Private variable that is used to match action syntax in the data property object
     var __reArray = /\[.*?\]$/;
     var __reFn = /\(\)$/;

     /**
 Split string on periods, taking into account escaped periods
 @param  {string} str String to split
 @return {array} Split string
/
     function _fnSplitObjNotation( str )
     {
             return $.map( str.match(/(\\.|[^\.])+/g), function ( s ) {
                     return s.replace(/\\./g, &#39;.&#39;);
             } );
     }

     /**
 Return a function that can be used to get data from a source object, taking
 into account the ability to use nested objects as a source
  @param {string|int|function} mSource The data source for the object
  @returns {function} Data get function
  @memberof DataTable#oApi
/
     function _fnGetObjectDataFn( mSource )
     {
             if ( $.isPlainObject( mSource ) )
             {
                     /* Build an object of get functions, and wrap them in a single call */
                     var o = {};
                     $.each( mSource, function (key, val) {
                             if ( val ) {
                                     o[key] = _fnGetObjectDataFn( val );
                             }
                     } );

                     return function (data, type, row, meta) {
                             var t = o[type] || o._;
                             return t !== undefined ?
                                     t(data, type, row, meta) :
                                     data;
                     };
             }
             else if ( mSource === null )
             {
                     /* Give an empty string for rendering / sorting etc */
                     return function (data) { // type, row and meta also passed, but not used
                             return data;
                     };
             }
             else if ( typeof mSource === &#39;function&#39; )
             {
                     return function (data, type, row, meta) {
                             return mSource( data, type, row, meta );
                     };
             }
             else if ( typeof mSource === &#39;string&#39; &amp;&amp; (mSource.indexOf(&#39;.&#39;) !== -1 ||
                           mSource.indexOf(&#39;[&#39;) !== -1 || mSource.indexOf(&#39;(&#39;) !== -1) )
             {
                     /* If there is a . in the source string then the data source is in a
   nested object so we loop over the data for each level to get the next
   level down. On each loop we test for undefined, and if found immediately
   return. This allows entire objects to be missing and sDefaultContent to
   be used if defined, rather than throwing an error
  /
                     var fetchData = function (data, type, src) {
                             var arrayNotation, funcNotation, out, innerSrc;

                             if ( src !== &quot;&quot; )
                             {
                                     var a = _fnSplitObjNotation( src );

                                     for ( var i=0, iLen=a.length ; i&lt;iLen ; i++ )
                                     {
                                             // Check if we are dealing with special notation
                                             arrayNotation = a[i].match(__reArray);
                                             funcNotation = a[i].match(__reFn);

                                             if ( arrayNotation )
                                             {
                                                     // Array notation
                                                     a[i] = a[i].replace(__reArray, &#39;&#39;);

                                                     // Condition allows simply [] to be passed in
                                                     if ( a[i] !== &quot;&quot; ) {
                                                             data = data[ a[i] ];
                                                     }
                                                     out = [];

                                                     // Get the remainder of the nested object to get
                                                     a.splice( 0, i+1 );
                                                     innerSrc = a.join(&#39;.&#39;);

                                                     // Traverse each entry in the array getting the properties requested
                                                     for ( var j=0, jLen=data.length ; j&lt;jLen ; j++ ) {
                                                             out.push( fetchData( data[j], type, innerSrc ) );
                                                     }

                                                     // If a string is given in between the array notation indicators, that
                                                     // is used to join the strings together, otherwise an array is returned
                                                     var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
                                                     data = (join===&quot;&quot;) ? out : out.join(join);

                                                     // The inner call to fetchData has already traversed through the remainder
                                                     // of the source requested, so we exit from the loop
                                                     break;
                                             }
                                             else if ( funcNotation )
                                             {
                                                     // Function call
                                                     a[i] = a[i].replace(__reFn, &#39;&#39;);
                                                     data = data[ a[i] ]();
                                                     continue;
                                             }

                                             if ( data === null || data[ a[i] ] === undefined )
                                             {
                                                     return undefined;
                                             }
                                             data = data[ a[i] ];
                                     }
                             }

                             return data;
                     };

                     return function (data, type) { // row and meta also passed, but not used
                             return fetchData( data, type, mSource );
                     };
             }
             else
             {
                     /* Array or flat object mapping */
                     return function (data, type) { // row and meta also passed, but not used
                             return data[mSource];
                     };
             }
     }

     /**
 Return a function that can be used to set data from a source object, taking
 into account the ability to use nested objects as a source
  @param {string|int|function} mSource The data source for the object
  @returns {function} Data set function
  @memberof DataTable#oApi
/
     function _fnSetObjectDataFn( mSource )
     {
             if ( $.isPlainObject( mSource ) )
             {
                     /* Unlike get, only the underscore (global) option is used for for
   setting data since we don&#39;t know the type here. This is why an object
   option is not documented for `mData` (which is read/write), but it is
   for `mRender` which is read only.
  /
                     return _fnSetObjectDataFn( mSource._ );
             }
             else if ( mSource === null )
             {
                     /* Nothing to do when the data source is null */
                     return function () {};
             }
             else if ( typeof mSource === &#39;function&#39; )
             {
                     return function (data, val, meta) {
                             mSource( data, &#39;set&#39;, val, meta );
                     };
             }
             else if ( typeof mSource === &#39;string&#39; &amp;&amp; (mSource.indexOf(&#39;.&#39;) !== -1 ||
                           mSource.indexOf(&#39;[&#39;) !== -1 || mSource.indexOf(&#39;(&#39;) !== -1) )
             {
                     /* Like the get, we need to get data from a nested object */
                     var setData = function (data, val, src) {
                             var a = _fnSplitObjNotation( src ), b;
                             var aLast = a[a.length-1];
                             var arrayNotation, funcNotation, o, innerSrc;

                             for ( var i=0, iLen=a.length-1 ; i&lt;iLen ; i++ )
                             {
                                     // Check if we are dealing with an array notation request
                                     arrayNotation = a[i].match(__reArray);
                                     funcNotation = a[i].match(__reFn);

                                     if ( arrayNotation )
                                     {
                                             a[i] = a[i].replace(__reArray, &#39;&#39;);
                                             data[ a[i] ] = [];

                                             // Get the remainder of the nested object to set so we can recurse
                                             b = a.slice();
                                             b.splice( 0, i+1 );
                                             innerSrc = b.join(&#39;.&#39;);

                                             // Traverse each entry in the array setting the properties requested
                                             for ( var j=0, jLen=val.length ; j&lt;jLen ; j++ )
                                             {
                                                     o = {};
                                                     setData( o, val[j], innerSrc );
                                                     data[ a[i] ].push( o );
                                             }

                                             // The inner call to setData has already traversed through the remainder
                                             // of the source and has set the data, thus we can exit here
                                             return;
                                     }
                                     else if ( funcNotation )
                                     {
                                             // Function call
                                             a[i] = a[i].replace(__reFn, &#39;&#39;);
                                             data = data[ a[i] ]( val );
                                     }

                                     // If the nested object doesn&#39;t currently exist - since we are
                                     // trying to set the value - create it
                                     if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
                                     {
                                             data[ a[i] ] = {};
                                     }
                                     data = data[ a[i] ];
                             }

                             // Last item in the input - i.e, the actual set
                             if ( aLast.match(__reFn ) )
                             {
                                     // Function call
                                     data = data[ aLast.replace(__reFn, &#39;&#39;) ]( val );
                             }
                             else
                             {
                                     // If array notation is used, we just want to strip it and use the property name
                                     // and assign the value. If it isn&#39;t used, then we get the result we want anyway
                                     data[ aLast.replace(__reArray, &#39;&#39;) ] = val;
                             }
                     };

                     return function (data, val) { // meta is also passed in, but not used
                             return setData( data, val, mSource );
                     };
             }
             else
             {
                     /* Array or flat object mapping */
                     return function (data, val) { // meta is also passed in, but not used
                             data[mSource] = val;
                     };
             }
     }

     /**
 Return an array with the full table data
  @param {object} oSettings dataTables settings object
  @returns array {array} aData Master data array
  @memberof DataTable#oApi
/
     function _fnGetDataMaster ( settings )
     {
             return _pluck( settings.aoData, &#39;_aData&#39; );
     }

     /**
 Nuke the table
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnClearTable( settings )
     {
             settings.aoData.length = 0;
             settings.aiDisplayMaster.length = 0;
             settings.aiDisplay.length = 0;
     }

      /**
 Take an array of integers (index array) and remove a target integer (value - not
 the key!)
  @param {array} a Index array to target
  @param {int} iTarget value to find
  @memberof DataTable#oApi
/
     function _fnDeleteIndex( a, iTarget, splice )
     {
             var iTargetIndex = -1;

             for ( var i=0, iLen=a.length ; i&lt;iLen ; i++ )
             {
                     if ( a[i] == iTarget )
                     {
                             iTargetIndex = i;
                     }
                     else if ( a[i] &gt; iTarget )
                     {
                             a[i]--;
                     }
             }

             if ( iTargetIndex != -1 &amp;&amp; splice === undefined )
             {
                     a.splice( iTargetIndex, 1 );
             }
     }

     /**
 Mark cached data as invalid such that a re-read of the data will occur when
 the cached data is next requested. Also update from the data source object.

 @param {object} settings DataTables settings object
 @param {int}    rowIdx   Row index to invalidate
 @param {string} [src]    Source to invalidate from: undefined, &#39;auto&#39;, &#39;dom&#39;
     or &#39;data&#39;
 @param {int}    [colIdx] Column index to invalidate. If undefined the whole
     row will be invalidated
 @memberof DataTable#oApi

 @todo For the modularisation of v1.11 this will need to become a callback, so
   the sort and filter methods can subscribe to it. That will required
   initialisation options for sorting, which is why it is not already baked in
/
     function _fnInvalidate( settings, rowIdx, src, colIdx )
     {
             var row = settings.aoData[ rowIdx ];
             var i, ien;
             var cellWrite = function ( cell, col ) {
                     // This is very frustrating, but in IE if you just write directly
                     // to innerHTML, and elements that are overwritten are GC&#39;ed,
                     // even if there is a reference to them elsewhere
                     while ( cell.childNodes.length ) {
                             cell.removeChild( cell.firstChild );
                     }

                     cell.innerHTML = _fnGetCellData( settings, rowIdx, col, &#39;display&#39; );
             };

             // Are we reading last data from DOM or the data object?
             if ( src === &#39;dom&#39; || ((! src || src === &#39;auto&#39;) &amp;&amp; row.src === &#39;dom&#39;) ) {
                     // Read the data from the DOM
                     row._aData = _fnGetRowElements(
                                     settings, row, colIdx, colIdx === undefined ? undefined : row._aData
                             )
                             .data;
             }
             else {
                     // Reading from data object, update the DOM
                     var cells = row.anCells;

                     if ( cells ) {
                             if ( colIdx !== undefined ) {
                                     cellWrite( cells[colIdx], colIdx );
                             }
                             else {
                                     for ( i=0, ien=cells.length ; i&lt;ien ; i++ ) {
                                             cellWrite( cells[i], i );
                                     }
                             }
                     }
             }

             // For both row and cell invalidation, the cached data for sorting and
             // filtering is nulled out
             row._aSortData = null;
             row._aFilterData = null;

             // Invalidate the type for a specific column (if given) or all columns since
             // the data might have changed
             var cols = settings.aoColumns;
             if ( colIdx !== undefined ) {
                     cols[ colIdx ].sType = null;
             }
             else {
                     for ( i=0, ien=cols.length ; i&lt;ien ; i++ ) {
                             cols[i].sType = null;
                     }

                     // Update DataTables special `DT_*` attributes for the row
                     _fnRowAttributes( row );
             }
     }

     /**
 Build a data source object from an HTML row, reading the contents of the
 cells that are in the row.

 @param {object} settings DataTables settings object
 @param {node|object} TR element from which to read data or existing row
   object from which to re-read the data from the cells
 @param {int} [colIdx] Optional column index
 @param {array|object} [d] Data source object. If `colIdx` is given then this
   parameter should also be given and will be used to write the data into.
   Only the column in question will be written
 @returns {object} Object with two parameters: `data` the data read, in
   document order, and `cells` and array of nodes (they can be useful to the
   caller, so rather than needing a second traversal to get them, just return
   them from here).
 @memberof DataTable#oApi
/
     function _fnGetRowElements( settings, row, colIdx, d )
     {
             var
                     tds = [],
                     td = row.firstChild,
                     name, col, o, i=0, contents,
                     columns = settings.aoColumns,
                     objectRead = settings._rowReadObject;

             // Allow the data object to be passed in, or construct
             d = d || objectRead ? {} : [];

             var attr = function ( str, td  ) {
                     if ( typeof str === &#39;string&#39; ) {
                             var idx = str.indexOf(&#39;@&#39;);

                             if ( idx !== -1 ) {
                                     var attr = str.substring( idx+1 );
                                     var setter = _fnSetObjectDataFn( str );
                                     setter( d, td.getAttribute( attr ) );
                             }
                     }
             };

             // Read data from a cell and store into the data object
             var cellProcess = function ( cell ) {
                     if ( colIdx === undefined || colIdx === i ) {
                             col = columns[i];
                             contents = $.trim(cell.innerHTML);

                             if ( col &amp;&amp; col._bAttrSrc ) {
                                     var setter = _fnSetObjectDataFn( col.mData._ );
                                     setter( d, contents );

                                     attr( col.mData.sort, cell );
                                     attr( col.mData.type, cell );
                                     attr( col.mData.filter, cell );
                             }
                             else {
                                     // Depending on the `data` option for the columns the data can
                                     // be read to either an object or an array.
                                     if ( objectRead ) {
                                             if ( ! col._setter ) {
                                                     // Cache the setter function
                                                     col._setter = _fnSetObjectDataFn( col.mData );
                                             }
                                             col._setter( d, contents );
                                     }
                                     else {
                                             d[i] = contents;
                                     }
                             }
                     }

                     i++;
             };

             if ( td ) {
                     // `tr` element was passed in
                     while ( td ) {
                             name = td.nodeName.toUpperCase();

                             if ( name == &quot;TD&quot; || name == &quot;TH&quot; ) {
                                     cellProcess( td );
                                     tds.push( td );
                             }

                             td = td.nextSibling;
                     }
             }
             else {
                     // Existing row object passed in
                     tds = row.anCells;

                     for ( var j=0, jen=tds.length ; j&lt;jen ; j++ ) {
                             cellProcess( tds[j] );
                     }
             }

             return {
                     data: d,
                     cells: tds
             };
     }
     /**
 Create a new TR element (and it&#39;s TD children) for a row
  @param {object} oSettings dataTables settings object
  @param {int} iRow Row to consider
  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
    DataTables will create a row automatically
  @param {array} [anTds] Array of TD|TH elements for the row - must be given
    if nTr is.
  @memberof DataTable#oApi
/
     function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
     {
             var
                     row = oSettings.aoData[iRow],
                     rowData = row._aData,
                     cells = [],
                     nTr, nTd, oCol,
                     i, iLen;

             if ( row.nTr === null )
             {
                     nTr = nTrIn || document.createElement(&#39;tr&#39;);

                     row.nTr = nTr;
                     row.anCells = cells;

                     /* Use a private property on the node to allow reserve mapping from the node
   to the aoData array for fast look up
  /
                     nTr._DT_RowIndex = iRow;

                     /* Special parameters can be given by the data source to be used on the row */
                     _fnRowAttributes( row );

                     /* Process each column */
                     for ( i=0, iLen=oSettings.aoColumns.length ; i&lt;iLen ; i++ )
                     {
                             oCol = oSettings.aoColumns[i];

                             nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );
                             cells.push( nTd );

                             // Need to create the HTML if new, or if a rendering function is defined
                             if ( !nTrIn || oCol.mRender || oCol.mData !== i )
                             {
                                     nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, &#39;display&#39; );
                             }

                             /* Add user defined class */
                             if ( oCol.sClass )
                             {
                                     nTd.className += &#39; &#39;+oCol.sClass;
                             }

                             // Visibility - add or remove as required
                             if ( oCol.bVisible &amp;&amp; ! nTrIn )
                             {
                                     nTr.appendChild( nTd );
                             }
                             else if ( ! oCol.bVisible &amp;&amp; nTrIn )
                             {
                                     nTd.parentNode.removeChild( nTd );
                             }

                             if ( oCol.fnCreatedCell )
                             {
                                     oCol.fnCreatedCell.call( oSettings.oInstance,
                                             nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
                                     );
                             }
                     }

                     _fnCallbackFire( oSettings, &#39;aoRowCreatedCallback&#39;, null, [nTr, rowData, iRow] );
             }

             // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
             // and deployed
             row.nTr.setAttribute( &#39;role&#39;, &#39;row&#39; );
     }

     /**
 Add attributes to a row based on the special `DT_*` parameters in a data
 source object.
  @param {object} DataTables row object for the row to be modified
  @memberof DataTable#oApi
/
     function _fnRowAttributes( row )
     {
             var tr = row.nTr;
             var data = row._aData;

             if ( tr ) {
                     if ( data.DT_RowId ) {
                             tr.id = data.DT_RowId;
                     }

                     if ( data.DT_RowClass ) {
                             // Remove any classes added by DT_RowClass before
                             var a = data.DT_RowClass.split(&#39; &#39;);
                             row.__rowc = row.__rowc ?
                                     _unique( row.__rowc.concat( a ) ) :
                                     a;

                             $(tr)
                                     .removeClass( row.__rowc.join(&#39; &#39;) )
                                     .addClass( data.DT_RowClass );
                     }

                     if ( data.DT_RowAttr ) {
                             $(tr).attr( data.DT_RowAttr );
                     }

                     if ( data.DT_RowData ) {
                             $(tr).data( data.DT_RowData );
                     }
             }
     }

     /**
 Create the HTML header for the table
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnBuildHead( oSettings )
     {
             var i, ien, cell, row, column;
             var thead = oSettings.nTHead;
             var tfoot = oSettings.nTFoot;
             var createHeader = $(&#39;th, td&#39;, thead).length === 0;
             var classes = oSettings.oClasses;
             var columns = oSettings.aoColumns;

             if ( createHeader ) {
                     row = $(&#39;&lt;tr/&gt;&#39;).appendTo( thead );
             }

             for ( i=0, ien=columns.length ; i&lt;ien ; i++ ) {
                     column = columns[i];
                     cell = $( column.nTh ).addClass( column.sClass );

                     if ( createHeader ) {
                             cell.appendTo( row );
                     }

                     // 1.11 move into sorting
                     if ( oSettings.oFeatures.bSort ) {
                             cell.addClass( column.sSortingClass );

                             if ( column.bSortable !== false ) {
                                     cell
                                             .attr( &#39;tabindex&#39;, oSettings.iTabIndex )
                                             .attr( &#39;aria-controls&#39;, oSettings.sTableId );

                                     _fnSortAttachListener( oSettings, column.nTh, i );
                             }
                     }

                     if ( column.sTitle != cell.html() ) {
                             cell.html( column.sTitle );
                     }

                     _fnRenderer( oSettings, &#39;header&#39; )(
                             oSettings, cell, column, classes
                     );
             }

             if ( createHeader ) {
                     _fnDetectHeader( oSettings.aoHeader, thead );
             }

             /* ARIA role for the rows */
             $(thead).find(&#39;&gt;tr&#39;).attr(&#39;role&#39;, &#39;row&#39;);

             /* Deal with the footer - add classes if required */
             $(thead).find(&#39;&gt;tr&gt;th, &gt;tr&gt;td&#39;).addClass( classes.sHeaderTH );
             $(tfoot).find(&#39;&gt;tr&gt;th, &gt;tr&gt;td&#39;).addClass( classes.sFooterTH );

             // Cache the footer cells. Note that we only take the cells from the first
             // row in the footer. If there is more than one row the user wants to
             // interact with, they need to use the table().foot() method. Note also this
             // allows cells to be used for multiple columns using colspan
             if ( tfoot !== null ) {
                     var cells = oSettings.aoFooter[0];

                     for ( i=0, ien=cells.length ; i&lt;ien ; i++ ) {
                             column = columns[i];
                             column.nTf = cells[i].cell;

                             if ( column.sClass ) {
                                     $(column.nTf).addClass( column.sClass );
                             }
                     }
             }
     }

     /**
 Draw the header (or footer) element based on the column visibility states. The
 methodology here is to use the layout array from _fnDetectHeader, modified for
 the instantaneous column visibility, to construct the new layout. The grid is
 traversed over cell at a time in a rows x columns grid fashion, although each
 cell insert can cover multiple elements in the grid - which is tracks using the
 aApplied array. Cell inserts in the grid will only occur where there isn&#39;t
 already a cell in that position.
  @param {object} oSettings dataTables settings object
  @param array {objects} aoSource Layout array from _fnDetectHeader
  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
  @memberof DataTable#oApi
/
     function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
     {
             var i, iLen, j, jLen, k, kLen, n, nLocalTr;
             var aoLocal = [];
             var aApplied = [];
             var iColumns = oSettings.aoColumns.length;
             var iRowspan, iColspan;

             if ( ! aoSource )
             {
                     return;
             }

             if (  bIncludeHidden === undefined )
             {
                     bIncludeHidden = false;
             }

             /* Make a copy of the master layout array, but without the visible columns in it */
             for ( i=0, iLen=aoSource.length ; i&lt;iLen ; i++ )
             {
                     aoLocal[i] = aoSource[i].slice();
                     aoLocal[i].nTr = aoSource[i].nTr;

                     /* Remove any columns which are currently hidden */
                     for ( j=iColumns-1 ; j&gt;=0 ; j-- )
                     {
                             if ( !oSettings.aoColumns[j].bVisible &amp;&amp; !bIncludeHidden )
                             {
                                     aoLocal[i].splice( j, 1 );
                             }
                     }

                     /* Prep the applied array - it needs an element for each row */
                     aApplied.push( [] );
             }

             for ( i=0, iLen=aoLocal.length ; i&lt;iLen ; i++ )
             {
                     nLocalTr = aoLocal[i].nTr;

                     /* All cells are going to be replaced, so empty out the row */
                     if ( nLocalTr )
                     {
                             while( (n = nLocalTr.firstChild) )
                             {
                                     nLocalTr.removeChild( n );
                             }
                     }

                     for ( j=0, jLen=aoLocal[i].length ; j&lt;jLen ; j++ )
                     {
                             iRowspan = 1;
                             iColspan = 1;

                             /* Check to see if there is already a cell (row/colspan) covering our target
    insert point. If there is, then there is nothing to do.
   /
                             if ( aApplied[i][j] === undefined )
                             {
                                     nLocalTr.appendChild( aoLocal[i][j].cell );
                                     aApplied[i][j] = 1;

                                     /* Expand the cell to cover as many rows as needed */
                                     while ( aoLocal[i+iRowspan] !== undefined &amp;&amp;
                                             aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
                                     {
                                             aApplied[i+iRowspan][j] = 1;
                                             iRowspan++;
                                     }

                                     /* Expand the cell to cover as many columns as needed */
                                     while ( aoLocal[i][j+iColspan] !== undefined &amp;&amp;
                                             aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
                                     {
                                             /* Must update the applied array over the rows for the columns */
                                             for ( k=0 ; k&lt;iRowspan ; k++ )
                                             {
                                                     aApplied[i+k][j+iColspan] = 1;
                                             }
                                             iColspan++;
                                     }

                                     /* Do the actual expansion in the DOM */
                                     $(aoLocal[i][j].cell)
                                             .attr(&#39;rowspan&#39;, iRowspan)
                                             .attr(&#39;colspan&#39;, iColspan);
                             }
                     }
             }
     }

     /**
 Insert the required TR nodes into the table for display
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnDraw( oSettings )
     {
             /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
             var aPreDraw = _fnCallbackFire( oSettings, &#39;aoPreDrawCallback&#39;, &#39;preDraw&#39;, [oSettings] );
             if ( $.inArray( false, aPreDraw ) !== -1 )
             {
                     _fnProcessingDisplay( oSettings, false );
                     return;
             }

             var i, iLen, n;
             var anRows = [];
             var iRowCount = 0;
             var asStripeClasses = oSettings.asStripeClasses;
             var iStripes = asStripeClasses.length;
             var iOpenRows = oSettings.aoOpenRows.length;
             var oLang = oSettings.oLanguage;
             var iInitDisplayStart = oSettings.iInitDisplayStart;
             var bServerSide = _fnDataSource( oSettings ) == &#39;ssp&#39;;
             var aiDisplay = oSettings.aiDisplay;

             oSettings.bDrawing = true;

             /* Check and see if we have an initial draw position from state saving */
             if ( iInitDisplayStart !== undefined &amp;&amp; iInitDisplayStart !== -1 )
             {
                     oSettings._iDisplayStart = bServerSide ?
                             iInitDisplayStart :
                             iInitDisplayStart &gt;= oSettings.fnRecordsDisplay() ?
                                     0 :
                                     iInitDisplayStart;

                     oSettings.iInitDisplayStart = -1;
             }

             var iDisplayStart = oSettings._iDisplayStart;
             var iDisplayEnd = oSettings.fnDisplayEnd();

             /* Server-side processing draw intercept */
             if ( oSettings.bDeferLoading )
             {
                     oSettings.bDeferLoading = false;
                     oSettings.iDraw++;
                     _fnProcessingDisplay( oSettings, false );
             }
             else if ( !bServerSide )
             {
                     oSettings.iDraw++;
             }
             else if ( !oSettings.bDestroying &amp;&amp; !_fnAjaxUpdate( oSettings ) )
             {
                     return;
             }

             if ( aiDisplay.length !== 0 )
             {
                     var iStart = bServerSide ? 0 : iDisplayStart;
                     var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

                     for ( var j=iStart ; j&lt;iEnd ; j++ )
                     {
                             var iDataIndex = aiDisplay[j];
                             var aoData = oSettings.aoData[ iDataIndex ];
                             if ( aoData.nTr === null )
                             {
                                     _fnCreateTr( oSettings, iDataIndex );
                             }

                             var nRow = aoData.nTr;

                             /* Remove the old striping classes and then add the new one */
                             if ( iStripes !== 0 )
                             {
                                     var sStripe = asStripeClasses[ iRowCount % iStripes ];
                                     if ( aoData._sRowStripe != sStripe )
                                     {
                                             $(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
                                             aoData._sRowStripe = sStripe;
                                     }
                             }

                             // Row callback functions - might want to manipulate the row
                             // iRowCount and j are not currently documented. Are they at all
                             // useful?
                             _fnCallbackFire( oSettings, &#39;aoRowCallback&#39;, null,
                                     [nRow, aoData._aData, iRowCount, j] );

                             anRows.push( nRow );
                             iRowCount++;
                     }
             }
             else
             {
                     /* Table is empty - create a row with an empty message in it */
                     var sZero = oLang.sZeroRecords;
                     if ( oSettings.iDraw == 1 &amp;&amp;  _fnDataSource( oSettings ) == &#39;ajax&#39; )
                     {
                             sZero = oLang.sLoadingRecords;
                     }
                     else if ( oLang.sEmptyTable &amp;&amp; oSettings.fnRecordsTotal() === 0 )
                     {
                             sZero = oLang.sEmptyTable;
                     }

                     anRows[ 0 ] = $( &#39;&lt;tr/&gt;&#39;, { &#39;class&#39;: iStripes ? asStripeClasses[0] : &#39;&#39; } )
                             .append( $(&#39;&lt;td /&gt;&#39;, {
                                     &#39;valign&#39;:  &#39;top&#39;,
                                     &#39;colSpan&#39;: _fnVisbleColumns( oSettings ),
                                     &#39;class&#39;:   oSettings.oClasses.sRowEmpty
                             } ).html( sZero ) )[0];
             }

             /* Header and footer callbacks */
             _fnCallbackFire( oSettings, &#39;aoHeaderCallback&#39;, &#39;header&#39;, [ $(oSettings.nTHead).children(&#39;tr&#39;)[0],
                     _fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

             _fnCallbackFire( oSettings, &#39;aoFooterCallback&#39;, &#39;footer&#39;, [ $(oSettings.nTFoot).children(&#39;tr&#39;)[0],
                     _fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

             var body = $(oSettings.nTBody);

             body.children().detach();
             body.append( $(anRows) );

             /* Call all required callback functions for the end of a draw */
             _fnCallbackFire( oSettings, &#39;aoDrawCallback&#39;, &#39;draw&#39;, [oSettings] );

             /* Draw is complete, sorting and filtering must be as well */
             oSettings.bSorted = false;
             oSettings.bFiltered = false;
             oSettings.bDrawing = false;
     }

     /**
 Redraw the table - taking account of the various features which are enabled
  @param {object} oSettings dataTables settings object
  @param {boolean} [holdPosition] Keep the current paging position. By default
    the paging is reset to the first page
  @memberof DataTable#oApi
/
     function _fnReDraw( settings, holdPosition )
     {
             var
                     features = settings.oFeatures,
                     sort     = features.bSort,
                     filter   = features.bFilter;

             if ( sort ) {
                     _fnSort( settings );
             }

             if ( filter ) {
                     _fnFilterComplete( settings, settings.oPreviousSearch );
             }
             else {
                     // No filtering, so we want to just use the display master
                     settings.aiDisplay = settings.aiDisplayMaster.slice();
             }

             if ( holdPosition !== true ) {
                     settings._iDisplayStart = 0;
             }

             // Let any modules know about the draw hold position state (used by
             // scrolling internally)
             settings._drawHold = holdPosition;

             _fnDraw( settings );

             settings._drawHold = false;
     }

     /**
 Add the options to the page HTML for the table
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnAddOptionsHtml ( oSettings )
     {
             var classes = oSettings.oClasses;
             var table = $(oSettings.nTable);
             var holding = $(&#39;&lt;div/&gt;&#39;).insertBefore( table ); // Holding element for speed
             var features = oSettings.oFeatures;

             // All DataTables are wrapped in a div
             var insert = $(&#39;&lt;div/&gt;&#39;, {
                     id:      oSettings.sTableId+&#39;_wrapper&#39;,
                     &#39;class&#39;: classes.sWrapper + (oSettings.nTFoot ? &#39;&#39; : &#39; &#39;+classes.sNoFooter)
             } );

             oSettings.nHolding = holding[0];
             oSettings.nTableWrapper = insert[0];
             oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

             /* Loop over the user set positioning and place the elements as needed */
             var aDom = oSettings.sDom.split(&#39;&#39;);
             var featureNode, cOption, nNewNode, cNext, sAttr, j;
             for ( var i=0 ; i&lt;aDom.length ; i++ )
             {
                     featureNode = null;
                     cOption = aDom[i];

                     if ( cOption == &#39;&lt;&#39; )
                     {
                             /* New container div */
                             nNewNode = $(&#39;&lt;div/&gt;&#39;)[0];

                             /* Check to see if we should append an id and/or a class name to the container */
                             cNext = aDom[i+1];
                             if ( cNext == &quot;&#39;&quot; || cNext == &#39;&quot;&#39; )
                             {
                                     sAttr = &quot;&quot;;
                                     j = 2;
                                     while ( aDom[i+j] != cNext )
                                     {
                                             sAttr += aDom[i+j];
                                             j++;
                                     }

                                     /* Replace jQuery UI constants @todo depreciated */
                                     if ( sAttr == &quot;H&quot; )
                                     {
                                             sAttr = classes.sJUIHeader;
                                     }
                                     else if ( sAttr == &quot;F&quot; )
                                     {
                                             sAttr = classes.sJUIFooter;
                                     }

                                     /* The attribute can be in the format of &quot;#id.class&quot;, &quot;#id&quot; or &quot;class&quot; This logic
     breaks the string into parts and applies them as needed
    /
                                     if ( sAttr.indexOf(&#39;.&#39;) != -1 )
                                     {
                                             var aSplit = sAttr.split(&#39;.&#39;);
                                             nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
                                             nNewNode.className = aSplit[1];
                                     }
                                     else if ( sAttr.charAt(0) == &quot;#&quot; )
                                     {
                                             nNewNode.id = sAttr.substr(1, sAttr.length-1);
                                     }
                                     else
                                     {
                                             nNewNode.className = sAttr;
                                     }

                                     i += j; /* Move along the position array */
                             }

                             insert.append( nNewNode );
                             insert = $(nNewNode);
                     }
                     else if ( cOption == &#39;&gt;&#39; )
                     {
                             /* End container div */
                             insert = insert.parent();
                     }
                     // @todo Move options into their own plugins?
                     else if ( cOption == &#39;l&#39; &amp;&amp; features.bPaginate &amp;&amp; features.bLengthChange )
                     {
                             /* Length */
                             featureNode = _fnFeatureHtmlLength( oSettings );
                     }
                     else if ( cOption == &#39;f&#39; &amp;&amp; features.bFilter )
                     {
                             /* Filter */
                             featureNode = _fnFeatureHtmlFilter( oSettings );
                     }
                     else if ( cOption == &#39;r&#39; &amp;&amp; features.bProcessing )
                     {
                             /* pRocessing */
                             featureNode = _fnFeatureHtmlProcessing( oSettings );
                     }
                     else if ( cOption == &#39;t&#39; )
                     {
                             /* Table */
                             featureNode = _fnFeatureHtmlTable( oSettings );
                     }
                     else if ( cOption ==  &#39;i&#39; &amp;&amp; features.bInfo )
                     {
                             /* Info */
                             featureNode = _fnFeatureHtmlInfo( oSettings );
                     }
                     else if ( cOption == &#39;p&#39; &amp;&amp; features.bPaginate )
                     {
                             /* Pagination */
                             featureNode = _fnFeatureHtmlPaginate( oSettings );
                     }
                     else if ( DataTable.ext.feature.length !== 0 )
                     {
                             /* Plug-in features */
                             var aoFeatures = DataTable.ext.feature;
                             for ( var k=0, kLen=aoFeatures.length ; k&lt;kLen ; k++ )
                             {
                                     if ( cOption == aoFeatures[k].cFeature )
                                     {
                                             featureNode = aoFeatures[k].fnInit( oSettings );
                                             break;
                                     }
                             }
                     }

                     /* Add to the 2D features array */
                     if ( featureNode )
                     {
                             var aanFeatures = oSettings.aanFeatures;

                             if ( ! aanFeatures[cOption] )
                             {
                                     aanFeatures[cOption] = [];
                             }

                             aanFeatures[cOption].push( featureNode );
                             insert.append( featureNode );
                     }
             }

             /* Built our DOM structure - replace the holding div with what we want */
             holding.replaceWith( insert );
     }

     /**
 Use the DOM source to create up an array of header cells. The idea here is to
 create a layout grid (array) of rows x columns, which contains a reference
 to the cell that that point in the grid (regardless of col/rowspan), such that
 any column / row could be removed and the new grid constructed
  @param array {object} aLayout Array to store the calculated layout in
  @param {node} nThead The header/footer element for the table
  @memberof DataTable#oApi
/
     function _fnDetectHeader ( aLayout, nThead )
     {
             var nTrs = $(nThead).children(&#39;tr&#39;);
             var nTr, nCell;
             var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
             var bUnique;
             var fnShiftCol = function ( a, i, j ) {
                     var k = a[i];
                     while ( k[j] ) {
                             j++;
                     }
                     return j;
             };

             aLayout.splice( 0, aLayout.length );

             /* We know how many rows there are in the layout - so prep it */
             for ( i=0, iLen=nTrs.length ; i&lt;iLen ; i++ )
             {
                     aLayout.push( [] );
             }

             /* Calculate a layout array */
             for ( i=0, iLen=nTrs.length ; i&lt;iLen ; i++ )
             {
                     nTr = nTrs[i];
                     iColumn = 0;

                     /* For every cell in the row... */
                     nCell = nTr.firstChild;
                     while ( nCell ) {
                             if ( nCell.nodeName.toUpperCase() == &quot;TD&quot; ||
                                  nCell.nodeName.toUpperCase() == &quot;TH&quot; )
                             {
                                     /* Get the col and rowspan attributes from the DOM and sanitise them */
                                     iColspan = nCell.getAttribute(&#39;colspan&#39;) * 1;
                                     iRowspan = nCell.getAttribute(&#39;rowspan&#39;) * 1;
                                     iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
                                     iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;

                                     /* There might be colspan cells already in this row, so shift our target
     accordingly
    /
                                     iColShifted = fnShiftCol( aLayout, i, iColumn );

                                     /* Cache calculation for unique columns */
                                     bUnique = iColspan === 1 ? true : false;

                                     /* If there is col / rowspan, copy the information into the layout grid */
                                     for ( l=0 ; l&lt;iColspan ; l++ )
                                     {
                                             for ( k=0 ; k&lt;iRowspan ; k++ )
                                             {
                                                     aLayout[i+k][iColShifted+l] = {
                                                             &quot;cell&quot;: nCell,
                                                             &quot;unique&quot;: bUnique
                                                     };
                                                     aLayout[i+k].nTr = nTr;
                                             }
                                     }
                             }
                             nCell = nCell.nextSibling;
                     }
             }
     }

     /**
 Get an array of unique th elements, one for each column
  @param {object} oSettings dataTables settings object
  @param {node} nHeader automatically detect the layout from this node - optional
  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
  @returns array {node} aReturn list of unique th&#39;s
  @memberof DataTable#oApi
/
     function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
     {
             var aReturn = [];
             if ( !aLayout )
             {
                     aLayout = oSettings.aoHeader;
                     if ( nHeader )
                     {
                             aLayout = [];
                             _fnDetectHeader( aLayout, nHeader );
                     }
             }

             for ( var i=0, iLen=aLayout.length ; i&lt;iLen ; i++ )
             {
                     for ( var j=0, jLen=aLayout[i].length ; j&lt;jLen ; j++ )
                     {
                             if ( aLayout[i][j].unique &amp;&amp;
                                      (!aReturn[j] || !oSettings.bSortCellsTop) )
                             {
                                     aReturn[j] = aLayout[i][j].cell;
                             }
                     }
             }

             return aReturn;
     }

     /**
 Create an Ajax call based on the table&#39;s settings, taking into account that
 parameters can have multiple forms, and backwards compatibility.

 @param {object} oSettings dataTables settings object
 @param {array} data Data to send to the server, required by
     DataTables - may be augmented by developer callbacks
 @param {function} fn Callback function to run when data is obtained
/
     function _fnBuildAjax( oSettings, data, fn )
     {
             // Compatibility with 1.9-, allow fnServerData and event to manipulate
             _fnCallbackFire( oSettings, &#39;aoServerParams&#39;, &#39;serverParams&#39;, [data] );

             // Convert to object based for 1.10+ if using the old array scheme which can
             // come from server-side processing or serverParams
             if ( data &amp;&amp; $.isArray(data) ) {
                     var tmp = {};
                     var rbracket = /(.*?)\[\]$/;

                     $.each( data, function (key, val) {
                             var match = val.name.match(rbracket);

                             if ( match ) {
                                     // Support for arrays
                                     var name = match[0];

                                     if ( ! tmp[ name ] ) {
                                             tmp[ name ] = [];
                                     }
                                     tmp[ name ].push( val.value );
                             }
                             else {
                                     tmp[val.name] = val.value;
                             }
                     } );
                     data = tmp;
             }

             var ajaxData;
             var ajax = oSettings.ajax;
             var instance = oSettings.oInstance;
             var callback = function ( json ) {
                     _fnCallbackFire( oSettings, null, &#39;xhr&#39;, [oSettings, json] );
                     fn( json );
             };

             if ( $.isPlainObject( ajax ) &amp;&amp; ajax.data )
             {
                     ajaxData = ajax.data;

                     var newData = $.isFunction( ajaxData ) ?
                             ajaxData( data, oSettings ) :  // fn can manipulate data or return
                             ajaxData;                      // an object object or array to merge

                     // If the function returned something, use that alone
                     data = $.isFunction( ajaxData ) &amp;&amp; newData ?
                             newData :
                             $.extend( true, data, newData );

                     // Remove the data property as we&#39;ve resolved it already and don&#39;t want
                     // jQuery to do it again (it is restored at the end of the function)
                     delete ajax.data;
             }

             var baseAjax = {
                     &quot;data&quot;: data,
                     &quot;success&quot;: function (json) {
                             var error = json.error || json.sError;
                             if ( error ) {
                                     oSettings.oApi._fnLog( oSettings, 0, error );
                             }

                             oSettings.json = json;
                             callback( json );
                     },
                     &quot;dataType&quot;: &quot;json&quot;,
                     &quot;cache&quot;: false,
                     &quot;type&quot;: oSettings.sServerMethod,
                     &quot;error&quot;: function (xhr, error, thrown) {
                             var log = oSettings.oApi._fnLog;

                             if ( error == &quot;parsererror&quot; ) {
                                     log( oSettings, 0, &#39;Invalid JSON response&#39;, 1 );
                             }
                             else if ( xhr.readyState === 4 ) {
                                     log( oSettings, 0, &#39;Ajax error&#39;, 7 );
                             }

                             _fnProcessingDisplay( oSettings, false );
                     }
             };

             // Store the data submitted for the API
             oSettings.oAjaxData = data;

             // Allow plug-ins and external processes to modify the data
             _fnCallbackFire( oSettings, null, &#39;preXhr&#39;, [oSettings, data] );

             if ( oSettings.fnServerData )
             {
                     // DataTables 1.9- compatibility
                     oSettings.fnServerData.call( instance,
                             oSettings.sAjaxSource,
                             $.map( data, function (val, key) { // Need to convert back to 1.9 trad format
                                     return { name: key, value: val };
                             } ),
                             callback,
                             oSettings
                     );
             }
             else if ( oSettings.sAjaxSource || typeof ajax === &#39;string&#39; )
             {
                     // DataTables 1.9- compatibility
                     oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
                             url: ajax || oSettings.sAjaxSource
                     } ) );
             }
             else if ( $.isFunction( ajax ) )
             {
                     // Is a function - let the caller define what needs to be done
                     oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
             }
             else
             {
                     // Object to extend the base settings
                     oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );

                     // Restore for next time around
                     ajax.data = ajaxData;
             }
     }

     /**
 Update the table using an Ajax call
  @param {object} settings dataTables settings object
  @returns {boolean} Block the table drawing or not
  @memberof DataTable#oApi
/
     function _fnAjaxUpdate( settings )
     {
             if ( settings.bAjaxDataGet ) {
                     settings.iDraw++;
                     _fnProcessingDisplay( settings, true );

                     _fnBuildAjax(
                             settings,
                             _fnAjaxParameters( settings ),
                             function(json) {
                                     _fnAjaxUpdateDraw( settings, json );
                             }
                     );

                     return false;
             }
             return true;
     }

     /**
 Build up the parameters in an object needed for a server-side processing
 request. Note that this is basically done twice, is different ways - a modern
 method which is used by default in DataTables 1.10 which uses objects and
 arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
 the sAjaxSource option is used in the initialisation, or the legacyAjax
 option is set.
  @param {object} oSettings dataTables settings object
  @returns {bool} block the table drawing or not
  @memberof DataTable#oApi
/
     function _fnAjaxParameters( settings )
     {
             var
                     columns = settings.aoColumns,
                     columnCount = columns.length,
                     features = settings.oFeatures,
                     preSearch = settings.oPreviousSearch,
                     preColSearch = settings.aoPreSearchCols,
                     i, data = [], dataProp, column, columnSearch,
                     sort = _fnSortFlatten( settings ),
                     displayStart = settings._iDisplayStart,
                     displayLength = features.bPaginate !== false ?
                             settings._iDisplayLength :
                             -1;

             var param = function ( name, value ) {
                     data.push( { &#39;name&#39;: name, &#39;value&#39;: value } );
             };

             // DataTables 1.9- compatible method
             param( &#39;sEcho&#39;,          settings.iDraw );
             param( &#39;iColumns&#39;,       columnCount );
             param( &#39;sColumns&#39;,       _pluck( columns, &#39;sName&#39; ).join(&#39;,&#39;) );
             param( &#39;iDisplayStart&#39;,  displayStart );
             param( &#39;iDisplayLength&#39;, displayLength );

             // DataTables 1.10+ method
             var d = {
                     draw:    settings.iDraw,
                     columns: [],
                     order:   [],
                     start:   displayStart,
                     length:  displayLength,
                     search:  {
                             value: preSearch.sSearch,
                             regex: preSearch.bRegex
                     }
             };

             for ( i=0 ; i&lt;columnCount ; i++ ) {
                     column = columns[i];
                     columnSearch = preColSearch[i];
                     dataProp = typeof column.mData==&quot;function&quot; ? &#39;function&#39; : column.mData ;

                     d.columns.push( {
                             data:       dataProp,
                             name:       column.sName,
                             searchable: column.bSearchable,
                             orderable:  column.bSortable,
                             search:     {
                                     value: columnSearch.sSearch,
                                     regex: columnSearch.bRegex
                             }
                     } );

                     param( &quot;mDataProp_&quot;+i, dataProp );

                     if ( features.bFilter ) {
                             param( &#39;sSearch_&#39;+i,     columnSearch.sSearch );
                             param( &#39;bRegex_&#39;+i,      columnSearch.bRegex );
                             param( &#39;bSearchable_&#39;+i, column.bSearchable );
                     }

                     if ( features.bSort ) {
                             param( &#39;bSortable_&#39;+i, column.bSortable );
                     }
             }

             if ( features.bFilter ) {
                     param( &#39;sSearch&#39;, preSearch.sSearch );
                     param( &#39;bRegex&#39;, preSearch.bRegex );
             }

             if ( features.bSort ) {
                     $.each( sort, function ( i, val ) {
                             d.order.push( { column: val.col, dir: val.dir } );

                             param( &#39;iSortCol_&#39;+i, val.col );
                             param( &#39;sSortDir_&#39;+i, val.dir );
                     } );

                     param( &#39;iSortingCols&#39;, sort.length );
             }

             // If the legacy.ajax parameter is null, then we automatically decide which
             // form to use, based on sAjaxSource
             var legacy = DataTable.ext.legacy.ajax;
             if ( legacy === null ) {
                     return settings.sAjaxSource ? data : d;
             }

             // Otherwise, if legacy has been specified then we use that to decide on the
             // form
             return legacy ? data : d;
     }

     /**
 Data the data from the server (nuking the old) and redraw the table
  @param {object} oSettings dataTables settings object
  @param {object} json json data return from the server.
  @param {string} json.sEcho Tracking flag for DataTables to match requests
  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
  @param {array} json.aaData The data to display on this page
  @param {string} [json.sColumns] Column ordering (sName, comma separated)
  @memberof DataTable#oApi
/
     function _fnAjaxUpdateDraw ( settings, json )
     {
             // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
             // Support both
             var compat = function ( old, modern ) {
                     return json[old] !== undefined ? json[old] : json[modern];
             };

             var data = _fnAjaxDataSrc( settings, json );
             var draw            = compat( &#39;sEcho&#39;,                &#39;draw&#39; );
             var recordsTotal    = compat( &#39;iTotalRecords&#39;,        &#39;recordsTotal&#39; );
             var recordsFiltered = compat( &#39;iTotalDisplayRecords&#39;, &#39;recordsFiltered&#39; );

             if ( draw ) {
                     // Protect against out of sequence returns
                     if ( draw*1 &lt; settings.iDraw ) {
                             return;
                     }
                     settings.iDraw = draw * 1;
             }

             _fnClearTable( settings );
             settings._iRecordsTotal   = parseInt(recordsTotal, 10);
             settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

             for ( var i=0, ien=data.length ; i&lt;ien ; i++ ) {
                     _fnAddData( settings, data[i] );
             }
             settings.aiDisplay = settings.aiDisplayMaster.slice();

             settings.bAjaxDataGet = false;
             _fnDraw( settings );

             if ( ! settings._bInitComplete ) {
                     _fnInitComplete( settings, json );
             }

             settings.bAjaxDataGet = true;
             _fnProcessingDisplay( settings, false );
     }

     /**
 Get the data from the JSON data source to use for drawing a table. Using
 `_fnGetObjectDataFn` allows the data to be sourced from a property of the
 source object, or from a processing function.
  @param {object} oSettings dataTables settings object
  @param  {object} json Data source object / array from the server
  @return {array} Array of data to use
/
     function _fnAjaxDataSrc ( oSettings, json )
     {
             var dataSrc = $.isPlainObject( oSettings.ajax ) &amp;&amp; oSettings.ajax.dataSrc !== undefined ?
                     oSettings.ajax.dataSrc :
                     oSettings.sAjaxDataProp; // Compatibility with 1.9-.

             // Compatibility with 1.9-. In order to read from aaData, check if the
             // default has been changed, if not, check for aaData
             if ( dataSrc === &#39;data&#39; ) {
                     return json.aaData || json[dataSrc];
             }

             return dataSrc !== &quot;&quot; ?
                     _fnGetObjectDataFn( dataSrc )( json ) :
                     json;
     }

     /**
 Generate the node required for filtering text
  @returns {node} Filter control element
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnFeatureHtmlFilter ( settings )
     {
             var classes = settings.oClasses;
             var tableId = settings.sTableId;
             var language = settings.oLanguage;
             var previousSearch = settings.oPreviousSearch;
             var features = settings.aanFeatures;
             var input = &#39;&lt;input type=&quot;search&quot; class=&quot;&#39;+classes.sFilterInput+&#39;&quot;/&gt;&#39;;

             var str = language.sSearch;
             str = str.match(/_INPUT_/) ?
                     str.replace(&#39;_INPUT_&#39;, input) :
                     str+input;

             var filter = $(&#39;&lt;div/&gt;&#39;, {
                             &#39;id&#39;: ! features.f ? tableId+&#39;_filter&#39; : null,
                             &#39;class&#39;: classes.sFilter
                     } )
                     .append( $(&#39;&lt;label/&gt;&#39; ).append( str ) );

             var searchFn = function() {
                     /* Update all other filter input elements for the new display */
                     var n = features.f;
                     var val = !this.value ? &quot;&quot; : this.value; // mental IE8 fix :-(

                     /* Now do the filter */
                     if ( val != previousSearch.sSearch ) {
                             _fnFilterComplete( settings, {
                                     &quot;sSearch&quot;: val,
                                     &quot;bRegex&quot;: previousSearch.bRegex,
                                     &quot;bSmart&quot;: previousSearch.bSmart ,
                                     &quot;bCaseInsensitive&quot;: previousSearch.bCaseInsensitive
                             } );

                             // Need to redraw, without resorting
                             settings._iDisplayStart = 0;
                             _fnDraw( settings );
                     }
             };

             var searchDelay = settings.searchDelay !== null ?
                     settings.searchDelay :
                     _fnDataSource( settings ) === &#39;ssp&#39; ?
                             400 :
                             0;

             var jqFilter = $(&#39;input&#39;, filter)
                     .val( previousSearch.sSearch )
                     .attr( &#39;placeholder&#39;, language.sSearchPlaceholder )
                     .bind(
                             &#39;keyup.DT search.DT input.DT paste.DT cut.DT&#39;,
                             searchDelay ?
                                     _fnThrottle( searchFn, searchDelay ) :
                                     searchFn
                     )
                     .bind( &#39;keypress.DT&#39;, function(e) {
                             /* Prevent form submission */
                             if ( e.keyCode == 13 ) {
                                     return false;
                             }
                     } )
                     .attr(&#39;aria-controls&#39;, tableId);

             // Update the input elements whenever the table is filtered
             $(settings.nTable).on( &#39;search.dt.DT&#39;, function ( ev, s ) {
                     if ( settings === s ) {
                             // IE9 throws an &#39;unknown error&#39; if document.activeElement is used
                             // inside an iframe or frame...
                             try {
                                     if ( jqFilter[0] !== document.activeElement ) {
                                             jqFilter.val( previousSearch.sSearch );
                                     }
                             }
                             catch ( e ) {}
                     }
             } );

             return filter[0];
     }

     /**
 Filter the table using both the global filter and column based filtering
  @param {object} oSettings dataTables settings object
  @param {object} oSearch search information
  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
  @memberof DataTable#oApi
/
     function _fnFilterComplete ( oSettings, oInput, iForce )
     {
             var oPrevSearch = oSettings.oPreviousSearch;
             var aoPrevSearch = oSettings.aoPreSearchCols;
             var fnSaveFilter = function ( oFilter ) {
                     /* Save the filtering values */
                     oPrevSearch.sSearch = oFilter.sSearch;
                     oPrevSearch.bRegex = oFilter.bRegex;
                     oPrevSearch.bSmart = oFilter.bSmart;
                     oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
             };
             var fnRegex = function ( o ) {
                     // Backwards compatibility with the bEscapeRegex option
                     return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
             };

             // Resolve any column types that are unknown due to addition or invalidation
             // @todo As per sort - can this be moved into an event handler?
             _fnColumnTypes( oSettings );

             /* In server-side processing all filtering is done by the server, so no point hanging around here */
             if ( _fnDataSource( oSettings ) != &#39;ssp&#39; )
             {
                     /* Global filter */
                     _fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
                     fnSaveFilter( oInput );

                     /* Now do the individual column filter */
                     for ( var i=0 ; i&lt;aoPrevSearch.length ; i++ )
                     {
                             _fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
                                     aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
                     }

                     /* Custom filtering */
                     _fnFilterCustom( oSettings );
             }
             else
             {
                     fnSaveFilter( oInput );
             }

             /* Tell the draw function we have been filtering */
             oSettings.bFiltered = true;
             _fnCallbackFire( oSettings, null, &#39;search&#39;, [oSettings] );
     }

     /**
 Apply custom filtering functions
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnFilterCustom( settings )
     {
             var filters = DataTable.ext.search;
             var displayRows = settings.aiDisplay;
             var row, rowIdx;

             for ( var i=0, ien=filters.length ; i&lt;ien ; i++ ) {
                     var rows = [];

                     // Loop over each row and see if it should be included
                     for ( var j=0, jen=displayRows.length ; j&lt;jen ; j++ ) {
                             rowIdx = displayRows[ j ];
                             row = settings.aoData[ rowIdx ];

                             if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
                                     rows.push( rowIdx );
                             }
                     }

                     // So the array reference doesn&#39;t break set the results into the
                     // existing array
                     displayRows.length = 0;
                     displayRows.push.apply( displayRows, rows );
             }
     }

     /**
 Filter the table on a per-column basis
  @param {object} oSettings dataTables settings object
  @param {string} sInput string to filter on
  @param {int} iColumn column to filter
  @param {bool} bRegex treat search string as a regular expression or not
  @param {bool} bSmart use smart filtering or not
  @param {bool} bCaseInsensitive Do case insenstive matching or not
  @memberof DataTable#oApi
/
     function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
     {
             if ( searchStr === &#39;&#39; ) {
                     return;
             }

             var data;
             var display = settings.aiDisplay;
             var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );

             for ( var i=display.length-1 ; i&gt;=0 ; i-- ) {
                     data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];

                     if ( ! rpSearch.test( data ) ) {
                             display.splice( i, 1 );
                     }
             }
     }

     /**
 Filter the data table based on user input and draw the table
  @param {object} settings dataTables settings object
  @param {string} input string to filter on
  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
  @param {bool} regex treat as a regular expression or not
  @param {bool} smart perform smart filtering or not
  @param {bool} caseInsensitive Do case insenstive matching or not
  @memberof DataTable#oApi
/
     function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
     {
             var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
             var prevSearch = settings.oPreviousSearch.sSearch;
             var displayMaster = settings.aiDisplayMaster;
             var display, invalidated, i;

             // Need to take account of custom filtering functions - always filter
             if ( DataTable.ext.search.length !== 0 ) {
                     force = true;
             }

             // Check if any of the rows were invalidated
             invalidated = _fnFilterData( settings );

             // If the input is blank - we just want the full data set
             if ( input.length &lt;= 0 ) {
                     settings.aiDisplay = displayMaster.slice();
             }
             else {
                     // New search - start from the master array
                     if ( invalidated ||
                              force ||
                              prevSearch.length &gt; input.length ||
                              input.indexOf(prevSearch) !== 0 ||
                              settings.bSorted // On resort, the display master needs to be
                                               // re-filtered since indexes will have changed
                     ) {
                             settings.aiDisplay = displayMaster.slice();
                     }

                     // Search the display array
                     display = settings.aiDisplay;

                     for ( i=display.length-1 ; i&gt;=0 ; i-- ) {
                             if ( ! rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
                                     display.splice( i, 1 );
                             }
                     }
             }
     }

     /**
 Build a regular expression object suitable for searching a table
  @param {string} sSearch string to search for
  @param {bool} bRegex treat as a regular expression or not
  @param {bool} bSmart perform smart filtering or not
  @param {bool} bCaseInsensitive Do case insensitive matching or not
  @returns {RegExp} constructed object
  @memberof DataTable#oApi
/
     function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
     {
             search = regex ?
                     search :
                     _fnEscapeRegex( search );

             if ( smart ) {
                     /* For smart filtering we want to allow the search to work regardless of
   word order. We also want double quoted text to be preserved, so word
   order is important - a la google. So this is what we want to
   generate:

   ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
  /
                     var a = $.map( search.match( /&quot;[^&quot;]+&quot;|[^ ]+/g ) || &#39;&#39;, function ( word ) {
                             if ( word.charAt(0) === &#39;&quot;&#39; ) {
                                     var m = word.match( /^&quot;(.*)&quot;$/ );
                                     word = m ? m[1] : word;
                             }

                             return word.replace(&#39;&quot;&#39;, &#39;&#39;);
                     } );

                     search = &#39;^(?=.*?&#39;+a.join( &#39;)(?=.*?&#39; )+&#39;).*$&#39;;
             }

             return new RegExp( search, caseInsensitive ? &#39;i&#39; : &#39;&#39; );
     }

     /**
 Escape a string such that it can be used in a regular expression
  @param {string} sVal string to escape
  @returns {string} escaped string
  @memberof DataTable#oApi
/
     function _fnEscapeRegex ( sVal )
     {
             return sVal.replace( _re_escape_regex, &#39;\\$1&#39; );
     }

     var __filter_div = $(&#39;&lt;div&gt;&#39;)[0];
     var __filter_div_textContent = __filter_div.textContent !== undefined;

     // Update the filtering data for each row if needed (by invalidation or first run)
     function _fnFilterData ( settings )
     {
             var columns = settings.aoColumns;
             var column;
             var i, j, ien, jen, filterData, cellData, row;
             var fomatters = DataTable.ext.type.search;
             var wasInvalidated = false;

             for ( i=0, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
                     row = settings.aoData[i];

                     if ( ! row._aFilterData ) {
                             filterData = [];

                             for ( j=0, jen=columns.length ; j&lt;jen ; j++ ) {
                                     column = columns[j];

                                     if ( column.bSearchable ) {
                                             cellData = _fnGetCellData( settings, i, j, &#39;filter&#39; );

                                             if ( fomatters[ column.sType ] ) {
                                                     cellData = fomatters[ column.sType ]( cellData );
                                             }

                                             // Search in DataTables 1.10 is string based. In 1.11 this
                                             // should be altered to also allow strict type checking.
                                             if ( cellData === null ) {
                                                     cellData = &#39;&#39;;
                                             }

                                             if ( typeof cellData !== &#39;string&#39; &amp;&amp; cellData.toString ) {
                                                     cellData = cellData.toString();
                                             }
                                     }
                                     else {
                                             cellData = &#39;&#39;;
                                     }

                                     // If it looks like there is an HTML entity in the string,
                                     // attempt to decode it so sorting works as expected. Note that
                                     // we could use a single line of jQuery to do this, but the DOM
                                     // method used here is much faster http://jsperf.com/html-decode
                                     if ( cellData.indexOf &amp;&amp; cellData.indexOf(&#39;&amp;&#39;) !== -1 ) {
                                             __filter_div.innerHTML = cellData;
                                             cellData = __filter_div_textContent ?
                                                     __filter_div.textContent :
                                                     __filter_div.innerText;
                                     }

                                     if ( cellData.replace ) {
                                             cellData = cellData.replace(/[\r\n]/g, &#39;&#39;);
                                     }

                                     filterData.push( cellData );
                             }

                             row._aFilterData = filterData;
                             row._sFilterRow = filterData.join(&#39;  &#39;);
                             wasInvalidated = true;
                     }
             }

             return wasInvalidated;
     }

     /**
 Convert from the internal Hungarian notation to camelCase for external
 interaction
  @param {object} obj Object to convert
  @returns {object} Inverted object
  @memberof DataTable#oApi
/
     function _fnSearchToCamel ( obj )
     {
             return {
                     search:          obj.sSearch,
                     smart:           obj.bSmart,
                     regex:           obj.bRegex,
                     caseInsensitive: obj.bCaseInsensitive
             };
     }

     /**
 Convert from camelCase notation to the internal Hungarian. We could use the
 Hungarian convert function here, but this is cleaner
  @param {object} obj Object to convert
  @returns {object} Inverted object
  @memberof DataTable#oApi
/
     function _fnSearchToHung ( obj )
     {
             return {
                     sSearch:          obj.search,
                     bSmart:           obj.smart,
                     bRegex:           obj.regex,
                     bCaseInsensitive: obj.caseInsensitive
             };
     }

     /**
 Generate the node required for the info display
  @param {object} oSettings dataTables settings object
  @returns {node} Information element
  @memberof DataTable#oApi
/
     function _fnFeatureHtmlInfo ( settings )
     {
             var
                     tid = settings.sTableId,
                     nodes = settings.aanFeatures.i,
                     n = $(&#39;&lt;div/&gt;&#39;, {
                             &#39;class&#39;: settings.oClasses.sInfo,
                             &#39;id&#39;: ! nodes ? tid+&#39;_info&#39; : null
                     } );

             if ( ! nodes ) {
                     // Update display on each draw
                     settings.aoDrawCallback.push( {
                             &quot;fn&quot;: _fnUpdateInfo,
                             &quot;sName&quot;: &quot;information&quot;
                     } );

                     n
                             .attr( &#39;role&#39;, &#39;status&#39; )
                             .attr( &#39;aria-live&#39;, &#39;polite&#39; );

                     // Table is described by our info div
                     $(settings.nTable).attr( &#39;aria-describedby&#39;, tid+&#39;_info&#39; );
             }

             return n[0];
     }

     /**
 Update the information elements in the display
  @param {object} settings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnUpdateInfo ( settings )
     {
             /* Show information about the table */
             var nodes = settings.aanFeatures.i;
             if ( nodes.length === 0 ) {
                     return;
             }

             var
                     lang  = settings.oLanguage,
                     start = settings._iDisplayStart+1,
                     end   = settings.fnDisplayEnd(),
                     max   = settings.fnRecordsTotal(),
                     total = settings.fnRecordsDisplay(),
                     out   = total ?
                             lang.sInfo :
                             lang.sInfoEmpty;

             if ( total !== max ) {
                     /* Record set after filtering */
                     out += &#39; &#39; + lang.sInfoFiltered;
             }

             // Convert the macros
             out += lang.sInfoPostFix;
             out = _fnInfoMacros( settings, out );

             var callback = lang.fnInfoCallback;
             if ( callback !== null ) {
                     out = callback.call( settings.oInstance,
                             settings, start, end, max, total, out
                     );
             }

             $(nodes).html( out );
     }

     function _fnInfoMacros ( settings, str )
     {
             // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
             // internally
             var
                     formatter  = settings.fnFormatNumber,
                     start      = settings._iDisplayStart+1,
                     len        = settings._iDisplayLength,
                     vis        = settings.fnRecordsDisplay(),
                     all        = len === -1;

             return str.
                     replace(/_START_/g, formatter.call( settings, start ) ).
                     replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
                     replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
                     replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
                     replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
                     replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
     }

     /**
 Draw the table for the first time, adding all required features
  @param {object} settings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnInitialise ( settings )
     {
             var i, iLen, iAjaxStart=settings.iInitDisplayStart;
             var columns = settings.aoColumns, column;
             var features = settings.oFeatures;

             /* Ensure that the table data is fully initialised */
             if ( ! settings.bInitialised ) {
                     setTimeout( function(){ _fnInitialise( settings ); }, 200 );
                     return;
             }

             /* Show the display HTML options */
             _fnAddOptionsHtml( settings );

             /* Build and draw the header / footer for the table */
             _fnBuildHead( settings );
             _fnDrawHead( settings, settings.aoHeader );
             _fnDrawHead( settings, settings.aoFooter );

             /* Okay to show that something is going on now */
             _fnProcessingDisplay( settings, true );

             /* Calculate sizes for columns */
             if ( features.bAutoWidth ) {
                     _fnCalculateColumnWidths( settings );
             }

             for ( i=0, iLen=columns.length ; i&lt;iLen ; i++ ) {
                     column = columns[i];

                     if ( column.sWidth ) {
                             column.nTh.style.width = _fnStringToCss( column.sWidth );
                     }
             }

             // If there is default sorting required - let&#39;s do it. The sort function
             // will do the drawing for us. Otherwise we draw the table regardless of the
             // Ajax source - this allows the table to look initialised for Ajax sourcing
             // data (show &#39;loading&#39; message possibly)
             _fnReDraw( settings );

             // Server-side processing init complete is done by _fnAjaxUpdateDraw
             var dataSrc = _fnDataSource( settings );
             if ( dataSrc != &#39;ssp&#39; ) {
                     // if there is an ajax source load the data
                     if ( dataSrc == &#39;ajax&#39; ) {
                             _fnBuildAjax( settings, [], function(json) {
                                     var aData = _fnAjaxDataSrc( settings, json );

                                     // Got the data - add it to the table
                                     for ( i=0 ; i&lt;aData.length ; i++ ) {
                                             _fnAddData( settings, aData[i] );
                                     }

                                     // Reset the init display for cookie saving. We&#39;ve already done
                                     // a filter, and therefore cleared it before. So we need to make
                                     // it appear &#39;fresh&#39;
                                     settings.iInitDisplayStart = iAjaxStart;

                                     _fnReDraw( settings );

                                     _fnProcessingDisplay( settings, false );
                                     _fnInitComplete( settings, json );
                             }, settings );
                     }
                     else {
                             _fnProcessingDisplay( settings, false );
                             _fnInitComplete( settings );
                     }
             }
     }

     /**
 Draw the table for the first time, adding all required features
  @param {object} oSettings dataTables settings object
  @param {object} [json] JSON from the server that completed the table, if using Ajax source
    with client-side processing (optional)
  @memberof DataTable#oApi
/
     function _fnInitComplete ( settings, json )
     {
             settings._bInitComplete = true;

             // On an Ajax load we now have data and therefore want to apply the column
             // sizing
             if ( json ) {
                     _fnAdjustColumnSizing( settings );
             }

             _fnCallbackFire( settings, &#39;aoInitComplete&#39;, &#39;init&#39;, [settings, json] );
     }

     function _fnLengthChange ( settings, val )
     {
             var len = parseInt( val, 10 );
             settings._iDisplayLength = len;

             _fnLengthOverflow( settings );

             // Fire length change event
             _fnCallbackFire( settings, null, &#39;length&#39;, [settings, len] );
     }

     /**
 Generate the node required for user display length changing
  @param {object} settings dataTables settings object
  @returns {node} Display length feature node
  @memberof DataTable#oApi
/
     function _fnFeatureHtmlLength ( settings )
     {
             var
                     classes  = settings.oClasses,
                     tableId  = settings.sTableId,
                     menu     = settings.aLengthMenu,
                     d2       = $.isArray( menu[0] ),
                     lengths  = d2 ? menu[0] : menu,
                     language = d2 ? menu[1] : menu;

             var select = $(&#39;&lt;select/&gt;&#39;, {
                     &#39;name&#39;:          tableId+&#39;_length&#39;,
                     &#39;aria-controls&#39;: tableId,
                     &#39;class&#39;:         classes.sLengthSelect
             } );

             for ( var i=0, ien=lengths.length ; i&lt;ien ; i++ ) {
                     select[0][ i ] = new Option( language[i], lengths[i] );
             }

             var div = $(&#39;&lt;div&gt;&lt;label/&gt;&lt;/div&gt;&#39;).addClass( classes.sLength );
             if ( ! settings.aanFeatures.l ) {
                     div[0].id = tableId+&#39;_length&#39;;
             }

             div.children().append(
                     settings.oLanguage.sLengthMenu.replace( &#39;_MENU_&#39;, select[0].outerHTML )
             );

             // Can&#39;t use `select` variable as user might provide their own and the
             // reference is broken by the use of outerHTML
             $(&#39;select&#39;, div)
                     .val( settings._iDisplayLength )
                     .bind( &#39;change.DT&#39;, function(e) {
                             _fnLengthChange( settings, $(this).val() );
                             _fnDraw( settings );
                     } );

             // Update node value whenever anything changes the table&#39;s length
             $(settings.nTable).bind( &#39;length.dt.DT&#39;, function (e, s, len) {
                     if ( settings === s ) {
                             $(&#39;select&#39;, div).val( len );
                     }
             } );

             return div[0];
     }

     /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Note that most of the paging logic is done in
 DataTable.ext.pager
/

     /**
 Generate the node required for default pagination
  @param {object} oSettings dataTables settings object
  @returns {node} Pagination feature node
  @memberof DataTable#oApi
/
     function _fnFeatureHtmlPaginate ( settings )
     {
             var
                     type   = settings.sPaginationType,
                     plugin = DataTable.ext.pager[ type ],
                     modern = typeof plugin === &#39;function&#39;,
                     redraw = function( settings ) {
                             _fnDraw( settings );
                     },
                     node = $(&#39;&lt;div/&gt;&#39;).addClass( settings.oClasses.sPaging + type )[0],
                     features = settings.aanFeatures;

             if ( ! modern ) {
                     plugin.fnInit( settings, node, redraw );
             }

             /* Add a draw callback for the pagination on first instance, to update the paging display */
             if ( ! features.p )
             {
                     node.id = settings.sTableId+&#39;_paginate&#39;;

                     settings.aoDrawCallback.push( {
                             &quot;fn&quot;: function( settings ) {
                                     if ( modern ) {
                                             var
                                                     start      = settings._iDisplayStart,
                                                     len        = settings._iDisplayLength,
                                                     visRecords = settings.fnRecordsDisplay(),
                                                     all        = len === -1,
                                                     page = all ? 0 : Math.ceil( start / len ),
                                                     pages = all ? 1 : Math.ceil( visRecords / len ),
                                                     buttons = plugin(page, pages),
                                                     i, ien;

                                             for ( i=0, ien=features.p.length ; i&lt;ien ; i++ ) {
                                                     _fnRenderer( settings, &#39;pageButton&#39; )(
                                                             settings, features.p[i], i, buttons, page, pages
                                                     );
                                             }
                                     }
                                     else {
                                             plugin.fnUpdate( settings, redraw );
                                     }
                             },
                             &quot;sName&quot;: &quot;pagination&quot;
                     } );
             }

             return node;
     }

     /**
 Alter the display settings to change the page
  @param {object} settings DataTables settings object
  @param {string|int} action Paging action to take: &quot;first&quot;, &quot;previous&quot;,
    &quot;next&quot; or &quot;last&quot; or page number to jump to (integer)
  @param [bool] redraw Automatically draw the update or not
  @returns {bool} true page has changed, false - no change
  @memberof DataTable#oApi
/
     function _fnPageChange ( settings, action, redraw )
     {
             var
                     start     = settings._iDisplayStart,
                     len       = settings._iDisplayLength,
                     records   = settings.fnRecordsDisplay();

             if ( records === 0 || len === -1 )
             {
                     start = 0;
             }
             else if ( typeof action === &quot;number&quot; )
             {
                     start = action * len;

                     if ( start &gt; records )
                     {
                             start = 0;
                     }
             }
             else if ( action == &quot;first&quot; )
             {
                     start = 0;
             }
             else if ( action == &quot;previous&quot; )
             {
                     start = len &gt;= 0 ?
                             start - len :
                             0;

                     if ( start &lt; 0 )
                     {
                       start = 0;
                     }
             }
             else if ( action == &quot;next&quot; )
             {
                     if ( start + len &lt; records )
                     {
                             start += len;
                     }
             }
             else if ( action == &quot;last&quot; )
             {
                     start = Math.floor( (records-1) / len) * len;
             }
             else
             {
                     _fnLog( settings, 0, &quot;Unknown paging action: &quot;+action, 5 );
             }

             var changed = settings._iDisplayStart !== start;
             settings._iDisplayStart = start;

             if ( changed ) {
                     _fnCallbackFire( settings, null, &#39;page&#39;, [settings] );

                     if ( redraw ) {
                             _fnDraw( settings );
                     }
             }

             return changed;
     }

     /**
 Generate the node required for the processing node
  @param {object} settings dataTables settings object
  @returns {node} Processing element
  @memberof DataTable#oApi
/
     function _fnFeatureHtmlProcessing ( settings )
     {
             return $(&#39;&lt;div/&gt;&#39;, {
                             &#39;id&#39;: ! settings.aanFeatures.r ? settings.sTableId+&#39;_processing&#39; : null,
                             &#39;class&#39;: settings.oClasses.sProcessing
                     } )
                     .html( settings.oLanguage.sProcessing )
                     .insertBefore( settings.nTable )[0];
     }

     /**
 Display or hide the processing indicator
  @param {object} settings dataTables settings object
  @param {bool} show Show the processing indicator (true) or not (false)
  @memberof DataTable#oApi
/
     function _fnProcessingDisplay ( settings, show )
     {
             if ( settings.oFeatures.bProcessing ) {
                     $(settings.aanFeatures.r).css( &#39;display&#39;, show ? &#39;block&#39; : &#39;none&#39; );
             }

             _fnCallbackFire( settings, null, &#39;processing&#39;, [settings, show] );
     }

     /**
 Add any control elements for the table - specifically scrolling
  @param {object} settings dataTables settings object
  @returns {node} Node to add to the DOM
  @memberof DataTable#oApi
/
     function _fnFeatureHtmlTable ( settings )
     {
             var table = $(settings.nTable);

             // Add the ARIA grid role to the table
             table.attr( &#39;role&#39;, &#39;grid&#39; );

             // Scrolling from here on in
             var scroll = settings.oScroll;

             if ( scroll.sX === &#39;&#39; &amp;&amp; scroll.sY === &#39;&#39; ) {
                     return settings.nTable;
             }

             var scrollX = scroll.sX;
             var scrollY = scroll.sY;
             var classes = settings.oClasses;
             var caption = table.children(&#39;caption&#39;);
             var captionSide = caption.length ? caption[0]._captionSide : null;
             var headerClone = $( table[0].cloneNode(false) );
             var footerClone = $( table[0].cloneNode(false) );
             var footer = table.children(&#39;tfoot&#39;);
             var _div = &#39;&lt;div/&gt;&#39;;
             var size = function ( s ) {
                     return !s ? null : _fnStringToCss( s );
             };

             // This is fairly messy, but with x scrolling enabled, if the table has a
             // width attribute, regardless of any width applied using the column width
             // options, the browser will shrink or grow the table as needed to fit into
             // that 100%. That would make the width options useless. So we remove it.
             // This is okay, under the assumption that width:100% is applied to the
             // table in CSS (it is in the default stylesheet) which will set the table
             // width as appropriate (the attribute and css behave differently...)
             if ( scroll.sX &amp;&amp; table.attr(&#39;width&#39;) === &#39;100%&#39; ) {
                     table.removeAttr(&#39;width&#39;);
             }

             if ( ! footer.length ) {
                     footer = null;
             }

             /*
  The HTML structure that we want to generate in this function is:
   div - scroller
     div - scroll head
       div - scroll head inner
         table - scroll head table
           thead - thead
     div - scroll body
       table - table (master table)
         thead - thead clone for sizing
         tbody - tbody
     div - scroll foot
       div - scroll foot inner
         table - scroll foot table
           tfoot - tfoot
 /
             var scroller = $( _div, { &#39;class&#39;: classes.sScrollWrapper } )
                     .append(
                             $(_div, { &#39;class&#39;: classes.sScrollHead } )
                                     .css( {
                                             overflow: &#39;hidden&#39;,
                                             position: &#39;relative&#39;,
                                             border: 0,
                                             width: scrollX ? size(scrollX) : &#39;100%&#39;
                                     } )
                                     .append(
                                             $(_div, { &#39;class&#39;: classes.sScrollHeadInner } )
                                                     .css( {
                                                             &#39;box-sizing&#39;: &#39;content-box&#39;,
                                                             width: scroll.sXInner || &#39;100%&#39;
                                                     } )
                                                     .append(
                                                             headerClone
                                                                     .removeAttr(&#39;id&#39;)
                                                                     .css( &#39;margin-left&#39;, 0 )
                                                                     .append( captionSide === &#39;top&#39; ? caption : null )
                                                                     .append(
                                                                             table.children(&#39;thead&#39;)
                                                                     )
                                                     )
                                     )
                     )
                     .append(
                             $(_div, { &#39;class&#39;: classes.sScrollBody } )
                                     .css( {
                                             overflow: &#39;auto&#39;,
                                             height: size( scrollY ),
                                             width: size( scrollX )
                                     } )
                                     .append( table )
                     );

             if ( footer ) {
                     scroller.append(
                             $(_div, { &#39;class&#39;: classes.sScrollFoot } )
                                     .css( {
                                             overflow: &#39;hidden&#39;,
                                             border: 0,
                                             width: scrollX ? size(scrollX) : &#39;100%&#39;
                                     } )
                                     .append(
                                             $(_div, { &#39;class&#39;: classes.sScrollFootInner } )
                                                     .append(
                                                             footerClone
                                                                     .removeAttr(&#39;id&#39;)
                                                                     .css( &#39;margin-left&#39;, 0 )
                                                                     .append( captionSide === &#39;bottom&#39; ? caption : null )
                                                                     .append(
                                                                             table.children(&#39;tfoot&#39;)
                                                                     )
                                                     )
                                     )
                     );
             }

             var children = scroller.children();
             var scrollHead = children[0];
             var scrollBody = children[1];
             var scrollFoot = footer ? children[2] : null;

             // When the body is scrolled, then we also want to scroll the headers
             if ( scrollX ) {
                     $(scrollBody).on( &#39;scroll.DT&#39;, function (e) {
                             var scrollLeft = this.scrollLeft;

                             scrollHead.scrollLeft = scrollLeft;

                             if ( footer ) {
                                     scrollFoot.scrollLeft = scrollLeft;
                             }
                     } );
             }

             settings.nScrollHead = scrollHead;
             settings.nScrollBody = scrollBody;
             settings.nScrollFoot = scrollFoot;

             // On redraw - align columns
             settings.aoDrawCallback.push( {
                     &quot;fn&quot;: _fnScrollDraw,
                     &quot;sName&quot;: &quot;scrolling&quot;
             } );

             return scroller[0];
     }

     /**
 Update the header, footer and body tables for resizing - i.e. column
 alignment.

 Welcome to the most horrible function DataTables. The process that this
 function follows is basically:
   1. Re-create the table inside the scrolling div
   2. Take live measurements from the DOM
   3. Apply the measurements to align the columns
   4. Clean up

  @param {object} settings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnScrollDraw ( settings )
     {
             // Given that this is such a monster function, a lot of variables are use
             // to try and keep the minimised size as small as possible
             var
                     scroll         = settings.oScroll,
                     scrollX        = scroll.sX,
                     scrollXInner   = scroll.sXInner,
                     scrollY        = scroll.sY,
                     barWidth       = scroll.iBarWidth,
                     divHeader      = $(settings.nScrollHead),
                     divHeaderStyle = divHeader[0].style,
                     divHeaderInner = divHeader.children(&#39;div&#39;),
                     divHeaderInnerStyle = divHeaderInner[0].style,
                     divHeaderTable = divHeaderInner.children(&#39;table&#39;),
                     divBodyEl      = settings.nScrollBody,
                     divBody        = $(divBodyEl),
                     divBodyStyle   = divBodyEl.style,
                     divFooter      = $(settings.nScrollFoot),
                     divFooterInner = divFooter.children(&#39;div&#39;),
                     divFooterTable = divFooterInner.children(&#39;table&#39;),
                     header         = $(settings.nTHead),
                     table          = $(settings.nTable),
                     tableEl        = table[0],
                     tableStyle     = tableEl.style,
                     footer         = settings.nTFoot ? $(settings.nTFoot) : null,
                     browser        = settings.oBrowser,
                     ie67           = browser.bScrollOversize,
                     headerTrgEls, footerTrgEls,
                     headerSrcEls, footerSrcEls,
                     headerCopy, footerCopy,
                     headerWidths=[], footerWidths=[],
                     headerContent=[],
                     idx, correction, sanityWidth,
                     zeroOut = function(nSizer) {
                             var style = nSizer.style;
                             style.paddingTop = &quot;0&quot;;
                             style.paddingBottom = &quot;0&quot;;
                             style.borderTopWidth = &quot;0&quot;;
                             style.borderBottomWidth = &quot;0&quot;;
                             style.height = 0;
                     };

             /*
  1. Re-create the table inside the scrolling div
 /

             // Remove the old minimised thead and tfoot elements in the inner table
             table.children(&#39;thead, tfoot&#39;).remove();

             // Clone the current header and footer elements and then place it into the inner table
             headerCopy = header.clone().prependTo( table );
             headerTrgEls = header.find(&#39;tr&#39;); // original header is in its own table
             headerSrcEls = headerCopy.find(&#39;tr&#39;);
             headerCopy.find(&#39;th, td&#39;).removeAttr(&#39;tabindex&#39;);

             if ( footer ) {
                     footerCopy = footer.clone().prependTo( table );
                     footerTrgEls = footer.find(&#39;tr&#39;); // the original tfoot is in its own table and must be sized
                     footerSrcEls = footerCopy.find(&#39;tr&#39;);
             }

             /*
  2. Take live measurements from the DOM - do not alter the DOM itself!
 /

             // Remove old sizing and apply the calculated column widths
             // Get the unique column headers in the newly created (cloned) header. We want to apply the
             // calculated sizes to this header
             if ( ! scrollX )
             {
                     divBodyStyle.width = &#39;100%&#39;;
                     divHeader[0].style.width = &#39;100%&#39;;
             }

             $.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
                     idx = _fnVisibleToColumnIndex( settings, i );
                     el.style.width = settings.aoColumns[idx].sWidth;
             } );

             if ( footer ) {
                     _fnApplyToChildren( function(n) {
                             n.style.width = &quot;&quot;;
                     }, footerSrcEls );
             }

             // If scroll collapse is enabled, when we put the headers back into the body for sizing, we
             // will end up forcing the scrollbar to appear, making our measurements wrong for when we
             // then hide it (end of this function), so add the header height to the body scroller.
             if ( scroll.bCollapse &amp;&amp; scrollY !== &quot;&quot; ) {
                     divBodyStyle.height = (divBody[0].offsetHeight + header[0].offsetHeight)+&quot;px&quot;;
             }

             // Size the table as a whole
             sanityWidth = table.outerWidth();
             if ( scrollX === &quot;&quot; ) {
                     // No x scrolling
                     tableStyle.width = &quot;100%&quot;;

                     // IE7 will make the width of the table when 100% include the scrollbar
                     // - which is shouldn&#39;t. When there is a scrollbar we need to take this
                     // into account.
                     if ( ie67 &amp;&amp; (table.find(&#39;tbody&#39;).height() &gt; divBodyEl.offsetHeight ||
                             divBody.css(&#39;overflow-y&#39;) == &quot;scroll&quot;)
                     ) {
                             tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
                     }
             }
             else
             {
                     // x scrolling
                     if ( scrollXInner !== &quot;&quot; ) {
                             // x scroll inner has been given - use it
                             tableStyle.width = _fnStringToCss(scrollXInner);
                     }
                     else if ( sanityWidth == divBody.width() &amp;&amp; divBody.height() &lt; table.height() ) {
                             // There is y-scrolling - try to take account of the y scroll bar
                             tableStyle.width = _fnStringToCss( sanityWidth-barWidth );
                             if ( table.outerWidth() &gt; sanityWidth-barWidth ) {
                                     // Not possible to take account of it
                                     tableStyle.width = _fnStringToCss( sanityWidth );
                             }
                     }
                     else {
                             // When all else fails
                             tableStyle.width = _fnStringToCss( sanityWidth );
                     }
             }

             // Recalculate the sanity width - now that we&#39;ve applied the required width,
             // before it was a temporary variable. This is required because the column
             // width calculation is done before this table DOM is created.
             sanityWidth = table.outerWidth();

             // Hidden header should have zero height, so remove padding and borders. Then
             // set the width based on the real headers

             // Apply all styles in one pass
             _fnApplyToChildren( zeroOut, headerSrcEls );

             // Read all widths in next pass
             _fnApplyToChildren( function(nSizer) {
                     headerContent.push( nSizer.innerHTML );
                     headerWidths.push( _fnStringToCss( $(nSizer).css(&#39;width&#39;) ) );
             }, headerSrcEls );

             // Apply all widths in final pass
             _fnApplyToChildren( function(nToSize, i) {
                     nToSize.style.width = headerWidths[i];
             }, headerTrgEls );

             $(headerSrcEls).height(0);

             /* Same again with the footer if we have one */
             if ( footer )
             {
                     _fnApplyToChildren( zeroOut, footerSrcEls );

                     _fnApplyToChildren( function(nSizer) {
                             footerWidths.push( _fnStringToCss( $(nSizer).css(&#39;width&#39;) ) );
                     }, footerSrcEls );

                     _fnApplyToChildren( function(nToSize, i) {
                             nToSize.style.width = footerWidths[i];
                     }, footerTrgEls );

                     $(footerSrcEls).height(0);
             }

             /*
  3. Apply the measurements
 /

             // &quot;Hide&quot; the header and footer that we used for the sizing. We need to keep
             // the content of the cell so that the width applied to the header and body
             // both match, but we want to hide it completely. We want to also fix their
             // width to what they currently are
             _fnApplyToChildren( function(nSizer, i) {
                     nSizer.innerHTML = &#39;&lt;div class=&quot;dataTables_sizing&quot; style=&quot;height:0;overflow:hidden;&quot;&gt;&#39;+headerContent[i]+&#39;&lt;/div&gt;&#39;;
                     nSizer.style.width = headerWidths[i];
             }, headerSrcEls );

             if ( footer )
             {
                     _fnApplyToChildren( function(nSizer, i) {
                             nSizer.innerHTML = &quot;&quot;;
                             nSizer.style.width = footerWidths[i];
                     }, footerSrcEls );
             }

             // Sanity check that the table is of a sensible width. If not then we are going to get
             // misalignment - try to prevent this by not allowing the table to shrink below its min width
             if ( table.outerWidth() &lt; sanityWidth )
             {
                     // The min width depends upon if we have a vertical scrollbar visible or not */
                     correction = ((divBodyEl.scrollHeight &gt; divBodyEl.offsetHeight ||
                             divBody.css(&#39;overflow-y&#39;) == &quot;scroll&quot;)) ?
                                     sanityWidth+barWidth :
                                     sanityWidth;

                     // IE6/7 are a law unto themselves...
                     if ( ie67 &amp;&amp; (divBodyEl.scrollHeight &gt;
                             divBodyEl.offsetHeight || divBody.css(&#39;overflow-y&#39;) == &quot;scroll&quot;)
                     ) {
                             tableStyle.width = _fnStringToCss( correction-barWidth );
                     }

                     // And give the user a warning that we&#39;ve stopped the table getting too small
                     if ( scrollX === &quot;&quot; || scrollXInner !== &quot;&quot; ) {
                             _fnLog( settings, 1, &#39;Possible column misalignment&#39;, 6 );
                     }
             }
             else
             {
                     correction = &#39;100%&#39;;
             }

             // Apply to the container elements
             divBodyStyle.width = _fnStringToCss( correction );
             divHeaderStyle.width = _fnStringToCss( correction );

             if ( footer ) {
                     settings.nScrollFoot.style.width = _fnStringToCss( correction );
             }

             /*
  4. Clean up
 /
             if ( ! scrollY ) {
                     /* IE7&lt; puts a vertical scrollbar in place (when it shouldn&#39;t be) due to subtracting
   the scrollbar height from the visible display, rather than adding it on. We need to
   set the height in order to sort this. Don&#39;t want to do it in any other browsers.
  /
                     if ( ie67 ) {
                             divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
                     }
             }

             if ( scrollY &amp;&amp; scroll.bCollapse ) {
                     divBodyStyle.height = _fnStringToCss( scrollY );

                     var iExtra = (scrollX &amp;&amp; tableEl.offsetWidth &gt; divBodyEl.offsetWidth) ?
                             barWidth :
                             0;

                     if ( tableEl.offsetHeight &lt; divBodyEl.offsetHeight ) {
                             divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+iExtra );
                     }
             }

             /* Finally set the width&#39;s of the header and footer tables */
             var iOuterWidth = table.outerWidth();
             divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
             divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );

             // Figure out if there are scrollbar present - if so then we need a the header and footer to
             // provide a bit more space to allow &quot;overflow&quot; scrolling (i.e. past the scrollbar)
             var bScrolling = table.height() &gt; divBodyEl.clientHeight || divBody.css(&#39;overflow-y&#39;) == &quot;scroll&quot;;
             var padding = &#39;padding&#39; + (browser.bScrollbarLeft ? &#39;Left&#39; : &#39;Right&#39; );
             divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+&quot;px&quot; : &quot;0px&quot;;

             if ( footer ) {
                     divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
                     divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
                     divFooterInner[0].style[padding] = bScrolling ? barWidth+&quot;px&quot; : &quot;0px&quot;;
             }

             /* Adjust the position of the header in case we loose the y-scrollbar */
             divBody.scroll();

             // If sorting or filtering has occurred, jump the scrolling back to the top
             // only if we aren&#39;t holding the position
             if ( (settings.bSorted || settings.bFiltered) &amp;&amp; ! settings._drawHold ) {
                     divBodyEl.scrollTop = 0;
             }
     }

     /**
 Apply a given function to the display child nodes of an element array (typically
 TD children of TR rows
  @param {function} fn Method to apply to the objects
  @param array {nodes} an1 List of elements to look through for display children
  @param array {nodes} an2 Another list (identical structure to the first) - optional
  @memberof DataTable#oApi
/
     function _fnApplyToChildren( fn, an1, an2 )
     {
             var index=0, i=0, iLen=an1.length;
             var nNode1, nNode2;

             while ( i &lt; iLen ) {
                     nNode1 = an1[i].firstChild;
                     nNode2 = an2 ? an2[i].firstChild : null;

                     while ( nNode1 ) {
                             if ( nNode1.nodeType === 1 ) {
                                     if ( an2 ) {
                                             fn( nNode1, nNode2, index );
                                     }
                                     else {
                                             fn( nNode1, index );
                                     }

                                     index++;
                             }

                             nNode1 = nNode1.nextSibling;
                             nNode2 = an2 ? nNode2.nextSibling : null;
                     }

                     i++;
             }
     }

     var __re_html_remove = /&lt;.*?&gt;/g;

     /**
 Calculate the width of columns for the table
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnCalculateColumnWidths ( oSettings )
     {
             var
                     table = oSettings.nTable,
                     columns = oSettings.aoColumns,
                     scroll = oSettings.oScroll,
                     scrollY = scroll.sY,
                     scrollX = scroll.sX,
                     scrollXInner = scroll.sXInner,
                     columnCount = columns.length,
                     visibleColumns = _fnGetColumns( oSettings, &#39;bVisible&#39; ),
                     headerCells = $(&#39;th&#39;, oSettings.nTHead),
                     tableWidthAttr = table.getAttribute(&#39;width&#39;), // from DOM element
                     tableContainer = table.parentNode,
                     userInputs = false,
                     i, column, columnIdx, width, outerWidth;

             var styleWidth = table.style.width;
             if ( styleWidth &amp;&amp; styleWidth.indexOf(&#39;%&#39;) !== -1 ) {
                     tableWidthAttr = styleWidth;
             }

             /* Convert any user input sizes into pixel sizes */
             for ( i=0 ; i&lt;visibleColumns.length ; i++ ) {
                     column = columns[ visibleColumns[i] ];

                     if ( column.sWidth !== null ) {
                             column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );

                             userInputs = true;
                     }
             }

             /* If the number of columns in the DOM equals the number that we have to
  process in DataTables, then we can use the offsets that are created by
  the web- browser. No custom sizes can be set in order for this to happen,
  nor scrolling used
 /
             if ( ! userInputs &amp;&amp; ! scrollX &amp;&amp; ! scrollY &amp;&amp;
                 columnCount == _fnVisbleColumns( oSettings ) &amp;&amp;
                     columnCount == headerCells.length
             ) {
                     for ( i=0 ; i&lt;columnCount ; i++ ) {
                             columns[i].sWidth = _fnStringToCss( headerCells.eq(i).width() );
                     }
             }
             else
             {
                     // Otherwise construct a single row table with the widest node in the
                     // data, assign any user defined widths, then insert it into the DOM and
                     // allow the browser to do all the hard work of calculating table widths
                     var tmpTable = $(table).clone() // don&#39;t use cloneNode - IE8 will remove events on the main table
                             .empty()
                             .css( &#39;visibility&#39;, &#39;hidden&#39; )
                             .removeAttr( &#39;id&#39; )
                             .append( $(oSettings.nTHead).clone( false ) )
                             .append( $(oSettings.nTFoot).clone( false ) )
                             .append( $(&#39;&lt;tbody&gt;&lt;tr/&gt;&lt;/tbody&gt;&#39;) );

                     // Remove any assigned widths from the footer (from scrolling)
                     tmpTable.find(&#39;tfoot th, tfoot td&#39;).css(&#39;width&#39;, &#39;&#39;);

                     var tr = tmpTable.find( &#39;tbody tr&#39; );

                     // Apply custom sizing to the cloned header
                     headerCells = _fnGetUniqueThs( oSettings, tmpTable.find(&#39;thead&#39;)[0] );

                     for ( i=0 ; i&lt;visibleColumns.length ; i++ ) {
                             column = columns[ visibleColumns[i] ];

                             headerCells[i].style.width = column.sWidthOrig !== null &amp;&amp; column.sWidthOrig !== &#39;&#39; ?
                                     _fnStringToCss( column.sWidthOrig ) :
                                     &#39;&#39;;
                     }

                     // Find the widest cell for each column and put it into the table
                     if ( oSettings.aoData.length ) {
                             for ( i=0 ; i&lt;visibleColumns.length ; i++ ) {
                                     columnIdx = visibleColumns[i];
                                     column = columns[ columnIdx ];

                                     $( _fnGetWidestNode( oSettings, columnIdx ) )
                                             .clone( false )
                                             .append( column.sContentPadding )
                                             .appendTo( tr );
                             }
                     }

                     // Table has been built, attach to the document so we can work with it
                     tmpTable.appendTo( tableContainer );

                     // When scrolling (X or Y) we want to set the width of the table as 
                     // appropriate. However, when not scrolling leave the table width as it
                     // is. This results in slightly different, but I think correct behaviour
                     if ( scrollX &amp;&amp; scrollXInner ) {
                             tmpTable.width( scrollXInner );
                     }
                     else if ( scrollX ) {
                             tmpTable.css( &#39;width&#39;, &#39;auto&#39; );

                             if ( tmpTable.width() &lt; tableContainer.offsetWidth ) {
                                     tmpTable.width( tableContainer.offsetWidth );
                             }
                     }
                     else if ( scrollY ) {
                             tmpTable.width( tableContainer.offsetWidth );
                     }
                     else if ( tableWidthAttr ) {
                             tmpTable.width( tableWidthAttr );
                     }

                     // Take into account the y scrollbar
                     _fnScrollingWidthAdjust( oSettings, tmpTable[0] );

                     // Browsers need a bit of a hand when a width is assigned to any columns
                     // when x-scrolling as they tend to collapse the table to the min-width,
                     // even if we sent the column widths. So we need to keep track of what
                     // the table width should be by summing the user given values, and the
                     // automatic values
                     if ( scrollX )
                     {
                             var total = 0;

                             for ( i=0 ; i&lt;visibleColumns.length ; i++ ) {
                                     column = columns[ visibleColumns[i] ];
                                     outerWidth = $(headerCells[i]).outerWidth();

                                     total += column.sWidthOrig === null ?
                                             outerWidth :
                                             parseInt( column.sWidth, 10 ) + outerWidth - $(headerCells[i]).width();
                             }

                             tmpTable.width( _fnStringToCss( total ) );
                             table.style.width = _fnStringToCss( total );
                     }

                     // Get the width of each column in the constructed table
                     for ( i=0 ; i&lt;visibleColumns.length ; i++ ) {
                             column = columns[ visibleColumns[i] ];
                             width = $(headerCells[i]).width();

                             if ( width ) {
                                     column.sWidth = _fnStringToCss( width );
                             }
                     }

                     table.style.width = _fnStringToCss( tmpTable.css(&#39;width&#39;) );

                     // Finished with the table - ditch it
                     tmpTable.remove();
             }

             // If there is a width attr, we want to attach an event listener which
             // allows the table sizing to automatically adjust when the window is
             // resized. Use the width attr rather than CSS, since we can&#39;t know if the
             // CSS is a relative value or absolute - DOM read is always px.
             if ( tableWidthAttr ) {
                     table.style.width = _fnStringToCss( tableWidthAttr );
             }

             if ( (tableWidthAttr || scrollX) &amp;&amp; ! oSettings._reszEvt ) {
                     $(window).bind(&#39;resize.DT-&#39;+oSettings.sInstance, _fnThrottle( function () {
                             _fnAdjustColumnSizing( oSettings );
                     } ) );

                     oSettings._reszEvt = true;
             }
     }

     /**
 Throttle the calls to a function. Arguments and context are maintained for
 the throttled function
  @param {function} fn Function to be called
  @param {int} [freq=200] call frequency in mS
  @returns {function} wrapped function
  @memberof DataTable#oApi
/
     function _fnThrottle( fn, freq ) {
             var
                     frequency = freq !== undefined ? freq : 200,
                     last,
                     timer;

             return function () {
                     var
                             that = this,
                             now  = +new Date(),
                             args = arguments;

                     if ( last &amp;&amp; now &lt; last + frequency ) {
                             clearTimeout( timer );

                             timer = setTimeout( function () {
                                     last = undefined;
                                     fn.apply( that, args );
                             }, frequency );
                     }
                     else {
                             last = now;
                             fn.apply( that, args );
                     }
             };
     }

     /**
 Convert a CSS unit width to pixels (e.g. 2em)
  @param {string} width width to be converted
  @param {node} parent parent to get the with for (required for relative widths) - optional
  @returns {int} width in pixels
  @memberof DataTable#oApi
/
     function _fnConvertToWidth ( width, parent )
     {
             if ( ! width ) {
                     return 0;
             }

             var n = $(&#39;&lt;div/&gt;&#39;)
                     .css( &#39;width&#39;, _fnStringToCss( width ) )
                     .appendTo( parent || document.body );

             var val = n[0].offsetWidth;
             n.remove();

             return val;
     }

     /**
 Adjust a table&#39;s width to take account of vertical scroll bar
  @param {object} oSettings dataTables settings object
  @param {node} n table node
  @memberof DataTable#oApi
/

     function _fnScrollingWidthAdjust ( settings, n )
     {
             var scroll = settings.oScroll;

             if ( scroll.sX || scroll.sY ) {
                     // When y-scrolling only, we want to remove the width of the scroll bar
                     // so the table + scroll bar will fit into the area available, otherwise
                     // we fix the table at its current size with no adjustment
                     var correction = ! scroll.sX ? scroll.iBarWidth : 0;
                     n.style.width = _fnStringToCss( $(n).outerWidth() - correction );
             }
     }

     /**
 Get the widest node
  @param {object} settings dataTables settings object
  @param {int} colIdx column of interest
  @returns {node} widest table node
  @memberof DataTable#oApi
/
     function _fnGetWidestNode( settings, colIdx )
     {
             var idx = _fnGetMaxLenString( settings, colIdx );
             if ( idx &lt; 0 ) {
                     return null;
             }

             var data = settings.aoData[ idx ];
             return ! data.nTr ? // Might not have been created when deferred rendering
                     $(&#39;&lt;td/&gt;&#39;).html( _fnGetCellData( settings, idx, colIdx, &#39;display&#39; ) )[0] :
                     data.anCells[ colIdx ];
     }

     /**
 Get the maximum strlen for each data column
  @param {object} settings dataTables settings object
  @param {int} colIdx column of interest
  @returns {string} max string length for each column
  @memberof DataTable#oApi
/
     function _fnGetMaxLenString( settings, colIdx )
     {
             var s, max=-1, maxIdx = -1;

             for ( var i=0, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
                     s = _fnGetCellData( settings, i, colIdx, &#39;display&#39; )+&#39;&#39;;
                     s = s.replace( __re_html_remove, &#39;&#39; );

                     if ( s.length &gt; max ) {
                             max = s.length;
                             maxIdx = i;
                     }
             }

             return maxIdx;
     }

     /**
 Append a CSS unit (only if required) to a string
  @param {string} value to css-ify
  @returns {string} value with css unit
  @memberof DataTable#oApi
/
     function _fnStringToCss( s )
     {
             if ( s === null ) {
                     return &#39;0px&#39;;
             }

             if ( typeof s == &#39;number&#39; ) {
                     return s &lt; 0 ?
                             &#39;0px&#39; :
                             s+&#39;px&#39;;
             }

             // Check it has a unit character already
             return s.match(/\d$/) ?
                     s+&#39;px&#39; :
                     s;
     }

     /**
 Get the width of a scroll bar in this browser being used
  @returns {int} width in pixels
  @memberof DataTable#oApi
/
     function _fnScrollBarWidth ()
     {
             // On first run a static variable is set, since this is only needed once.
             // Subsequent runs will just use the previously calculated value
             var width = DataTable.__scrollbarWidth;

             if ( width === undefined ) {
                     var sizer = $(&#39;&lt;p/&gt;&#39;).css( {
                                     position: &#39;absolute&#39;,
                                     top: 0,
                                     left: 0,
                                     width: &#39;100%&#39;,
                                     height: 150,
                                     padding: 0,
                                     overflow: &#39;scroll&#39;,
                                     visibility: &#39;hidden&#39;
                             } )
                             .appendTo(&#39;body&#39;);

                     width = sizer[0].offsetWidth - sizer[0].clientWidth;
                     DataTable.__scrollbarWidth = width;

                     sizer.remove();
             }

             return width;
     }

     function _fnSortFlatten ( settings )
     {
             var
                     i, iLen, k, kLen,
                     aSort = [],
                     aiOrig = [],
                     aoColumns = settings.aoColumns,
                     aDataSort, iCol, sType, srcCol,
                     fixed = settings.aaSortingFixed,
                     fixedObj = $.isPlainObject( fixed ),
                     nestedSort = [],
                     add = function ( a ) {
                             if ( a.length &amp;&amp; ! $.isArray( a[0] ) ) {
                                     // 1D array
                                     nestedSort.push( a );
                             }
                             else {
                                     // 2D array
                                     nestedSort.push.apply( nestedSort, a );
                             }
                     };

             // Build the sort array, with pre-fix and post-fix options if they have been
             // specified
             if ( $.isArray( fixed ) ) {
                     add( fixed );
             }

             if ( fixedObj &amp;&amp; fixed.pre ) {
                     add( fixed.pre );
             }

             add( settings.aaSorting );

             if (fixedObj &amp;&amp; fixed.post ) {
                     add( fixed.post );
             }

             for ( i=0 ; i&lt;nestedSort.length ; i++ )
             {
                     srcCol = nestedSort[i][0];
                     aDataSort = aoColumns[ srcCol ].aDataSort;

                     for ( k=0, kLen=aDataSort.length ; k&lt;kLen ; k++ )
                     {
                             iCol = aDataSort[k];
                             sType = aoColumns[ iCol ].sType || &#39;string&#39;;

                             if ( nestedSort[i]._idx === undefined ) {
                                     nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
                             }

                             aSort.push( {
                                     src:       srcCol,
                                     col:       iCol,
                                     dir:       nestedSort[i][1],
                                     index:     nestedSort[i]._idx,
                                     type:      sType,
                                     formatter: DataTable.ext.type.order[ sType+&quot;-pre&quot; ]
                             } );
                     }
             }

             return aSort;
     }

     /**
 Change the order of the table
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
  @todo This really needs split up!
/
     function _fnSort ( oSettings )
     {
             var
                     i, ien, iLen, j, jLen, k, kLen,
                     sDataType, nTh,
                     aiOrig = [],
                     oExtSort = DataTable.ext.type.order,
                     aoData = oSettings.aoData,
                     aoColumns = oSettings.aoColumns,
                     aDataSort, data, iCol, sType, oSort,
                     formatters = 0,
                     sortCol,
                     displayMaster = oSettings.aiDisplayMaster,
                     aSort;

             // Resolve any column types that are unknown due to addition or invalidation
             // @todo Can this be moved into a &#39;data-ready&#39; handler which is called when
             //   data is going to be used in the table?
             _fnColumnTypes( oSettings );

             aSort = _fnSortFlatten( oSettings );

             for ( i=0, ien=aSort.length ; i&lt;ien ; i++ ) {
                     sortCol = aSort[i];

                     // Track if we can use the fast sort algorithm
                     if ( sortCol.formatter ) {
                             formatters++;
                     }

                     // Load the data needed for the sort, for each cell
                     _fnSortData( oSettings, sortCol.col );
             }

             /* No sorting required if server-side or no sorting array */
             if ( _fnDataSource( oSettings ) != &#39;ssp&#39; &amp;&amp; aSort.length !== 0 )
             {
                     // Create a value - key array of the current row positions such that we can use their
                     // current position during the sort, if values match, in order to perform stable sorting
                     for ( i=0, iLen=displayMaster.length ; i&lt;iLen ; i++ ) {
                             aiOrig[ displayMaster[i] ] = i;
                     }

                     /* Do the sort - here we want multi-column sorting based on a given data source (column)
   and sorting function (from oSort) in a certain direction. It&#39;s reasonably complex to
   follow on it&#39;s own, but this is what we want (example two column sorting):
    fnLocalSorting = function(a,b){
      var iTest;
      iTest = oSort[&#39;string-asc&#39;](&#39;data11&#39;, &#39;data12&#39;);
        if (iTest !== 0)
          return iTest;
      iTest = oSort[&#39;numeric-desc&#39;](&#39;data21&#39;, &#39;data22&#39;);
      if (iTest !== 0)
        return iTest;
      return oSort[&#39;numeric-asc&#39;]( aiOrig[a], aiOrig[b] );
    }
   Basically we have a test for each sorting column, if the data in that column is equal,
   test the next column. If all columns match, then we use a numeric sort on the row
   positions in the original data array to provide a stable sort.

   Note - I know it seems excessive to have two sorting methods, but the first is around
   15% faster, so the second is only maintained for backwards compatibility with sorting
   methods which do not have a pre-sort formatting function.
  /
                     if ( formatters === aSort.length ) {
                             // All sort types have formatting functions
                             displayMaster.sort( function ( a, b ) {
                                     var
                                             x, y, k, test, sort,
                                             len=aSort.length,
                                             dataA = aoData[a]._aSortData,
                                             dataB = aoData[b]._aSortData;

                                     for ( k=0 ; k&lt;len ; k++ ) {
                                             sort = aSort[k];

                                             x = dataA[ sort.col ];
                                             y = dataB[ sort.col ];

                                             test = x&lt;y ? -1 : x&gt;y ? 1 : 0;
                                             if ( test !== 0 ) {
                                                     return sort.dir === &#39;asc&#39; ? test : -test;
                                             }
                                     }

                                     x = aiOrig[a];
                                     y = aiOrig[b];
                                     return x&lt;y ? -1 : x&gt;y ? 1 : 0;
                             } );
                     }
                     else {
                             // Depreciated - remove in 1.11 (providing a plug-in option)
                             // Not all sort types have formatting methods, so we have to call their sorting
                             // methods.
                             displayMaster.sort( function ( a, b ) {
                                     var
                                             x, y, k, l, test, sort, fn,
                                             len=aSort.length,
                                             dataA = aoData[a]._aSortData,
                                             dataB = aoData[b]._aSortData;

                                     for ( k=0 ; k&lt;len ; k++ ) {
                                             sort = aSort[k];

                                             x = dataA[ sort.col ];
                                             y = dataB[ sort.col ];

                                             fn = oExtSort[ sort.type+&quot;-&quot;+sort.dir ] || oExtSort[ &quot;string-&quot;+sort.dir ];
                                             test = fn( x, y );
                                             if ( test !== 0 ) {
                                                     return test;
                                             }
                                     }

                                     x = aiOrig[a];
                                     y = aiOrig[b];
                                     return x&lt;y ? -1 : x&gt;y ? 1 : 0;
                             } );
                     }
             }

             /* Tell the draw function that we have sorted the data */
             oSettings.bSorted = true;
     }

     function _fnSortAria ( settings )
     {
             var label;
             var nextSort;
             var columns = settings.aoColumns;
             var aSort = _fnSortFlatten( settings );
             var oAria = settings.oLanguage.oAria;

             // ARIA attributes - need to loop all columns, to update all (removing old
             // attributes as needed)
             for ( var i=0, iLen=columns.length ; i&lt;iLen ; i++ )
             {
                     var col = columns[i];
                     var asSorting = col.asSorting;
                     var sTitle = col.sTitle.replace( /&lt;.*?&gt;/g, &quot;&quot; );
                     var th = col.nTh;

                     // IE7 is throwing an error when setting these properties with jQuery&#39;s
                     // attr() and removeAttr() methods...
                     th.removeAttribute(&#39;aria-sort&#39;);

                     /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
                     if ( col.bSortable ) {
                             if ( aSort.length &gt; 0 &amp;&amp; aSort[0].col == i ) {
                                     th.setAttribute(&#39;aria-sort&#39;, aSort[0].dir==&quot;asc&quot; ? &quot;ascending&quot; : &quot;descending&quot; );
                                     nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
                             }
                             else {
                                     nextSort = asSorting[0];
                             }

                             label = sTitle + ( nextSort === &quot;asc&quot; ?
                                     oAria.sSortAscending :
                                     oAria.sSortDescending
                             );
                     }
                     else {
                             label = sTitle;
                     }

                     th.setAttribute(&#39;aria-label&#39;, label);
             }
     }

     /**
 Function to run on user sort request
  @param {object} settings dataTables settings object
  @param {node} attachTo node to attach the handler to
  @param {int} colIdx column sorting index
  @param {boolean} [append=false] Append the requested sort to the existing
    sort if true (i.e. multi-column sort)
  @param {function} [callback] callback function
  @memberof DataTable#oApi
/
     function _fnSortListener ( settings, colIdx, append, callback )
     {
             var col = settings.aoColumns[ colIdx ];
             var sorting = settings.aaSorting;
             var asSorting = col.asSorting;
             var nextSortIdx;
             var next = function ( a, overflow ) {
                     var idx = a._idx;
                     if ( idx === undefined ) {
                             idx = $.inArray( a[1], asSorting );
                     }

                     return idx+1 &lt; asSorting.length ?
                             idx+1 :
                             overflow ?
                                     null :
                                     0;
             };

             // Convert to 2D array if needed
             if ( typeof sorting[0] === &#39;number&#39; ) {
                     sorting = settings.aaSorting = [ sorting ];
             }

             // If appending the sort then we are multi-column sorting
             if ( append &amp;&amp; settings.oFeatures.bSortMulti ) {
                     // Are we already doing some kind of sort on this column?
                     var sortIdx = $.inArray( colIdx, _pluck(sorting, &#39;0&#39;) );

                     if ( sortIdx !== -1 ) {
                             // Yes, modify the sort
                             nextSortIdx = next( sorting[sortIdx], true );

                             if ( nextSortIdx === null &amp;&amp; sorting.length === 1 ) {
                                     nextSortIdx = 0; // can&#39;t remove sorting completely
                             }

                             if ( nextSortIdx === null ) {
                                     sorting.splice( sortIdx, 1 );
                             }
                             else {
                                     sorting[sortIdx][1] = asSorting[ nextSortIdx ];
                                     sorting[sortIdx]._idx = nextSortIdx;
                             }
                     }
                     else {
                             // No sort on this column yet
                             sorting.push( [ colIdx, asSorting[0], 0 ] );
                             sorting[sorting.length-1]._idx = 0;
                     }
             }
             else if ( sorting.length &amp;&amp; sorting[0][0] == colIdx ) {
                     // Single column - already sorting on this column, modify the sort
                     nextSortIdx = next( sorting[0] );

                     sorting.length = 1;
                     sorting[0][1] = asSorting[ nextSortIdx ];
                     sorting[0]._idx = nextSortIdx;
             }
             else {
                     // Single column - sort only on this column
                     sorting.length = 0;
                     sorting.push( [ colIdx, asSorting[0] ] );
                     sorting[0]._idx = 0;
             }

             // Run the sort by calling a full redraw
             _fnReDraw( settings );

             // callback used for async user interaction
             if ( typeof callback == &#39;function&#39; ) {
                     callback( settings );
             }
     }

     /**
 Attach a sort handler (click) to a node
  @param {object} settings dataTables settings object
  @param {node} attachTo node to attach the handler to
  @param {int} colIdx column sorting index
  @param {function} [callback] callback function
  @memberof DataTable#oApi
/
     function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
     {
             var col = settings.aoColumns[ colIdx ];

             _fnBindAction( attachTo, {}, function (e) {
                     /* If the column is not sortable - don&#39;t to anything */
                     if ( col.bSortable === false ) {
                             return;
                     }

                     // If processing is enabled use a timeout to allow the processing
                     // display to be shown - otherwise to it synchronously
                     if ( settings.oFeatures.bProcessing ) {
                             _fnProcessingDisplay( settings, true );

                             setTimeout( function() {
                                     _fnSortListener( settings, colIdx, e.shiftKey, callback );

                                     // In server-side processing, the draw callback will remove the
                                     // processing display
                                     if ( _fnDataSource( settings ) !== &#39;ssp&#39; ) {
                                             _fnProcessingDisplay( settings, false );
                                     }
                             }, 0 );
                     }
                     else {
                             _fnSortListener( settings, colIdx, e.shiftKey, callback );
                     }
             } );
     }

     /**
 Set the sorting classes on table&#39;s body, Note: it is safe to call this function
 when bSort and bSortClasses are false
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnSortingClasses( settings )
     {
             var oldSort = settings.aLastSort;
             var sortClass = settings.oClasses.sSortColumn;
             var sort = _fnSortFlatten( settings );
             var features = settings.oFeatures;
             var i, ien, colIdx;

             if ( features.bSort &amp;&amp; features.bSortClasses ) {
                     // Remove old sorting classes
                     for ( i=0, ien=oldSort.length ; i&lt;ien ; i++ ) {
                             colIdx = oldSort[i].src;

                             // Remove column sorting
                             $( _pluck( settings.aoData, &#39;anCells&#39;, colIdx ) )
                                     .removeClass( sortClass + (i&lt;2 ? i+1 : 3) );
                     }

                     // Add new column sorting
                     for ( i=0, ien=sort.length ; i&lt;ien ; i++ ) {
                             colIdx = sort[i].src;

                             $( _pluck( settings.aoData, &#39;anCells&#39;, colIdx ) )
                                     .addClass( sortClass + (i&lt;2 ? i+1 : 3) );
                     }
             }

             settings.aLastSort = sort;
     }

     // Get the data to sort a column, be it from cache, fresh (populating the
     // cache), or from a sort formatter
     function _fnSortData( settings, idx )
     {
             // Custom sorting function - provided by the sort data type
             var column = settings.aoColumns[ idx ];
             var customSort = DataTable.ext.order[ column.sSortDataType ];
             var customData;

             if ( customSort ) {
                     customData = customSort.call( settings.oInstance, settings, idx,
                             _fnColumnIndexToVisible( settings, idx )
                     );
             }

             // Use / populate cache
             var row, cellData;
             var formatter = DataTable.ext.type.order[ column.sType+&quot;-pre&quot; ];

             for ( var i=0, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
                     row = settings.aoData[i];

                     if ( ! row._aSortData ) {
                             row._aSortData = [];
                     }

                     if ( ! row._aSortData[idx] || customSort ) {
                             cellData = customSort ?
                                     customData[i] : // If there was a custom sort function, use data from there
                                     _fnGetCellData( settings, i, idx, &#39;sort&#39; );

                             row._aSortData[ idx ] = formatter ?
                                     formatter( cellData ) :
                                     cellData;
                     }
             }
     }

     /**
 Save the state of a table
  @param {object} oSettings dataTables settings object
  @memberof DataTable#oApi
/
     function _fnSaveState ( settings )
     {
             if ( !settings.oFeatures.bStateSave || settings.bDestroying )
             {
                     return;
             }

             /* Store the interesting variables */
             var state = {
                     time:    +new Date(),
                     start:   settings._iDisplayStart,
                     length:  settings._iDisplayLength,
                     order:   $.extend( true, [], settings.aaSorting ),
                     search:  _fnSearchToCamel( settings.oPreviousSearch ),
                     columns: $.map( settings.aoColumns, function ( col, i ) {
                             return {
                                     visible: col.bVisible,
                                     search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
                             };
                     } )
             };

             _fnCallbackFire( settings, &quot;aoStateSaveParams&quot;, &#39;stateSaveParams&#39;, [settings, state] );

             settings.oSavedState = state;
             settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
     }

     /**
 Attempt to load a saved table state
  @param {object} oSettings dataTables settings object
  @param {object} oInit DataTables init object so we can override settings
  @memberof DataTable#oApi
/
     function _fnLoadState ( settings, oInit )
     {
             var i, ien;
             var columns = settings.aoColumns;

             if ( ! settings.oFeatures.bStateSave ) {
                     return;
             }

             var state = settings.fnStateLoadCallback.call( settings.oInstance, settings );
             if ( ! state || ! state.time ) {
                     return;
             }

             /* Allow custom and plug-in manipulation functions to alter the saved data set and
  cancelling of loading by returning false
 /
             var abStateLoad = _fnCallbackFire( settings, &#39;aoStateLoadParams&#39;, &#39;stateLoadParams&#39;, [settings, state] );
             if ( $.inArray( false, abStateLoad ) !== -1 ) {
                     return;
             }

             /* Reject old data */
             var duration = settings.iStateDuration;
             if ( duration &gt; 0 &amp;&amp; state.time &lt; +new Date() - (duration*1000) ) {
                     return;
             }

             // Number of columns have changed - all bets are off, no restore of settings
             if ( columns.length !== state.columns.length ) {
                     return;
             }

             // Store the saved state so it might be accessed at any time
             settings.oLoadedState = $.extend( true, {}, state );

             // Restore key features - todo - for 1.11 this needs to be done by
             // subscribed events
             if ( state.start !== undefined ) {
                     settings._iDisplayStart    = state.start;
                     settings.iInitDisplayStart = state.start;
             }
             if ( state.length !== undefined ) {
                     settings._iDisplayLength   = state.length;
             }

             // Order
             if ( state.order !== undefined ) {
                     settings.aaSorting = [];
                     $.each( state.order, function ( i, col ) {
                             settings.aaSorting.push( col[0] &gt;= columns.length ?
                                     [ 0, col[1] ] :
                                     col
                             );
                     } );
             }

             // Search
             if ( state.search !== undefined ) {
                     $.extend( settings.oPreviousSearch, _fnSearchToHung( state.search ) );
             }

             // Columns
             for ( i=0, ien=state.columns.length ; i&lt;ien ; i++ ) {
                     var col = state.columns[i];

                     // Visibility
                     if ( col.visible !== undefined ) {
                             columns[i].bVisible = col.visible;
                     }

                     // Search
                     if ( col.search !== undefined ) {
                             $.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
                     }
             }

             _fnCallbackFire( settings, &#39;aoStateLoaded&#39;, &#39;stateLoaded&#39;, [settings, state] );
     }

     /**
 Return the settings object for a particular table
  @param {node} table table we are using as a dataTable
  @returns {object} Settings object - or null if not found
  @memberof DataTable#oApi
/
     function _fnSettingsFromNode ( table )
     {
             var settings = DataTable.settings;
             var idx = $.inArray( table, _pluck( settings, &#39;nTable&#39; ) );

             return idx !== -1 ?
                     settings[ idx ] :
                     null;
     }

     /**
 Log an error message
  @param {object} settings dataTables settings object
  @param {int} level log error messages, or display them to the user
  @param {string} msg error message
  @param {int} tn Technical note id to get more information about the error.
  @memberof DataTable#oApi
/
     function _fnLog( settings, level, msg, tn )
     {
             msg = &#39;DataTables warning: &#39;+
                     (settings!==null ? &#39;table id=&#39;+settings.sTableId+&#39; - &#39; : &#39;&#39;)+msg;

             if ( tn ) {
                     msg += &#39;. For more information about this error, please see &#39;+
                     &#39;http://datatables.net/tn/&#39;+tn;
             }

             if ( ! level  ) {
                     // Backwards compatibility pre 1.10
                     var ext = DataTable.ext;
                     var type = ext.sErrMode || ext.errMode;

                     _fnCallbackFire( settings, null, &#39;error&#39;, [ settings, tn, msg ] );

                     if ( type == &#39;alert&#39; ) {
                             alert( msg );
                     }
                     else if ( type == &#39;throw&#39; ) {
                             throw new Error(msg);
                     }
                     else if ( typeof type == &#39;function&#39; ) {
                             type( settings, tn, msg );
                     }
             }
             else if ( window.console &amp;&amp; console.log ) {
                     console.log( msg );
             }
     }

     /**
 See if a property is defined on one object, if so assign it to the other object
  @param {object} ret target object
  @param {object} src source object
  @param {string} name property
  @param {string} [mappedName] name to map too - optional, name used if not given
  @memberof DataTable#oApi
/
     function _fnMap( ret, src, name, mappedName )
     {
             if ( $.isArray( name ) ) {
                     $.each( name, function (i, val) {
                             if ( $.isArray( val ) ) {
                                     _fnMap( ret, src, val[0], val[1] );
                             }
                             else {
                                     _fnMap( ret, src, val );
                             }
                     } );

                     return;
             }

             if ( mappedName === undefined ) {
                     mappedName = name;
             }

             if ( src[name] !== undefined ) {
                     ret[mappedName] = src[name];
             }
     }

     /**
 Extend objects - very similar to jQuery.extend, but deep copy objects, and
 shallow copy arrays. The reason we need to do this, is that we don&#39;t want to
 deep copy array init values (such as aaSorting) since the dev wouldn&#39;t be
 able to override them, but we do want to deep copy arrays.
  @param {object} out Object to extend
  @param {object} extender Object from which the properties will be applied to
      out
  @param {boolean} breakRefs If true, then arrays will be sliced to take an
      independent copy with the exception of the `data` or `aaData` parameters
      if they are present. This is so you can pass in a collection to
      DataTables and have that used as your data source without breaking the
      references
  @returns {object} out Reference, just for convenience - out === the return.
  @memberof DataTable#oApi
  @todo This doesn&#39;t take account of arrays inside the deep copied objects.
/
     function _fnExtend( out, extender, breakRefs )
     {
             var val;

             for ( var prop in extender ) {
                     if ( extender.hasOwnProperty(prop) ) {
                             val = extender[prop];

                             if ( $.isPlainObject( val ) ) {
                                     if ( ! $.isPlainObject( out[prop] ) ) {
                                             out[prop] = {};
                                     }
                                     $.extend( true, out[prop], val );
                             }
                             else if ( breakRefs &amp;&amp; prop !== &#39;data&#39; &amp;&amp; prop !== &#39;aaData&#39; &amp;&amp; $.isArray(val) ) {
                                     out[prop] = val.slice();
                             }
                             else {
                                     out[prop] = val;
                             }
                     }
             }

             return out;
     }

     /**
 Bind an event handers to allow a click or return key to activate the callback.
 This is good for accessibility since a return on the keyboard will have the
 same effect as a click, if the element has focus.
  @param {element} n Element to bind the action to
  @param {object} oData Data object to pass to the triggered function
  @param {function} fn Callback function for when the event is triggered
  @memberof DataTable#oApi
/
     function _fnBindAction( n, oData, fn )
     {
             $(n)
                     .bind( &#39;click.DT&#39;, oData, function (e) {
                                     n.blur(); // Remove focus outline for mouse users
                                     fn(e);
                             } )
                     .bind( &#39;keypress.DT&#39;, oData, function (e){
                                     if ( e.which === 13 ) {
                                             e.preventDefault();
                                             fn(e);
                                     }
                             } )
                     .bind( &#39;selectstart.DT&#39;, function () {
                                     /* Take the brutal approach to cancelling text selection */
                                     return false;
                             } );
     }

     /**
 Register a callback function. Easily allows a callback function to be added to
 an array store of callback functions that can then all be called together.
  @param {object} oSettings dataTables settings object
  @param {string} sStore Name of the array storage for the callbacks in oSettings
  @param {function} fn Function to be called back
  @param {string} sName Identifying name for the callback (i.e. a label)
  @memberof DataTable#oApi
/
     function _fnCallbackReg( oSettings, sStore, fn, sName )
     {
             if ( fn )
             {
                     oSettings[sStore].push( {
                             &quot;fn&quot;: fn,
                             &quot;sName&quot;: sName
                     } );
             }
     }

     /**
 Fire callback functions and trigger events. Note that the loop over the
 callback array store is done backwards! Further note that you do not want to
 fire off triggers in time sensitive applications (for example cell creation)
 as its slow.
  @param {object} settings dataTables settings object
  @param {string} callbackArr Name of the array storage for the callbacks in
      oSettings
  @param {string} event Name of the jQuery custom event to trigger. If null no
      trigger is fired
  @param {array} args Array of arguments to pass to the callback function /
      trigger
  @memberof DataTable#oApi
/
     function _fnCallbackFire( settings, callbackArr, e, args )
     {
             var ret = [];

             if ( callbackArr ) {
                     ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
                             return val.fn.apply( settings.oInstance, args );
                     } );
             }

             if ( e !== null ) {
                     $(settings.nTable).trigger( e+&#39;.dt&#39;, args );
             }

             return ret;
     }

     function _fnLengthOverflow ( settings )
     {
             var
                     start = settings._iDisplayStart,
                     end = settings.fnDisplayEnd(),
                     len = settings._iDisplayLength;

             /* If we have space to show extra rows (backing up from the end point - then do so */
             if ( start &gt;= end )
             {
                     start = end - len;
             }

             // Keep the start record on the current page
             start -= (start % len);

             if ( len === -1 || start &lt; 0 )
             {
                     start = 0;
             }

             settings._iDisplayStart = start;
     }

     function _fnRenderer( settings, type )
     {
             var renderer = settings.renderer;
             var host = DataTable.ext.renderer[type];

             if ( $.isPlainObject( renderer ) &amp;&amp; renderer[type] ) {
                     // Specific renderer for this type. If available use it, otherwise use
                     // the default.
                     return host[renderer[type]] || host._;
             }
             else if ( typeof renderer === &#39;string&#39; ) {
                     // Common renderer - if there is one available for this type use it,
                     // otherwise use the default
                     return host[renderer] || host._;
             }

             // Use the default
             return host._;
     }

     /**
 Detect the data source being used for the table. Used to simplify the code
 a little (ajax) and to make it compress a little smaller.

  @param {object} settings dataTables settings object
  @returns {string} Data source
  @memberof DataTable#oApi
/
     function _fnDataSource ( settings )
     {
             if ( settings.oFeatures.bServerSide ) {
                     return &#39;ssp&#39;;
             }
             else if ( settings.ajax || settings.sAjaxSource ) {
                     return &#39;ajax&#39;;
             }
             return &#39;dom&#39;;
     }

     DataTable = function( options )
     {
             /**
  Perform a jQuery selector action on the table&#39;s TR elements (from the tbody) and
  return the resulting jQuery object.
   @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
   @param {object} [oOpts] Optional parameters for modifying the rows to be included
   @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
     criterion (&quot;applied&quot;) or all TR elements (i.e. no filter).
   @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
     Can be either &#39;current&#39;, whereby the current sorting of the table is used, or
     &#39;original&#39; whereby the original order the data was read into the table is used.
   @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     (&quot;current&quot;) or not (&quot;all&quot;). If &#39;current&#39; is given, then order is assumed to be
     &#39;current&#39; and filter is &#39;applied&#39;, regardless of what they might be given as.
   @returns {object} jQuery object, filtered by the given selector.
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Highlight every second row
       oTable.$(&#39;tr:odd&#39;).css(&#39;backgroundColor&#39;, &#39;blue&#39;);
     } );

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Filter to rows with &#39;Webkit&#39; in them, add a background colour and then
       // remove the filter, thus highlighting the &#39;Webkit&#39; rows only.
       oTable.fnFilter(&#39;Webkit&#39;);
       oTable.$(&#39;tr&#39;, {&quot;search&quot;: &quot;applied&quot;}).css(&#39;backgroundColor&#39;, &#39;blue&#39;);
       oTable.fnFilter(&#39;&#39;);
     } );
 /
             this.$ = function ( sSelector, oOpts )
             {
                     return this.api(true).$( sSelector, oOpts );
             };

             /**
  Almost identical to $ in operation, but in this case returns the data for the matched
  rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
  rather than any descendants, so the data can be obtained for the row/cell. If matching
  rows are found, the data returned is the original data array/object that was used to
  create the row (or a generated array if from a DOM source).

  This method is often useful in-combination with $ where both functions are given the
  same parameters and the array indexes will match identically.
   @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
   @param {object} [oOpts] Optional parameters for modifying the rows to be included
   @param {string} [oOpts.filter=none] Select elements that meet the current filter
     criterion (&quot;applied&quot;) or all elements (i.e. no filter).
   @param {string} [oOpts.order=current] Order of the data in the processed array.
     Can be either &#39;current&#39;, whereby the current sorting of the table is used, or
     &#39;original&#39; whereby the original order the data was read into the table is used.
   @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     (&quot;current&quot;) or not (&quot;all&quot;). If &#39;current&#39; is given, then order is assumed to be
     &#39;current&#39; and filter is &#39;applied&#39;, regardless of what they might be given as.
   @returns {array} Data for the matched elements. If any elements, as a result of the
     selector, were not TR, TD or TH elements in the DataTable, they will have a null
     entry in the array.
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Get the data from the first row in the table
       var data = oTable._(&#39;tr:first&#39;);

       // Do something useful with the data
       alert( &quot;First cell is: &quot;+data[0] );
     } );

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Filter to &#39;Webkit&#39; and get all data for
       oTable.fnFilter(&#39;Webkit&#39;);
       var data = oTable._(&#39;tr&#39;, {&quot;search&quot;: &quot;applied&quot;});

       // Do something with the data
       alert( data.length+&quot; rows matched the search&quot; );
     } );
 /
             this._ = function ( sSelector, oOpts )
             {
                     return this.api(true).rows( sSelector, oOpts ).data();
             };

             /**
  Create a DataTables Api instance, with the currently selected tables for
  the Api&#39;s context.
  @param {boolean} [traditional=false] Set the API instance&#39;s context to be
    only the table referred to by the `DataTable.ext.iApiIndex` option, as was
    used in the API presented by DataTables 1.9- (i.e. the traditional mode),
    or if all tables captured in the jQuery object should be used.
  @return {DataTables.Api}
 /
             this.api = function ( traditional )
             {
                     return traditional ?
                             new _Api(
                                     _fnSettingsFromNode( this[ _ext.iApiIndex ] )
                             ) :
                             new _Api( this );
             };

             /**
  Add a single new row or multiple rows of data to the table. Please note
  that this is suitable for client-side processing only - if you are using
  server-side processing (i.e. &quot;bServerSide&quot;: true), then to add data, you
  must add it to the data source, i.e. the server-side, through an Ajax call.
   @param {array|object} data The data to be added to the table. This can be:
     &lt;ul&gt;
       &lt;li&gt;1D array of data - add a single row with the data provided&lt;/li&gt;
       &lt;li&gt;2D array of arrays - add multiple rows in a single call&lt;/li&gt;
       &lt;li&gt;object - data object when using &lt;i&gt;mData&lt;/i&gt;&lt;/li&gt;
       &lt;li&gt;array of objects - multiple data objects when using &lt;i&gt;mData&lt;/i&gt;&lt;/li&gt;
     &lt;/ul&gt;
   @param {bool} [redraw=true] redraw the table or not
   @returns {array} An array of integers, representing the list of indexes in
     &lt;i&gt;aoData&lt;/i&gt; ({@link DataTable.models.oSettings}) that have been added to
     the table.
   @dtopt API
   @deprecated Since v1.10

   @example
     // Global var for counter
     var giCount = 2;

     $(document).ready(function() {
       $(&#39;#example&#39;).dataTable();
     } );

     function fnClickAddRow() {
       $(&#39;#example&#39;).dataTable().fnAddData( [
         giCount+&quot;.1&quot;,
         giCount+&quot;.2&quot;,
         giCount+&quot;.3&quot;,
         giCount+&quot;.4&quot; ]
       );

       giCount++;
     }
 /
             this.fnAddData = function( data, redraw )
             {
                     var api = this.api( true );

                     /* Check if we want to add multiple rows or not */
                     var rows = $.isArray(data) &amp;&amp; ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
                             api.rows.add( data ) :
                             api.row.add( data );

                     if ( redraw === undefined || redraw ) {
                             api.draw();
                     }

                     return rows.flatten().toArray();
             };

             /**
  This function will make DataTables recalculate the column sizes, based on the data
  contained in the table and the sizes applied to the columns (in the DOM, CSS or
  through the sWidth parameter). This can be useful when the width of the table&#39;s
  parent element changes (for example a window resize).
   @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable( {
         &quot;sScrollY&quot;: &quot;200px&quot;,
         &quot;bPaginate&quot;: false
       } );

       $(window).bind(&#39;resize&#39;, function () {
         oTable.fnAdjustColumnSizing();
       } );
     } );
 /
             this.fnAdjustColumnSizing = function ( bRedraw )
             {
                     var api = this.api( true ).columns.adjust();
                     var settings = api.settings()[0];
                     var scroll = settings.oScroll;

                     if ( bRedraw === undefined || bRedraw ) {
                             api.draw( false );
                     }
                     else if ( scroll.sX !== &quot;&quot; || scroll.sY !== &quot;&quot; ) {
                             /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
                             _fnScrollDraw( settings );
                     }
             };

             /**
  Quickly and simply clear a table
   @param {bool} [bRedraw=true] redraw the table or not
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Immediately &#39;nuke&#39; the current rows (perhaps waiting for an Ajax callback...)
       oTable.fnClearTable();
     } );
 /
             this.fnClearTable = function( bRedraw )
             {
                     var api = this.api( true ).clear();

                     if ( bRedraw === undefined || bRedraw ) {
                             api.draw();
                     }
             };

             /**
  The exact opposite of &#39;opening&#39; a row, this function will close any rows which
  are currently &#39;open&#39;.
   @param {node} nTr the table row to &#39;close&#39;
   @returns {int} 0 on success, or 1 if failed (can&#39;t find the row)
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable;

       // &#39;open&#39; an information row when a row is clicked on
       $(&#39;#example tbody tr&#39;).click( function () {
         if ( oTable.fnIsOpen(this) ) {
           oTable.fnClose( this );
         } else {
           oTable.fnOpen( this, &quot;Temporary row opened&quot;, &quot;info_row&quot; );
         }
       } );

       oTable = $(&#39;#example&#39;).dataTable();
     } );
 /
             this.fnClose = function( nTr )
             {
                     this.api( true ).row( nTr ).child.hide();
             };

             /**
  Remove a row for the table
   @param {mixed} target The index of the row from aoData to be deleted, or
     the TR element you want to delete
   @param {function|null} [callBack] Callback function
   @param {bool} [redraw=true] Redraw the table or not
   @returns {array} The row that was deleted
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Immediately remove the first row
       oTable.fnDeleteRow( 0 );
     } );
 /
             this.fnDeleteRow = function( target, callback, redraw )
             {
                     var api = this.api( true );
                     var rows = api.rows( target );
                     var settings = rows.settings()[0];
                     var data = settings.aoData[ rows[0][0] ];

                     rows.remove();

                     if ( callback ) {
                             callback.call( this, settings, data );
                     }

                     if ( redraw === undefined || redraw ) {
                             api.draw();
                     }

                     return data;
             };

             /**
  Restore the table to it&#39;s original state in the DOM by removing all of DataTables
  enhancements, alterations to the DOM structure of the table and event listeners.
   @param {boolean} [remove=false] Completely remove the table from the DOM
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       // This example is fairly pointless in reality, but shows how fnDestroy can be used
       var oTable = $(&#39;#example&#39;).dataTable();
       oTable.fnDestroy();
     } );
 /
             this.fnDestroy = function ( remove )
             {
                     this.api( true ).destroy( remove );
             };

             /**
  Redraw the table
   @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Re-draw the table - you wouldn&#39;t want to do it here, but it&#39;s an example :-)
       oTable.fnDraw();
     } );
 /
             this.fnDraw = function( complete )
             {
                     // Note that this isn&#39;t an exact match to the old call to _fnDraw - it takes
                     // into account the new data, but can hold position.
                     this.api( true ).draw( complete );
             };

             /**
  Filter the input based on data
   @param {string} sInput String to filter the table on
   @param {int|null} [iColumn] Column to limit filtering to
   @param {bool} [bRegex=false] Treat as regular expression or not
   @param {bool} [bSmart=true] Perform smart filtering or not
   @param {bool} [bShowGlobal=true] Show the input global filter in it&#39;s input box(es)
   @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Sometime later - filter...
       oTable.fnFilter( &#39;test string&#39; );
     } );
 /
             this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
             {
                     var api = this.api( true );

                     if ( iColumn === null || iColumn === undefined ) {
                             api.search( sInput, bRegex, bSmart, bCaseInsensitive );
                     }
                     else {
                             api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
                     }

                     api.draw();
             };

             /**
  Get the data for the whole table, an individual row or an individual cell based on the
  provided parameters.
   @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
     a TR node then the data source for the whole row will be returned. If given as a
     TD/TH cell node then iCol will be automatically calculated and the data for the
     cell returned. If given as an integer, then this is treated as the aoData internal
     data index for the row (see fnGetPosition) and the data for that row used.
   @param {int} [col] Optional column index that you want the data of.
   @returns {array|object|string} If mRow is undefined, then the data for all rows is
     returned. If mRow is defined, just data for that row, and is iCol is
     defined, only data for the designated cell is returned.
   @dtopt API
   @deprecated Since v1.10

   @example
     // Row data
     $(document).ready(function() {
       oTable = $(&#39;#example&#39;).dataTable();

       oTable.$(&#39;tr&#39;).click( function () {
         var data = oTable.fnGetData( this );
         // ... do something with the array / object of data for the row
       } );
     } );

   @example
     // Individual cell data
     $(document).ready(function() {
       oTable = $(&#39;#example&#39;).dataTable();

       oTable.$(&#39;td&#39;).click( function () {
         var sData = oTable.fnGetData( this );
         alert( &#39;The cell clicked on had the value of &#39;+sData );
       } );
     } );
 /
             this.fnGetData = function( src, col )
             {
                     var api = this.api( true );

                     if ( src !== undefined ) {
                             var type = src.nodeName ? src.nodeName.toLowerCase() : &#39;&#39;;

                             return col !== undefined || type == &#39;td&#39; || type == &#39;th&#39; ?
                                     api.cell( src, col ).data() :
                                     api.row( src ).data() || null;
                     }

                     return api.data().toArray();
             };

             /**
  Get an array of the TR nodes that are used in the table&#39;s body. Note that you will
  typically want to use the &#39;$&#39; API method in preference to this as it is more
  flexible.
   @param {int} [iRow] Optional row index for the TR element you want
   @returns {array|node} If iRow is undefined, returns an array of all TR elements
     in the table&#39;s body, or iRow is defined, just the TR element requested.
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Get the nodes from the table
       var nNodes = oTable.fnGetNodes( );
     } );
 /
             this.fnGetNodes = function( iRow )
             {
                     var api = this.api( true );

                     return iRow !== undefined ?
                             api.row( iRow ).node() :
                             api.rows().nodes().flatten().toArray();
             };

             /**
  Get the array indexes of a particular cell from it&#39;s DOM element
  and column index including hidden columns
   @param {node} node this can either be a TR, TD or TH in the table&#39;s body
   @returns {int} If nNode is given as a TR, then a single index is returned, or
     if given as a cell, an array of [row index, column index (visible),
     column index (all)] is given.
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       $(&#39;#example tbody td&#39;).click( function () {
         // Get the position of the current data from the node
         var aPos = oTable.fnGetPosition( this );

         // Get the data array for this row
         var aData = oTable.fnGetData( aPos[0] );

         // Update the data array and return the value
         aData[ aPos[1] ] = &#39;clicked&#39;;
         this.innerHTML = &#39;clicked&#39;;
       } );

       // Init DataTables
       oTable = $(&#39;#example&#39;).dataTable();
     } );
 /
             this.fnGetPosition = function( node )
             {
                     var api = this.api( true );
                     var nodeName = node.nodeName.toUpperCase();

                     if ( nodeName == &#39;TR&#39; ) {
                             return api.row( node ).index();
                     }
                     else if ( nodeName == &#39;TD&#39; || nodeName == &#39;TH&#39; ) {
                             var cell = api.cell( node ).index();

                             return [
                                     cell.row,
                                     cell.columnVisible,
                                     cell.column
                             ];
                     }
                     return null;
             };

             /**
  Check to see if a row is &#39;open&#39; or not.
   @param {node} nTr the table row to check
   @returns {boolean} true if the row is currently open, false otherwise
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable;

       // &#39;open&#39; an information row when a row is clicked on
       $(&#39;#example tbody tr&#39;).click( function () {
         if ( oTable.fnIsOpen(this) ) {
           oTable.fnClose( this );
         } else {
           oTable.fnOpen( this, &quot;Temporary row opened&quot;, &quot;info_row&quot; );
         }
       } );

       oTable = $(&#39;#example&#39;).dataTable();
     } );
 /
             this.fnIsOpen = function( nTr )
             {
                     return this.api( true ).row( nTr ).child.isShown();
             };

             /**
  This function will place a new row directly after a row which is currently
  on display on the page, with the HTML contents that is passed into the
  function. This can be used, for example, to ask for confirmation that a
  particular record should be deleted.
   @param {node} nTr The table row to &#39;open&#39;
   @param {string|node|jQuery} mHtml The HTML to put into the row
   @param {string} sClass Class to give the new TD cell
   @returns {node} The row opened. Note that if the table row passed in as the
     first parameter, is not found in the table, this method will silently
     return.
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable;

       // &#39;open&#39; an information row when a row is clicked on
       $(&#39;#example tbody tr&#39;).click( function () {
         if ( oTable.fnIsOpen(this) ) {
           oTable.fnClose( this );
         } else {
           oTable.fnOpen( this, &quot;Temporary row opened&quot;, &quot;info_row&quot; );
         }
       } );

       oTable = $(&#39;#example&#39;).dataTable();
     } );
 /
             this.fnOpen = function( nTr, mHtml, sClass )
             {
                     return this.api( true )
                             .row( nTr )
                             .child( mHtml, sClass )
                             .show()
                             .child()[0];
             };

             /**
  Change the pagination - provides the internal logic for pagination in a simple API
  function. With this function you can have a DataTables table go to the next,
  previous, first or last pages.
   @param {string|int} mAction Paging action to take: &quot;first&quot;, &quot;previous&quot;, &quot;next&quot; or &quot;last&quot;
     or page number to jump to (integer), note that page 0 is the first page.
   @param {bool} [bRedraw=true] Redraw the table or not
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();
       oTable.fnPageChange( &#39;next&#39; );
     } );
 /
             this.fnPageChange = function ( mAction, bRedraw )
             {
                     var api = this.api( true ).page( mAction );

                     if ( bRedraw === undefined || bRedraw ) {
                             api.draw(false);
                     }
             };

             /**
  Show a particular column
   @param {int} iCol The column whose display should be changed
   @param {bool} bShow Show (true) or hide (false) the column
   @param {bool} [bRedraw=true] Redraw the table or not
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Hide the second column after initialisation
       oTable.fnSetColumnVis( 1, false );
     } );
 /
             this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
             {
                     var api = this.api( true ).column( iCol ).visible( bShow );

                     if ( bRedraw === undefined || bRedraw ) {
                             api.columns.adjust().draw();
                     }
             };

             /**
  Get the settings for a particular table for external manipulation
   @returns {object} DataTables settings object. See
     {@link DataTable.models.oSettings}
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();
       var oSettings = oTable.fnSettings();

       // Show an example parameter from the settings
       alert( oSettings._iDisplayStart );
     } );
 /
             this.fnSettings = function()
             {
                     return _fnSettingsFromNode( this[_ext.iApiIndex] );
             };

             /**
  Sort the table by a particular column
   @param {int} iCol the data index to sort on. Note that this will not match the
     &#39;display index&#39; if you have hidden data entries
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Sort immediately with columns 0 and 1
       oTable.fnSort( [ [0,&#39;asc&#39;], [1,&#39;asc&#39;] ] );
     } );
 /
             this.fnSort = function( aaSort )
             {
                     this.api( true ).order( aaSort ).draw();
             };

             /**
  Attach a sort listener to an element for a given column
   @param {node} nNode the element to attach the sort listener to
   @param {int} iColumn the column that a click on this node will sort on
   @param {function} [fnCallback] callback function when sort is run
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();

       // Sort on column 1, when &#39;sorter&#39; is clicked on
       oTable.fnSortListener( document.getElementById(&#39;sorter&#39;), 1 );
     } );
 /
             this.fnSortListener = function( nNode, iColumn, fnCallback )
             {
                     this.api( true ).order.listener( nNode, iColumn, fnCallback );
             };

             /**
  Update a table cell or row - this method will accept either a single value to
  update the cell with, an array of values with one element for each column or
  an object in the same format as the original data source. The function is
  self-referencing in order to make the multi column updates easier.
   @param {object|array|string} mData Data to update the cell/row with
   @param {node|int} mRow TR element you want to update or the aoData index
   @param {int} [iColumn] The column to update, give as null or undefined to
     update a whole row.
   @param {bool} [bRedraw=true] Redraw the table or not
   @param {bool} [bAction=true] Perform pre-draw actions or not
   @returns {int} 0 on success, 1 on error
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();
       oTable.fnUpdate( &#39;Example update&#39;, 0, 0 ); // Single cell
       oTable.fnUpdate( [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], $(&#39;tbody tr&#39;)[0] ); // Row
     } );
 /
             this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
             {
                     var api = this.api( true );

                     if ( iColumn === undefined || iColumn === null ) {
                             api.row( mRow ).data( mData );
                     }
                     else {
                             api.cell( mRow, iColumn ).data( mData );
                     }

                     if ( bAction === undefined || bAction ) {
                             api.columns.adjust();
                     }

                     if ( bRedraw === undefined || bRedraw ) {
                             api.draw();
                     }
                     return 0;
             };

             /**
  Provide a common method for plug-ins to check the version of DataTables being used, in order
  to ensure compatibility.
   @param {string} sVersion Version string to check for, in the format &quot;X.Y.Z&quot;. Note that the
     formats &quot;X&quot; and &quot;X.Y&quot; are also acceptable.
   @returns {boolean} true if this version of DataTables is greater or equal to the required
     version, or false if this version of DataTales is not suitable
   @method
   @dtopt API
   @deprecated Since v1.10

   @example
     $(document).ready(function() {
       var oTable = $(&#39;#example&#39;).dataTable();
       alert( oTable.fnVersionCheck( &#39;1.9.0&#39; ) );
     } );
 /
             this.fnVersionCheck = _ext.fnVersionCheck;

             var _that = this;
             var emptyInit = options === undefined;
             var len = this.length;

             if ( emptyInit ) {
                     options = {};
             }

             this.oApi = this.internal = _ext.internal;

             // Extend with old style plug-in API methods
             for ( var fn in DataTable.ext.internal ) {
                     if ( fn ) {
                             this[fn] = _fnExternApiFunc(fn);
                     }
             }

             this.each(function() {
                     // For each initialisation we want to give it a clean initialisation
                     // object that can be bashed around
                     var o = {};
                     var oInit = len &gt; 1 ? // optimisation for single table case
                             _fnExtend( o, options, true ) :
                             options;

                     /*global oInit,_that,emptyInit*/
                     var i=0, iLen, j, jLen, k, kLen;
                     var sId = this.getAttribute( &#39;id&#39; );
                     var bInitHandedOff = false;
                     var defaults = DataTable.defaults;
                     var $this = $(this);

                     /* Sanity check */
                     if ( this.nodeName.toLowerCase() != &#39;table&#39; )
                     {
                             _fnLog( null, 0, &#39;Non-table node initialisation (&#39;+this.nodeName+&#39;)&#39;, 2 );
                             return;
                     }

                     /* Backwards compatibility for the defaults */
                     _fnCompatOpts( defaults );
                     _fnCompatCols( defaults.column );

                     /* Convert the camel-case defaults to Hungarian */
                     _fnCamelToHungarian( defaults, defaults, true );
                     _fnCamelToHungarian( defaults.column, defaults.column, true );

                     /* Setting up the initialisation object */
                     _fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ) );

                     /* Check to see if we are re-initialising a table */
                     var allSettings = DataTable.settings;
                     for ( i=0, iLen=allSettings.length ; i&lt;iLen ; i++ )
                     {
                             var s = allSettings[i];

                             /* Base check on table node */
                             if ( s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot &amp;&amp; s.nTFoot.parentNode == this) )
                             {
                                     var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
                                     var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

                                     if ( emptyInit || bRetrieve )
                                     {
                                             return s.oInstance;
                                     }
                                     else if ( bDestroy )
                                     {
                                             s.oInstance.fnDestroy();
                                             break;
                                     }
                                     else
                                     {
                                             _fnLog( s, 0, &#39;Cannot reinitialise DataTable&#39;, 3 );
                                             return;
                                     }
                             }

                             /* If the element we are initialising has the same ID as a table which was previously
    initialised, but the table nodes don&#39;t match (from before) then we destroy the old
    instance by simply deleting it. This is under the assumption that the table has been
    destroyed by other methods. Anyone using non-id selectors will need to do this manually
   /
                             if ( s.sTableId == this.id )
                             {
                                     allSettings.splice( i, 1 );
                                     break;
                             }
                     }

                     /* Ensure the table has an ID - required for accessibility */
                     if ( sId === null || sId === &quot;&quot; )
                     {
                             sId = &quot;DataTables_Table_&quot;+(DataTable.ext._unique++);
                             this.id = sId;
                     }

                     /* Create the settings object for this table and set some of the default parameters */
                     var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
                             &quot;sDestroyWidth&quot;: $this[0].style.width,
                             &quot;sInstance&quot;:     sId,
                             &quot;sTableId&quot;:      sId
                     } );
                     oSettings.nTable = this;
                     oSettings.oApi   = _that.internal;
                     oSettings.oInit  = oInit;

                     allSettings.push( oSettings );

                     // Need to add the instance after the instance after the settings object has been added
                     // to the settings array, so we can self reference the table instance if more than one
                     oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();

                     // Backwards compatibility, before we apply all the defaults
                     _fnCompatOpts( oInit );

                     if ( oInit.oLanguage )
                     {
                             _fnLanguageCompat( oInit.oLanguage );
                     }

                     // If the length menu is given, but the init display length is not, use the length menu
                     if ( oInit.aLengthMenu &amp;&amp; ! oInit.iDisplayLength )
                     {
                             oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?
                                     oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
                     }

                     // Apply the defaults and init options to make a single init object will all
                     // options defined from defaults and instance options.
                     oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );

                     // Map the initialisation options onto the settings object
                     _fnMap( oSettings.oFeatures, oInit, [
                             &quot;bPaginate&quot;,
                             &quot;bLengthChange&quot;,
                             &quot;bFilter&quot;,
                             &quot;bSort&quot;,
                             &quot;bSortMulti&quot;,
                             &quot;bInfo&quot;,
                             &quot;bProcessing&quot;,
                             &quot;bAutoWidth&quot;,
                             &quot;bSortClasses&quot;,
                             &quot;bServerSide&quot;,
                             &quot;bDeferRender&quot;
                     ] );
                     _fnMap( oSettings, oInit, [
                             &quot;asStripeClasses&quot;,
                             &quot;ajax&quot;,
                             &quot;fnServerData&quot;,
                             &quot;fnFormatNumber&quot;,
                             &quot;sServerMethod&quot;,
                             &quot;aaSorting&quot;,
                             &quot;aaSortingFixed&quot;,
                             &quot;aLengthMenu&quot;,
                             &quot;sPaginationType&quot;,
                             &quot;sAjaxSource&quot;,
                             &quot;sAjaxDataProp&quot;,
                             &quot;iStateDuration&quot;,
                             &quot;sDom&quot;,
                             &quot;bSortCellsTop&quot;,
                             &quot;iTabIndex&quot;,
                             &quot;fnStateLoadCallback&quot;,
                             &quot;fnStateSaveCallback&quot;,
                             &quot;renderer&quot;,
                             &quot;searchDelay&quot;,
                             [ &quot;iCookieDuration&quot;, &quot;iStateDuration&quot; ], // backwards compat
                             [ &quot;oSearch&quot;, &quot;oPreviousSearch&quot; ],
                             [ &quot;aoSearchCols&quot;, &quot;aoPreSearchCols&quot; ],
                             [ &quot;iDisplayLength&quot;, &quot;_iDisplayLength&quot; ],
                             [ &quot;bJQueryUI&quot;, &quot;bJUI&quot; ]
                     ] );
                     _fnMap( oSettings.oScroll, oInit, [
                             [ &quot;sScrollX&quot;, &quot;sX&quot; ],
                             [ &quot;sScrollXInner&quot;, &quot;sXInner&quot; ],
                             [ &quot;sScrollY&quot;, &quot;sY&quot; ],
                             [ &quot;bScrollCollapse&quot;, &quot;bCollapse&quot; ]
                     ] );
                     _fnMap( oSettings.oLanguage, oInit, &quot;fnInfoCallback&quot; );

                     /* Callback functions which are array driven */
                     _fnCallbackReg( oSettings, &#39;aoDrawCallback&#39;,       oInit.fnDrawCallback,      &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoServerParams&#39;,       oInit.fnServerParams,      &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoStateSaveParams&#39;,    oInit.fnStateSaveParams,   &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoStateLoadParams&#39;,    oInit.fnStateLoadParams,   &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoStateLoaded&#39;,        oInit.fnStateLoaded,       &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoRowCallback&#39;,        oInit.fnRowCallback,       &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoRowCreatedCallback&#39;, oInit.fnCreatedRow,        &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoHeaderCallback&#39;,     oInit.fnHeaderCallback,    &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoFooterCallback&#39;,     oInit.fnFooterCallback,    &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoInitComplete&#39;,       oInit.fnInitComplete,      &#39;user&#39; );
                     _fnCallbackReg( oSettings, &#39;aoPreDrawCallback&#39;,    oInit.fnPreDrawCallback,   &#39;user&#39; );

                     var oClasses = oSettings.oClasses;

                     // @todo Remove in 1.11
                     if ( oInit.bJQueryUI )
                     {
                             /* Use the JUI classes object for display. You could clone the oStdClasses object if
    you want to have multiple tables with multiple independent classes
   /
                             $.extend( oClasses, DataTable.ext.oJUIClasses, oInit.oClasses );

                             if ( oInit.sDom === defaults.sDom &amp;&amp; defaults.sDom === &quot;lfrtip&quot; )
                             {
                                     /* Set the DOM to use a layout suitable for jQuery UI&#39;s theming */
                                     oSettings.sDom = &#39;&lt;&quot;H&quot;lfr&gt;t&lt;&quot;F&quot;ip&gt;&#39;;
                             }

                             if ( ! oSettings.renderer ) {
                                     oSettings.renderer = &#39;jqueryui&#39;;
                             }
                             else if ( $.isPlainObject( oSettings.renderer ) &amp;&amp; ! oSettings.renderer.header ) {
                                     oSettings.renderer.header = &#39;jqueryui&#39;;
                             }
                     }
                     else
                     {
                             $.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
                     }
                     $this.addClass( oClasses.sTable );

                     /* Calculate the scroll bar width and cache it for use later on */
                     if ( oSettings.oScroll.sX !== &quot;&quot; || oSettings.oScroll.sY !== &quot;&quot; )
                     {
                             oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
                     }
                     if ( oSettings.oScroll.sX === true ) { // Easy initialisation of x-scrolling
                             oSettings.oScroll.sX = &#39;100%&#39;;
                     }

                     if ( oSettings.iInitDisplayStart === undefined )
                     {
                             /* Display start point, taking into account the save saving */
                             oSettings.iInitDisplayStart = oInit.iDisplayStart;
                             oSettings._iDisplayStart = oInit.iDisplayStart;
                     }

                     if ( oInit.iDeferLoading !== null )
                     {
                             oSettings.bDeferLoading = true;
                             var tmp = $.isArray( oInit.iDeferLoading );
                             oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
                             oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
                     }

                     /* Language definitions */
                     var oLanguage = oSettings.oLanguage;
                     $.extend( true, oLanguage, oInit.oLanguage );

                     if ( oLanguage.sUrl !== &quot;&quot; )
                     {
                             /* Get the language definitions from a file - because this Ajax call makes the language
    get async to the remainder of this function we use bInitHandedOff to indicate that
    _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
   /
                             $.ajax( {
                                     dataType: &#39;json&#39;,
                                     url: oLanguage.sUrl,
                                     success: function ( json ) {
                                             _fnLanguageCompat( json );
                                             _fnCamelToHungarian( defaults.oLanguage, json );
                                             $.extend( true, oLanguage, json );
                                             _fnInitialise( oSettings );
                                     },
                                     error: function () {
                                             // Error occurred loading language file, continue on as best we can
                                             _fnInitialise( oSettings );
                                     }
                             } );
                             bInitHandedOff = true;
                     }

                     /*
   Stripes
  /
                     if ( oInit.asStripeClasses === null )
                     {
                             oSettings.asStripeClasses =[
                                     oClasses.sStripeOdd,
                                     oClasses.sStripeEven
                             ];
                     }

                     /* Remove row stripe classes if they are already on the table row */
                     var stripeClasses = oSettings.asStripeClasses;
                     var rowOne = $this.children(&#39;tbody&#39;).find(&#39;tr&#39;).eq(0);
                     if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
                             return rowOne.hasClass(el);
                     } ) ) !== -1 ) {
                             $(&#39;tbody tr&#39;, this).removeClass( stripeClasses.join(&#39; &#39;) );
                             oSettings.asDestroyStripes = stripeClasses.slice();
                     }

                     /*
   Columns
   See if we should load columns automatically or use defined ones
  /
                     var anThs = [];
                     var aoColumnsInit;
                     var nThead = this.getElementsByTagName(&#39;thead&#39;);
                     if ( nThead.length !== 0 )
                     {
                             _fnDetectHeader( oSettings.aoHeader, nThead[0] );
                             anThs = _fnGetUniqueThs( oSettings );
                     }

                     /* If not given a column array, generate one with nulls */
                     if ( oInit.aoColumns === null )
                     {
                             aoColumnsInit = [];
                             for ( i=0, iLen=anThs.length ; i&lt;iLen ; i++ )
                             {
                                     aoColumnsInit.push( null );
                             }
                     }
                     else
                     {
                             aoColumnsInit = oInit.aoColumns;
                     }

                     /* Add the columns */
                     for ( i=0, iLen=aoColumnsInit.length ; i&lt;iLen ; i++ )
                     {
                             _fnAddColumn( oSettings, anThs ? anThs[i] : null );
                     }

                     /* Apply the column definitions */
                     _fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
                             _fnColumnOptions( oSettings, iCol, oDef );
                     } );

                     /* HTML5 attribute detection - build an mData object automatically if the
   attributes are found
  /
                     if ( rowOne.length ) {
                             var a = function ( cell, name ) {
                                     return cell.getAttribute( &#39;data-&#39;+name ) !== null ? name : null;
                             };

                             $.each( _fnGetRowElements( oSettings, rowOne[0] ).cells, function (i, cell) {
                                     var col = oSettings.aoColumns[i];

                                     if ( col.mData === i ) {
                                             var sort = a( cell, &#39;sort&#39; ) || a( cell, &#39;order&#39; );
                                             var filter = a( cell, &#39;filter&#39; ) || a( cell, &#39;search&#39; );

                                             if ( sort !== null || filter !== null ) {
                                                     col.mData = {
                                                             _:      i+&#39;.display&#39;,
                                                             sort:   sort !== null   ? i+&#39;.@data-&#39;+sort   : undefined,
                                                             type:   sort !== null   ? i+&#39;.@data-&#39;+sort   : undefined,
                                                             filter: filter !== null ? i+&#39;.@data-&#39;+filter : undefined
                                                     };

                                                     _fnColumnOptions( oSettings, i );
                                             }
                                     }
                             } );
                     }

                     var features = oSettings.oFeatures;

                     /* Must be done after everything which can be overridden by the state saving! */
                     if ( oInit.bStateSave )
                     {
                             features.bStateSave = true;
                             _fnLoadState( oSettings, oInit );
                             _fnCallbackReg( oSettings, &#39;aoDrawCallback&#39;, _fnSaveState, &#39;state_save&#39; );
                     }

                     /*
   Sorting
   @todo For modularisation (1.11) this needs to do into a sort start up handler
  /

                     // If aaSorting is not defined, then we use the first indicator in asSorting
                     // in case that has been altered, so the default sort reflects that option
                     if ( oInit.aaSorting === undefined )
                     {
                             var sorting = oSettings.aaSorting;
                             for ( i=0, iLen=sorting.length ; i&lt;iLen ; i++ )
                             {
                                     sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
                             }
                     }

                     /* Do a first pass on the sorting classes (allows any size changes to be taken into
   account, and also will apply sorting disabled classes if disabled
  /
                     _fnSortingClasses( oSettings );

                     if ( features.bSort )
                     {
                             _fnCallbackReg( oSettings, &#39;aoDrawCallback&#39;, function () {
                                     if ( oSettings.bSorted ) {
                                             var aSort = _fnSortFlatten( oSettings );
                                             var sortedColumns = {};

                                             $.each( aSort, function (i, val) {
                                                     sortedColumns[ val.src ] = val.dir;
                                             } );

                                             _fnCallbackFire( oSettings, null, &#39;order&#39;, [oSettings, aSort, sortedColumns] );
                                             _fnSortAria( oSettings );
                                     }
                             } );
                     }

                     _fnCallbackReg( oSettings, &#39;aoDrawCallback&#39;, function () {
                             if ( oSettings.bSorted || _fnDataSource( oSettings ) === &#39;ssp&#39; || features.bDeferRender ) {
                                     _fnSortingClasses( oSettings );
                             }
                     }, &#39;sc&#39; );

                     /*
   Final init
   Cache the header, body and footer as required, creating them if needed
  /

                     /* Browser support detection */
                     _fnBrowserDetect( oSettings );

                     // Work around for Webkit bug 83867 - store the caption-side before removing from doc
                     var captions = $this.children(&#39;caption&#39;).each( function () {
                             this._captionSide = $this.css(&#39;caption-side&#39;);
                     } );

                     var thead = $this.children(&#39;thead&#39;);
                     if ( thead.length === 0 )
                     {
                             thead = $(&#39;&lt;thead/&gt;&#39;).appendTo(this);
                     }
                     oSettings.nTHead = thead[0];

                     var tbody = $this.children(&#39;tbody&#39;);
                     if ( tbody.length === 0 )
                     {
                             tbody = $(&#39;&lt;tbody/&gt;&#39;).appendTo(this);
                     }
                     oSettings.nTBody = tbody[0];

                     var tfoot = $this.children(&#39;tfoot&#39;);
                     if ( tfoot.length === 0 &amp;&amp; captions.length &gt; 0 &amp;&amp; (oSettings.oScroll.sX !== &quot;&quot; || oSettings.oScroll.sY !== &quot;&quot;) )
                     {
                             // If we are a scrolling table, and no footer has been given, then we need to create
                             // a tfoot element for the caption element to be appended to
                             tfoot = $(&#39;&lt;tfoot/&gt;&#39;).appendTo(this);
                     }

                     if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
                             $this.addClass( oClasses.sNoFooter );
                     }
                     else if ( tfoot.length &gt; 0 ) {
                             oSettings.nTFoot = tfoot[0];
                             _fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
                     }

                     /* Check if there is data passing into the constructor */
                     if ( oInit.aaData )
                     {
                             for ( i=0 ; i&lt;oInit.aaData.length ; i++ )
                             {
                                     _fnAddData( oSettings, oInit.aaData[ i ] );
                             }
                     }
                     else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == &#39;dom&#39; )
                     {
                             /* Grab the data from the page - only do this when deferred loading or no Ajax
    source since there is no point in reading the DOM data if we are then going
    to replace it with Ajax data
   /
                             _fnAddTr( oSettings, $(oSettings.nTBody).children(&#39;tr&#39;) );
                     }

                     /* Copy the data index array */
                     oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

                     /* Initialisation complete - table can be drawn */
                     oSettings.bInitialised = true;

                     /* Check if we need to initialise the table (it might not have been handed off to the
   language processor)
  /
                     if ( bInitHandedOff === false )
                     {
                             _fnInitialise( oSettings );
                     }
             } );
             _that = null;
             return this;
     };

     /**
 Computed structure of the DataTables API, defined by the options passed to
 `DataTable.Api.register()` when building the API.

 The structure is built in order to speed creation and extension of the Api
 objects since the extensions are effectively pre-parsed.

 The array is an array of objects with the following structure, where this
 base array represents the Api prototype base:

     [
       {
         name:      &#39;data&#39;                -- string   - Property name
         val:       function () {},       -- function - Api method (or undefined if just an object
         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
       },
       {
         name:     &#39;row&#39;
         val:       {},
         methodExt: [ ... ],
         propExt:   [
           {
             name:      &#39;data&#39;
             val:       function () {},
             methodExt: [ ... ],
             propExt:   [ ... ]
           },
           ...
         ]
       }
     ]

 @type {Array}
 @ignore
/
     var __apiStruct = [];

     /**
 `Array.prototype` reference.

 @type object
 @ignore
/
     var __arrayProto = Array.prototype;

     /**
 Abstraction for `context` parameter of the `Api` constructor to allow it to
 take several different forms for ease of use.

 Each of the input parameter types will be converted to a DataTables settings
 object where possible.

 @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
   of:

     `string` - jQuery selector. Any DataTables&#39; matching the given selector
     with be found and used.
     `node` - `TABLE` node which has already been formed into a DataTable.
     `jQuery` - A jQuery object of `TABLE` nodes.
     `object` - DataTables settings object
     `DataTables.Api` - API instance
 @return {array|null} Matching DataTables settings objects. `null` or
   `undefined` is returned if no matching DataTable is found.
 @ignore
/
     var _toSettings = function ( mixed )
     {
             var idx, jq;
             var settings = DataTable.settings;
             var tables = $.map( settings, function (el, i) {
                     return el.nTable;
             } );

             if ( ! mixed ) {
                     return [];
             }
             else if ( mixed.nTable &amp;&amp; mixed.oApi ) {
                     // DataTables settings object
                     return [ mixed ];
             }
             else if ( mixed.nodeName &amp;&amp; mixed.nodeName.toLowerCase() === &#39;table&#39; ) {
                     // Table node
                     idx = $.inArray( mixed, tables );
                     return idx !== -1 ? [ settings[idx] ] : null;
             }
             else if ( mixed &amp;&amp; typeof mixed.settings === &#39;function&#39; ) {
                     return mixed.settings().toArray();
             }
             else if ( typeof mixed === &#39;string&#39; ) {
                     // jQuery selector
                     jq = $(mixed);
             }
             else if ( mixed instanceof $ ) {
                     // jQuery object (also DataTables instance)
                     jq = mixed;
             }

             if ( jq ) {
                     return jq.map( function(i) {
                             idx = $.inArray( this, tables );
                             return idx !== -1 ? settings[idx] : null;
                     } ).toArray();
             }
     };

     /**
 DataTables API class - used to control and interface with  one or more
 DataTables enhanced tables.

 The API class is heavily based on jQuery, presenting a chainable interface
 that you can use to interact with tables. Each instance of the API class has
 a &quot;context&quot; - i.e. the tables that it will operate on. This could be a single
 table, all tables on a page or a sub-set thereof.

 Additionally the API is designed to allow you to easily work with the data in
 the tables, retrieving and manipulating it as required. This is done by
 presenting the API class as an array like interface. The contents of the
 array depend upon the actions requested by each method (for example
 `rows().nodes()` will return an array of nodes, while `rows().data()` will
 return an array of objects or arrays depending upon your table&#39;s
 configuration). The API object has a number of array like methods (`push`,
 `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
 `unique` etc) to assist your working with the data held in a table.

 Most methods (those which return an Api instance) are chainable, which means
 the return from a method call also has all of the methods available that the
 top level object had. For example, these two calls are equivalent:

     // Not chained
     api.row.add( {...} );
     api.draw();

     // Chained
     api.row.add( {...} ).draw();

 @class DataTable.Api
 @param {array|object|string|jQuery} context DataTable identifier. This is
   used to define which DataTables enhanced tables this API will operate on.
   Can be one of:

     `string` - jQuery selector. Any DataTables&#39; matching the given selector
     with be found and used.
     `node` - `TABLE` node which has already been formed into a DataTable.
     `jQuery` - A jQuery object of `TABLE` nodes.
     `object` - DataTables settings object
 @param {array} [data] Data to initialise the Api instance with.

 @example
   // Direct initialisation during DataTables construction
   var api = $(&#39;#example&#39;).DataTable();

 @example
   // Initialisation using a DataTables jQuery object
   var api = $(&#39;#example&#39;).dataTable().api();

 @example
   // Initialisation as a constructor
   var api = new $.fn.DataTable.Api( &#39;table.dataTable&#39; );
/
     _Api = function ( context, data )
     {
             if ( ! this instanceof _Api ) {
                     throw &#39;DT API must be constructed as a new object&#39;;
                     // or should it do the &#39;new&#39; for the caller?
                     // return new _Api.apply( this, arguments );
             }

             var settings = [];
             var ctxSettings = function ( o ) {
                     var a = _toSettings( o );
                     if ( a ) {
                             settings.push.apply( settings, a );
                     }
             };

             if ( $.isArray( context ) ) {
                     for ( var i=0, ien=context.length ; i&lt;ien ; i++ ) {
                             ctxSettings( context[i] );
                     }
             }
             else {
                     ctxSettings( context );
             }

             // Remove duplicates
             this.context = _unique( settings );

             // Initial data
             if ( data ) {
                     this.push.apply( this, data.toArray ? data.toArray() : data );
             }

             // selector
             this.selector = {
                     rows: null,
                     cols: null,
                     opts: null
             };

             _Api.extend( this, this, __apiStruct );
     };

     DataTable.Api = _Api;

     _Api.prototype = /** @lends DataTables.Api */{
             /**
  Return a new Api instance, comprised of the data held in the current
  instance, join with the other array(s) and/or value(s).

  An alias for `Array.prototype.concat`.

  @type method
  @param {*} value1 Arrays and/or values to concatenate.
  @param {*} [...] Additional arrays and/or values to concatenate.
  @returns {DataTables.Api} New API instance, comprising of the combined
    array.
 /
             concat:  __arrayProto.concat,

             context: [], // array of table settings objects

             each: function ( fn )
             {
                     for ( var i=0, ien=this.length ; i&lt;ien; i++ ) {
                             fn.call( this, this[i], i, this );
                     }

                     return this;
             },

             eq: function ( idx )
             {
                     var ctx = this.context;

                     return ctx.length &gt; idx ?
                             new _Api( ctx[idx], this[idx] ) :
                             null;
             },

             filter: function ( fn )
             {
                     var a = [];

                     if ( __arrayProto.filter ) {
                             a = __arrayProto.filter.call( this, fn, this );
                     }
                     else {
                             // Compatibility for browsers without EMCA-252-5 (JS 1.6)
                             for ( var i=0, ien=this.length ; i&lt;ien ; i++ ) {
                                     if ( fn.call( this, this[i], i, this ) ) {
                                             a.push( this[i] );
                                     }
                             }
                     }

                     return new _Api( this.context, a );
             },

             flatten: function ()
             {
                     var a = [];
                     return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
             },

             join:    __arrayProto.join,

             indexOf: __arrayProto.indexOf || function (obj, start)
             {
                     for ( var i=(start || 0), ien=this.length ; i&lt;ien ; i++ ) {
                             if ( this[i] === obj ) {
                                     return i;
                             }
                     }
                     return -1;
             },

             // Note that `alwaysNew` is internal - use iteratorNew externally
             iterator: function ( flatten, type, fn, alwaysNew ) {
                     var
                             a = [], ret,
                             i, ien, j, jen,
                             context = this.context,
                             rows, items, item,
                             selector = this.selector;

                     // Argument shifting
                     if ( typeof flatten === &#39;string&#39; ) {
                             alwaysNew = fn;
                             fn = type;
                             type = flatten;
                             flatten = false;
                     }

                     for ( i=0, ien=context.length ; i&lt;ien ; i++ ) {
                             var apiInst = new _Api( context[i] );

                             if ( type === &#39;table&#39; ) {
                                     ret = fn.call( apiInst, context[i], i );

                                     if ( ret !== undefined ) {
                                             a.push( ret );
                                     }
                             }
                             else if ( type === &#39;columns&#39; || type === &#39;rows&#39; ) {
                                     // this has same length as context - one entry for each table
                                     ret = fn.call( apiInst, context[i], this[i], i );

                                     if ( ret !== undefined ) {
                                             a.push( ret );
                                     }
                             }
                             else if ( type === &#39;column&#39; || type === &#39;column-rows&#39; || type === &#39;row&#39; || type === &#39;cell&#39; ) {
                                     // columns and rows share the same structure.
                                     // &#39;this&#39; is an array of column indexes for each context
                                     items = this[i];

                                     if ( type === &#39;column-rows&#39; ) {
                                             rows = _selector_row_indexes( context[i], selector.opts );
                                     }

                                     for ( j=0, jen=items.length ; j&lt;jen ; j++ ) {
                                             item = items[j];

                                             if ( type === &#39;cell&#39; ) {
                                                     ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
                                             }
                                             else {
                                                     ret = fn.call( apiInst, context[i], item, i, j, rows );
                                             }

                                             if ( ret !== undefined ) {
                                                     a.push( ret );
                                             }
                                     }
                             }
                     }

                     if ( a.length || alwaysNew ) {
                             var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
                             var apiSelector = api.selector;
                             apiSelector.rows = selector.rows;
                             apiSelector.cols = selector.cols;
                             apiSelector.opts = selector.opts;
                             return api;
                     }
                     return this;
             },

             lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
             {
                     // Bit cheeky...
                     return this.indexOf.apply( this.toArray.reverse(), arguments );
             },

             length:  0,

             map: function ( fn )
             {
                     var a = [];

                     if ( __arrayProto.map ) {
                             a = __arrayProto.map.call( this, fn, this );
                     }
                     else {
                             // Compatibility for browsers without EMCA-252-5 (JS 1.6)
                             for ( var i=0, ien=this.length ; i&lt;ien ; i++ ) {
                                     a.push( fn.call( this, this[i], i ) );
                             }
                     }

                     return new _Api( this.context, a );
             },

             pluck: function ( prop )
             {
                     return this.map( function ( el ) {
                             return el[ prop ];
                     } );
             },

             pop:     __arrayProto.pop,

             push:    __arrayProto.push,

             // Does not return an API instance
             reduce: __arrayProto.reduce || function ( fn, init )
             {
                     return _fnReduce( this, fn, init, 0, this.length, 1 );
             },

             reduceRight: __arrayProto.reduceRight || function ( fn, init )
             {
                     return _fnReduce( this, fn, init, this.length-1, -1, -1 );
             },

             reverse: __arrayProto.reverse,

             // Object with rows, columns and opts
             selector: null,

             shift:   __arrayProto.shift,

             sort:    __arrayProto.sort, // ? name - order?

             splice:  __arrayProto.splice,

             toArray: function ()
             {
                     return __arrayProto.slice.call( this );
             },

             to$: function ()
             {
                     return $( this );
             },

             toJQuery: function ()
             {
                     return $( this );
             },

             unique: function ()
             {
                     return new _Api( this.context, _unique(this) );
             },

             unshift: __arrayProto.unshift
     };

     _Api.extend = function ( scope, obj, ext )
     {
             // Only extend API instances and static properties of the API
             if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) &amp;&amp; ! obj.__dt_wrapper ) ) {
                     return;
             }

             var
                     i, ien,
                     j, jen,
                     struct, inner,
                     methodScoping = function ( scope, fn, struc ) {
                             return function () {
                                     var ret = fn.apply( scope, arguments );

                                     // Method extension
                                     _Api.extend( ret, ret, struc.methodExt );
                                     return ret;
                             };
                     };

             for ( i=0, ien=ext.length ; i&lt;ien ; i++ ) {
                     struct = ext[i];

                     // Value
                     obj[ struct.name ] = typeof struct.val === &#39;function&#39; ?
                             methodScoping( scope, struct.val, struct ) :
                             $.isPlainObject( struct.val ) ?
                                     {} :
                                     struct.val;

                     obj[ struct.name ].__dt_wrapper = true;

                     // Property extension
                     _Api.extend( scope, obj[ struct.name ], struct.propExt );
             }
     };

     // @todo - Is there need for an augment function?
     // _Api.augment = function ( inst, name )
     // {
     //      // Find src object in the structure from the name
     //      var parts = name.split(&#39;.&#39;);

     //      _Api.extend( inst, obj );
     // };

     //     [
     //       {
     //         name:      &#39;data&#39;                -- string   - Property name
     //         val:       function () {},       -- function - Api method (or undefined if just an object
     //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
     //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
     //       },
     //       {
     //         name:     &#39;row&#39;
     //         val:       {},
     //         methodExt: [ ... ],
     //         propExt:   [
     //           {
     //             name:      &#39;data&#39;
     //             val:       function () {},
     //             methodExt: [ ... ],
     //             propExt:   [ ... ]
     //           },
     //           ...
     //         ]
     //       }
     //     ]

     _Api.register = _api_register = function ( name, val )
     {
             if ( $.isArray( name ) ) {
                     for ( var j=0, jen=name.length ; j&lt;jen ; j++ ) {
                             _Api.register( name[j], val );
                     }
                     return;
             }

             var
                     i, ien,
                     heir = name.split(&#39;.&#39;),
                     struct = __apiStruct,
                     key, method;

             var find = function ( src, name ) {
                     for ( var i=0, ien=src.length ; i&lt;ien ; i++ ) {
                             if ( src[i].name === name ) {
                                     return src[i];
                             }
                     }
                     return null;
             };

             for ( i=0, ien=heir.length ; i&lt;ien ; i++ ) {
                     method = heir[i].indexOf(&#39;()&#39;) !== -1;
                     key = method ?
                             heir[i].replace(&#39;()&#39;, &#39;&#39;) :
                             heir[i];

                     var src = find( struct, key );
                     if ( ! src ) {
                             src = {
                                     name:      key,
                                     val:       {},
                                     methodExt: [],
                                     propExt:   []
                             };
                             struct.push( src );
                     }

                     if ( i === ien-1 ) {
                             src.val = val;
                     }
                     else {
                             struct = method ?
                                     src.methodExt :
                                     src.propExt;
                     }
             }
     };

     _Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
             _Api.register( pluralName, val );

             _Api.register( singularName, function () {
                     var ret = val.apply( this, arguments );

                     if ( ret === this ) {
                             // Returned item is the API instance that was passed in, return it
                             return this;
                     }
                     else if ( ret instanceof _Api ) {
                             // New API instance returned, want the value from the first item
                             // in the returned array for the singular result.
                             return ret.length ?
                                     $.isArray( ret[0] ) ?
                                             new _Api( ret.context, ret[0] ) : // Array results are &#39;enhanced&#39;
                                             ret[0] :
                                     undefined;
                     }

                     // Non-API return - just fire it back
                     return ret;
             } );
     };

     /**
 Selector for HTML tables. Apply the given selector to the give array of
 DataTables settings objects.

 @param {string|integer} [selector] jQuery selector string or integer
 @param  {array} Array of DataTables settings objects to be filtered
 @return {array}
 @ignore
/
     var __table_selector = function ( selector, a )
     {
             // Integer is used to pick out a table by index
             if ( typeof selector === &#39;number&#39; ) {
                     return [ a[ selector ] ];
             }

             // Perform a jQuery selector on the table nodes
             var nodes = $.map( a, function (el, i) {
                     return el.nTable;
             } );

             return $(nodes)
                     .filter( selector )
                     .map( function (i) {
                             // Need to translate back from the table node to the settings
                             var idx = $.inArray( this, nodes );
                             return a[ idx ];
                     } )
                     .toArray();
     };

     /**
 Context selector for the API&#39;s context (i.e. the tables the API instance
 refers to.

 @name    DataTable.Api#tables
 @param {string|integer} [selector] Selector to pick which tables the iterator
   should operate on. If not given, all tables in the current context are
   used. This can be given as a jQuery selector (for example `&#39;:gt(0)&#39;`) to
   select multiple tables or as an integer to select a single table.
 @returns {DataTable.Api} Returns a new API instance if a selector is given.
/
     _api_register( &#39;tables()&#39;, function ( selector ) {
             // A new instance is created if there was a selector specified
             return selector ?
                     new _Api( __table_selector( selector, this.context ) ) :
                     this;
     } );

     _api_register( &#39;table()&#39;, function ( selector ) {
             var tables = this.tables( selector );
             var ctx = tables.context;

             // Truncate to the first matched table
             return ctx.length ?
                     new _Api( ctx[0] ) :
                     tables;
     } );

     _api_registerPlural( &#39;tables().nodes()&#39;, &#39;table().node()&#39; , function () {
             return this.iterator( &#39;table&#39;, function ( ctx ) {
                     return ctx.nTable;
             }, 1 );
     } );

     _api_registerPlural( &#39;tables().body()&#39;, &#39;table().body()&#39; , function () {
             return this.iterator( &#39;table&#39;, function ( ctx ) {
                     return ctx.nTBody;
             }, 1 );
     } );

     _api_registerPlural( &#39;tables().header()&#39;, &#39;table().header()&#39; , function () {
             return this.iterator( &#39;table&#39;, function ( ctx ) {
                     return ctx.nTHead;
             }, 1 );
     } );

     _api_registerPlural( &#39;tables().footer()&#39;, &#39;table().footer()&#39; , function () {
             return this.iterator( &#39;table&#39;, function ( ctx ) {
                     return ctx.nTFoot;
             }, 1 );
     } );

     _api_registerPlural( &#39;tables().containers()&#39;, &#39;table().container()&#39; , function () {
             return this.iterator( &#39;table&#39;, function ( ctx ) {
                     return ctx.nTableWrapper;
             }, 1 );
     } );

     /**
 Redraw the tables in the current context.

 @param {boolean} [reset=true] Reset (default) or hold the current paging
   position. A full re-sort and re-filter is performed when this method is
   called, which is why the pagination reset is the default action.
 @returns {DataTables.Api} this
/
     _api_register( &#39;draw()&#39;, function ( resetPaging ) {
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     _fnReDraw( settings, resetPaging===false );
             } );
     } );

     /**
 Get the current page index.

 @return {integer} Current page index (zero based)
//**
 Set the current page.

 Note that if you attempt to show a page which does not exist, DataTables will
 not throw an error, but rather reset the paging.

 @param {integer|string} action The paging action to take. This can be one of:
    `integer` - The page index to jump to
    `string` - An action to take:
      `first` - Jump to first page.
      `next` - Jump to the next page
      `previous` - Jump to previous page
      `last` - Jump to the last page.
 @returns {DataTables.Api} this
/
     _api_register( &#39;page()&#39;, function ( action ) {
             if ( action === undefined ) {
                     return this.page.info().page; // not an expensive call
             }

             // else, have an action to take on all tables
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     _fnPageChange( settings, action );
             } );
     } );

     /**
 Paging information for the first table in the current context.

 If you require paging information for another table, use the `table()` method
 with a suitable selector.

 @return {object} Object with the following properties set:
    `page` - Current page index (zero based - i.e. the first page is `0`)
    `pages` - Total number of pages
    `start` - Display index for the first record shown on the current page
    `end` - Display index for the last record shown on the current page
    `length` - Display length (number of records). Note that generally `start
    + length = end`, but this is not always true, for example if there are
    only 2 records to show on the final page, with a length of 10.
    `recordsTotal` - Full data set length
    `recordsDisplay` - Data set length once the current filtering criterion
    are applied.
/
     _api_register( &#39;page.info()&#39;, function ( action ) {
             if ( this.context.length === 0 ) {
                     return undefined;
             }

             var
                     settings   = this.context[0],
                     start      = settings._iDisplayStart,
                     len        = settings._iDisplayLength,
                     visRecords = settings.fnRecordsDisplay(),
                     all        = len === -1;

             return {
                     &quot;page&quot;:           all ? 0 : Math.floor( start / len ),
                     &quot;pages&quot;:          all ? 1 : Math.ceil( visRecords / len ),
                     &quot;start&quot;:          start,
                     &quot;end&quot;:            settings.fnDisplayEnd(),
                     &quot;length&quot;:         len,
                     &quot;recordsTotal&quot;:   settings.fnRecordsTotal(),
                     &quot;recordsDisplay&quot;: visRecords
             };
     } );

     /**
 Get the current page length.

 @return {integer} Current page length. Note `-1` indicates that all records
   are to be shown.
//**
 Set the current page length.

 @param {integer} Page length to set. Use `-1` to show all records.
 @returns {DataTables.Api} this
/
     _api_register( &#39;page.len()&#39;, function ( len ) {
             // Note that we can&#39;t call this function &#39;length()&#39; because `length`
             // is a Javascript property of functions which defines how many arguments
             // the function expects.
             if ( len === undefined ) {
                     return this.context.length !== 0 ?
                             this.context[0]._iDisplayLength :
                             undefined;
             }

             // else, set the page length
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     _fnLengthChange( settings, len );
             } );
     } );

     var __reload = function ( settings, holdPosition, callback ) {
             // Use the draw event to trigger a callback
             if ( callback ) {
                     var api = new _Api( settings );

                     api.one( &#39;draw&#39;, function () {
                             callback( api.ajax.json() );
                     } );
             }

             if ( _fnDataSource( settings ) == &#39;ssp&#39; ) {
                     _fnReDraw( settings, holdPosition );
             }
             else {
                     // Trigger xhr
                     _fnProcessingDisplay( settings, true );

                     _fnBuildAjax( settings, [], function( json ) {
                             _fnClearTable( settings );

                             var data = _fnAjaxDataSrc( settings, json );
                             for ( var i=0, ien=data.length ; i&lt;ien ; i++ ) {
                                     _fnAddData( settings, data[i] );
                             }

                             _fnReDraw( settings, holdPosition );
                             _fnProcessingDisplay( settings, false );
                     } );
             }
     };

     /**
 Get the JSON response from the last Ajax request that DataTables made to the
 server. Note that this returns the JSON from the first table in the current
 context.

 @return {object} JSON received from the server.
/
     _api_register( &#39;ajax.json()&#39;, function () {
             var ctx = this.context;

             if ( ctx.length &gt; 0 ) {
                     return ctx[0].json;
             }

             // else return undefined;
     } );

     /**
 Get the data submitted in the last Ajax request
/
     _api_register( &#39;ajax.params()&#39;, function () {
             var ctx = this.context;

             if ( ctx.length &gt; 0 ) {
                     return ctx[0].oAjaxData;
             }

             // else return undefined;
     } );

     /**
 Reload tables from the Ajax data source. Note that this function will
 automatically re-draw the table when the remote data has been loaded.

 @param {boolean} [reset=true] Reset (default) or hold the current paging
   position. A full re-sort and re-filter is performed when this method is
   called, which is why the pagination reset is the default action.
 @returns {DataTables.Api} this
/
     _api_register( &#39;ajax.reload()&#39;, function ( callback, resetPaging ) {
             return this.iterator( &#39;table&#39;, function (settings) {
                     __reload( settings, resetPaging===false, callback );
             } );
     } );

     /**
 Get the current Ajax URL. Note that this returns the URL from the first
 table in the current context.

 @return {string} Current Ajax source URL
//**
 Set the Ajax URL. Note that this will set the URL for all tables in the
 current context.

 @param {string} url URL to set.
 @returns {DataTables.Api} this
/
     _api_register( &#39;ajax.url()&#39;, function ( url ) {
             var ctx = this.context;

             if ( url === undefined ) {
                     // get
                     if ( ctx.length === 0 ) {
                             return undefined;
                     }
                     ctx = ctx[0];

                     return ctx.ajax ?
                             $.isPlainObject( ctx.ajax ) ?
                                     ctx.ajax.url :
                                     ctx.ajax :
                             ctx.sAjaxSource;
             }

             // set
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     if ( $.isPlainObject( settings.ajax ) ) {
                             settings.ajax.url = url;
                     }
                     else {
                             settings.ajax = url;
                     }
                     // No need to consider sAjaxSource here since DataTables gives priority
                     // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
                     // value of `sAjaxSource` redundant.
             } );
     } );

     /**
 Load data from the newly set Ajax URL. Note that this method is only
 available when `ajax.url()` is used to set a URL. Additionally, this method
 has the same effect as calling `ajax.reload()` but is provided for
 convenience when setting a new URL. Like `ajax.reload()` it will
 automatically redraw the table once the remote data has been loaded.

 @returns {DataTables.Api} this
/
     _api_register( &#39;ajax.url().load()&#39;, function ( callback, resetPaging ) {
             // Same as a reload, but makes sense to present it for easy access after a
             // url change
             return this.iterator( &#39;table&#39;, function ( ctx ) {
                     __reload( ctx, resetPaging===false, callback );
             } );
     } );

     var _selector_run = function ( selector, select )
     {
             var
                     out = [], res,
                     a, i, ien, j, jen,
                     selectorType = typeof selector;

             // Can&#39;t just check for isArray here, as an API or jQuery instance might be
             // given with their array like look
             if ( ! selector || selectorType === &#39;string&#39; || selectorType === &#39;function&#39; || selector.length === undefined ) {
                     selector = [ selector ];
             }

             for ( i=0, ien=selector.length ; i&lt;ien ; i++ ) {
                     a = selector[i] &amp;&amp; selector[i].split ?
                             selector[i].split(&#39;,&#39;) :
                             [ selector[i] ];

                     for ( j=0, jen=a.length ; j&lt;jen ; j++ ) {
                             res = select( typeof a[j] === &#39;string&#39; ? $.trim(a[j]) : a[j] );

                             if ( res &amp;&amp; res.length ) {
                                     out.push.apply( out, res );
                             }
                     }
             }

             return out;
     };

     var _selector_opts = function ( opts )
     {
             if ( ! opts ) {
                     opts = {};
             }

             // Backwards compatibility for 1.9- which used the terminology filter rather
             // than search
             if ( opts.filter &amp;&amp; ! opts.search ) {
                     opts.search = opts.filter;
             }

             return {
                     search: opts.search || &#39;none&#39;,
                     order:  opts.order  || &#39;current&#39;,
                     page:   opts.page   || &#39;all&#39;
             };
     };

     var _selector_first = function ( inst )
     {
             // Reduce the API instance to the first item found
             for ( var i=0, ien=inst.length ; i&lt;ien ; i++ ) {
                     if ( inst[i].length &gt; 0 ) {
                             // Assign the first element to the first item in the instance
                             // and truncate the instance and context
                             inst[0] = inst[i];
                             inst.length = 1;
                             inst.context = [ inst.context[i] ];

                             return inst;
                     }
             }

             // Not found - return an empty instance
             inst.length = 0;
             return inst;
     };

     var _selector_row_indexes = function ( settings, opts )
     {
             var
                     i, ien, tmp, a=[],
                     displayFiltered = settings.aiDisplay,
                     displayMaster = settings.aiDisplayMaster;

             var
                     search = opts.search,  // none, applied, removed
                     order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
                     page   = opts.page;    // all, current

             if ( _fnDataSource( settings ) == &#39;ssp&#39; ) {
                     // In server-side processing mode, most options are irrelevant since
                     // rows not shown don&#39;t exist and the index order is the applied order
                     // Removed is a special case - for consistency just return an empty
                     // array
                     return search === &#39;removed&#39; ?
                             [] :
                             _range( 0, displayMaster.length );
             }
             else if ( page == &#39;current&#39; ) {
                     // Current page implies that order=current and fitler=applied, since it is
                     // fairly senseless otherwise, regardless of what order and search actually
                     // are
                     for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i&lt;ien ; i++ ) {
                             a.push( displayFiltered[i] );
                     }
             }
             else if ( order == &#39;current&#39; || order == &#39;applied&#39; ) {
                     a = search == &#39;none&#39; ?
                             displayMaster.slice() :                      // no search
                             search == &#39;applied&#39; ?
                                     displayFiltered.slice() :                // applied search
                                     $.map( displayMaster, function (el, i) { // removed search
                                             return $.inArray( el, displayFiltered ) === -1 ? el : null;
                                     } );
             }
             else if ( order == &#39;index&#39; || order == &#39;original&#39; ) {
                     for ( i=0, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
                             if ( search == &#39;none&#39; ) {
                                     a.push( i );
                             }
                             else { // applied | removed
                                     tmp = $.inArray( i, displayFiltered );

                                     if ((tmp === -1 &amp;&amp; search == &#39;removed&#39;) ||
                                             (tmp &gt;= 0   &amp;&amp; search == &#39;applied&#39;) )
                                     {
                                             a.push( i );
                                     }
                             }
                     }
             }

             return a;
     };

     /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Rows

 {}          - no selector - use all available rows
 {integer}   - row aoData index
 {node}      - TR node
 {string}    - jQuery selector to apply to the TR elements
 {array}     - jQuery array of nodes, or simply an array of TR nodes

/

     var __row_selector = function ( settings, selector, opts )
     {
             return _selector_run( selector, function ( sel ) {
                     var selInt = _intVal( sel );
                     var i, ien;

                     // Short cut - selector is a number and no options provided (default is
                     // all records, so no need to check if the index is in there, since it
                     // must be - dev error if the index doesn&#39;t exist).
                     if ( selInt !== null &amp;&amp; ! opts ) {
                             return [ selInt ];
                     }

                     var rows = _selector_row_indexes( settings, opts );

                     if ( selInt !== null &amp;&amp; $.inArray( selInt, rows ) !== -1 ) {
                             // Selector - integer
                             return [ selInt ];
                     }
                     else if ( ! sel ) {
                             // Selector - none
                             return rows;
                     }

                     // Selector - function
                     if ( typeof sel === &#39;function&#39; ) {
                             return $.map( rows, function (idx) {
                                     var row = settings.aoData[ idx ];
                                     return sel( idx, row._aData, row.nTr ) ? idx : null;
                             } );
                     }

                     // Get nodes in the order from the `rows` array with null values removed
                     var nodes = _removeEmpty(
                             _pluck_order( settings.aoData, rows, &#39;nTr&#39; )
                     );

                     // Selector - node
                     if ( sel.nodeName ) {
                             if ( $.inArray( sel, nodes ) !== -1 ) {
                                     return [ sel._DT_RowIndex ]; // sel is a TR node that is in the table
                                                                  // and DataTables adds a prop for fast lookup
                             }
                     }

                     // Selector - jQuery selector string, array of nodes or jQuery object/
                     // As jQuery&#39;s .filter() allows jQuery objects to be passed in filter,
                     // it also allows arrays, so this will cope with all three options
                     return $(nodes)
                             .filter( sel )
                             .map( function () {
                                     return this._DT_RowIndex;
                             } )
                             .toArray();
             } );
     };

     _api_register( &#39;rows()&#39;, function ( selector, opts ) {
             // argument shifting
             if ( selector === undefined ) {
                     selector = &#39;&#39;;
             }
             else if ( $.isPlainObject( selector ) ) {
                     opts = selector;
                     selector = &#39;&#39;;
             }

             opts = _selector_opts( opts );

             var inst = this.iterator( &#39;table&#39;, function ( settings ) {
                     return __row_selector( settings, selector, opts );
             }, 1 );

             // Want argument shifting here and in __row_selector?
             inst.selector.rows = selector;
             inst.selector.opts = opts;

             return inst;
     } );

     _api_register( &#39;rows().nodes()&#39;, function () {
             return this.iterator( &#39;row&#39;, function ( settings, row ) {
                     return settings.aoData[ row ].nTr || undefined;
             }, 1 );
     } );

     _api_register( &#39;rows().data()&#39;, function () {
             return this.iterator( true, &#39;rows&#39;, function ( settings, rows ) {
                     return _pluck_order( settings.aoData, rows, &#39;_aData&#39; );
             }, 1 );
     } );

     _api_registerPlural( &#39;rows().cache()&#39;, &#39;row().cache()&#39;, function ( type ) {
             return this.iterator( &#39;row&#39;, function ( settings, row ) {
                     var r = settings.aoData[ row ];
                     return type === &#39;search&#39; ? r._aFilterData : r._aSortData;
             }, 1 );
     } );

     _api_registerPlural( &#39;rows().invalidate()&#39;, &#39;row().invalidate()&#39;, function ( src ) {
             return this.iterator( &#39;row&#39;, function ( settings, row ) {
                     _fnInvalidate( settings, row, src );
             } );
     } );

     _api_registerPlural( &#39;rows().indexes()&#39;, &#39;row().index()&#39;, function () {
             return this.iterator( &#39;row&#39;, function ( settings, row ) {
                     return row;
             }, 1 );
     } );

     _api_registerPlural( &#39;rows().remove()&#39;, &#39;row().remove()&#39;, function () {
             var that = this;

             return this.iterator( &#39;row&#39;, function ( settings, row, thatIdx ) {
                     var data = settings.aoData;

                     data.splice( row, 1 );

                     // Update the _DT_RowIndex parameter on all rows in the table
                     for ( var i=0, ien=data.length ; i&lt;ien ; i++ ) {
                             if ( data[i].nTr !== null ) {
                                     data[i].nTr._DT_RowIndex = i;
                             }
                     }

                     // Remove the target row from the search array
                     var displayIndex = $.inArray( row, settings.aiDisplay );

                     // Delete from the display arrays
                     _fnDeleteIndex( settings.aiDisplayMaster, row );
                     _fnDeleteIndex( settings.aiDisplay, row );
                     _fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes

                     // Check for an &#39;overflow&#39; they case for displaying the table
                     _fnLengthOverflow( settings );
             } );
     } );

     _api_register( &#39;rows.add()&#39;, function ( rows ) {
             var newRows = this.iterator( &#39;table&#39;, function ( settings ) {
                             var row, i, ien;
                             var out = [];

                             for ( i=0, ien=rows.length ; i&lt;ien ; i++ ) {
                                     row = rows[i];

                                     if ( row.nodeName &amp;&amp; row.nodeName.toUpperCase() === &#39;TR&#39; ) {
                                             out.push( _fnAddTr( settings, row )[0] );
                                     }
                                     else {
                                             out.push( _fnAddData( settings, row ) );
                                     }
                             }

                             return out;
                     }, 1 );

             // Return an Api.rows() extended instance, so rows().nodes() etc can be used
             var modRows = this.rows( -1 );
             modRows.pop();
             modRows.push.apply( modRows, newRows.toArray() );

             return modRows;
     } );

     /**

/
     _api_register( &#39;row()&#39;, function ( selector, opts ) {
             return _selector_first( this.rows( selector, opts ) );
     } );

     _api_register( &#39;row().data()&#39;, function ( data ) {
             var ctx = this.context;

             if ( data === undefined ) {
                     // Get
                     return ctx.length &amp;&amp; this.length ?
                             ctx[0].aoData[ this[0] ]._aData :
                             undefined;
             }

             // Set
             ctx[0].aoData[ this[0] ]._aData = data;

             // Automatically invalidate
             _fnInvalidate( ctx[0], this[0], &#39;data&#39; );

             return this;
     } );

     _api_register( &#39;row().node()&#39;, function () {
             var ctx = this.context;

             return ctx.length &amp;&amp; this.length ?
                     ctx[0].aoData[ this[0] ].nTr || null :
                     null;
     } );

     _api_register( &#39;row.add()&#39;, function ( row ) {
             // Allow a jQuery object to be passed in - only a single row is added from
             // it though - the first element in the set
             if ( row instanceof $ &amp;&amp; row.length ) {
                     row = row[0];
             }

             var rows = this.iterator( &#39;table&#39;, function ( settings ) {
                     if ( row.nodeName &amp;&amp; row.nodeName.toUpperCase() === &#39;TR&#39; ) {
                             return _fnAddTr( settings, row )[0];
                     }
                     return _fnAddData( settings, row );
             } );

             // Return an Api.rows() extended instance, with the newly added row selected
             return this.row( rows[0] );
     } );

     var __details_add = function ( ctx, row, data, klass )
     {
             // Convert to array of TR elements
             var rows = [];
             var addRow = function ( r, k ) {
                     // Recursion to allow for arrays of jQuery objects
                     if ( $.isArray( r ) || r instanceof $ ) {
                             for ( var i=0, ien=r.length ; i&lt;ien ; i++ ) {
                                     addRow( r[i], k );
                             }
                             return;
                     }

                     // If we get a TR element, then just add it directly - up to the dev
                     // to add the correct number of columns etc
                     if ( r.nodeName &amp;&amp; r.nodeName.toLowerCase() === &#39;tr&#39; ) {
                             rows.push( r );
                     }
                     else {
                             // Otherwise create a row with a wrapper
                             var created = $(&#39;&lt;tr&gt;&lt;td/&gt;&lt;/tr&gt;&#39;).addClass( k );
                             $(&#39;td&#39;, created)
                                     .addClass( k )
                                     .html( r )
                                     [0].colSpan = _fnVisbleColumns( ctx );

                             rows.push( created[0] );
                     }
             };

             addRow( data, klass );

             if ( row._details ) {
                     row._details.remove();
             }

             row._details = $(rows);

             // If the children were already shown, that state should be retained
             if ( row._detailsShow ) {
                     row._details.insertAfter( row.nTr );
             }
     };

     var __details_remove = function ( api, idx )
     {
             var ctx = api.context;

             if ( ctx.length ) {
                     var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];

                     if ( row._details ) {
                             row._details.remove();

                             row._detailsShow = undefined;
                             row._details = undefined;
                     }
             }
     };

     var __details_display = function ( api, show ) {
             var ctx = api.context;

             if ( ctx.length &amp;&amp; api.length ) {
                     var row = ctx[0].aoData[ api[0] ];

                     if ( row._details ) {
                             row._detailsShow = show;

                             if ( show ) {
                                     row._details.insertAfter( row.nTr );
                             }
                             else {
                                     row._details.detach();
                             }

                             __details_events( ctx[0] );
                     }
             }
     };

     var __details_events = function ( settings )
     {
             var api = new _Api( settings );
             var namespace = &#39;.dt.DT_details&#39;;
             var drawEvent = &#39;draw&#39;+namespace;
             var colvisEvent = &#39;column-visibility&#39;+namespace;
             var destroyEvent = &#39;destroy&#39;+namespace;
             var data = settings.aoData;

             api.off( drawEvent +&#39; &#39;+ colvisEvent +&#39; &#39;+ destroyEvent );

             if ( _pluck( data, &#39;_details&#39; ).length &gt; 0 ) {
                     // On each draw, insert the required elements into the document
                     api.on( drawEvent, function ( e, ctx ) {
                             if ( settings !== ctx ) {
                                     return;
                             }

                             api.rows( {page:&#39;current&#39;} ).eq(0).each( function (idx) {
                                     // Internal data grab
                                     var row = data[ idx ];

                                     if ( row._detailsShow ) {
                                             row._details.insertAfter( row.nTr );
                                     }
                             } );
                     } );

                     // Column visibility change - update the colspan
                     api.on( colvisEvent, function ( e, ctx, idx, vis ) {
                             if ( settings !== ctx ) {
                                     return;
                             }

                             // Update the colspan for the details rows (note, only if it already has
                             // a colspan)
                             var row, visible = _fnVisbleColumns( ctx );

                             for ( var i=0, ien=data.length ; i&lt;ien ; i++ ) {
                                     row = data[i];

                                     if ( row._details ) {
                                             row._details.children(&#39;td[colspan]&#39;).attr(&#39;colspan&#39;, visible );
                                     }
                             }
                     } );

                     // Table destroyed - nuke any child rows
                     api.on( destroyEvent, function ( e, ctx ) {
                             if ( settings !== ctx ) {
                                     return;
                             }

                             for ( var i=0, ien=data.length ; i&lt;ien ; i++ ) {
                                     if ( data[i]._details ) {
                                             __details_remove( api, i );
                                     }
                             }
                     } );
             }
     };

     // Strings for the method names to help minification
     var _emp = &#39;&#39;;
     var _child_obj = _emp+&#39;row().child&#39;;
     var _child_mth = _child_obj+&#39;()&#39;;

     // data can be:
     //  tr
     //  string
     //  jQuery or array of any of the above
     _api_register( _child_mth, function ( data, klass ) {
             var ctx = this.context;

             if ( data === undefined ) {
                     // get
                     return ctx.length &amp;&amp; this.length ?
                             ctx[0].aoData[ this[0] ]._details :
                             undefined;
             }
             else if ( data === true ) {
                     // show
                     this.child.show();
             }
             else if ( data === false ) {
                     // remove
                     __details_remove( this );
             }
             else if ( ctx.length &amp;&amp; this.length ) {
                     // set
                     __details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
             }

             return this;
     } );

     _api_register( [
             _child_obj+&#39;.show()&#39;,
             _child_mth+&#39;.show()&#39; // only when `child()` was called with parameters (without
     ], function ( show ) {   // it returns an object and this method is not executed)
             __details_display( this, true );
             return this;
     } );

     _api_register( [
             _child_obj+&#39;.hide()&#39;,
             _child_mth+&#39;.hide()&#39; // only when `child()` was called with parameters (without
     ], function () {         // it returns an object and this method is not executed)
             __details_display( this, false );
             return this;
     } );

     _api_register( [
             _child_obj+&#39;.remove()&#39;,
             _child_mth+&#39;.remove()&#39; // only when `child()` was called with parameters (without
     ], function () {           // it returns an object and this method is not executed)
             __details_remove( this );
             return this;
     } );

     _api_register( _child_obj+&#39;.isShown()&#39;, function () {
             var ctx = this.context;

             if ( ctx.length &amp;&amp; this.length ) {
                     // _detailsShown as false or undefined will fall through to return false
                     return ctx[0].aoData[ this[0] ]._detailsShow || false;
             }
             return false;
     } );

     /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Columns

 {integer}           - column index (&gt;=0 count from left, &lt;0 count from right)
 &quot;{integer}:visIdx&quot;  - visible column index (i.e. translate to column index)  (&gt;=0 count from left, &lt;0 count from right)
 &quot;{integer}:visible&quot; - alias for {integer}:visIdx  (&gt;=0 count from left, &lt;0 count from right)
 &quot;{string}:name&quot;     - column name
 &quot;{string}&quot;          - jQuery selector on column header nodes

/

     // can be an array of these items, comma separated list, or an array of comma
     // separated lists

     var __re_column_selector = /^(.+):(name|visIdx|visible)$/;

     // r1 and r2 are redundant - but it means that the parameters match for the
     // iterator callback in columns().data()
     var __columnData = function ( settings, column, r1, r2, rows ) {
             var a = [];
             for ( var row=0, ien=rows.length ; row&lt;ien ; row++ ) {
                     a.push( _fnGetCellData( settings, rows[row], column ) );
             }
             return a;
     };

     var __column_selector = function ( settings, selector, opts )
     {
             var
                     columns = settings.aoColumns,
                     names = _pluck( columns, &#39;sName&#39; ),
                     nodes = _pluck( columns, &#39;nTh&#39; );

             return _selector_run( selector, function ( s ) {
                     var selInt = _intVal( s );

                     // Selector - all
                     if ( s === &#39;&#39; ) {
                             return _range( columns.length );
                     }

                     // Selector - index
                     if ( selInt !== null ) {
                             return [ selInt &gt;= 0 ?
                                     selInt : // Count from left
                                     columns.length + selInt // Count from right (+ because its a negative value)
                             ];
                     }

                     // Selector = function
                     if ( typeof s === &#39;function&#39; ) {
                             var rows = _selector_row_indexes( settings, opts );

                             return $.map( columns, function (col, idx) {
                                     return s(
                                                     idx,
                                                     __columnData( settings, idx, 0, 0, rows ),
                                                     nodes[ idx ]
                                             ) ? idx : null;
                             } );
                     }

                     // jQuery or string selector
                     var match = typeof s === &#39;string&#39; ?
                             s.match( __re_column_selector ) :
                             &#39;&#39;;

                     if ( match ) {
                             switch( match[2] ) {
                                     case &#39;visIdx&#39;:
                                     case &#39;visible&#39;:
                                             var idx = parseInt( match[1], 10 );
                                             // Visible index given, convert to column index
                                             if ( idx &lt; 0 ) {
                                                     // Counting from the right
                                                     var visColumns = $.map( columns, function (col,i) {
                                                             return col.bVisible ? i : null;
                                                     } );
                                                     return [ visColumns[ visColumns.length + idx ] ];
                                             }
                                             // Counting from the left
                                             return [ _fnVisibleToColumnIndex( settings, idx ) ];

                                     case &#39;name&#39;:
                                             // match by name. `names` is column index complete and in order
                                             return $.map( names, function (name, i) {
                                                     return name === match[1] ? i : null;
                                             } );
                             }
                     }
                     else {
                             // jQuery selector on the TH elements for the columns
                             return $( nodes )
                                     .filter( s )
                                     .map( function () {
                                             return $.inArray( this, nodes ); // `nodes` is column index complete and in order
                                     } )
                                     .toArray();
                     }
             } );
     };

     var __setColumnVis = function ( settings, column, vis, recalc ) {
             var
                     cols = settings.aoColumns,
                     col  = cols[ column ],
                     data = settings.aoData,
                     row, cells, i, ien, tr;

             // Get
             if ( vis === undefined ) {
                     return col.bVisible;
             }

             // Set
             // No change
             if ( col.bVisible === vis ) {
                     return;
             }

             if ( vis ) {
                     // Insert column
                     // Need to decide if we should use appendChild or insertBefore
                     var insertBefore = $.inArray( true, _pluck(cols, &#39;bVisible&#39;), column+1 );

                     for ( i=0, ien=data.length ; i&lt;ien ; i++ ) {
                             tr = data[i].nTr;
                             cells = data[i].anCells;

                             if ( tr ) {
                                     // insertBefore can act like appendChild if 2nd arg is null
                                     tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
                             }
                     }
             }
             else {
                     // Remove column
                     $( _pluck( settings.aoData, &#39;anCells&#39;, column ) ).detach();
             }

             // Common actions
             col.bVisible = vis;
             _fnDrawHead( settings, settings.aoHeader );
             _fnDrawHead( settings, settings.aoFooter );

             if ( recalc === undefined || recalc ) {
                     // Automatically adjust column sizing
                     _fnAdjustColumnSizing( settings );

                     // Realign columns for scrolling
                     if ( settings.oScroll.sX || settings.oScroll.sY ) {
                             _fnScrollDraw( settings );
                     }
             }

             _fnCallbackFire( settings, null, &#39;column-visibility&#39;, [settings, column, vis] );

             _fnSaveState( settings );
     };

     _api_register( &#39;columns()&#39;, function ( selector, opts ) {
             // argument shifting
             if ( selector === undefined ) {
                     selector = &#39;&#39;;
             }
             else if ( $.isPlainObject( selector ) ) {
                     opts = selector;
                     selector = &#39;&#39;;
             }

             opts = _selector_opts( opts );

             var inst = this.iterator( &#39;table&#39;, function ( settings ) {
                     return __column_selector( settings, selector, opts );
             }, 1 );

             // Want argument shifting here and in _row_selector?
             inst.selector.cols = selector;
             inst.selector.opts = opts;

             return inst;
     } );

     _api_registerPlural( &#39;columns().header()&#39;, &#39;column().header()&#39;, function ( selector, opts ) {
             return this.iterator( &#39;column&#39;, function ( settings, column ) {
                     return settings.aoColumns[column].nTh;
             }, 1 );
     } );

     _api_registerPlural( &#39;columns().footer()&#39;, &#39;column().footer()&#39;, function ( selector, opts ) {
             return this.iterator( &#39;column&#39;, function ( settings, column ) {
                     return settings.aoColumns[column].nTf;
             }, 1 );
     } );

     _api_registerPlural( &#39;columns().data()&#39;, &#39;column().data()&#39;, function () {
             return this.iterator( &#39;column-rows&#39;, __columnData, 1 );
     } );

     _api_registerPlural( &#39;columns().dataSrc()&#39;, &#39;column().dataSrc()&#39;, function () {
             return this.iterator( &#39;column&#39;, function ( settings, column ) {
                     return settings.aoColumns[column].mData;
             }, 1 );
     } );

     _api_registerPlural( &#39;columns().cache()&#39;, &#39;column().cache()&#39;, function ( type ) {
             return this.iterator( &#39;column-rows&#39;, function ( settings, column, i, j, rows ) {
                     return _pluck_order( settings.aoData, rows,
                             type === &#39;search&#39; ? &#39;_aFilterData&#39; : &#39;_aSortData&#39;, column
                     );
             }, 1 );
     } );

     _api_registerPlural( &#39;columns().nodes()&#39;, &#39;column().nodes()&#39;, function () {
             return this.iterator( &#39;column-rows&#39;, function ( settings, column, i, j, rows ) {
                     return _pluck_order( settings.aoData, rows, &#39;anCells&#39;, column ) ;
             }, 1 );
     } );

     _api_registerPlural( &#39;columns().visible()&#39;, &#39;column().visible()&#39;, function ( vis, calc ) {
             return this.iterator( &#39;column&#39;, function ( settings, column ) {
                     if ( vis === undefined ) {
                             return settings.aoColumns[ column ].bVisible;
                     } // else
                     __setColumnVis( settings, column, vis, calc );
             } );
     } );

     _api_registerPlural( &#39;columns().indexes()&#39;, &#39;column().index()&#39;, function ( type ) {
             return this.iterator( &#39;column&#39;, function ( settings, column ) {
                     return type === &#39;visible&#39; ?
                             _fnColumnIndexToVisible( settings, column ) :
                             column;
             }, 1 );
     } );

     _api_register( &#39;columns.adjust()&#39;, function () {
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     _fnAdjustColumnSizing( settings );
             }, 1 );
     } );

     _api_register( &#39;column.index()&#39;, function ( type, idx ) {
             if ( this.context.length !== 0 ) {
                     var ctx = this.context[0];

                     if ( type === &#39;fromVisible&#39; || type === &#39;toData&#39; ) {
                             return _fnVisibleToColumnIndex( ctx, idx );
                     }
                     else if ( type === &#39;fromData&#39; || type === &#39;toVisible&#39; ) {
                             return _fnColumnIndexToVisible( ctx, idx );
                     }
             }
     } );

     _api_register( &#39;column()&#39;, function ( selector, opts ) {
             return _selector_first( this.columns( selector, opts ) );
     } );

     var __cell_selector = function ( settings, selector, opts )
     {
             var data = settings.aoData;
             var rows = _selector_row_indexes( settings, opts );
             var cells = _removeEmpty( _pluck_order( data, rows, &#39;anCells&#39; ) );
             var allCells = $( [].concat.apply([], cells) );
             var row;
             var columns = settings.aoColumns.length;
             var a, i, ien, j, o, host;

             return _selector_run( selector, function ( s ) {
                     var fnSelector = typeof s === &#39;function&#39;;

                     if ( s === null || s === undefined || fnSelector ) {
                             // All cells and function selectors
                             a = [];

                             for ( i=0, ien=rows.length ; i&lt;ien ; i++ ) {
                                     row = rows[i];

                                     for ( j=0 ; j&lt;columns ; j++ ) {
                                             o = {
                                                     row: row,
                                                     column: j
                                             };

                                             if ( fnSelector ) {
                                                     // Selector - function
                                                     host = settings.aoData[ row ];

                                                     if ( s( o, _fnGetCellData(settings, row, j), host.anCells[j] ) ) {
                                                             a.push( o );
                                                     }
                                             }
                                             else {
                                                     // Selector - all
                                                     a.push( o );
                                             }
                                     }
                             }

                             return a;
                     }

                     // Selector - index
                     if ( $.isPlainObject( s ) ) {
                             return [s];
                     }

                     // Selector - jQuery filtered cells
                     return allCells
                             .filter( s )
                             .map( function (i, el) {
                                     row = el.parentNode._DT_RowIndex;

                                     return {
                                             row: row,
                                             column: $.inArray( el, data[ row ].anCells )
                                     };
                             } )
                             .toArray();
             } );
     };

     _api_register( &#39;cells()&#39;, function ( rowSelector, columnSelector, opts ) {
             // Argument shifting
             if ( $.isPlainObject( rowSelector ) ) {
                     // Indexes
                     if ( rowSelector.row === undefined ) {
                             // Selector options in first parameter
                             opts = rowSelector;
                             rowSelector = null;
                     }
                     else {
                             // Cell index objects in first parameter
                             opts = columnSelector;
                             columnSelector = null;
                     }
             }
             if ( $.isPlainObject( columnSelector ) ) {
                     opts = columnSelector;
                     columnSelector = null;
             }

             // Cell selector
             if ( columnSelector === null || columnSelector === undefined ) {
                     return this.iterator( &#39;table&#39;, function ( settings ) {
                             return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
                     } );
             }

             // Row + column selector
             var columns = this.columns( columnSelector, opts );
             var rows = this.rows( rowSelector, opts );
             var a, i, ien, j, jen;

             var cells = this.iterator( &#39;table&#39;, function ( settings, idx ) {
                     a = [];

                     for ( i=0, ien=rows[idx].length ; i&lt;ien ; i++ ) {
                             for ( j=0, jen=columns[idx].length ; j&lt;jen ; j++ ) {
                                     a.push( {
                                             row:    rows[idx][i],
                                             column: columns[idx][j]
                                     } );
                             }
                     }

                     return a;
             }, 1 );

             $.extend( cells.selector, {
                     cols: columnSelector,
                     rows: rowSelector,
                     opts: opts
             } );

             return cells;
     } );

     _api_registerPlural( &#39;cells().nodes()&#39;, &#39;cell().node()&#39;, function () {
             return this.iterator( &#39;cell&#39;, function ( settings, row, column ) {
                     var cells = settings.aoData[ row ].anCells;
                     return cells ?
                             cells[ column ] :
                             undefined;
             }, 1 );
     } );

     _api_register( &#39;cells().data()&#39;, function () {
             return this.iterator( &#39;cell&#39;, function ( settings, row, column ) {
                     return _fnGetCellData( settings, row, column );
             }, 1 );
     } );

     _api_registerPlural( &#39;cells().cache()&#39;, &#39;cell().cache()&#39;, function ( type ) {
             type = type === &#39;search&#39; ? &#39;_aFilterData&#39; : &#39;_aSortData&#39;;

             return this.iterator( &#39;cell&#39;, function ( settings, row, column ) {
                     return settings.aoData[ row ][ type ][ column ];
             }, 1 );
     } );

     _api_registerPlural( &#39;cells().render()&#39;, &#39;cell().render()&#39;, function ( type ) {
             return this.iterator( &#39;cell&#39;, function ( settings, row, column ) {
                     return _fnGetCellData( settings, row, column, type );
             }, 1 );
     } );

     _api_registerPlural( &#39;cells().indexes()&#39;, &#39;cell().index()&#39;, function () {
             return this.iterator( &#39;cell&#39;, function ( settings, row, column ) {
                     return {
                             row: row,
                             column: column,
                             columnVisible: _fnColumnIndexToVisible( settings, column )
                     };
             }, 1 );
     } );

     _api_registerPlural( &#39;cells().invalidate()&#39;, &#39;cell().invalidate()&#39;, function ( src ) {
             return this.iterator( &#39;cell&#39;, function ( settings, row, column ) {
                     _fnInvalidate( settings, row, src, column );
             } );
     } );

     _api_register( &#39;cell()&#39;, function ( rowSelector, columnSelector, opts ) {
             return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
     } );

     _api_register( &#39;cell().data()&#39;, function ( data ) {
             var ctx = this.context;
             var cell = this[0];

             if ( data === undefined ) {
                     // Get
                     return ctx.length &amp;&amp; cell.length ?
                             _fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
                             undefined;
             }

             // Set
             _fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
             _fnInvalidate( ctx[0], cell[0].row, &#39;data&#39;, cell[0].column );

             return this;
     } );

     /**
 Get current ordering (sorting) that has been applied to the table.

 @returns {array} 2D array containing the sorting information for the first
   table in the current context. Each element in the parent array represents
   a column being sorted upon (i.e. multi-sorting with two columns would have
   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
   the column index that the sorting condition applies to, the second is the
   direction of the sort (`desc` or `asc`) and, optionally, the third is the
   index of the sorting order from the `column.sorting` initialisation array.
//**
 Set the ordering for the table.

 @param {integer} order Column index to sort upon.
 @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
 @returns {DataTables.Api} this
//**
 Set the ordering for the table.

 @param {array} order 1D array of sorting information to be applied.
 @param {array} [...] Optional additional sorting conditions
 @returns {DataTables.Api} this
//**
 Set the ordering for the table.

 @param {array} order 2D array of sorting information to be applied.
 @returns {DataTables.Api} this
/
     _api_register( &#39;order()&#39;, function ( order, dir ) {
             var ctx = this.context;

             if ( order === undefined ) {
                     // get
                     return ctx.length !== 0 ?
                             ctx[0].aaSorting :
                             undefined;
             }

             // set
             if ( typeof order === &#39;number&#39; ) {
                     // Simple column / direction passed in
                     order = [ [ order, dir ] ];
             }
             else if ( ! $.isArray( order[0] ) ) {
                     // Arguments passed in (list of 1D arrays)
                     order = Array.prototype.slice.call( arguments );
             }
             // otherwise a 2D array was passed in

             return this.iterator( &#39;table&#39;, function ( settings ) {
                     settings.aaSorting = order.slice();
             } );
     } );

     /**
 Attach a sort listener to an element for a given column

 @param {node|jQuery|string} node Identifier for the element(s) to attach the
   listener to. This can take the form of a single DOM node, a jQuery
   collection of nodes or a jQuery selector which will identify the node(s).
 @param {integer} column the column that a click on this node will sort on
 @param {function} [callback] callback function when sort is run
 @returns {DataTables.Api} this
/
     _api_register( &#39;order.listener()&#39;, function ( node, column, callback ) {
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     _fnSortAttachListener( settings, node, column, callback );
             } );
     } );

     // Order by the selected column(s)
     _api_register( [
             &#39;columns().order()&#39;,
             &#39;column().order()&#39;
     ], function ( dir ) {
             var that = this;

             return this.iterator( &#39;table&#39;, function ( settings, i ) {
                     var sort = [];

                     $.each( that[i], function (j, col) {
                             sort.push( [ col, dir ] );
                     } );

                     settings.aaSorting = sort;
             } );
     } );

     _api_register( &#39;search()&#39;, function ( input, regex, smart, caseInsen ) {
             var ctx = this.context;

             if ( input === undefined ) {
                     // get
                     return ctx.length !== 0 ?
                             ctx[0].oPreviousSearch.sSearch :
                             undefined;
             }

             // set
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     if ( ! settings.oFeatures.bFilter ) {
                             return;
                     }

                     _fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
                             &quot;sSearch&quot;: input+&quot;&quot;,
                             &quot;bRegex&quot;:  regex === null ? false : regex,
                             &quot;bSmart&quot;:  smart === null ? true  : smart,
                             &quot;bCaseInsensitive&quot;: caseInsen === null ? true : caseInsen
                     } ), 1 );
             } );
     } );

     _api_registerPlural(
             &#39;columns().search()&#39;,
             &#39;column().search()&#39;,
             function ( input, regex, smart, caseInsen ) {
                     return this.iterator( &#39;column&#39;, function ( settings, column ) {
                             var preSearch = settings.aoPreSearchCols;

                             if ( input === undefined ) {
                                     // get
                                     return preSearch[ column ].sSearch;
                             }

                             // set
                             if ( ! settings.oFeatures.bFilter ) {
                                     return;
                             }

                             $.extend( preSearch[ column ], {
                                     &quot;sSearch&quot;: input+&quot;&quot;,
                                     &quot;bRegex&quot;:  regex === null ? false : regex,
                                     &quot;bSmart&quot;:  smart === null ? true  : smart,
                                     &quot;bCaseInsensitive&quot;: caseInsen === null ? true : caseInsen
                             } );

                             _fnFilterComplete( settings, settings.oPreviousSearch, 1 );
                     } );
             }
     );

     /*
 State API methods
/

     _api_register( &#39;state()&#39;, function () {
             return this.context.length ?
                     this.context[0].oSavedState :
                     null;
     } );

     _api_register( &#39;state.clear()&#39;, function () {
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     // Save an empty object
                     settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
             } );
     } );

     _api_register( &#39;state.loaded()&#39;, function () {
             return this.context.length ?
                     this.context[0].oLoadedState :
                     null;
     } );

     _api_register( &#39;state.save()&#39;, function () {
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     _fnSaveState( settings );
             } );
     } );

     /**
 Provide a common method for plug-ins to check the version of DataTables being
 used, in order to ensure compatibility.

  @param {string} version Version string to check for, in the format &quot;X.Y.Z&quot;.
    Note that the formats &quot;X&quot; and &quot;X.Y&quot; are also acceptable.
  @returns {boolean} true if this version of DataTables is greater or equal to
    the required version, or false if this version of DataTales is not
    suitable
  @static
  @dtopt API-Static

  @example
    alert( $.fn.dataTable.versionCheck( &#39;1.9.0&#39; ) );
/
     DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
     {
             var aThis = DataTable.version.split(&#39;.&#39;);
             var aThat = version.split(&#39;.&#39;);
             var iThis, iThat;

             for ( var i=0, iLen=aThat.length ; i&lt;iLen ; i++ ) {
                     iThis = parseInt( aThis[i], 10 ) || 0;
                     iThat = parseInt( aThat[i], 10 ) || 0;

                     // Parts are the same, keep comparing
                     if (iThis === iThat) {
                             continue;
                     }

                     // Parts are different, return immediately
                     return iThis &gt; iThat;
             }

             return true;
     };

     /**
 Check if a `&lt;table&gt;` node is a DataTable table already or not.

  @param {node|jquery|string} table Table node, jQuery object or jQuery
      selector for the table to test. Note that if more than more than one
      table is passed on, only the first will be checked
  @returns {boolean} true the table given is a DataTable, or false otherwise
  @static
  @dtopt API-Static

  @example
    if ( ! $.fn.DataTable.isDataTable( &#39;#example&#39; ) ) {
      $(&#39;#example&#39;).dataTable();
    }
/
     DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
     {
             var t = $(table).get(0);
             var is = false;

             $.each( DataTable.settings, function (i, o) {
                     var head = o.nScrollHead ? $(&#39;table&#39;, o.nScrollHead)[0] : null;
                     var foot = o.nScrollFoot ? $(&#39;table&#39;, o.nScrollFoot)[0] : null;

                     if ( o.nTable === t || head === t || foot === t ) {
                             is = true;
                     }
             } );

             return is;
     };

     /**
 Get all DataTable tables that have been initialised - optionally you can
 select to get only currently visible tables.

  @param {boolean} [visible=false] Flag to indicate if you want all (default)
    or visible tables only.
  @returns {array} Array of `table` nodes (not DataTable instances) which are
    DataTables
  @static
  @dtopt API-Static

  @example
    $.each( $.fn.dataTable.tables(true), function () {
      $(table).DataTable().columns.adjust();
    } );
/
     DataTable.tables = DataTable.fnTables = function ( visible )
     {
             return $.map( DataTable.settings, function (o) {
                     if ( !visible || (visible &amp;&amp; $(o.nTable).is(&#39;:visible&#39;)) ) {
                             return o.nTable;
                     }
             } );
     };

     /**
 DataTables utility methods

 This namespace provides helper methods that DataTables uses internally to
 create a DataTable, but which are not exclusively used only for DataTables.
 These methods can be used by extension authors to save the duplication of
 code.

  @namespace
/
     DataTable.util = {
             /**
  Throttle the calls to a function. Arguments and context are maintained
  for the throttled function.

  @param {function} fn Function to be called
  @param {integer} freq Call frequency in mS
  @return {function} Wrapped function
 /
             throttle: _fnThrottle,

             /**
  Escape a string such that it can be used in a regular expression

   @param {string} sVal string to escape
   @returns {string} escaped string
 /
             escapeRegex: _fnEscapeRegex
     };

     /**
 Convert from camel case parameters to Hungarian notation. This is made public
 for the extensions to provide the same ability as DataTables core to accept
 either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
 parameters.

  @param {object} src The model object which holds all parameters that can be
    mapped.
  @param {object} user The object to convert from camel case to Hungarian.
  @param {boolean} force When set to `true`, properties which already have a
    Hungarian value in the `user` object will be overwritten. Otherwise they
    won&#39;t be.
/
     DataTable.camelToHungarian = _fnCamelToHungarian;

     /**

/
     _api_register( &#39;$()&#39;, function ( selector, opts ) {
             var
                     rows   = this.rows( opts ).nodes(), // Get all rows
                     jqRows = $(rows);

             return $( [].concat(
                     jqRows.filter( selector ).toArray(),
                     jqRows.find( selector ).toArray()
             ) );
     } );

     // jQuery functions to operate on the tables
     $.each( [ &#39;on&#39;, &#39;one&#39;, &#39;off&#39; ], function (i, key) {
             _api_register( key+&#39;()&#39;, function ( /* event, handler */ ) {
                     var args = Array.prototype.slice.call(arguments);

                     // Add the `dt` namespace automatically if it isn&#39;t already present
                     if ( ! args[0].match(/\.dt\b/) ) {
                             args[0] += &#39;.dt&#39;;
                     }

                     var inst = $( this.tables().nodes() );
                     inst[key].apply( inst, args );
                     return this;
             } );
     } );

     _api_register( &#39;clear()&#39;, function () {
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     _fnClearTable( settings );
             } );
     } );

     _api_register( &#39;settings()&#39;, function () {
             return new _Api( this.context, this.context );
     } );

     _api_register( &#39;init()&#39;, function () {
             var ctx = this.context;
             return ctx.length ? ctx[0].oInit : null;
     } );

     _api_register( &#39;data()&#39;, function () {
             return this.iterator( &#39;table&#39;, function ( settings ) {
                     return _pluck( settings.aoData, &#39;_aData&#39; );
             } ).flatten();
     } );

     _api_register( &#39;destroy()&#39;, function ( remove ) {
             remove = remove || false;

             return this.iterator( &#39;table&#39;, function ( settings ) {
                     var orig      = settings.nTableWrapper.parentNode;
                     var classes   = settings.oClasses;
                     var table     = settings.nTable;
                     var tbody     = settings.nTBody;
                     var thead     = settings.nTHead;
                     var tfoot     = settings.nTFoot;
                     var jqTable   = $(table);
                     var jqTbody   = $(tbody);
                     var jqWrapper = $(settings.nTableWrapper);
                     var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
                     var i, ien;

                     // Flag to note that the table is currently being destroyed - no action
                     // should be taken
                     settings.bDestroying = true;

                     // Fire off the destroy callbacks for plug-ins etc
                     _fnCallbackFire( settings, &quot;aoDestroyCallback&quot;, &quot;destroy&quot;, [settings] );

                     // If not being removed from the document, make all columns visible
                     if ( ! remove ) {
                             new _Api( settings ).columns().visible( true );
                     }

                     // Blitz all `DT` namespaced events (these are internal events, the
                     // lowercase, `dt` events are user subscribed and they are responsible
                     // for removing them
                     jqWrapper.unbind(&#39;.DT&#39;).find(&#39;:not(tbody *)&#39;).unbind(&#39;.DT&#39;);
                     $(window).unbind(&#39;.DT-&#39;+settings.sInstance);

                     // When scrolling we had to break the table up - restore it
                     if ( table != thead.parentNode ) {
                             jqTable.children(&#39;thead&#39;).detach();
                             jqTable.append( thead );
                     }

                     if ( tfoot &amp;&amp; table != tfoot.parentNode ) {
                             jqTable.children(&#39;tfoot&#39;).detach();
                             jqTable.append( tfoot );
                     }

                     // Remove the DataTables generated nodes, events and classes
                     jqTable.detach();
                     jqWrapper.detach();

                     settings.aaSorting = [];
                     settings.aaSortingFixed = [];
                     _fnSortingClasses( settings );

                     $( rows ).removeClass( settings.asStripeClasses.join(&#39; &#39;) );

                     $(&#39;th, td&#39;, thead).removeClass( classes.sSortable+&#39; &#39;+
                             classes.sSortableAsc+&#39; &#39;+classes.sSortableDesc+&#39; &#39;+classes.sSortableNone
                     );

                     if ( settings.bJUI ) {
                             $(&#39;th span.&#39;+classes.sSortIcon+ &#39;, td span.&#39;+classes.sSortIcon, thead).detach();
                             $(&#39;th, td&#39;, thead).each( function () {
                                     var wrapper = $(&#39;div.&#39;+classes.sSortJUIWrapper, this);
                                     $(this).append( wrapper.contents() );
                                     wrapper.detach();
                             } );
                     }

                     if ( ! remove &amp;&amp; orig ) {
                             // insertBefore acts like appendChild if !arg[1]
                             orig.insertBefore( table, settings.nTableReinsertBefore );
                     }

                     // Add the TR elements back into the table in their original order
                     jqTbody.children().detach();
                     jqTbody.append( rows );

                     // Restore the width of the original table - was read from the style property,
                     // so we can restore directly to that
                     jqTable
                             .css( &#39;width&#39;, settings.sDestroyWidth )
                             .removeClass( classes.sTable );

                     // If the were originally stripe classes - then we add them back here.
                     // Note this is not fool proof (for example if not all rows had stripe
                     // classes - but it&#39;s a good effort without getting carried away
                     ien = settings.asDestroyStripes.length;

                     if ( ien ) {
                             jqTbody.children().each( function (i) {
                                     $(this).addClass( settings.asDestroyStripes[i % ien] );
                             } );
                     }

                     /* Remove the settings object from the settings array */
                     var idx = $.inArray( settings, DataTable.settings );
                     if ( idx !== -1 ) {
                             DataTable.settings.splice( idx, 1 );
                     }
             } );
     } );

     // Add the `every()` method for rows, columns and cells in a compact form
     $.each( [ &#39;column&#39;, &#39;row&#39;, &#39;cell&#39; ], function ( i, type ) {
             _api_register( type+&#39;s().every()&#39;, function ( fn ) {
                     return this.iterator( type, function ( settings, idx, idx2 ) {
                             // idx2 is undefined for rows and columns.
                             fn.call( new _Api( settings )[ type ]( idx, idx2 ) );
                     } );
             } );
     } );

     /**
 Version string for plug-ins to check compatibility. Allowed format is
 `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
 only for non-release builds. See http://semver.org/ for more information.
  @member
  @type string
  @default Version number
/
     DataTable.version = &quot;1.10.6&quot;;

     /**
 Private data store, containing all of the settings objects that are
 created for the tables on a given page.

 Note that the `DataTable.settings` object is aliased to
 `jQuery.fn.dataTableExt` through which it may be accessed and
 manipulated, or `jQuery.fn.dataTable.settings`.
  @member
  @type array
  @default []
  @private
/
     DataTable.settings = [];

     /**
 Object models container, for the various models that DataTables has
 available to it. These models define the objects that are used to hold
 the active state and configuration of the table.
  @namespace
/
     DataTable.models = {};

     /**
 Template object for the way in which DataTables holds information about
 search information for the global filter and individual column filters.
  @namespace
/
     DataTable.models.oSearch = {
             /**
  Flag to indicate if the filtering should be case insensitive or not
   @type boolean
   @default true
 /
             &quot;bCaseInsensitive&quot;: true,

             /**
  Applied search term
   @type string
   @default &lt;i&gt;Empty string&lt;/i&gt;
 /
             &quot;sSearch&quot;: &quot;&quot;,

             /**
  Flag to indicate if the search term should be interpreted as a
  regular expression (true) or not (false) and therefore and special
  regex characters escaped.
   @type boolean
   @default false
 /
             &quot;bRegex&quot;: false,

             /**
  Flag to indicate if DataTables is to use its smart filtering or not.
   @type boolean
   @default true
 /
             &quot;bSmart&quot;: true
     };

     /**
 Template object for the way in which DataTables holds information about
 each individual row. This is the object format used for the settings
 aoData array.
  @namespace
/
     DataTable.models.oRow = {
             /**
  TR element for the row
   @type node
   @default null
 /
             &quot;nTr&quot;: null,

             /**
  Array of TD elements for each row. This is null until the row has been
  created.
   @type array nodes
   @default []
 /
             &quot;anCells&quot;: null,

             /**
  Data object from the original data source for the row. This is either
  an array if using the traditional form of DataTables, or an object if
  using mData options. The exact type will depend on the passed in
  data from the data source, or will be an array if using DOM a data
  source.
   @type array|object
   @default []
 /
             &quot;_aData&quot;: [],

             /**
  Sorting data cache - this array is ostensibly the same length as the
  number of columns (although each index is generated only as it is
  needed), and holds the data that is used for sorting each column in the
  row. We do this cache generation at the start of the sort in order that
  the formatting of the sort data need be done only once for each cell
  per sort. This array should not be read from or written to by anything
  other than the master sorting methods.
   @type array
   @default null
   @private
 /
             &quot;_aSortData&quot;: null,

             /**
  Per cell filtering data cache. As per the sort data cache, used to
  increase the performance of the filtering in DataTables
   @type array
   @default null
   @private
 /
             &quot;_aFilterData&quot;: null,

             /**
  Filtering data cache. This is the same as the cell filtering cache, but
  in this case a string rather than an array. This is easily computed with
  a join on `_aFilterData`, but is provided as a cache so the join isn&#39;t
  needed on every search (memory traded for performance)
   @type array
   @default null
   @private
 /
             &quot;_sFilterRow&quot;: null,

             /**
  Cache of the class name that DataTables has applied to the row, so we
  can quickly look at this variable rather than needing to do a DOM check
  on className for the nTr property.
   @type string
   @default &lt;i&gt;Empty string&lt;/i&gt;
   @private
 /
             &quot;_sRowStripe&quot;: &quot;&quot;,

             /**
  Denote if the original data source was from the DOM, or the data source
  object. This is used for invalidating data, so DataTables can
  automatically read data from the original source, unless uninstructed
  otherwise.
   @type string
   @default null
   @private
 /
             &quot;src&quot;: null
     };

     /**
 Template object for the column information object in DataTables. This object
 is held in the settings aoColumns array and contains all the information that
 DataTables needs about each individual column.

 Note that this object is related to {@link DataTable.defaults.column}
 but this one is the internal data store for DataTables&#39;s cache of columns.
 It should NOT be manipulated outside of DataTables. Any configuration should
 be done through the initialisation options.
  @namespace
/
     DataTable.models.oColumn = {
             /**
  Column index. This could be worked out on-the-fly with $.inArray, but it
  is faster to just hold it as a variable
   @type integer
   @default null
 /
             &quot;idx&quot;: null,

             /**
  A list of the columns that sorting should occur on when this column
  is sorted. That this property is an array allows multi-column sorting
  to be defined for a column (for example first name / last name columns
  would benefit from this). The values are integers pointing to the
  columns to be sorted on (typically it will be a single integer pointing
  at itself, but that doesn&#39;t need to be the case).
   @type array
 /
             &quot;aDataSort&quot;: null,

             /**
  Define the sorting directions that are applied to the column, in sequence
  as the column is repeatedly sorted upon - i.e. the first value is used
  as the sorting direction when the column if first sorted (clicked on).
  Sort it again (click again) and it will move on to the next index.
  Repeat until loop.
   @type array
 /
             &quot;asSorting&quot;: null,

             /**
  Flag to indicate if the column is searchable, and thus should be included
  in the filtering or not.
   @type boolean
 /
             &quot;bSearchable&quot;: null,

             /**
  Flag to indicate if the column is sortable or not.
   @type boolean
 /
             &quot;bSortable&quot;: null,

             /**
  Flag to indicate if the column is currently visible in the table or not
   @type boolean
 /
             &quot;bVisible&quot;: null,

             /**
  Store for manual type assignment using the `column.type` option. This
  is held in store so we can manipulate the column&#39;s `sType` property.
   @type string
   @default null
   @private
 /
             &quot;_sManualType&quot;: null,

             /**
  Flag to indicate if HTML5 data attributes should be used as the data
  source for filtering or sorting. True is either are.
   @type boolean
   @default false
   @private
 /
             &quot;_bAttrSrc&quot;: false,

             /**
  Developer definable function that is called whenever a cell is created (Ajax source,
  etc) or processed for input (DOM source). This can be used as a compliment to mRender
  allowing you to modify the DOM element (add background colour for example) when the
  element is available.
   @type function
   @param {element} nTd The TD node that has been created
   @param {*} sData The Data for the cell
   @param {array|object} oData The data for the whole row
   @param {int} iRow The row index for the aoData data store
   @default null
 /
             &quot;fnCreatedCell&quot;: null,

             /**
  Function to get data from a cell in a column. You should &lt;b&gt;never&lt;/b&gt;
  access data directly through _aData internally in DataTables - always use
  the method attached to this property. It allows mData to function as
  required. This function is automatically assigned by the column
  initialisation method
   @type function
   @param {array|object} oData The data array/object for the array
     (i.e. aoData[]._aData)
   @param {string} sSpecific The specific data type you want to get -
     &#39;display&#39;, &#39;type&#39; &#39;filter&#39; &#39;sort&#39;
   @returns {*} The data for the cell from the given row&#39;s data
   @default null
 /
             &quot;fnGetData&quot;: null,

             /**
  Function to set data for a cell in the column. You should &lt;b&gt;never&lt;/b&gt;
  set the data directly to _aData internally in DataTables - always use
  this method. It allows mData to function as required. This function
  is automatically assigned by the column initialisation method
   @type function
   @param {array|object} oData The data array/object for the array
     (i.e. aoData[]._aData)
   @param {*} sValue Value to set
   @default null
 /
             &quot;fnSetData&quot;: null,

             /**
  Property to read the value for the cells in the column from the data
  source array / object. If null, then the default content is used, if a
  function is given then the return from the function is used.
   @type function|int|string|null
   @default null
 /
             &quot;mData&quot;: null,

             /**
  Partner property to mData which is used (only when defined) to get
  the data - i.e. it is basically the same as mData, but without the
  &#39;set&#39; option, and also the data fed to it is the result from mData.
  This is the rendering method to match the data method of mData.
   @type function|int|string|null
   @default null
 /
             &quot;mRender&quot;: null,

             /**
  Unique header TH/TD element for this column - this is what the sorting
  listener is attached to (if sorting is enabled.)
   @type node
   @default null
 /
             &quot;nTh&quot;: null,

             /**
  Unique footer TH/TD element for this column (if there is one). Not used
  in DataTables as such, but can be used for plug-ins to reference the
  footer for each column.
   @type node
   @default null
 /
             &quot;nTf&quot;: null,

             /**
  The class to apply to all TD elements in the table&#39;s TBODY for the column
   @type string
   @default null
 /
             &quot;sClass&quot;: null,

             /**
  When DataTables calculates the column widths to assign to each column,
  it finds the longest string in each column and then constructs a
  temporary table and reads the widths from that. The problem with this
  is that &quot;mmm&quot; is much wider then &quot;iiii&quot;, but the latter is a longer
  string - thus the calculation can go wrong (doing it properly and putting
  it into an DOM object and measuring that is horribly(!) slow). Thus as
  a &quot;work around&quot; we provide this option. It will append its value to the
  text that is found to be the longest string for the column - i.e. padding.
   @type string
 /
             &quot;sContentPadding&quot;: null,

             /**
  Allows a default value to be given for a column&#39;s data, and will be used
  whenever a null data source is encountered (this can be because mData
  is set to null, or because the data source itself is null).
   @type string
   @default null
 /
             &quot;sDefaultContent&quot;: null,

             /**
  Name for the column, allowing reference to the column by name as well as
  by index (needs a lookup to work by name).
   @type string
 /
             &quot;sName&quot;: null,

             /**
  Custom sorting data type - defines which of the available plug-ins in
  afnSortData the custom sorting will use - if any is defined.
   @type string
   @default std
 /
             &quot;sSortDataType&quot;: &#39;std&#39;,

             /**
  Class to be applied to the header element when sorting on this column
   @type string
   @default null
 /
             &quot;sSortingClass&quot;: null,

             /**
  Class to be applied to the header element when sorting on this column -
  when jQuery UI theming is used.
   @type string
   @default null
 /
             &quot;sSortingClassJUI&quot;: null,

             /**
  Title of the column - what is seen in the TH element (nTh).
   @type string
 /
             &quot;sTitle&quot;: null,

             /**
  Column sorting and filtering type
   @type string
   @default null
 /
             &quot;sType&quot;: null,

             /**
  Width of the column
   @type string
   @default null
 /
             &quot;sWidth&quot;: null,

             /**
  Width of the column when it was first &quot;encountered&quot;
   @type string
   @default null
 /
             &quot;sWidthOrig&quot;: null
     };

     /*
 Developer note: The properties of the object below are given in Hungarian
 notation, that was used as the interface for DataTables prior to v1.10, however
 from v1.10 onwards the primary interface is camel case. In order to avoid
 breaking backwards compatibility utterly with this change, the Hungarian
 version is still, internally the primary interface, but is is not documented
 - hence the @name tags in each doc comment. This allows a Javascript function
 to create a map from Hungarian notation to camel case (going the other direction
 would require each property to be listed, which would at around 3K to the size
 of DataTables, while this method is about a 0.5K hit.

 Ultimately this does pave the way for Hungarian notation to be dropped
 completely, but that is a massive amount of work and will break current
 installs (therefore is on-hold until v2).
/

     /**
 Initialisation options that can be given to DataTables at initialisation
 time.
  @namespace
/
     DataTable.defaults = {
             /**
  An array of data to use for the table, passed in at initialisation which
  will be used in preference to any data which is already in the DOM. This is
  particularly useful for constructing tables purely in Javascript, for
  example with a custom Ajax call.
   @type array
   @default null

   @dtopt Option
   @name DataTable.defaults.data

   @example
     // Using a 2D array data source
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;data&quot;: [
           [&#39;Trident&#39;, &#39;Internet Explorer 4.0&#39;, &#39;Win 95+&#39;, 4, &#39;X&#39;],
           [&#39;Trident&#39;, &#39;Internet Explorer 5.0&#39;, &#39;Win 95+&#39;, 5, &#39;C&#39;],
         ],
         &quot;columns&quot;: [
           { &quot;title&quot;: &quot;Engine&quot; },
           { &quot;title&quot;: &quot;Browser&quot; },
           { &quot;title&quot;: &quot;Platform&quot; },
           { &quot;title&quot;: &quot;Version&quot; },
           { &quot;title&quot;: &quot;Grade&quot; }
         ]
       } );
     } );

   @example
     // Using an array of objects as a data source (`data`)
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;data&quot;: [
           {
             &quot;engine&quot;:   &quot;Trident&quot;,
             &quot;browser&quot;:  &quot;Internet Explorer 4.0&quot;,
             &quot;platform&quot;: &quot;Win 95+&quot;,
             &quot;version&quot;:  4,
             &quot;grade&quot;:    &quot;X&quot;
           },
           {
             &quot;engine&quot;:   &quot;Trident&quot;,
             &quot;browser&quot;:  &quot;Internet Explorer 5.0&quot;,
             &quot;platform&quot;: &quot;Win 95+&quot;,
             &quot;version&quot;:  5,
             &quot;grade&quot;:    &quot;C&quot;
           }
         ],
         &quot;columns&quot;: [
           { &quot;title&quot;: &quot;Engine&quot;,   &quot;data&quot;: &quot;engine&quot; },
           { &quot;title&quot;: &quot;Browser&quot;,  &quot;data&quot;: &quot;browser&quot; },
           { &quot;title&quot;: &quot;Platform&quot;, &quot;data&quot;: &quot;platform&quot; },
           { &quot;title&quot;: &quot;Version&quot;,  &quot;data&quot;: &quot;version&quot; },
           { &quot;title&quot;: &quot;Grade&quot;,    &quot;data&quot;: &quot;grade&quot; }
         ]
       } );
     } );
 /
             &quot;aaData&quot;: null,

             /**
  If ordering is enabled, then DataTables will perform a first pass sort on
  initialisation. You can define which column(s) the sort is performed
  upon, and the sorting direction, with this variable. The `sorting` array
  should contain an array for each column to be sorted initially containing
  the column&#39;s index and a direction string (&#39;asc&#39; or &#39;desc&#39;).
   @type array
   @default [[0,&#39;asc&#39;]]

   @dtopt Option
   @name DataTable.defaults.order

   @example
     // Sort by 3rd column first, and then 4th column
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;order&quot;: [[2,&#39;asc&#39;], [3,&#39;desc&#39;]]
       } );
     } );

     // No initial sorting
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;order&quot;: []
       } );
     } );
 /
             &quot;aaSorting&quot;: [[0,&#39;asc&#39;]],

             /**
  This parameter is basically identical to the `sorting` parameter, but
  cannot be overridden by user interaction with the table. What this means
  is that you could have a column (visible or hidden) which the sorting
  will always be forced on first - any sorting after that (from the user)
  will then be performed as required. This can be useful for grouping rows
  together.
   @type array
   @default null

   @dtopt Option
   @name DataTable.defaults.orderFixed

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;orderFixed&quot;: [[0,&#39;asc&#39;]]
       } );
     } )
 /
             &quot;aaSortingFixed&quot;: [],

             /**
  DataTables can be instructed to load data to display in the table from a
  Ajax source. This option defines how that Ajax call is made and where to.

  The `ajax` property has three different modes of operation, depending on
  how it is defined. These are:

    `string` - Set the URL from where the data should be loaded from.
    `object` - Define properties for `jQuery.ajax`.
    `function` - Custom data get function

  `string`
  --------

  As a string, the `ajax` property simply defines the URL from which
  DataTables will load data.

  `object`
  --------

  As an object, the parameters in the object are passed to
  [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
  of the Ajax request. DataTables has a number of default parameters which
  you can override using this option. Please refer to the jQuery
  documentation for a full description of the options available, although
  the following parameters provide additional options in DataTables or
  require special consideration:

    `data` - As with jQuery, `data` can be provided as an object, but it
    can also be used as a function to manipulate the data DataTables sends
    to the server. The function takes a single parameter, an object of
    parameters with the values that DataTables has readied for sending. An
    object may be returned which will be merged into the DataTables
    defaults, or you can add the items to the object that was passed in and
    not return anything from the function. This supersedes `fnServerParams`
    from DataTables 1.9-.

    `dataSrc` - By default DataTables will look for the property `data` (or
    `aaData` for compatibility with DataTables 1.9-) when obtaining data
    from an Ajax source or for server-side processing - this parameter
    allows that property to be changed. You can use Javascript dotted
    object notation to get a data source for multiple levels of nesting, or
    it my be used as a function. As a function it takes a single parameter,
    the JSON returned from the server, which can be manipulated as
    required, with the returned value being that used by DataTables as the
    data source for the table. This supersedes `sAjaxDataProp` from
    DataTables 1.9-.

    `success` - Should not be overridden it is used internally in
    DataTables. To manipulate / transform the data returned by the server
    use `ajax.dataSrc`, or use `ajax` as a function (see below).

  `function`
  ----------

  As a function, making the Ajax call is left up to yourself allowing
  complete control of the Ajax request. Indeed, if desired, a method other
  than Ajax could be used to obtain the required data, such as Web storage
  or an AIR database.

  The function is given four parameters and no return is required. The
  parameters are:

  1. _object_ - Data to send to the server
  2. _function_ - Callback function that must be executed when the required
     data has been obtained. That data should be passed into the callback
     as the only parameter
  3. _object_ - DataTables settings object for the table

  Note that this supersedes `fnServerData` from DataTables 1.9-.

   @type string|object|function
   @default null

   @dtopt Option
   @name DataTable.defaults.ajax
   @since 1.10.0

  @example
    // Get JSON data from a file via Ajax.
    // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
    $(&#39;#example&#39;).dataTable( {
      &quot;ajax&quot;: &quot;data.json&quot;
    } );

  @example
    // Get JSON data from a file via Ajax, using `dataSrc` to change
    // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
    $(&#39;#example&#39;).dataTable( {
      &quot;ajax&quot;: {
        &quot;url&quot;: &quot;data.json&quot;,
        &quot;dataSrc&quot;: &quot;tableData&quot;
      }
    } );

  @example
    // Get JSON data from a file via Ajax, using `dataSrc` to read data
    // from a plain array rather than an array in an object
    $(&#39;#example&#39;).dataTable( {
      &quot;ajax&quot;: {
        &quot;url&quot;: &quot;data.json&quot;,
        &quot;dataSrc&quot;: &quot;&quot;
      }
    } );

  @example
    // Manipulate the data returned from the server - add a link to data
    // (note this can, should, be done using `render` for the column - this
    // is just a simple example of how the data can be manipulated).
    $(&#39;#example&#39;).dataTable( {
      &quot;ajax&quot;: {
        &quot;url&quot;: &quot;data.json&quot;,
        &quot;dataSrc&quot;: function ( json ) {
          for ( var i=0, ien=json.length ; i&lt;ien ; i++ ) {
            json[i][0] = &#39;&lt;a href=&quot;/message/&#39;+json[i][0]+&#39;&gt;View message&lt;/a&gt;&#39;;
          }
          return json;
        }
      }
    } );

  @example
    // Add data to the request
    $(&#39;#example&#39;).dataTable( {
      &quot;ajax&quot;: {
        &quot;url&quot;: &quot;data.json&quot;,
        &quot;data&quot;: function ( d ) {
          return {
            &quot;extra_search&quot;: $(&#39;#extra&#39;).val()
          };
        }
      }
    } );

  @example
    // Send request as POST
    $(&#39;#example&#39;).dataTable( {
      &quot;ajax&quot;: {
        &quot;url&quot;: &quot;data.json&quot;,
        &quot;type&quot;: &quot;POST&quot;
      }
    } );

  @example
    // Get the data from localStorage (could interface with a form for
    // adding, editing and removing rows).
    $(&#39;#example&#39;).dataTable( {
      &quot;ajax&quot;: function (data, callback, settings) {
        callback(
          JSON.parse( localStorage.getItem(&#39;dataTablesData&#39;) )
        );
      }
    } );
 /
             &quot;ajax&quot;: null,

             /**
  This parameter allows you to readily specify the entries in the length drop
  down menu that DataTables shows when pagination is enabled. It can be
  either a 1D array of options which will be used for both the displayed
  option and the value, or a 2D array which will use the array in the first
  position as the value, and the array in the second position as the
  displayed options (useful for language strings such as &#39;All&#39;).

  Note that the `pageLength` property will be automatically set to the
  first value given in this array, unless `pageLength` is also provided.
   @type array
   @default [ 10, 25, 50, 100 ]

   @dtopt Option
   @name DataTable.defaults.lengthMenu

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;lengthMenu&quot;: [[10, 25, 50, -1], [10, 25, 50, &quot;All&quot;]]
       } );
     } );
 /
             &quot;aLengthMenu&quot;: [ 10, 25, 50, 100 ],

             /**
  The `columns` option in the initialisation parameter allows you to define
  details about the way individual columns behave. For a full list of
  column options that can be set, please see
  {@link DataTable.defaults.column}. Note that if you use `columns` to
  define your columns, you must have an entry in the array for every single
  column that you have in your table (these can be null if you don&#39;t which
  to specify any options).
   @member

   @name DataTable.defaults.column
 /
             &quot;aoColumns&quot;: null,

             /**
  Very similar to `columns`, `columnDefs` allows you to target a specific
  column, multiple columns, or all columns, using the `targets` property of
  each object in the array. This allows great flexibility when creating
  tables, as the `columnDefs` arrays can be of any length, targeting the
  columns you specifically want. `columnDefs` may use any of the column
  options available: {@link DataTable.defaults.column}, but it _must_
  have `targets` defined in each object in the array. Values in the `targets`
  array may be:
    &lt;ul&gt;
      &lt;li&gt;a string - class name will be matched on the TH for the column&lt;/li&gt;
      &lt;li&gt;0 or a positive integer - column index counting from the left&lt;/li&gt;
      &lt;li&gt;a negative integer - column index counting from the right&lt;/li&gt;
      &lt;li&gt;the string &quot;_all&quot; - all columns (i.e. assign a default)&lt;/li&gt;
    &lt;/ul&gt;
   @member

   @name DataTable.defaults.columnDefs
 /
             &quot;aoColumnDefs&quot;: null,

             /**
  Basically the same as `search`, this parameter defines the individual column
  filtering state at initialisation time. The array must be of the same size
  as the number of columns, and each element be an object with the parameters
  `search` and `escapeRegex` (the latter is optional). &#39;null&#39; is also
  accepted and the default will be used.
   @type array
   @default []

   @dtopt Option
   @name DataTable.defaults.searchCols

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;searchCols&quot;: [
           null,
           { &quot;search&quot;: &quot;My filter&quot; },
           null,
           { &quot;search&quot;: &quot;^[0-9]&quot;, &quot;escapeRegex&quot;: false }
         ]
       } );
     } )
 /
             &quot;aoSearchCols&quot;: [],

             /**
  An array of CSS classes that should be applied to displayed rows. This
  array may be of any length, and DataTables will apply each class
  sequentially, looping when required.
   @type array
   @default null &lt;i&gt;Will take the values determined by the `oClasses.stripe*`
     options&lt;/i&gt;

   @dtopt Option
   @name DataTable.defaults.stripeClasses

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;stripeClasses&quot;: [ &#39;strip1&#39;, &#39;strip2&#39;, &#39;strip3&#39; ]
       } );
     } )
 /
             &quot;asStripeClasses&quot;: null,

             /**
  Enable or disable automatic column width calculation. This can be disabled
  as an optimisation (it takes some time to calculate the widths) if the
  tables widths are passed in using `columns`.
   @type boolean
   @default true

   @dtopt Features
   @name DataTable.defaults.autoWidth

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;autoWidth&quot;: false
       } );
     } );
 /
             &quot;bAutoWidth&quot;: true,

             /**
  Deferred rendering can provide DataTables with a huge speed boost when you
  are using an Ajax or JS data source for the table. This option, when set to
  true, will cause DataTables to defer the creation of the table elements for
  each row until they are needed for a draw - saving a significant amount of
  time.
   @type boolean
   @default false

   @dtopt Features
   @name DataTable.defaults.deferRender

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;ajax&quot;: &quot;sources/arrays.txt&quot;,
         &quot;deferRender&quot;: true
       } );
     } );
 /
             &quot;bDeferRender&quot;: false,

             /**
  Replace a DataTable which matches the given selector and replace it with
  one which has the properties of the new initialisation object passed. If no
  table matches the selector, then the new DataTable will be constructed as
  per normal.
   @type boolean
   @default false

   @dtopt Options
   @name DataTable.defaults.destroy

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;srollY&quot;: &quot;200px&quot;,
         &quot;paginate&quot;: false
       } );

       // Some time later....
       $(&#39;#example&#39;).dataTable( {
         &quot;filter&quot;: false,
         &quot;destroy&quot;: true
       } );
     } );
 /
             &quot;bDestroy&quot;: false,

             /**
  Enable or disable filtering of data. Filtering in DataTables is &quot;smart&quot; in
  that it allows the end user to input multiple words (space separated) and
  will match a row containing those words, even if not in the order that was
  specified (this allow matching across multiple columns). Note that if you
  wish to use filtering in DataTables this must remain &#39;true&#39; - to remove the
  default filtering input box and retain filtering abilities, please use
  {@link DataTable.defaults.dom}.
   @type boolean
   @default true

   @dtopt Features
   @name DataTable.defaults.searching

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;searching&quot;: false
       } );
     } );
 /
             &quot;bFilter&quot;: true,

             /**
  Enable or disable the table information display. This shows information
  about the data that is currently visible on the page, including information
  about filtered data if that action is being performed.
   @type boolean
   @default true

   @dtopt Features
   @name DataTable.defaults.info

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;info&quot;: false
       } );
     } );
 /
             &quot;bInfo&quot;: true,

             /**
  Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
  slightly different and additional mark-up from what DataTables has
  traditionally used).
   @type boolean
   @default false

   @dtopt Features
   @name DataTable.defaults.jQueryUI

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;jQueryUI&quot;: true
       } );
     } );
 /
             &quot;bJQueryUI&quot;: false,

             /**
  Allows the end user to select the size of a formatted page from a select
  menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
   @type boolean
   @default true

   @dtopt Features
   @name DataTable.defaults.lengthChange

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;lengthChange&quot;: false
       } );
     } );
 /
             &quot;bLengthChange&quot;: true,

             /**
  Enable or disable pagination.
   @type boolean
   @default true

   @dtopt Features
   @name DataTable.defaults.paging

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;paging&quot;: false
       } );
     } );
 /
             &quot;bPaginate&quot;: true,

             /**
  Enable or disable the display of a &#39;processing&#39; indicator when the table is
  being processed (e.g. a sort). This is particularly useful for tables with
  large amounts of data where it can take a noticeable amount of time to sort
  the entries.
   @type boolean
   @default false

   @dtopt Features
   @name DataTable.defaults.processing

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;processing&quot;: true
       } );
     } );
 /
             &quot;bProcessing&quot;: false,

             /**
  Retrieve the DataTables object for the given selector. Note that if the
  table has already been initialised, this parameter will cause DataTables
  to simply return the object that has already been set up - it will not take
  account of any changes you might have made to the initialisation object
  passed to DataTables (setting this parameter to true is an acknowledgement
  that you understand this). `destroy` can be used to reinitialise a table if
  you need.
   @type boolean
   @default false

   @dtopt Options
   @name DataTable.defaults.retrieve

   @example
     $(document).ready( function() {
       initTable();
       tableActions();
     } );

     function initTable ()
     {
       return $(&#39;#example&#39;).dataTable( {
         &quot;scrollY&quot;: &quot;200px&quot;,
         &quot;paginate&quot;: false,
         &quot;retrieve&quot;: true
       } );
     }

     function tableActions ()
     {
       var table = initTable();
       // perform API operations with oTable
     }
 /
             &quot;bRetrieve&quot;: false,

             /**
  When vertical (y) scrolling is enabled, DataTables will force the height of
  the table&#39;s viewport to the given height at all times (useful for layout).
  However, this can look odd when filtering data down to a small data set,
  and the footer is left &quot;floating&quot; further down. This parameter (when
  enabled) will cause DataTables to collapse the table&#39;s viewport down when
  the result set will fit within the given Y height.
   @type boolean
   @default false

   @dtopt Options
   @name DataTable.defaults.scrollCollapse

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;scrollY&quot;: &quot;200&quot;,
         &quot;scrollCollapse&quot;: true
       } );
     } );
 /
             &quot;bScrollCollapse&quot;: false,

             /**
  Configure DataTables to use server-side processing. Note that the
  `ajax` parameter must also be given in order to give DataTables a
  source to obtain the required data for each draw.
   @type boolean
   @default false

   @dtopt Features
   @dtopt Server-side
   @name DataTable.defaults.serverSide

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;serverSide&quot;: true,
         &quot;ajax&quot;: &quot;xhr.php&quot;
       } );
     } );
 /
             &quot;bServerSide&quot;: false,

             /**
  Enable or disable sorting of columns. Sorting of individual columns can be
  disabled by the `sortable` option for each column.
   @type boolean
   @default true

   @dtopt Features
   @name DataTable.defaults.ordering

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;ordering&quot;: false
       } );
     } );
 /
             &quot;bSort&quot;: true,

             /**
  Enable or display DataTables&#39; ability to sort multiple columns at the
  same time (activated by shift-click by the user).
   @type boolean
   @default true

   @dtopt Options
   @name DataTable.defaults.orderMulti

   @example
     // Disable multiple column sorting ability
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;orderMulti&quot;: false
       } );
     } );
 /
             &quot;bSortMulti&quot;: true,

             /**
  Allows control over whether DataTables should use the top (true) unique
  cell that is found for a single column, or the bottom (false - default).
  This is useful when using complex headers.
   @type boolean
   @default false

   @dtopt Options
   @name DataTable.defaults.orderCellsTop

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;orderCellsTop&quot;: true
       } );
     } );
 /
             &quot;bSortCellsTop&quot;: false,

             /**
  Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
  `sorting\_3` to the columns which are currently being sorted on. This is
  presented as a feature switch as it can increase processing time (while
  classes are removed and added) so for large data sets you might want to
  turn this off.
   @type boolean
   @default true

   @dtopt Features
   @name DataTable.defaults.orderClasses

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;orderClasses&quot;: false
       } );
     } );
 /
             &quot;bSortClasses&quot;: true,

             /**
  Enable or disable state saving. When enabled HTML5 `localStorage` will be
  used to save table display information such as pagination information,
  display length, filtering and sorting. As such when the end user reloads
  the page the display display will match what thy had previously set up.

  Due to the use of `localStorage` the default state saving is not supported
  in IE6 or 7. If state saving is required in those browsers, use
  `stateSaveCallback` to provide a storage solution such as cookies.
   @type boolean
   @default false

   @dtopt Features
   @name DataTable.defaults.stateSave

   @example
     $(document).ready( function () {
       $(&#39;#example&#39;).dataTable( {
         &quot;stateSave&quot;: true
       } );
     } );
 /
             &quot;bStateSave&quot;: false,

             /**
  This function is called when a TR element is created (and all TD child
  elements have been inserted), or registered if using a DOM source, allowing
  manipulation of the TR element (adding classes etc).
   @type function
   @param {node} row &quot;TR&quot; element for the current row
   @param {array} data Raw data array for this row
   @param {int} dataIndex The index of this row in the internal aoData array

   @dtopt Callbacks
   @name DataTable.defaults.createdRow

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;createdRow&quot;: function( row, data, dataIndex ) {
           // Bold the grade for all &#39;A&#39; grade browsers
           if ( data[4] == &quot;A&quot; )
           {
             $(&#39;td:eq(4)&#39;, row).html( &#39;&lt;b&gt;A&lt;/b&gt;&#39; );
           }
         }
       } );
     } );
 /
             &quot;fnCreatedRow&quot;: null,

             /**
  This function is called on every &#39;draw&#39; event, and allows you to
  dynamically modify any aspect you want about the created DOM.
   @type function
   @param {object} settings DataTables settings object

   @dtopt Callbacks
   @name DataTable.defaults.drawCallback

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;drawCallback&quot;: function( settings ) {
           alert( &#39;DataTables has redrawn the table&#39; );
         }
       } );
     } );
 /
             &quot;fnDrawCallback&quot;: null,

             /**
  Identical to fnHeaderCallback() but for the table footer this function
  allows you to modify the table footer on every &#39;draw&#39; event.
   @type function
   @param {node} foot &quot;TR&quot; element for the footer
   @param {array} data Full table data (as derived from the original HTML)
   @param {int} start Index for the current display starting point in the
     display array
   @param {int} end Index for the current display ending point in the
     display array
   @param {array int} display Index array to translate the visual position
     to the full data array

   @dtopt Callbacks
   @name DataTable.defaults.footerCallback

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;footerCallback&quot;: function( tfoot, data, start, end, display ) {
           tfoot.getElementsByTagName(&#39;th&#39;)[0].innerHTML = &quot;Starting index is &quot;+start;
         }
       } );
     } )
 /
             &quot;fnFooterCallback&quot;: null,

             /**
  When rendering large numbers in the information element for the table
  (i.e. &quot;Showing 1 to 10 of 57 entries&quot;) DataTables will render large numbers
  to have a comma separator for the &#39;thousands&#39; units (e.g. 1 million is
  rendered as &quot;1,000,000&quot;) to help readability for the end user. This
  function will override the default method DataTables uses.
   @type function
   @member
   @param {int} toFormat number to be formatted
   @returns {string} formatted string for DataTables to show the number

   @dtopt Callbacks
   @name DataTable.defaults.formatNumber

   @example
     // Format a number using a single quote for the separator (note that
     // this can also be done with the language.thousands option)
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;formatNumber&quot;: function ( toFormat ) {
           return toFormat.toString().replace(
             /\B(?=(\d{3})+(?!\d))/g, &quot;&#39;&quot;
           );
         };
       } );
     } );
 /
             &quot;fnFormatNumber&quot;: function ( toFormat ) {
                     return toFormat.toString().replace(
                             /\B(?=(\d{3})+(?!\d))/g,
                             this.oLanguage.sThousands
                     );
             },

             /**
  This function is called on every &#39;draw&#39; event, and allows you to
  dynamically modify the header row. This can be used to calculate and
  display useful information about the table.
   @type function
   @param {node} head &quot;TR&quot; element for the header
   @param {array} data Full table data (as derived from the original HTML)
   @param {int} start Index for the current display starting point in the
     display array
   @param {int} end Index for the current display ending point in the
     display array
   @param {array int} display Index array to translate the visual position
     to the full data array

   @dtopt Callbacks
   @name DataTable.defaults.headerCallback

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;fheaderCallback&quot;: function( head, data, start, end, display ) {
           head.getElementsByTagName(&#39;th&#39;)[0].innerHTML = &quot;Displaying &quot;+(end-start)+&quot; records&quot;;
         }
       } );
     } )
 /
             &quot;fnHeaderCallback&quot;: null,

             /**
  The information element can be used to convey information about the current
  state of the table. Although the internationalisation options presented by
  DataTables are quite capable of dealing with most customisations, there may
  be times where you wish to customise the string further. This callback
  allows you to do exactly that.
   @type function
   @param {object} oSettings DataTables settings object
   @param {int} start Starting position in data for the draw
   @param {int} end End position in data for the draw
   @param {int} max Total number of rows in the table (regardless of
     filtering)
   @param {int} total Total number of rows in the data set, after filtering
   @param {string} pre The string that DataTables has formatted using it&#39;s
     own rules
   @returns {string} The string to be displayed in the information element.

   @dtopt Callbacks
   @name DataTable.defaults.infoCallback

   @example
     $(&#39;#example&#39;).dataTable( {
       &quot;infoCallback&quot;: function( settings, start, end, max, total, pre ) {
         return start +&quot; to &quot;+ end;
       }
     } );
 /
             &quot;fnInfoCallback&quot;: null,

             /**
  Called when the table has been initialised. Normally DataTables will
  initialise sequentially and there will be no need for this function,
  however, this does not hold true when using external language information
  since that is obtained using an async XHR call.
   @type function
   @param {object} settings DataTables settings object
   @param {object} json The JSON object request from the server - only
     present if client-side Ajax sourced data is used

   @dtopt Callbacks
   @name DataTable.defaults.initComplete

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;initComplete&quot;: function(settings, json) {
           alert( &#39;DataTables has finished its initialisation.&#39; );
         }
       } );
     } )
 /
             &quot;fnInitComplete&quot;: null,

             /**
  Called at the very start of each table draw and can be used to cancel the
  draw by returning false, any other return (including undefined) results in
  the full draw occurring).
   @type function
   @param {object} settings DataTables settings object
   @returns {boolean} False will cancel the draw, anything else (including no
     return) will allow it to complete.

   @dtopt Callbacks
   @name DataTable.defaults.preDrawCallback

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;preDrawCallback&quot;: function( settings ) {
           if ( $(&#39;#test&#39;).val() == 1 ) {
             return false;
           }
         }
       } );
     } );
 /
             &quot;fnPreDrawCallback&quot;: null,

             /**
  This function allows you to &#39;post process&#39; each row after it have been
  generated for each table draw, but before it is rendered on screen. This
  function might be used for setting the row class name etc.
   @type function
   @param {node} row &quot;TR&quot; element for the current row
   @param {array} data Raw data array for this row
   @param {int} displayIndex The display index for the current table draw
   @param {int} displayIndexFull The index of the data in the full list of
     rows (after filtering)

   @dtopt Callbacks
   @name DataTable.defaults.rowCallback

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;rowCallback&quot;: function( row, data, displayIndex, displayIndexFull ) {
           // Bold the grade for all &#39;A&#39; grade browsers
           if ( data[4] == &quot;A&quot; ) {
             $(&#39;td:eq(4)&#39;, row).html( &#39;&lt;b&gt;A&lt;/b&gt;&#39; );
           }
         }
       } );
     } );
 /
             &quot;fnRowCallback&quot;: null,

             /**
  __Deprecated__ The functionality provided by this parameter has now been
  superseded by that provided through `ajax`, which should be used instead.

  This parameter allows you to override the default function which obtains
  the data from the server so something more suitable for your application.
  For example you could use POST data, or pull information from a Gears or
  AIR database.
   @type function
   @member
   @param {string} source HTTP source to obtain the data from (`ajax`)
   @param {array} data A key/value pair object containing the data to send
     to the server
   @param {function} callback to be called on completion of the data get
     process that will draw the data on the page.
   @param {object} settings DataTables settings object

   @dtopt Callbacks
   @dtopt Server-side
   @name DataTable.defaults.serverData

   @deprecated 1.10. Please use `ajax` for this functionality now.
 /
             &quot;fnServerData&quot;: null,

             /**
  __Deprecated__ The functionality provided by this parameter has now been
  superseded by that provided through `ajax`, which should be used instead.

   It is often useful to send extra data to the server when making an Ajax
  request - for example custom filtering information, and this callback
  function makes it trivial to send extra information to the server. The
  passed in parameter is the data set that has been constructed by
  DataTables, and you can add to this or modify it as you require.
   @type function
   @param {array} data Data array (array of objects which are name/value
     pairs) that has been constructed by DataTables and will be sent to the
     server. In the case of Ajax sourced data with server-side processing
     this will be an empty array, for server-side processing there will be a
     significant number of parameters!
   @returns {undefined} Ensure that you modify the data array passed in,
     as this is passed by reference.

   @dtopt Callbacks
   @dtopt Server-side
   @name DataTable.defaults.serverParams

   @deprecated 1.10. Please use `ajax` for this functionality now.
 /
             &quot;fnServerParams&quot;: null,

             /**
  Load the table state. With this function you can define from where, and how, the
  state of a table is loaded. By default DataTables will load from `localStorage`
  but you might wish to use a server-side database or cookies.
   @type function
   @member
   @param {object} settings DataTables settings object
   @return {object} The DataTables state object to be loaded

   @dtopt Callbacks
   @name DataTable.defaults.stateLoadCallback

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;stateSave&quot;: true,
         &quot;stateLoadCallback&quot;: function (settings) {
           var o;

           // Send an Ajax request to the server to get the data. Note that
           // this is a synchronous request.
           $.ajax( {
             &quot;url&quot;: &quot;/state_load&quot;,
             &quot;async&quot;: false,
             &quot;dataType&quot;: &quot;json&quot;,
             &quot;success&quot;: function (json) {
               o = json;
             }
           } );

           return o;
         }
       } );
     } );
 /
             &quot;fnStateLoadCallback&quot;: function ( settings ) {
                     try {
                             return JSON.parse(
                                     (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
                                             &#39;DataTables_&#39;+settings.sInstance+&#39;_&#39;+location.pathname
                                     )
                             );
                     } catch (e) {}
             },

             /**
  Callback which allows modification of the saved state prior to loading that state.
  This callback is called when the table is loading state from the stored data, but
  prior to the settings object being modified by the saved state. Note that for
  plug-in authors, you should use the `stateLoadParams` event to load parameters for
  a plug-in.
   @type function
   @param {object} settings DataTables settings object
   @param {object} data The state object that is to be loaded

   @dtopt Callbacks
   @name DataTable.defaults.stateLoadParams

   @example
     // Remove a saved filter, so filtering is never loaded
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;stateSave&quot;: true,
         &quot;stateLoadParams&quot;: function (settings, data) {
           data.oSearch.sSearch = &quot;&quot;;
         }
       } );
     } );

   @example
     // Disallow state loading by returning false
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;stateSave&quot;: true,
         &quot;stateLoadParams&quot;: function (settings, data) {
           return false;
         }
       } );
     } );
 /
             &quot;fnStateLoadParams&quot;: null,

             /**
  Callback that is called when the state has been loaded from the state saving method
  and the DataTables settings object has been modified as a result of the loaded state.
   @type function
   @param {object} settings DataTables settings object
   @param {object} data The state object that was loaded

   @dtopt Callbacks
   @name DataTable.defaults.stateLoaded

   @example
     // Show an alert with the filtering value that was saved
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;stateSave&quot;: true,
         &quot;stateLoaded&quot;: function (settings, data) {
           alert( &#39;Saved filter was: &#39;+data.oSearch.sSearch );
         }
       } );
     } );
 /
             &quot;fnStateLoaded&quot;: null,

             /**
  Save the table state. This function allows you to define where and how the state
  information for the table is stored By default DataTables will use `localStorage`
  but you might wish to use a server-side database or cookies.
   @type function
   @member
   @param {object} settings DataTables settings object
   @param {object} data The state object to be saved

   @dtopt Callbacks
   @name DataTable.defaults.stateSaveCallback

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;stateSave&quot;: true,
         &quot;stateSaveCallback&quot;: function (settings, data) {
           // Send an Ajax request to the server with the state object
           $.ajax( {
             &quot;url&quot;: &quot;/state_save&quot;,
             &quot;data&quot;: data,
             &quot;dataType&quot;: &quot;json&quot;,
             &quot;method&quot;: &quot;POST&quot;
             &quot;success&quot;: function () {}
           } );
         }
       } );
     } );
 /
             &quot;fnStateSaveCallback&quot;: function ( settings, data ) {
                     try {
                             (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
                                     &#39;DataTables_&#39;+settings.sInstance+&#39;_&#39;+location.pathname,
                                     JSON.stringify( data )
                             );
                     } catch (e) {}
             },

             /**
  Callback which allows modification of the state to be saved. Called when the table
  has changed state a new state save is required. This method allows modification of
  the state saving object prior to actually doing the save, including addition or
  other state properties or modification. Note that for plug-in authors, you should
  use the `stateSaveParams` event to save parameters for a plug-in.
   @type function
   @param {object} settings DataTables settings object
   @param {object} data The state object to be saved

   @dtopt Callbacks
   @name DataTable.defaults.stateSaveParams

   @example
     // Remove a saved filter, so filtering is never saved
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;stateSave&quot;: true,
         &quot;stateSaveParams&quot;: function (settings, data) {
           data.oSearch.sSearch = &quot;&quot;;
         }
       } );
     } );
 /
             &quot;fnStateSaveParams&quot;: null,

             /**
  Duration for which the saved state information is considered valid. After this period
  has elapsed the state will be returned to the default.
  Value is given in seconds.
   @type int
   @default 7200 &lt;i&gt;(2 hours)&lt;/i&gt;

   @dtopt Options
   @name DataTable.defaults.stateDuration

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;stateDuration&quot;: 60*60*24; // 1 day
       } );
     } )
 /
             &quot;iStateDuration&quot;: 7200,

             /**
  When enabled DataTables will not make a request to the server for the first
  page draw - rather it will use the data already on the page (no sorting etc
  will be applied to it), thus saving on an XHR at load time. `deferLoading`
  is used to indicate that deferred loading is required, but it is also used
  to tell DataTables how many records there are in the full table (allowing
  the information element and pagination to be displayed correctly). In the case
  where a filtering is applied to the table on initial load, this can be
  indicated by giving the parameter as an array, where the first element is
  the number of records available after filtering and the second element is the
  number of records without filtering (allowing the table information element
  to be shown correctly).
   @type int | array
   @default null

   @dtopt Options
   @name DataTable.defaults.deferLoading

   @example
     // 57 records available in the table, no filtering applied
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;serverSide&quot;: true,
         &quot;ajax&quot;: &quot;scripts/server_processing.php&quot;,
         &quot;deferLoading&quot;: 57
       } );
     } );

   @example
     // 57 records after filtering, 100 without filtering (an initial filter applied)
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;serverSide&quot;: true,
         &quot;ajax&quot;: &quot;scripts/server_processing.php&quot;,
         &quot;deferLoading&quot;: [ 57, 100 ],
         &quot;search&quot;: {
           &quot;search&quot;: &quot;my_filter&quot;
         }
       } );
     } );
 /
             &quot;iDeferLoading&quot;: null,

             /**
  Number of rows to display on a single page when using pagination. If
  feature enabled (`lengthChange`) then the end user will be able to override
  this to a custom setting using a pop-up menu.
   @type int
   @default 10

   @dtopt Options
   @name DataTable.defaults.pageLength

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;pageLength&quot;: 50
       } );
     } )
 /
             &quot;iDisplayLength&quot;: 10,

             /**
  Define the starting point for data display when using DataTables with
  pagination. Note that this parameter is the number of records, rather than
  the page number, so if you have 10 records per page and want to start on
  the third page, it should be &quot;20&quot;.
   @type int
   @default 0

   @dtopt Options
   @name DataTable.defaults.displayStart

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;displayStart&quot;: 20
       } );
     } )
 /
             &quot;iDisplayStart&quot;: 0,

             /**
  By default DataTables allows keyboard navigation of the table (sorting, paging,
  and filtering) by adding a `tabindex` attribute to the required elements. This
  allows you to tab through the controls and press the enter key to activate them.
  The tabindex is default 0, meaning that the tab follows the flow of the document.
  You can overrule this using this parameter if you wish. Use a value of -1 to
  disable built-in keyboard navigation.
   @type int
   @default 0

   @dtopt Options
   @name DataTable.defaults.tabIndex

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;tabIndex&quot;: 1
       } );
     } );
 /
             &quot;iTabIndex&quot;: 0,

             /**
  Classes that DataTables assigns to the various components and features
  that it adds to the HTML table. This allows classes to be configured
  during initialisation in addition to through the static
  {@link DataTable.ext.oStdClasses} object).
   @namespace
   @name DataTable.defaults.classes
 /
             &quot;oClasses&quot;: {},

             /**
  All strings that DataTables uses in the user interface that it creates
  are defined in this object, allowing you to modified them individually or
  completely replace them all as required.
   @namespace
   @name DataTable.defaults.language
 /
             &quot;oLanguage&quot;: {
                     /**
   Strings that are used for WAI-ARIA labels and controls only (these are not
   actually visible on the page, but will be read by screenreaders, and thus
   must be internationalised as well).
    @namespace
    @name DataTable.defaults.language.aria
  /
                     &quot;oAria&quot;: {
                             /**
    ARIA label that is added to the table headers when the column may be
    sorted ascending by activing the column (click or return when focused).
    Note that the column header is prefixed to this string.
     @type string
     @default : activate to sort column ascending

     @dtopt Language
     @name DataTable.defaults.language.aria.sortAscending

     @example
       $(document).ready( function() {
         $(&#39;#example&#39;).dataTable( {
           &quot;language&quot;: {
             &quot;aria&quot;: {
               &quot;sortAscending&quot;: &quot; - click/return to sort ascending&quot;
             }
           }
         } );
       } );
   /
                             &quot;sSortAscending&quot;: &quot;: activate to sort column ascending&quot;,

                             /**
    ARIA label that is added to the table headers when the column may be
    sorted descending by activing the column (click or return when focused).
    Note that the column header is prefixed to this string.
     @type string
     @default : activate to sort column ascending

     @dtopt Language
     @name DataTable.defaults.language.aria.sortDescending

     @example
       $(document).ready( function() {
         $(&#39;#example&#39;).dataTable( {
           &quot;language&quot;: {
             &quot;aria&quot;: {
               &quot;sortDescending&quot;: &quot; - click/return to sort descending&quot;
             }
           }
         } );
       } );
   /
                             &quot;sSortDescending&quot;: &quot;: activate to sort column descending&quot;
                     },

                     /**
   Pagination string used by DataTables for the built-in pagination
   control types.
    @namespace
    @name DataTable.defaults.language.paginate
  /
                     &quot;oPaginate&quot;: {
                             /**
    Text to use when using the &#39;full_numbers&#39; type of pagination for the
    button to take the user to the first page.
     @type string
     @default First

     @dtopt Language
     @name DataTable.defaults.language.paginate.first

     @example
       $(document).ready( function() {
         $(&#39;#example&#39;).dataTable( {
           &quot;language&quot;: {
             &quot;paginate&quot;: {
               &quot;first&quot;: &quot;First page&quot;
             }
           }
         } );
       } );
   /
                             &quot;sFirst&quot;: &quot;First&quot;,

                             /**
    Text to use when using the &#39;full_numbers&#39; type of pagination for the
    button to take the user to the last page.
     @type string
     @default Last

     @dtopt Language
     @name DataTable.defaults.language.paginate.last

     @example
       $(document).ready( function() {
         $(&#39;#example&#39;).dataTable( {
           &quot;language&quot;: {
             &quot;paginate&quot;: {
               &quot;last&quot;: &quot;Last page&quot;
             }
           }
         } );
       } );
   /
                             &quot;sLast&quot;: &quot;Last&quot;,

                             /**
    Text to use for the &#39;next&#39; pagination button (to take the user to the
    next page).
     @type string
     @default Next

     @dtopt Language
     @name DataTable.defaults.language.paginate.next

     @example
       $(document).ready( function() {
         $(&#39;#example&#39;).dataTable( {
           &quot;language&quot;: {
             &quot;paginate&quot;: {
               &quot;next&quot;: &quot;Next page&quot;
             }
           }
         } );
       } );
   /
                             &quot;sNext&quot;: &quot;Next&quot;,

                             /**
    Text to use for the &#39;previous&#39; pagination button (to take the user to
    the previous page).
     @type string
     @default Previous

     @dtopt Language
     @name DataTable.defaults.language.paginate.previous

     @example
       $(document).ready( function() {
         $(&#39;#example&#39;).dataTable( {
           &quot;language&quot;: {
             &quot;paginate&quot;: {
               &quot;previous&quot;: &quot;Previous page&quot;
             }
           }
         } );
       } );
   /
                             &quot;sPrevious&quot;: &quot;Previous&quot;
                     },

                     /**
   This string is shown in preference to `zeroRecords` when the table is
   empty of data (regardless of filtering). Note that this is an optional
   parameter - if it is not given, the value of `zeroRecords` will be used
   instead (either the default or given value).
    @type string
    @default No data available in table

    @dtopt Language
    @name DataTable.defaults.language.emptyTable

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;emptyTable&quot;: &quot;No data available in table&quot;
          }
        } );
      } );
  /
                     &quot;sEmptyTable&quot;: &quot;No data available in table&quot;,

                     /**
   This string gives information to the end user about the information
   that is current on display on the page. The following tokens can be
   used in the string and will be dynamically replaced as the table
   display updates. This tokens can be placed anywhere in the string, or
   removed as needed by the language requires:

     `\_START\_` - Display index of the first record on the current page
     `\_END\_` - Display index of the last record on the current page
     `\_TOTAL\_` - Number of records in the table after filtering
     `\_MAX\_` - Number of records in the table without filtering
     `\_PAGE\_` - Current page number
     `\_PAGES\_` - Total number of pages of data in the table

    @type string
    @default Showing _START_ to _END_ of _TOTAL_ entries

    @dtopt Language
    @name DataTable.defaults.language.info

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;info&quot;: &quot;Showing page _PAGE_ of _PAGES_&quot;
          }
        } );
      } );
  /
                     &quot;sInfo&quot;: &quot;Showing _START_ to _END_ of _TOTAL_ entries&quot;,

                     /**
   Display information string for when the table is empty. Typically the
   format of this string should match `info`.
    @type string
    @default Showing 0 to 0 of 0 entries

    @dtopt Language
    @name DataTable.defaults.language.infoEmpty

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;infoEmpty&quot;: &quot;No entries to show&quot;
          }
        } );
      } );
  /
                     &quot;sInfoEmpty&quot;: &quot;Showing 0 to 0 of 0 entries&quot;,

                     /**
   When a user filters the information in a table, this string is appended
   to the information (`info`) to give an idea of how strong the filtering
   is. The variable _MAX_ is dynamically updated.
    @type string
    @default (filtered from _MAX_ total entries)

    @dtopt Language
    @name DataTable.defaults.language.infoFiltered

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;infoFiltered&quot;: &quot; - filtering from _MAX_ records&quot;
          }
        } );
      } );
  /
                     &quot;sInfoFiltered&quot;: &quot;(filtered from _MAX_ total entries)&quot;,

                     /**
   If can be useful to append extra information to the info string at times,
   and this variable does exactly that. This information will be appended to
   the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
   being used) at all times.
    @type string
    @default &lt;i&gt;Empty string&lt;/i&gt;

    @dtopt Language
    @name DataTable.defaults.language.infoPostFix

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;infoPostFix&quot;: &quot;All records shown are derived from real information.&quot;
          }
        } );
      } );
  /
                     &quot;sInfoPostFix&quot;: &quot;&quot;,

                     /**
   This decimal place operator is a little different from the other
   language options since DataTables doesn&#39;t output floating point
   numbers, so it won&#39;t ever use this for display of a number. Rather,
   what this parameter does is modify the sort methods of the table so
   that numbers which are in a format which has a character other than
   a period (`.`) as a decimal place will be sorted numerically.

   Note that numbers with different decimal places cannot be shown in
   the same table and still be sortable, the table must be consistent.
   However, multiple different tables on the page can use different
   decimal place characters.
    @type string
    @default 

    @dtopt Language
    @name DataTable.defaults.language.decimal

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;decimal&quot;: &quot;,&quot;
            &quot;thousands&quot;: &quot;.&quot;
          }
        } );
      } );
  /
                     &quot;sDecimal&quot;: &quot;&quot;,

                     /**
   DataTables has a build in number formatter (`formatNumber`) which is
   used to format large numbers that are used in the table information.
   By default a comma is used, but this can be trivially changed to any
   character you wish with this parameter.
    @type string
    @default ,

    @dtopt Language
    @name DataTable.defaults.language.thousands

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;thousands&quot;: &quot;&#39;&quot;
          }
        } );
      } );
  /
                     &quot;sThousands&quot;: &quot;,&quot;,

                     /**
   Detail the action that will be taken when the drop down menu for the
   pagination length option is changed. The &#39;_MENU_&#39; variable is replaced
   with a default select list of 10, 25, 50 and 100, and can be replaced
   with a custom select box if required.
    @type string
    @default Show _MENU_ entries

    @dtopt Language
    @name DataTable.defaults.language.lengthMenu

    @example
      // Language change only
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;lengthMenu&quot;: &quot;Display _MENU_ records&quot;
          }
        } );
      } );

    @example
      // Language and options change
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;lengthMenu&quot;: &#39;Display &lt;select&gt;&#39;+
              &#39;&lt;option value=&quot;10&quot;&gt;10&lt;/option&gt;&#39;+
              &#39;&lt;option value=&quot;20&quot;&gt;20&lt;/option&gt;&#39;+
              &#39;&lt;option value=&quot;30&quot;&gt;30&lt;/option&gt;&#39;+
              &#39;&lt;option value=&quot;40&quot;&gt;40&lt;/option&gt;&#39;+
              &#39;&lt;option value=&quot;50&quot;&gt;50&lt;/option&gt;&#39;+
              &#39;&lt;option value=&quot;-1&quot;&gt;All&lt;/option&gt;&#39;+
              &#39;&lt;/select&gt; records&#39;
          }
        } );
      } );
  /
                     &quot;sLengthMenu&quot;: &quot;Show _MENU_ entries&quot;,

                     /**
   When using Ajax sourced data and during the first draw when DataTables is
   gathering the data, this message is shown in an empty row in the table to
   indicate to the end user the the data is being loaded. Note that this
   parameter is not used when loading data by server-side processing, just
   Ajax sourced data with client-side processing.
    @type string
    @default Loading...

    @dtopt Language
    @name DataTable.defaults.language.loadingRecords

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;loadingRecords&quot;: &quot;Please wait - loading...&quot;
          }
        } );
      } );
  /
                     &quot;sLoadingRecords&quot;: &quot;Loading...&quot;,

                     /**
   Text which is displayed when the table is processing a user action
   (usually a sort command or similar).
    @type string
    @default Processing...

    @dtopt Language
    @name DataTable.defaults.language.processing

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;processing&quot;: &quot;DataTables is currently busy&quot;
          }
        } );
      } );
  /
                     &quot;sProcessing&quot;: &quot;Processing...&quot;,

                     /**
   Details the actions that will be taken when the user types into the
   filtering input text box. The variable &quot;_INPUT_&quot;, if used in the string,
   is replaced with the HTML text box for the filtering input allowing
   control over where it appears in the string. If &quot;_INPUT_&quot; is not given
   then the input box is appended to the string automatically.
    @type string
    @default Search:

    @dtopt Language
    @name DataTable.defaults.language.search

    @example
      // Input text box will be appended at the end automatically
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;search&quot;: &quot;Filter records:&quot;
          }
        } );
      } );

    @example
      // Specify where the filter should appear
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;search&quot;: &quot;Apply filter _INPUT_ to table&quot;
          }
        } );
      } );
  /
                     &quot;sSearch&quot;: &quot;Search:&quot;,

                     /**
   Assign a `placeholder` attribute to the search `input` element
    @type string
    @default 

    @dtopt Language
    @name DataTable.defaults.language.searchPlaceholder
  /
                     &quot;sSearchPlaceholder&quot;: &quot;&quot;,

                     /**
   All of the language information can be stored in a file on the
   server-side, which DataTables will look up if this parameter is passed.
   It must store the URL of the language file, which is in a JSON format,
   and the object has the same properties as the oLanguage object in the
   initialiser object (i.e. the above parameters). Please refer to one of
   the example language files to see how this works in action.
    @type string
    @default &lt;i&gt;Empty string - i.e. disabled&lt;/i&gt;

    @dtopt Language
    @name DataTable.defaults.language.url

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;url&quot;: &quot;http://www.sprymedia.co.uk/dataTables/lang.txt&quot;
          }
        } );
      } );
  /
                     &quot;sUrl&quot;: &quot;&quot;,

                     /**
   Text shown inside the table records when the is no information to be
   displayed after filtering. `emptyTable` is shown when there is simply no
   information in the table at all (regardless of filtering).
    @type string
    @default No matching records found

    @dtopt Language
    @name DataTable.defaults.language.zeroRecords

    @example
      $(document).ready( function() {
        $(&#39;#example&#39;).dataTable( {
          &quot;language&quot;: {
            &quot;zeroRecords&quot;: &quot;No records to display&quot;
          }
        } );
      } );
  /
                     &quot;sZeroRecords&quot;: &quot;No matching records found&quot;
             },

             /**
  This parameter allows you to have define the global filtering state at
  initialisation time. As an object the `search` parameter must be
  defined, but all other parameters are optional. When `regex` is true,
  the search string will be treated as a regular expression, when false
  (default) it will be treated as a straight string. When `smart`
  DataTables will use it&#39;s smart filtering methods (to word match at
  any point in the data), when false this will not be done.
   @namespace
   @extends DataTable.models.oSearch

   @dtopt Options
   @name DataTable.defaults.search

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;search&quot;: {&quot;search&quot;: &quot;Initial search&quot;}
       } );
     } )
 /
             &quot;oSearch&quot;: $.extend( {}, DataTable.models.oSearch ),

             /**
  __Deprecated__ The functionality provided by this parameter has now been
  superseded by that provided through `ajax`, which should be used instead.

  By default DataTables will look for the property `data` (or `aaData` for
  compatibility with DataTables 1.9-) when obtaining data from an Ajax
  source or for server-side processing - this parameter allows that
  property to be changed. You can use Javascript dotted object notation to
  get a data source for multiple levels of nesting.
   @type string
   @default data

   @dtopt Options
   @dtopt Server-side
   @name DataTable.defaults.ajaxDataProp

   @deprecated 1.10. Please use `ajax` for this functionality now.
 /
             &quot;sAjaxDataProp&quot;: &quot;data&quot;,

             /**
  __Deprecated__ The functionality provided by this parameter has now been
  superseded by that provided through `ajax`, which should be used instead.

  You can instruct DataTables to load data from an external
  source using this parameter (use aData if you want to pass data in you
  already have). Simply provide a url a JSON object can be obtained from.
   @type string
   @default null

   @dtopt Options
   @dtopt Server-side
   @name DataTable.defaults.ajaxSource

   @deprecated 1.10. Please use `ajax` for this functionality now.
 /
             &quot;sAjaxSource&quot;: null,

             /**
  This initialisation variable allows you to specify exactly where in the
  DOM you want DataTables to inject the various controls it adds to the page
  (for example you might want the pagination controls at the top of the
  table). DIV elements (with or without a custom class) can also be added to
  aid styling. The follow syntax is used:
    &lt;ul&gt;
      &lt;li&gt;The following options are allowed:
        &lt;ul&gt;
          &lt;li&gt;&#39;l&#39; - Length changing&lt;/li&gt;
          &lt;li&gt;&#39;f&#39; - Filtering input&lt;/li&gt;
          &lt;li&gt;&#39;t&#39; - The table!&lt;/li&gt;
          &lt;li&gt;&#39;i&#39; - Information&lt;/li&gt;
          &lt;li&gt;&#39;p&#39; - Pagination&lt;/li&gt;
          &lt;li&gt;&#39;r&#39; - pRocessing&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;The following constants are allowed:
        &lt;ul&gt;
          &lt;li&gt;&#39;H&#39; - jQueryUI theme &quot;header&quot; classes (&#39;fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix&#39;)&lt;/li&gt;
          &lt;li&gt;&#39;F&#39; - jQueryUI theme &quot;footer&quot; classes (&#39;fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix&#39;)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;The following syntax is expected:
        &lt;ul&gt;
          &lt;li&gt;&#39;&amp;lt;&#39; and &#39;&amp;gt;&#39; - div elements&lt;/li&gt;
          &lt;li&gt;&#39;&amp;lt;&quot;class&quot; and &#39;&amp;gt;&#39; - div with a class&lt;/li&gt;
          &lt;li&gt;&#39;&amp;lt;&quot;#id&quot; and &#39;&amp;gt;&#39; - div with an ID&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Examples:
        &lt;ul&gt;
          &lt;li&gt;&#39;&amp;lt;&quot;wrapper&quot;flipt&amp;gt;&#39;&lt;/li&gt;
          &lt;li&gt;&#39;&amp;lt;lf&amp;lt;t&amp;gt;ip&amp;gt;&#39;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
   @type string
   @default lfrtip &lt;i&gt;(when `jQueryUI` is false)&lt;/i&gt; &lt;b&gt;or&lt;/b&gt;
     &lt;&quot;H&quot;lfr&gt;t&lt;&quot;F&quot;ip&gt; &lt;i&gt;(when `jQueryUI` is true)&lt;/i&gt;

   @dtopt Options
   @name DataTable.defaults.dom

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;dom&quot;: &#39;&amp;lt;&quot;top&quot;i&amp;gt;rt&amp;lt;&quot;bottom&quot;flp&amp;gt;&amp;lt;&quot;clear&quot;&amp;gt;&#39;
       } );
     } );
 /
             &quot;sDom&quot;: &quot;lfrtip&quot;,

             /**
  Search delay option. This will throttle full table searches that use the
  DataTables provided search input element (it does not effect calls to
  `dt-api search()`, providing a delay before the search is made.
   @type integer
   @default 0

   @dtopt Options
   @name DataTable.defaults.searchDelay

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;searchDelay&quot;: 200
       } );
     } )
 /
             &quot;searchDelay&quot;: null,

             /**
  DataTables features four different built-in options for the buttons to
  display for pagination control:

    `simple` - &#39;Previous&#39; and &#39;Next&#39; buttons only
    &#39;simple_numbers` - &#39;Previous&#39; and &#39;Next&#39; buttons, plus page numbers
    `full` - &#39;First&#39;, &#39;Previous&#39;, &#39;Next&#39; and &#39;Last&#39; buttons
    `full_numbers` - &#39;First&#39;, &#39;Previous&#39;, &#39;Next&#39; and &#39;Last&#39; buttons, plus
    page numbers

  Further methods can be added using {@link DataTable.ext.oPagination}.
   @type string
   @default simple_numbers

   @dtopt Options
   @name DataTable.defaults.pagingType

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;pagingType&quot;: &quot;full_numbers&quot;
       } );
     } )
 /
             &quot;sPaginationType&quot;: &quot;simple_numbers&quot;,

             /**
  Enable horizontal scrolling. When a table is too wide to fit into a
  certain layout, or you have a large number of columns in the table, you
  can enable x-scrolling to show the table in a viewport, which can be
  scrolled. This property can be `true` which will allow the table to
  scroll horizontally when needed, or any CSS unit, or a number (in which
  case it will be treated as a pixel measurement). Setting as simply `true`
  is recommended.
   @type boolean|string
   @default &lt;i&gt;blank string - i.e. disabled&lt;/i&gt;

   @dtopt Features
   @name DataTable.defaults.scrollX

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;scrollX&quot;: true,
         &quot;scrollCollapse&quot;: true
       } );
     } );
 /
             &quot;sScrollX&quot;: &quot;&quot;,

             /**
  This property can be used to force a DataTable to use more width than it
  might otherwise do when x-scrolling is enabled. For example if you have a
  table which requires to be well spaced, this parameter is useful for
  &quot;over-sizing&quot; the table, and thus forcing scrolling. This property can by
  any CSS unit, or a number (in which case it will be treated as a pixel
  measurement).
   @type string
   @default &lt;i&gt;blank string - i.e. disabled&lt;/i&gt;

   @dtopt Options
   @name DataTable.defaults.scrollXInner

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;scrollX&quot;: &quot;100%&quot;,
         &quot;scrollXInner&quot;: &quot;110%&quot;
       } );
     } );
 /
             &quot;sScrollXInner&quot;: &quot;&quot;,

             /**
  Enable vertical scrolling. Vertical scrolling will constrain the DataTable
  to the given height, and enable scrolling for any data which overflows the
  current viewport. This can be used as an alternative to paging to display
  a lot of data in a small area (although paging and scrolling can both be
  enabled at the same time). This property can be any CSS unit, or a number
  (in which case it will be treated as a pixel measurement).
   @type string
   @default &lt;i&gt;blank string - i.e. disabled&lt;/i&gt;

   @dtopt Features
   @name DataTable.defaults.scrollY

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;scrollY&quot;: &quot;200px&quot;,
         &quot;paginate&quot;: false
       } );
     } );
 /
             &quot;sScrollY&quot;: &quot;&quot;,

             /**
  __Deprecated__ The functionality provided by this parameter has now been
  superseded by that provided through `ajax`, which should be used instead.

  Set the HTTP method that is used to make the Ajax call for server-side
  processing or Ajax sourced data.
   @type string
   @default GET

   @dtopt Options
   @dtopt Server-side
   @name DataTable.defaults.serverMethod

   @deprecated 1.10. Please use `ajax` for this functionality now.
 /
             &quot;sServerMethod&quot;: &quot;GET&quot;,

             /**
  DataTables makes use of renderers when displaying HTML elements for
  a table. These renderers can be added or modified by plug-ins to
  generate suitable mark-up for a site. For example the Bootstrap
  integration plug-in for DataTables uses a paging button renderer to
  display pagination buttons in the mark-up required by Bootstrap.

  For further information about the renderers available see
  DataTable.ext.renderer
   @type string|object
   @default null

   @name DataTable.defaults.renderer

 /
             &quot;renderer&quot;: null
     };

     _fnHungarianMap( DataTable.defaults );

     /*
 Developer note - See note in model.defaults.js about the use of Hungarian
 notation and camel case.
/

     /**
 Column options that can be given to DataTables at initialisation time.
  @namespace
/
     DataTable.defaults.column = {
             /**
  Define which column(s) an order will occur on for this column. This
  allows a column&#39;s ordering to take multiple columns into account when
  doing a sort or use the data from a different column. For example first
  name / last name columns make sense to do a multi-column sort over the
  two columns.
   @type array|int
   @default null &lt;i&gt;Takes the value of the column index automatically&lt;/i&gt;

   @name DataTable.defaults.column.orderData
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;orderData&quot;: [ 0, 1 ], &quot;targets&quot;: [ 0 ] },
           { &quot;orderData&quot;: [ 1, 0 ], &quot;targets&quot;: [ 1 ] },
           { &quot;orderData&quot;: 2, &quot;targets&quot;: [ 2 ] }
         ]
       } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           { &quot;orderData&quot;: [ 0, 1 ] },
           { &quot;orderData&quot;: [ 1, 0 ] },
           { &quot;orderData&quot;: 2 },
           null,
           null
         ]
       } );
     } );
 /
             &quot;aDataSort&quot;: null,
             &quot;iDataSort&quot;: -1,

             /**
  You can control the default ordering direction, and even alter the
  behaviour of the sort handler (i.e. only allow ascending ordering etc)
  using this parameter.
   @type array
   @default [ &#39;asc&#39;, &#39;desc&#39; ]

   @name DataTable.defaults.column.orderSequence
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;orderSequence&quot;: [ &quot;asc&quot; ], &quot;targets&quot;: [ 1 ] },
           { &quot;orderSequence&quot;: [ &quot;desc&quot;, &quot;asc&quot;, &quot;asc&quot; ], &quot;targets&quot;: [ 2 ] },
           { &quot;orderSequence&quot;: [ &quot;desc&quot; ], &quot;targets&quot;: [ 3 ] }
         ]
       } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           null,
           { &quot;orderSequence&quot;: [ &quot;asc&quot; ] },
           { &quot;orderSequence&quot;: [ &quot;desc&quot;, &quot;asc&quot;, &quot;asc&quot; ] },
           { &quot;orderSequence&quot;: [ &quot;desc&quot; ] },
           null
         ]
       } );
     } );
 /
             &quot;asSorting&quot;: [ &#39;asc&#39;, &#39;desc&#39; ],

             /**
  Enable or disable filtering on the data in this column.
   @type boolean
   @default true

   @name DataTable.defaults.column.searchable
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;searchable&quot;: false, &quot;targets&quot;: [ 0 ] }
         ] } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           { &quot;searchable&quot;: false },
           null,
           null,
           null,
           null
         ] } );
     } );
 /
             &quot;bSearchable&quot;: true,

             /**
  Enable or disable ordering on this column.
   @type boolean
   @default true

   @name DataTable.defaults.column.orderable
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;orderable&quot;: false, &quot;targets&quot;: [ 0 ] }
         ] } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           { &quot;orderable&quot;: false },
           null,
           null,
           null,
           null
         ] } );
     } );
 /
             &quot;bSortable&quot;: true,

             /**
  Enable or disable the display of this column.
   @type boolean
   @default true

   @name DataTable.defaults.column.visible
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;visible&quot;: false, &quot;targets&quot;: [ 0 ] }
         ] } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           { &quot;visible&quot;: false },
           null,
           null,
           null,
           null
         ] } );
     } );
 /
             &quot;bVisible&quot;: true,

             /**
  Developer definable function that is called whenever a cell is created (Ajax source,
  etc) or processed for input (DOM source). This can be used as a compliment to mRender
  allowing you to modify the DOM element (add background colour for example) when the
  element is available.
   @type function
   @param {element} td The TD node that has been created
   @param {*} cellData The Data for the cell
   @param {array|object} rowData The data for the whole row
   @param {int} row The row index for the aoData data store
   @param {int} col The column index for aoColumns

   @name DataTable.defaults.column.createdCell
   @dtopt Columns

   @example
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [ {
           &quot;targets&quot;: [3],
           &quot;createdCell&quot;: function (td, cellData, rowData, row, col) {
             if ( cellData == &quot;1.7&quot; ) {
               $(td).css(&#39;color&#39;, &#39;blue&#39;)
             }
           }
         } ]
       });
     } );
 /
             &quot;fnCreatedCell&quot;: null,

             /**
  This parameter has been replaced by `data` in DataTables to ensure naming
  consistency. `dataProp` can still be used, as there is backwards
  compatibility in DataTables for this option, but it is strongly
  recommended that you use `data` in preference to `dataProp`.
   @name DataTable.defaults.column.dataProp
 /

             /**
  This property can be used to read data from any data source property,
  including deeply nested objects / properties. `data` can be given in a
  number of different ways which effect its behaviour:

    `integer` - treated as an array index for the data source. This is the
    default that DataTables uses (incrementally increased for each column).
    `string` - read an object property from the data source. There are
    three &#39;special&#39; options that can be used in the string to alter how
    DataTables reads the data from the source object:
       `.` - Dotted Javascript notation. Just as you use a `.` in
       Javascript to read from nested objects, so to can the options
       specified in `data`. For example: `browser.version` or
       `browser.name`. If your object parameter name contains a period, use
       `\\` to escape it - i.e. `first\\.name`.
       `[]` - Array notation. DataTables can automatically combine data
       from and array source, joining the data with the characters provided
       between the two brackets. For example: `name[, ]` would provide a
       comma-space separated list from the source array. If no characters
       are provided between the brackets, the original array source is
       returned.
       `()` - Function notation. Adding `()` to the end of a parameter will
       execute a function of the name given. For example: `browser()` for a
       simple function on the data source, `browser.version()` for a
       function in a nested property or even `browser().version` to get an
       object property if the function called returns an object. Note that
       function notation is recommended for use in `render` rather than
       `data` as it is much simpler to use as a renderer.
    `null` - use the original data source for the row rather than plucking
    data directly from it. This action has effects on two other
    initialisation options:
       `defaultContent` - When null is given as the `data` option and
       `defaultContent` is specified for the column, the value defined by
       `defaultContent` will be used for the cell.
       `render` - When null is used for the `data` option and the `render`
       option is specified for the column, the whole data source for the
       row is used for the renderer.
    `function` - the function given will be executed whenever DataTables
    needs to set or get the data for a cell in the column. The function
    takes three parameters:
       Parameters:
         `{array|object}` The data source for the row
         `{string}` The type call data requested - this will be &#39;set&#39; when
         setting data or &#39;filter&#39;, &#39;display&#39;, &#39;type&#39;, &#39;sort&#39; or undefined
         when gathering data. Note that when `undefined` is given for the
         type DataTables expects to get the raw data for the object back&lt;
         `{*}` Data to set when the second parameter is &#39;set&#39;.
       Return:
         The return value from the function is not required when &#39;set&#39; is
         the type of call, but otherwise the return is what will be used
         for the data requested.

  Note that `data` is a getter and setter option. If you just require
  formatting of data for output, you will likely want to use `render` which
  is simply a getter and thus simpler to use.

  Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
  name change reflects the flexibility of this property and is consistent
  with the naming of mRender. If &#39;mDataProp&#39; is given, then it will still
  be used by DataTables, as it automatically maps the old name to the new
  if required.

   @type string|int|function|null
   @default null &lt;i&gt;Use automatically calculated column index&lt;/i&gt;

   @name DataTable.defaults.column.data
   @dtopt Columns

   @example
     // Read table data from objects
     // JSON structure for each row:
     //   {
     //      &quot;engine&quot;: {value},
     //      &quot;browser&quot;: {value},
     //      &quot;platform&quot;: {value},
     //      &quot;version&quot;: {value},
     //      &quot;grade&quot;: {value}
     //   }
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;ajaxSource&quot;: &quot;sources/objects.txt&quot;,
         &quot;columns&quot;: [
           { &quot;data&quot;: &quot;engine&quot; },
           { &quot;data&quot;: &quot;browser&quot; },
           { &quot;data&quot;: &quot;platform&quot; },
           { &quot;data&quot;: &quot;version&quot; },
           { &quot;data&quot;: &quot;grade&quot; }
         ]
       } );
     } );

   @example
     // Read information from deeply nested objects
     // JSON structure for each row:
     //   {
     //      &quot;engine&quot;: {value},
     //      &quot;browser&quot;: {value},
     //      &quot;platform&quot;: {
     //         &quot;inner&quot;: {value}
     //      },
     //      &quot;details&quot;: [
     //         {value}, {value}
     //      ]
     //   }
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;ajaxSource&quot;: &quot;sources/deep.txt&quot;,
         &quot;columns&quot;: [
           { &quot;data&quot;: &quot;engine&quot; },
           { &quot;data&quot;: &quot;browser&quot; },
           { &quot;data&quot;: &quot;platform.inner&quot; },
           { &quot;data&quot;: &quot;platform.details.0&quot; },
           { &quot;data&quot;: &quot;platform.details.1&quot; }
         ]
       } );
     } );

   @example
     // Using `data` as a function to provide different information for
     // sorting, filtering and display. In this case, currency (price)
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [ {
           &quot;targets&quot;: [ 0 ],
           &quot;data&quot;: function ( source, type, val ) {
             if (type === &#39;set&#39;) {
               source.price = val;
               // Store the computed dislay and filter values for efficiency
               source.price_display = val==&quot;&quot; ? &quot;&quot; : &quot;$&quot;+numberFormat(val);
               source.price_filter  = val==&quot;&quot; ? &quot;&quot; : &quot;$&quot;+numberFormat(val)+&quot; &quot;+val;
               return;
             }
             else if (type === &#39;display&#39;) {
               return source.price_display;
             }
             else if (type === &#39;filter&#39;) {
               return source.price_filter;
             }
             // &#39;sort&#39;, &#39;type&#39; and undefined all just use the integer
             return source.price;
           }
         } ]
       } );
     } );

   @example
     // Using default content
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [ {
           &quot;targets&quot;: [ 0 ],
           &quot;data&quot;: null,
           &quot;defaultContent&quot;: &quot;Click to edit&quot;
         } ]
       } );
     } );

   @example
     // Using array notation - outputting a list from an array
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [ {
           &quot;targets&quot;: [ 0 ],
           &quot;data&quot;: &quot;name[, ]&quot;
         } ]
       } );
     } );

 /
             &quot;mData&quot;: null,

             /**
  This property is the rendering partner to `data` and it is suggested that
  when you want to manipulate data for display (including filtering,
  sorting etc) without altering the underlying data for the table, use this
  property. `render` can be considered to be the the read only companion to
  `data` which is read / write (then as such more complex). Like `data`
  this option can be given in a number of different ways to effect its
  behaviour:

    `integer` - treated as an array index for the data source. This is the
    default that DataTables uses (incrementally increased for each column).
    `string` - read an object property from the data source. There are
    three &#39;special&#39; options that can be used in the string to alter how
    DataTables reads the data from the source object:
       `.` - Dotted Javascript notation. Just as you use a `.` in
       Javascript to read from nested objects, so to can the options
       specified in `data`. For example: `browser.version` or
       `browser.name`. If your object parameter name contains a period, use
       `\\` to escape it - i.e. `first\\.name`.
       `[]` - Array notation. DataTables can automatically combine data
       from and array source, joining the data with the characters provided
       between the two brackets. For example: `name[, ]` would provide a
       comma-space separated list from the source array. If no characters
       are provided between the brackets, the original array source is
       returned.
       `()` - Function notation. Adding `()` to the end of a parameter will
       execute a function of the name given. For example: `browser()` for a
       simple function on the data source, `browser.version()` for a
       function in a nested property or even `browser().version` to get an
       object property if the function called returns an object.
    `object` - use different data for the different data types requested by
    DataTables (&#39;filter&#39;, &#39;display&#39;, &#39;type&#39; or &#39;sort&#39;). The property names
    of the object is the data type the property refers to and the value can
    defined using an integer, string or function using the same rules as
    `render` normally does. Note that an `_` option _must_ be specified.
    This is the default value to use if you haven&#39;t specified a value for
    the data type requested by DataTables.
    `function` - the function given will be executed whenever DataTables
    needs to set or get the data for a cell in the column. The function
    takes three parameters:
       Parameters:
         {array|object} The data source for the row (based on `data`)
         {string} The type call data requested - this will be &#39;filter&#39;,
         &#39;display&#39;, &#39;type&#39; or &#39;sort&#39;.
         {array|object} The full data source for the row (not based on
         `data`)
       Return:
         The return value from the function is what will be used for the
         data requested.

   @type string|int|function|object|null
   @default null Use the data source value.

   @name DataTable.defaults.column.render
   @dtopt Columns

   @example
     // Create a comma separated list from an array of objects
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;ajaxSource&quot;: &quot;sources/deep.txt&quot;,
         &quot;columns&quot;: [
           { &quot;data&quot;: &quot;engine&quot; },
           { &quot;data&quot;: &quot;browser&quot; },
           {
             &quot;data&quot;: &quot;platform&quot;,
             &quot;render&quot;: &quot;[, ].name&quot;
           }
         ]
       } );
     } );

   @example
     // Execute a function to obtain data
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [ {
           &quot;targets&quot;: [ 0 ],
           &quot;data&quot;: null, // Use the full data source object for the renderer&#39;s source
           &quot;render&quot;: &quot;browserName()&quot;
         } ]
       } );
     } );

   @example
     // As an object, extracting different data for the different types
     // This would be used with a data source such as:
     //   { &quot;phone&quot;: 5552368, &quot;phone_filter&quot;: &quot;5552368 555-2368&quot;, &quot;phone_display&quot;: &quot;555-2368&quot; }
     // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
     // (which has both forms) is used for filtering for if a user inputs either format, while
     // the formatted phone number is the one that is shown in the table.
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [ {
           &quot;targets&quot;: [ 0 ],
           &quot;data&quot;: null, // Use the full data source object for the renderer&#39;s source
           &quot;render&quot;: {
             &quot;_&quot;: &quot;phone&quot;,
             &quot;filter&quot;: &quot;phone_filter&quot;,
             &quot;display&quot;: &quot;phone_display&quot;
           }
         } ]
       } );
     } );

   @example
     // Use as a function to create a link from the data source
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [ {
           &quot;targets&quot;: [ 0 ],
           &quot;data&quot;: &quot;download_link&quot;,
           &quot;render&quot;: function ( data, type, full ) {
             return &#39;&lt;a href=&quot;&#39;+data+&#39;&quot;&gt;Download&lt;/a&gt;&#39;;
           }
         } ]
       } );
     } );
 /
             &quot;mRender&quot;: null,

             /**
  Change the cell type created for the column - either TD cells or TH cells. This
  can be useful as TH cells have semantic meaning in the table body, allowing them
  to act as a header for a row (you may wish to add scope=&#39;row&#39; to the TH elements).
   @type string
   @default td

   @name DataTable.defaults.column.cellType
   @dtopt Columns

   @example
     // Make the first column use TH cells
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [ {
           &quot;targets&quot;: [ 0 ],
           &quot;cellType&quot;: &quot;th&quot;
         } ]
       } );
     } );
 /
             &quot;sCellType&quot;: &quot;td&quot;,

             /**
  Class to give to each cell in this column.
   @type string
   @default &lt;i&gt;Empty string&lt;/i&gt;

   @name DataTable.defaults.column.class
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;class&quot;: &quot;my_class&quot;, &quot;targets&quot;: [ 0 ] }
         ]
       } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           { &quot;class&quot;: &quot;my_class&quot; },
           null,
           null,
           null,
           null
         ]
       } );
     } );
 /
             &quot;sClass&quot;: &quot;&quot;,

             /**
  When DataTables calculates the column widths to assign to each column,
  it finds the longest string in each column and then constructs a
  temporary table and reads the widths from that. The problem with this
  is that &quot;mmm&quot; is much wider then &quot;iiii&quot;, but the latter is a longer
  string - thus the calculation can go wrong (doing it properly and putting
  it into an DOM object and measuring that is horribly(!) slow). Thus as
  a &quot;work around&quot; we provide this option. It will append its value to the
  text that is found to be the longest string for the column - i.e. padding.
  Generally you shouldn&#39;t need this!
   @type string
   @default &lt;i&gt;Empty string&lt;i&gt;

   @name DataTable.defaults.column.contentPadding
   @dtopt Columns

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           null,
           null,
           null,
           {
             &quot;contentPadding&quot;: &quot;mmm&quot;
           }
         ]
       } );
     } );
 /
             &quot;sContentPadding&quot;: &quot;&quot;,

             /**
  Allows a default value to be given for a column&#39;s data, and will be used
  whenever a null data source is encountered (this can be because `data`
  is set to null, or because the data source itself is null).
   @type string
   @default null

   @name DataTable.defaults.column.defaultContent
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           {
             &quot;data&quot;: null,
             &quot;defaultContent&quot;: &quot;Edit&quot;,
             &quot;targets&quot;: [ -1 ]
           }
         ]
       } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           null,
           null,
           null,
           {
             &quot;data&quot;: null,
             &quot;defaultContent&quot;: &quot;Edit&quot;
           }
         ]
       } );
     } );
 /
             &quot;sDefaultContent&quot;: null,

             /**
  This parameter is only used in DataTables&#39; server-side processing. It can
  be exceptionally useful to know what columns are being displayed on the
  client side, and to map these to database fields. When defined, the names
  also allow DataTables to reorder information from the server if it comes
  back in an unexpected order (i.e. if you switch your columns around on the
  client-side, your server-side code does not also need updating).
   @type string
   @default &lt;i&gt;Empty string&lt;/i&gt;

   @name DataTable.defaults.column.name
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;name&quot;: &quot;engine&quot;, &quot;targets&quot;: [ 0 ] },
           { &quot;name&quot;: &quot;browser&quot;, &quot;targets&quot;: [ 1 ] },
           { &quot;name&quot;: &quot;platform&quot;, &quot;targets&quot;: [ 2 ] },
           { &quot;name&quot;: &quot;version&quot;, &quot;targets&quot;: [ 3 ] },
           { &quot;name&quot;: &quot;grade&quot;, &quot;targets&quot;: [ 4 ] }
         ]
       } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           { &quot;name&quot;: &quot;engine&quot; },
           { &quot;name&quot;: &quot;browser&quot; },
           { &quot;name&quot;: &quot;platform&quot; },
           { &quot;name&quot;: &quot;version&quot; },
           { &quot;name&quot;: &quot;grade&quot; }
         ]
       } );
     } );
 /
             &quot;sName&quot;: &quot;&quot;,

             /**
  Defines a data source type for the ordering which can be used to read
  real-time information from the table (updating the internally cached
  version) prior to ordering. This allows ordering to occur on user
  editable elements such as form inputs.
   @type string
   @default std

   @name DataTable.defaults.column.orderDataType
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;orderDataType&quot;: &quot;dom-text&quot;, &quot;targets&quot;: [ 2, 3 ] },
           { &quot;type&quot;: &quot;numeric&quot;, &quot;targets&quot;: [ 3 ] },
           { &quot;orderDataType&quot;: &quot;dom-select&quot;, &quot;targets&quot;: [ 4 ] },
           { &quot;orderDataType&quot;: &quot;dom-checkbox&quot;, &quot;targets&quot;: [ 5 ] }
         ]
       } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           null,
           null,
           { &quot;orderDataType&quot;: &quot;dom-text&quot; },
           { &quot;orderDataType&quot;: &quot;dom-text&quot;, &quot;type&quot;: &quot;numeric&quot; },
           { &quot;orderDataType&quot;: &quot;dom-select&quot; },
           { &quot;orderDataType&quot;: &quot;dom-checkbox&quot; }
         ]
       } );
     } );
 /
             &quot;sSortDataType&quot;: &quot;std&quot;,

             /**
  The title of this column.
   @type string
   @default null &lt;i&gt;Derived from the &#39;TH&#39; value for this column in the
     original HTML table.&lt;/i&gt;

   @name DataTable.defaults.column.title
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;title&quot;: &quot;My column title&quot;, &quot;targets&quot;: [ 0 ] }
         ]
       } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           { &quot;title&quot;: &quot;My column title&quot; },
           null,
           null,
           null,
           null
         ]
       } );
     } );
 /
             &quot;sTitle&quot;: null,

             /**
  The type allows you to specify how the data for this column will be
  ordered. Four types (string, numeric, date and html (which will strip
  HTML tags before ordering)) are currently available. Note that only date
  formats understood by Javascript&#39;s Date() object will be accepted as type
  date. For example: &quot;Mar 26, 2008 5:03 PM&quot;. May take the values: &#39;string&#39;,
  &#39;numeric&#39;, &#39;date&#39; or &#39;html&#39; (by default). Further types can be adding
  through plug-ins.
   @type string
   @default null &lt;i&gt;Auto-detected from raw data&lt;/i&gt;

   @name DataTable.defaults.column.type
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;type&quot;: &quot;html&quot;, &quot;targets&quot;: [ 0 ] }
         ]
       } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           { &quot;type&quot;: &quot;html&quot; },
           null,
           null,
           null,
           null
         ]
       } );
     } );
 /
             &quot;sType&quot;: null,

             /**
  Defining the width of the column, this parameter may take any CSS value
  (3em, 20px etc). DataTables applies &#39;smart&#39; widths to columns which have not
  been given a specific width through this interface ensuring that the table
  remains readable.
   @type string
   @default null &lt;i&gt;Automatic&lt;/i&gt;

   @name DataTable.defaults.column.width
   @dtopt Columns

   @example
     // Using `columnDefs`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columnDefs&quot;: [
           { &quot;width&quot;: &quot;20%&quot;, &quot;targets&quot;: [ 0 ] }
         ]
       } );
     } );

   @example
     // Using `columns`
     $(document).ready( function() {
       $(&#39;#example&#39;).dataTable( {
         &quot;columns&quot;: [
           { &quot;width&quot;: &quot;20%&quot; },
           null,
           null,
           null,
           null
         ]
       } );
     } );
 /
             &quot;sWidth&quot;: null
     };

     _fnHungarianMap( DataTable.defaults.column );

     /**
 DataTables settings object - this holds all the information needed for a
 given table, including configuration, data and current application of the
 table options. DataTables does not have a single instance for each DataTable
 with the settings attached to that instance, but rather instances of the
 DataTable &quot;class&quot; are created on-the-fly as needed (typically by a
 $().dataTable() call) and the settings object is then applied to that
 instance.

 Note that this object is related to {@link DataTable.defaults} but this
 one is the internal data store for DataTables&#39;s cache of columns. It should
 NOT be manipulated outside of DataTables. Any configuration should be done
 through the initialisation options.
  @namespace
  @todo Really should attach the settings object to individual instances so we
    don&#39;t need to create new instances on each $().dataTable() call (if the
    table already exists). It would also save passing oSettings around and
    into every single function. However, this is a very significant
    architecture change for DataTables and will almost certainly break
    backwards compatibility with older installations. This is something that
    will be done in 2.0.
/
     DataTable.models.oSettings = {
             /**
  Primary features of DataTables and their enablement state.
   @namespace
 /
             &quot;oFeatures&quot;: {

                     /**
   Flag to say if DataTables should automatically try to calculate the
   optimum table and columns widths (true) or not (false).
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bAutoWidth&quot;: null,

                     /**
   Delay the creation of TR and TD elements until they are actually
   needed by a driven page draw. This can give a significant speed
   increase for Ajax source and Javascript source data, but makes no
   difference at all fro DOM and server-side processing tables.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bDeferRender&quot;: null,

                     /**
   Enable filtering on the table or not. Note that if this is disabled
   then there is no filtering at all on the table, including fnFilter.
   To just remove the filtering input use sDom and remove the &#39;f&#39; option.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bFilter&quot;: null,

                     /**
   Table information element (the &#39;Showing x of y records&#39; div) enable
   flag.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bInfo&quot;: null,

                     /**
   Present a user control allowing the end user to change the page size
   when pagination is enabled.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bLengthChange&quot;: null,

                     /**
   Pagination enabled or not. Note that if this is disabled then length
   changing must also be disabled.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bPaginate&quot;: null,

                     /**
   Processing indicator enable flag whenever DataTables is enacting a
   user request - typically an Ajax request for server-side processing.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bProcessing&quot;: null,

                     /**
   Server-side processing enabled flag - when enabled DataTables will
   get all data from the server for every draw - there is no filtering,
   sorting or paging done on the client-side.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bServerSide&quot;: null,

                     /**
   Sorting enablement flag.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bSort&quot;: null,

                     /**
   Multi-column sorting
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bSortMulti&quot;: null,

                     /**
   Apply a class to the columns which are being sorted to provide a
   visual highlight or not. This can slow things down when enabled since
   there is a lot of DOM interaction.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bSortClasses&quot;: null,

                     /**
   State saving enablement flag.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bStateSave&quot;: null
             },

             /**
  Scrolling settings for a table.
   @namespace
 /
             &quot;oScroll&quot;: {
                     /**
   When the table is shorter in height than sScrollY, collapse the
   table container down to the height of the table (when true).
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type boolean
  /
                     &quot;bCollapse&quot;: null,

                     /**
   Width of the scrollbar for the web-browser&#39;s platform. Calculated
   during table initialisation.
    @type int
    @default 0
  /
                     &quot;iBarWidth&quot;: 0,

                     /**
   Viewport width for horizontal scrolling. Horizontal scrolling is
   disabled if an empty string.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type string
  /
                     &quot;sX&quot;: null,

                     /**
   Width to expand the table to when using x-scrolling. Typically you
   should not need to use this.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type string
    @deprecated
  /
                     &quot;sXInner&quot;: null,

                     /**
   Viewport height for vertical scrolling. Vertical scrolling is disabled
   if an empty string.
   Note that this parameter will be set by the initialisation routine. To
   set a default use {@link DataTable.defaults}.
    @type string
  /
                     &quot;sY&quot;: null
             },

             /**
  Language information for the table.
   @namespace
   @extends DataTable.defaults.oLanguage
 /
             &quot;oLanguage&quot;: {
                     /**
   Information callback function. See
   {@link DataTable.defaults.fnInfoCallback}
    @type function
    @default null
  /
                     &quot;fnInfoCallback&quot;: null
             },

             /**
  Browser support parameters
   @namespace
 /
             &quot;oBrowser&quot;: {
                     /**
   Indicate if the browser incorrectly calculates width:100% inside a
   scrolling element (IE6/7)
    @type boolean
    @default false
  /
                     &quot;bScrollOversize&quot;: false,

                     /**
   Determine if the vertical scrollbar is on the right or left of the
   scrolling container - needed for rtl language layout, although not
   all browsers move the scrollbar (Safari).
    @type boolean
    @default false
  /
                     &quot;bScrollbarLeft&quot;: false
             },

             &quot;ajax&quot;: null,

             /**
  Array referencing the nodes which are used for the features. The
  parameters of this object match what is allowed by sDom - i.e.
    &lt;ul&gt;
      &lt;li&gt;&#39;l&#39; - Length changing&lt;/li&gt;
      &lt;li&gt;&#39;f&#39; - Filtering input&lt;/li&gt;
      &lt;li&gt;&#39;t&#39; - The table!&lt;/li&gt;
      &lt;li&gt;&#39;i&#39; - Information&lt;/li&gt;
      &lt;li&gt;&#39;p&#39; - Pagination&lt;/li&gt;
      &lt;li&gt;&#39;r&#39; - pRocessing&lt;/li&gt;
    &lt;/ul&gt;
   @type array
   @default []
 /
             &quot;aanFeatures&quot;: [],

             /**
  Store data information - see {@link DataTable.models.oRow} for detailed
  information.
   @type array
   @default []
 /
             &quot;aoData&quot;: [],

             /**
  Array of indexes which are in the current display (after filtering etc)
   @type array
   @default []
 /
             &quot;aiDisplay&quot;: [],

             /**
  Array of indexes for display - no filtering
   @type array
   @default []
 /
             &quot;aiDisplayMaster&quot;: [],

             /**
  Store information about each column that is in use
   @type array
   @default []
 /
             &quot;aoColumns&quot;: [],

             /**
  Store information about the table&#39;s header
   @type array
   @default []
 /
             &quot;aoHeader&quot;: [],

             /**
  Store information about the table&#39;s footer
   @type array
   @default []
 /
             &quot;aoFooter&quot;: [],

             /**
  Store the applied global search information in case we want to force a
  research or compare the old search to a new one.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @namespace
   @extends DataTable.models.oSearch
 /
             &quot;oPreviousSearch&quot;: {},

             /**
  Store the applied search for each column - see
  {@link DataTable.models.oSearch} for the format that is used for the
  filtering information for each column.
   @type array
   @default []
 /
             &quot;aoPreSearchCols&quot;: [],

             /**
  Sorting that is applied to the table. Note that the inner arrays are
  used in the following manner:
  &lt;ul&gt;
    &lt;li&gt;Index 0 - column number&lt;/li&gt;
    &lt;li&gt;Index 1 - current sorting direction&lt;/li&gt;
  &lt;/ul&gt;
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type array
   @todo These inner arrays should really be objects
 /
             &quot;aaSorting&quot;: null,

             /**
  Sorting that is always applied to the table (i.e. prefixed in front of
  aaSorting).
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type array
   @default []
 /
             &quot;aaSortingFixed&quot;: [],

             /**
  Classes to use for the striping of a table.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type array
   @default []
 /
             &quot;asStripeClasses&quot;: null,

             /**
  If restoring a table - we should restore its striping classes as well
   @type array
   @default []
 /
             &quot;asDestroyStripes&quot;: [],

             /**
  If restoring a table - we should restore its width
   @type int
   @default 0
 /
             &quot;sDestroyWidth&quot;: 0,

             /**
  Callback functions array for every time a row is inserted (i.e. on a draw).
   @type array
   @default []
 /
             &quot;aoRowCallback&quot;: [],

             /**
  Callback functions for the header on each draw.
   @type array
   @default []
 /
             &quot;aoHeaderCallback&quot;: [],

             /**
  Callback function for the footer on each draw.
   @type array
   @default []
 /
             &quot;aoFooterCallback&quot;: [],

             /**
  Array of callback functions for draw callback functions
   @type array
   @default []
 /
             &quot;aoDrawCallback&quot;: [],

             /**
  Array of callback functions for row created function
   @type array
   @default []
 /
             &quot;aoRowCreatedCallback&quot;: [],

             /**
  Callback functions for just before the table is redrawn. A return of
  false will be used to cancel the draw.
   @type array
   @default []
 /
             &quot;aoPreDrawCallback&quot;: [],

             /**
  Callback functions for when the table has been initialised.
   @type array
   @default []
 /
             &quot;aoInitComplete&quot;: [],

             /**
  Callbacks for modifying the settings to be stored for state saving, prior to
  saving state.
   @type array
   @default []
 /
             &quot;aoStateSaveParams&quot;: [],

             /**
  Callbacks for modifying the settings that have been stored for state saving
  prior to using the stored values to restore the state.
   @type array
   @default []
 /
             &quot;aoStateLoadParams&quot;: [],

             /**
  Callbacks for operating on the settings object once the saved state has been
  loaded
   @type array
   @default []
 /
             &quot;aoStateLoaded&quot;: [],

             /**
  Cache the table ID for quick access
   @type string
   @default &lt;i&gt;Empty string&lt;/i&gt;
 /
             &quot;sTableId&quot;: &quot;&quot;,

             /**
  The TABLE node for the main table
   @type node
   @default null
 /
             &quot;nTable&quot;: null,

             /**
  Permanent ref to the thead element
   @type node
   @default null
 /
             &quot;nTHead&quot;: null,

             /**
  Permanent ref to the tfoot element - if it exists
   @type node
   @default null
 /
             &quot;nTFoot&quot;: null,

             /**
  Permanent ref to the tbody element
   @type node
   @default null
 /
             &quot;nTBody&quot;: null,

             /**
  Cache the wrapper node (contains all DataTables controlled elements)
   @type node
   @default null
 /
             &quot;nTableWrapper&quot;: null,

             /**
  Indicate if when using server-side processing the loading of data
  should be deferred until the second draw.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type boolean
   @default false
 /
             &quot;bDeferLoading&quot;: false,

             /**
  Indicate if all required information has been read in
   @type boolean
   @default false
 /
             &quot;bInitialised&quot;: false,

             /**
  Information about open rows. Each object in the array has the parameters
  &#39;nTr&#39; and &#39;nParent&#39;
   @type array
   @default []
 /
             &quot;aoOpenRows&quot;: [],

             /**
  Dictate the positioning of DataTables&#39; control elements - see
  {@link DataTable.model.oInit.sDom}.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type string
   @default null
 /
             &quot;sDom&quot;: null,

             /**
  Search delay (in mS)
   @type integer
   @default null
 /
             &quot;searchDelay&quot;: null,

             /**
  Which type of pagination should be used.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type string
   @default two_button
 /
             &quot;sPaginationType&quot;: &quot;two_button&quot;,

             /**
  The state duration (for `stateSave`) in seconds.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type int
   @default 0
 /
             &quot;iStateDuration&quot;: 0,

             /**
  Array of callback functions for state saving. Each array element is an
  object with the following parameters:
    &lt;ul&gt;
      &lt;li&gt;function:fn - function to call. Takes two parameters, oSettings
        and the JSON string to save that has been thus far created. Returns
        a JSON string to be inserted into a json object
        (i.e. &#39;&quot;param&quot;: [ 0, 1, 2]&#39;)&lt;/li&gt;
      &lt;li&gt;string:sName - name of callback&lt;/li&gt;
    &lt;/ul&gt;
   @type array
   @default []
 /
             &quot;aoStateSave&quot;: [],

             /**
  Array of callback functions for state loading. Each array element is an
  object with the following parameters:
    &lt;ul&gt;
      &lt;li&gt;function:fn - function to call. Takes two parameters, oSettings
        and the object stored. May return false to cancel state loading&lt;/li&gt;
      &lt;li&gt;string:sName - name of callback&lt;/li&gt;
    &lt;/ul&gt;
   @type array
   @default []
 /
             &quot;aoStateLoad&quot;: [],

             /**
  State that was saved. Useful for back reference
   @type object
   @default null
 /
             &quot;oSavedState&quot;: null,

             /**
  State that was loaded. Useful for back reference
   @type object
   @default null
 /
             &quot;oLoadedState&quot;: null,

             /**
  Source url for AJAX data for the table.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type string
   @default null
 /
             &quot;sAjaxSource&quot;: null,

             /**
  Property from a given object from which to read the table data from. This
  can be an empty string (when not server-side processing), in which case
  it is  assumed an an array is given directly.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type string
 /
             &quot;sAjaxDataProp&quot;: null,

             /**
  Note if draw should be blocked while getting data
   @type boolean
   @default true
 /
             &quot;bAjaxDataGet&quot;: true,

             /**
  The last jQuery XHR object that was used for server-side data gathering.
  This can be used for working with the XHR information in one of the
  callbacks
   @type object
   @default null
 /
             &quot;jqXHR&quot;: null,

             /**
  JSON returned from the server in the last Ajax request
   @type object
   @default undefined
 /
             &quot;json&quot;: undefined,

             /**
  Data submitted as part of the last Ajax request
   @type object
   @default undefined
 /
             &quot;oAjaxData&quot;: undefined,

             /**
  Function to get the server-side data.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type function
 /
             &quot;fnServerData&quot;: null,

             /**
  Functions which are called prior to sending an Ajax request so extra
  parameters can easily be sent to the server
   @type array
   @default []
 /
             &quot;aoServerParams&quot;: [],

             /**
  Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
  required).
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type string
 /
             &quot;sServerMethod&quot;: null,

             /**
  Format numbers for display.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type function
 /
             &quot;fnFormatNumber&quot;: null,

             /**
  List of options that can be used for the user selectable length menu.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type array
   @default []
 /
             &quot;aLengthMenu&quot;: null,

             /**
  Counter for the draws that the table does. Also used as a tracker for
  server-side processing
   @type int
   @default 0
 /
             &quot;iDraw&quot;: 0,

             /**
  Indicate if a redraw is being done - useful for Ajax
   @type boolean
   @default false
 /
             &quot;bDrawing&quot;: false,

             /**
  Draw index (iDraw) of the last error when parsing the returned data
   @type int
   @default -1
 /
             &quot;iDrawError&quot;: -1,

             /**
  Paging display length
   @type int
   @default 10
 /
             &quot;_iDisplayLength&quot;: 10,

             /**
  Paging start point - aiDisplay index
   @type int
   @default 0
 /
             &quot;_iDisplayStart&quot;: 0,

             /**
  Server-side processing - number of records in the result set
  (i.e. before filtering), Use fnRecordsTotal rather than
  this property to get the value of the number of records, regardless of
  the server-side processing setting.
   @type int
   @default 0
   @private
 /
             &quot;_iRecordsTotal&quot;: 0,

             /**
  Server-side processing - number of records in the current display set
  (i.e. after filtering). Use fnRecordsDisplay rather than
  this property to get the value of the number of records, regardless of
  the server-side processing setting.
   @type boolean
   @default 0
   @private
 /
             &quot;_iRecordsDisplay&quot;: 0,

             /**
  Flag to indicate if jQuery UI marking and classes should be used.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type boolean
 /
             &quot;bJUI&quot;: null,

             /**
  The classes to use for the table
   @type object
   @default {}
 /
             &quot;oClasses&quot;: {},

             /**
  Flag attached to the settings object so you can check in the draw
  callback if filtering has been done in the draw. Deprecated in favour of
  events.
   @type boolean
   @default false
   @deprecated
 /
             &quot;bFiltered&quot;: false,

             /**
  Flag attached to the settings object so you can check in the draw
  callback if sorting has been done in the draw. Deprecated in favour of
  events.
   @type boolean
   @default false
   @deprecated
 /
             &quot;bSorted&quot;: false,

             /**
  Indicate that if multiple rows are in the header and there is more than
  one unique cell per column, if the top one (true) or bottom one (false)
  should be used for sorting / title by DataTables.
  Note that this parameter will be set by the initialisation routine. To
  set a default use {@link DataTable.defaults}.
   @type boolean
 /
             &quot;bSortCellsTop&quot;: null,

             /**
  Initialisation object that is used for the table
   @type object
   @default null
 /
             &quot;oInit&quot;: null,

             /**
  Destroy callback functions - for plug-ins to attach themselves to the
  destroy so they can clean up markup and events.
   @type array
   @default []
 /
             &quot;aoDestroyCallback&quot;: [],

             /**
  Get the number of records in the current record set, before filtering
   @type function
 /
             &quot;fnRecordsTotal&quot;: function ()
             {
                     return _fnDataSource( this ) == &#39;ssp&#39; ?
                             this._iRecordsTotal * 1 :
                             this.aiDisplayMaster.length;
             },

             /**
  Get the number of records in the current record set, after filtering
   @type function
 /
             &quot;fnRecordsDisplay&quot;: function ()
             {
                     return _fnDataSource( this ) == &#39;ssp&#39; ?
                             this._iRecordsDisplay * 1 :
                             this.aiDisplay.length;
             },

             /**
  Get the display end point - aiDisplay index
   @type function
 /
             &quot;fnDisplayEnd&quot;: function ()
             {
                     var
                             len      = this._iDisplayLength,
                             start    = this._iDisplayStart,
                             calc     = start + len,
                             records  = this.aiDisplay.length,
                             features = this.oFeatures,
                             paginate = features.bPaginate;

                     if ( features.bServerSide ) {
                             return paginate === false || len === -1 ?
                                     start + records :
                                     Math.min( start+len, this._iRecordsDisplay );
                     }
                     else {
                             return ! paginate || calc&gt;records || len===-1 ?
                                     records :
                                     calc;
                     }
             },

             /**
  The DataTables object for this table
   @type object
   @default null
 /
             &quot;oInstance&quot;: null,

             /**
  Unique identifier for each instance of the DataTables object. If there
  is an ID on the table node, then it takes that value, otherwise an
  incrementing internal counter is used.
   @type string
   @default null
 /
             &quot;sInstance&quot;: null,

             /**
  tabindex attribute value that is added to DataTables control elements, allowing
  keyboard navigation of the table and its controls.
 /
             &quot;iTabIndex&quot;: 0,

             /**
  DIV container for the footer scrolling table if scrolling
 /
             &quot;nScrollHead&quot;: null,

             /**
  DIV container for the footer scrolling table if scrolling
 /
             &quot;nScrollFoot&quot;: null,

             /**
  Last applied sort
   @type array
   @default []
 /
             &quot;aLastSort&quot;: [],

             /**
  Stored plug-in instances
   @type object
   @default {}
 /
             &quot;oPlugins&quot;: {}
     };

     /**
 Extension object for DataTables that is used to provide all extension
 options.

 Note that the `DataTable.ext` object is available through
 `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
 also aliased to `jQuery.fn.dataTableExt` for historic reasons.
  @namespace
  @extends DataTable.models.ext
/

     /**
 DataTables extensions

 This namespace acts as a collection area for plug-ins that can be used to
 extend DataTables capabilities. Indeed many of the build in methods
 use this method to provide their own capabilities (sorting methods for
 example).

 Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
 reasons

  @namespace
/
     DataTable.ext = _ext = {
             /**
  Buttons. For use with the Buttons extension for DataTables. This is
  defined here so other extensions can define buttons regardless of load
  order. It is _not_ used by DataTables core.

   @type object
   @default {}
 /
             buttons: {},

             /**
  Element class names

   @type object
   @default {}
 /
             classes: {},

             /**
  Error reporting.

  How should DataTables report an error. Can take the value &#39;alert&#39;,
  &#39;throw&#39;, &#39;none&#39; or a function.

   @type string|function
   @default alert
 /
             errMode: &quot;alert&quot;,

             /**
  Feature plug-ins.

  This is an array of objects which describe the feature plug-ins that are
  available to DataTables. These feature plug-ins are then available for
  use through the `dom` initialisation option.

  Each feature plug-in is described by an object which must have the
  following properties:

    `fnInit` - function that is used to initialise the plug-in,
    `cFeature` - a character so the feature can be enabled by the `dom`
    instillation option. This is case sensitive.

  The `fnInit` function has the following input parameters:

  1. `{object}` DataTables settings object: see
     {@link DataTable.models.oSettings}

  And the following return is expected:

    {node|null} The element which contains your feature. Note that the
    return may also be void if your plug-in does not require to inject any
    DOM elements into DataTables control (`dom`) - for example this might
    be useful when developing a plug-in which allows table control via
    keyboard entry

   @type array

   @example
     $.fn.dataTable.ext.features.push( {
       &quot;fnInit&quot;: function( oSettings ) {
         return new TableTools( { &quot;oDTSettings&quot;: oSettings } );
       },
       &quot;cFeature&quot;: &quot;T&quot;
     } );
 /
             feature: [],

             /**
  Row searching.

  This method of searching is complimentary to the default type based
  searching, and a lot more comprehensive as it allows you complete control
  over the searching logic. Each element in this array is a function
  (parameters described below) that is called for every row in the table,
  and your logic decides if it should be included in the searching data set
  or not.

  Searching functions have the following input parameters:

  1. `{object}` DataTables settings object: see
     {@link DataTable.models.oSettings}
  2. `{array|object}` Data for the row to be processed (same as the
     original format that was passed in as the data source, or an array
     from a DOM data source
  3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     can be useful to retrieve the `TR` element if you need DOM interaction.

  And the following return is expected:

    {boolean} Include the row in the searched result set (true) or not
    (false)

  Note that as with the main search ability in DataTables, technically this
  is &quot;filtering&quot;, since it is subtractive. However, for consistency in
  naming we call it searching here.

   @type array
   @default []

   @example
     // The following example shows custom search being applied to the
     // fourth column (i.e. the data[3] index) based on two input values
     // from the end-user, matching the data in a certain range.
     $.fn.dataTable.ext.search.push(
       function( settings, data, dataIndex ) {
         var min = document.getElementById(&#39;min&#39;).value * 1;
         var max = document.getElementById(&#39;max&#39;).value * 1;
         var version = data[3] == &quot;-&quot; ? 0 : data[3]*1;

         if ( min == &quot;&quot; &amp;&amp; max == &quot;&quot; ) {
           return true;
         }
         else if ( min == &quot;&quot; &amp;&amp; version &lt; max ) {
           return true;
         }
         else if ( min &lt; version &amp;&amp; &quot;&quot; == max ) {
           return true;
         }
         else if ( min &lt; version &amp;&amp; version &lt; max ) {
           return true;
         }
         return false;
       }
     );
 /
             search: [],

             /**
  Internal functions, exposed for used in plug-ins.

  Please note that you should not need to use the internal methods for
  anything other than a plug-in (and even then, try to avoid if possible).
  The internal function may change between releases.

   @type object
   @default {}
 /
             internal: {},

             /**
  Legacy configuration options. Enable and disable legacy options that
  are available in DataTables.

   @type object
 /
             legacy: {
                     /**
   Enable / disable DataTables 1.9 compatible server-side processing
   requests

    @type boolean
    @default null
  /
                     ajax: null
             },

             /**
  Pagination plug-in methods.

  Each entry in this object is a function and defines which buttons should
  be shown by the pagination rendering method that is used for the table:
  {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
  buttons are displayed in the document, while the functions here tell it
  what buttons to display. This is done by returning an array of button
  descriptions (what each button will do).

  Pagination types (the four built in options and any additional plug-in
  options defined here) can be used through the `paginationType`
  initialisation parameter.

  The functions defined take two parameters:

  1. `{int} page` The current page index
  2. `{int} pages` The number of pages in the table

  Each function is expected to return an array where each element of the
  array can be one of:

    `first` - Jump to first page when activated
    `last` - Jump to last page when activated
    `previous` - Show previous page when activated
    `next` - Show next page when activated
    `{int}` - Show page of the index given
    `{array}` - A nested array containing the above elements to add a
    containing &#39;DIV&#39; element (might be useful for styling).

  Note that DataTables v1.9- used this object slightly differently whereby
  an object with two functions would be defined for each plug-in. That
  ability is still supported by DataTables 1.10+ to provide backwards
  compatibility, but this option of use is now decremented and no longer
  documented in DataTables 1.10+.

   @type object
   @default {}

   @example
     // Show previous, next and current page buttons only
     $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
       return [ &#39;previous&#39;, page, &#39;next&#39; ];
     };
 /
             pager: {},

             renderer: {
                     pageButton: {},
                     header: {}
             },

             /**
  Ordering plug-ins - custom data source

  The extension options for ordering of data available here is complimentary
  to the default type based ordering that DataTables typically uses. It
  allows much greater control over the the data that is being used to
  order a column, but is necessarily therefore more complex.

  This type of ordering is useful if you want to do ordering based on data
  live from the DOM (for example the contents of an &#39;input&#39; element) rather
  than just the static string that DataTables knows of.

  The way these plug-ins work is that you create an array of the values you
  wish to be ordering for the column in question and then return that
  array. The data in the array much be in the index order of the rows in
  the table (not the currently ordering order!). Which order data gathering
  function is run here depends on the `dt-init columns.orderDataType`
  parameter that is used for the column (if any).

  The functions defined take two parameters:

  1. `{object}` DataTables settings object: see
     {@link DataTable.models.oSettings}
  2. `{int}` Target column index

  Each function is expected to return an array:

    `{array}` Data for the column to be ordering upon

   @type array

   @example
     // Ordering using `input` node values
     $.fn.dataTable.ext.order[&#39;dom-text&#39;] = function  ( settings, col )
     {
       return this.api().column( col, {order:&#39;index&#39;} ).nodes().map( function ( td, i ) {
         return $(&#39;input&#39;, td).val();
       } );
     }
 /
             order: {},

             /**
  Type based plug-ins.

  Each column in DataTables has a type assigned to it, either by automatic
  detection or by direct assignment using the `type` option for the column.
  The type of a column will effect how it is ordering and search (plug-ins
  can also make use of the column type if required).

  @namespace
 /
             type: {
                     /**
   Type detection functions.

   The functions defined in this object are used to automatically detect
   a column&#39;s type, making initialisation of DataTables super easy, even
   when complex data is in the table.

   The functions defined take two parameters:

       1. `{*}` Data from the column cell to be analysed
       2. `{settings}` DataTables settings object. This can be used to
          perform context specific type detection - for example detection
          based on language settings such as using a comma for a decimal
          place. Generally speaking the options from the settings will not
          be required

   Each function is expected to return:

     `{string|null}` Data type detected, or null if unknown (and thus
     pass it on to the other type detection functions.

    @type array

    @example
      // Currency type detection plug-in:
      $.fn.dataTable.ext.type.detect.push(
        function ( data, settings ) {
          // Check the numeric part
          if ( ! $.isNumeric( data.substring(1) ) ) {
            return null;
          }

          // Check prefixed by currency
          if ( data.charAt(0) == &#39;$&#39; || data.charAt(0) == &#39;&amp;pound;&#39; ) {
            return &#39;currency&#39;;
          }
          return null;
        }
      );
  /
                     detect: [],

                     /**
   Type based search formatting.

   The type based searching functions can be used to pre-format the
   data to be search on. For example, it can be used to strip HTML
   tags or to de-format telephone numbers for numeric only searching.

   Note that is a search is not defined for a column of a given type,
   no search formatting will be performed.

   Pre-processing of searching data plug-ins - When you assign the sType
   for a column (or have it automatically detected for you by DataTables
   or a type detection plug-in), you will typically be using this for
   custom sorting, but it can also be used to provide custom searching
   by allowing you to pre-processing the data and returning the data in
   the format that should be searched upon. This is done by adding
   functions this object with a parameter name which matches the sType
   for that target column. This is the corollary of &lt;i&gt;afnSortData&lt;/i&gt;
   for searching data.

   The functions defined take a single parameter:

       1. `{*}` Data from the column cell to be prepared for searching

   Each function is expected to return:

     `{string|null}` Formatted string that will be used for the searching.

    @type object
    @default {}

    @example
      $.fn.dataTable.ext.type.search[&#39;title-numeric&#39;] = function ( d ) {
        return d.replace(/\n/g,&quot; &quot;).replace( /&lt;.*?&gt;/g, &quot;&quot; );
      }
  /
                     search: {},

                     /**
   Type based ordering.

   The column type tells DataTables what ordering to apply to the table
   when a column is sorted upon. The order for each type that is defined,
   is defined by the functions available in this object.

   Each ordering option can be described by three properties added to
   this object:

     `{type}-pre` - Pre-formatting function
     `{type}-asc` - Ascending order function
     `{type}-desc` - Descending order function

   All three can be used together, only `{type}-pre` or only
   `{type}-asc` and `{type}-desc` together. It is generally recommended
   that only `{type}-pre` is used, as this provides the optimal
   implementation in terms of speed, although the others are provided
   for compatibility with existing Javascript sort functions.

   `{type}-pre`: Functions defined take a single parameter:

       1. `{*}` Data from the column cell to be prepared for ordering

   And return:

     `{*}` Data to be sorted upon

   `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
   functions, taking two parameters:

       1. `{*}` Data to compare to the second parameter
       2. `{*}` Data to compare to the first parameter

   And returning:

     `{*}` Ordering match: &lt;0 if first parameter should be sorted lower
     than the second parameter, ===0 if the two parameters are equal and
     &gt;0 if the first parameter should be sorted height than the second
     parameter.

    @type object
    @default {}

    @example
      // Numeric ordering of formatted numbers with a pre-formatter
      $.extend( $.fn.dataTable.ext.type.order, {
        &quot;string-pre&quot;: function(x) {
          a = (a === &quot;-&quot; || a === &quot;&quot;) ? 0 : a.replace( /[^\d\-\.]/g, &quot;&quot; );
          return parseFloat( a );
        }
      } );

    @example
      // Case-sensitive string ordering, with no pre-formatting method
      $.extend( $.fn.dataTable.ext.order, {
        &quot;string-case-asc&quot;: function(x,y) {
          return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0));
        },
        &quot;string-case-desc&quot;: function(x,y) {
          return ((x &lt; y) ? 1 : ((x &gt; y) ? -1 : 0));
        }
      } );
  /
                     order: {}
             },

             /**
  Unique DataTables instance counter

  @type int
  @private
 /
             _unique: 0,

             //
             // Depreciated
             // The following properties are retained for backwards compatiblity only.
             // The should not be used in new projects and will be removed in a future
             // version
             //

             /**
  Version check function.
   @type function
   @depreciated Since 1.10
 /
             fnVersionCheck: DataTable.fnVersionCheck,

             /**
  Index for what &#39;this&#39; index API functions should use
   @type int
   @deprecated Since v1.10
 /
             iApiIndex: 0,

             /**
  jQuery UI class container
   @type object
   @deprecated Since v1.10
 /
             oJUIClasses: {},

             /**
  Software version
   @type string
   @deprecated Since v1.10
 /
             sVersion: DataTable.version
     };

     //
     // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
     //
     $.extend( _ext, {
             afnFiltering: _ext.search,
             aTypes:       _ext.type.detect,
             ofnSearch:    _ext.type.search,
             oSort:        _ext.type.order,
             afnSortData:  _ext.order,
             aoFeatures:   _ext.feature,
             oApi:         _ext.internal,
             oStdClasses:  _ext.classes,
             oPagination:  _ext.pager
     } );

     $.extend( DataTable.ext.classes, {
             &quot;sTable&quot;: &quot;dataTable&quot;,
             &quot;sNoFooter&quot;: &quot;no-footer&quot;,

             /* Paging buttons */
             &quot;sPageButton&quot;: &quot;paginate_button&quot;,
             &quot;sPageButtonActive&quot;: &quot;current&quot;,
             &quot;sPageButtonDisabled&quot;: &quot;disabled&quot;,

             /* Striping classes */
             &quot;sStripeOdd&quot;: &quot;odd&quot;,
             &quot;sStripeEven&quot;: &quot;even&quot;,

             /* Empty row */
             &quot;sRowEmpty&quot;: &quot;dataTables_empty&quot;,

             /* Features */
             &quot;sWrapper&quot;: &quot;dataTables_wrapper&quot;,
             &quot;sFilter&quot;: &quot;dataTables_filter&quot;,
             &quot;sInfo&quot;: &quot;dataTables_info&quot;,
             &quot;sPaging&quot;: &quot;dataTables_paginate paging_&quot;, /* Note that the type is postfixed */
             &quot;sLength&quot;: &quot;dataTables_length&quot;,
             &quot;sProcessing&quot;: &quot;dataTables_processing&quot;,

             /* Sorting */
             &quot;sSortAsc&quot;: &quot;sorting_asc&quot;,
             &quot;sSortDesc&quot;: &quot;sorting_desc&quot;,
             &quot;sSortable&quot;: &quot;sorting&quot;, /* Sortable in both directions */
             &quot;sSortableAsc&quot;: &quot;sorting_asc_disabled&quot;,
             &quot;sSortableDesc&quot;: &quot;sorting_desc_disabled&quot;,
             &quot;sSortableNone&quot;: &quot;sorting_disabled&quot;,
             &quot;sSortColumn&quot;: &quot;sorting_&quot;, /* Note that an int is postfixed for the sorting order */

             /* Filtering */
             &quot;sFilterInput&quot;: &quot;&quot;,

             /* Page length */
             &quot;sLengthSelect&quot;: &quot;&quot;,

             /* Scrolling */
             &quot;sScrollWrapper&quot;: &quot;dataTables_scroll&quot;,
             &quot;sScrollHead&quot;: &quot;dataTables_scrollHead&quot;,
             &quot;sScrollHeadInner&quot;: &quot;dataTables_scrollHeadInner&quot;,
             &quot;sScrollBody&quot;: &quot;dataTables_scrollBody&quot;,
             &quot;sScrollFoot&quot;: &quot;dataTables_scrollFoot&quot;,
             &quot;sScrollFootInner&quot;: &quot;dataTables_scrollFootInner&quot;,

             /* Misc */
             &quot;sHeaderTH&quot;: &quot;&quot;,
             &quot;sFooterTH&quot;: &quot;&quot;,

             // Deprecated
             &quot;sSortJUIAsc&quot;: &quot;&quot;,
             &quot;sSortJUIDesc&quot;: &quot;&quot;,
             &quot;sSortJUI&quot;: &quot;&quot;,
             &quot;sSortJUIAscAllowed&quot;: &quot;&quot;,
             &quot;sSortJUIDescAllowed&quot;: &quot;&quot;,
             &quot;sSortJUIWrapper&quot;: &quot;&quot;,
             &quot;sSortIcon&quot;: &quot;&quot;,
             &quot;sJUIHeader&quot;: &quot;&quot;,
             &quot;sJUIFooter&quot;: &quot;&quot;
     } );

     (function() {

     // Reused strings for better compression. Closure compiler appears to have a
     // weird edge case where it is trying to expand strings rather than use the
     // variable version. This results in about 200 bytes being added, for very
     // little preference benefit since it this run on script load only.
     var _empty = &#39;&#39;;
     _empty = &#39;&#39;;

     var _stateDefault = _empty + &#39;ui-state-default&#39;;
     var _sortIcon     = _empty + &#39;css_right ui-icon ui-icon-&#39;;
     var _headerFooter = _empty + &#39;fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix&#39;;

     $.extend( DataTable.ext.oJUIClasses, DataTable.ext.classes, {
             /* Full numbers paging buttons */
             &quot;sPageButton&quot;:         &quot;fg-button ui-button &quot;+_stateDefault,
             &quot;sPageButtonActive&quot;:   &quot;ui-state-disabled&quot;,
             &quot;sPageButtonDisabled&quot;: &quot;ui-state-disabled&quot;,

             /* Features */
             &quot;sPaging&quot;: &quot;dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi &quot;+
                     &quot;ui-buttonset-multi paging_&quot;, /* Note that the type is postfixed */

             /* Sorting */
             &quot;sSortAsc&quot;:            _stateDefault+&quot; sorting_asc&quot;,
             &quot;sSortDesc&quot;:           _stateDefault+&quot; sorting_desc&quot;,
             &quot;sSortable&quot;:           _stateDefault+&quot; sorting&quot;,
             &quot;sSortableAsc&quot;:        _stateDefault+&quot; sorting_asc_disabled&quot;,
             &quot;sSortableDesc&quot;:       _stateDefault+&quot; sorting_desc_disabled&quot;,
             &quot;sSortableNone&quot;:       _stateDefault+&quot; sorting_disabled&quot;,
             &quot;sSortJUIAsc&quot;:         _sortIcon+&quot;triangle-1-n&quot;,
             &quot;sSortJUIDesc&quot;:        _sortIcon+&quot;triangle-1-s&quot;,
             &quot;sSortJUI&quot;:            _sortIcon+&quot;carat-2-n-s&quot;,
             &quot;sSortJUIAscAllowed&quot;:  _sortIcon+&quot;carat-1-n&quot;,
             &quot;sSortJUIDescAllowed&quot;: _sortIcon+&quot;carat-1-s&quot;,
             &quot;sSortJUIWrapper&quot;:     &quot;DataTables_sort_wrapper&quot;,
             &quot;sSortIcon&quot;:           &quot;DataTables_sort_icon&quot;,

             /* Scrolling */
             &quot;sScrollHead&quot;: &quot;dataTables_scrollHead &quot;+_stateDefault,
             &quot;sScrollFoot&quot;: &quot;dataTables_scrollFoot &quot;+_stateDefault,

             /* Misc */
             &quot;sHeaderTH&quot;:  _stateDefault,
             &quot;sFooterTH&quot;:  _stateDefault,
             &quot;sJUIHeader&quot;: _headerFooter+&quot; ui-corner-tl ui-corner-tr&quot;,
             &quot;sJUIFooter&quot;: _headerFooter+&quot; ui-corner-bl ui-corner-br&quot;
     } );

     }());

     var extPagination = DataTable.ext.pager;

     function _numbers ( page, pages ) {
             var
                     numbers = [],
                     buttons = extPagination.numbers_length,
                     half = Math.floor( buttons / 2 ),
                     i = 1;

             if ( pages &lt;= buttons ) {
                     numbers = _range( 0, pages );
             }
             else if ( page &lt;= half ) {
                     numbers = _range( 0, buttons-2 );
                     numbers.push( &#39;ellipsis&#39; );
                     numbers.push( pages-1 );
             }
             else if ( page &gt;= pages - 1 - half ) {
                     numbers = _range( pages-(buttons-2), pages );
                     numbers.splice( 0, 0, &#39;ellipsis&#39; ); // no unshift in ie6
                     numbers.splice( 0, 0, 0 );
             }
             else {
                     numbers = _range( page-half+2, page+half-1 );
                     numbers.push( &#39;ellipsis&#39; );
                     numbers.push( pages-1 );
                     numbers.splice( 0, 0, &#39;ellipsis&#39; );
                     numbers.splice( 0, 0, 0 );
             }

             numbers.DT_el = &#39;span&#39;;
             return numbers;
     }

     $.extend( extPagination, {
             simple: function ( page, pages ) {
                     return [ &#39;previous&#39;, &#39;next&#39; ];
             },

             full: function ( page, pages ) {
                     return [  &#39;first&#39;, &#39;previous&#39;, &#39;next&#39;, &#39;last&#39; ];
             },

             simple_numbers: function ( page, pages ) {
                     return [ &#39;previous&#39;, _numbers(page, pages), &#39;next&#39; ];
             },

             full_numbers: function ( page, pages ) {
                     return [ &#39;first&#39;, &#39;previous&#39;, _numbers(page, pages), &#39;next&#39;, &#39;last&#39; ];
             },

             // For testing and plug-ins to use
             _numbers: _numbers,

             // Number of number buttons (including ellipsis) to show. _Must be odd!_
             numbers_length: 7
     } );

     $.extend( true, DataTable.ext.renderer, {
             pageButton: {
                     _: function ( settings, host, idx, buttons, page, pages ) {
                             var classes = settings.oClasses;
                             var lang = settings.oLanguage.oPaginate;
                             var btnDisplay, btnClass, counter=0;

                             var attach = function( container, buttons ) {
                                     var i, ien, node, button;
                                     var clickHandler = function ( e ) {
                                             _fnPageChange( settings, e.data.action, true );
                                     };

                                     for ( i=0, ien=buttons.length ; i&lt;ien ; i++ ) {
                                             button = buttons[i];

                                             if ( $.isArray( button ) ) {
                                                     var inner = $( &#39;&lt;&#39;+(button.DT_el || &#39;div&#39;)+&#39;/&gt;&#39; )
                                                             .appendTo( container );
                                                     attach( inner, button );
                                             }
                                             else {
                                                     btnDisplay = &#39;&#39;;
                                                     btnClass = &#39;&#39;;

                                                     switch ( button ) {
                                                             case &#39;ellipsis&#39;:
                                                                     container.append(&#39;&lt;span class=&quot;ellipsis&quot;&gt;&amp;#x2026;&lt;/span&gt;&#39;);
                                                                     break;

                                                             case &#39;first&#39;:
                                                                     btnDisplay = lang.sFirst;
                                                                     btnClass = button + (page &gt; 0 ?
                                                                             &#39;&#39; : &#39; &#39;+classes.sPageButtonDisabled);
                                                                     break;

                                                             case &#39;previous&#39;:
                                                                     btnDisplay = lang.sPrevious;
                                                                     btnClass = button + (page &gt; 0 ?
                                                                             &#39;&#39; : &#39; &#39;+classes.sPageButtonDisabled);
                                                                     break;

                                                             case &#39;next&#39;:
                                                                     btnDisplay = lang.sNext;
                                                                     btnClass = button + (page &lt; pages-1 ?
                                                                             &#39;&#39; : &#39; &#39;+classes.sPageButtonDisabled);
                                                                     break;

                                                             case &#39;last&#39;:
                                                                     btnDisplay = lang.sLast;
                                                                     btnClass = button + (page &lt; pages-1 ?
                                                                             &#39;&#39; : &#39; &#39;+classes.sPageButtonDisabled);
                                                                     break;

                                                             default:
                                                                     btnDisplay = button + 1;
                                                                     btnClass = page === button ?
                                                                             classes.sPageButtonActive : &#39;&#39;;
                                                                     break;
                                                     }

                                                     if ( btnDisplay ) {
                                                             node = $(&#39;&lt;a&gt;&#39;, {
                                                                             &#39;class&#39;: classes.sPageButton+&#39; &#39;+btnClass,
                                                                             &#39;aria-controls&#39;: settings.sTableId,
                                                                             &#39;data-dt-idx&#39;: counter,
                                                                             &#39;tabindex&#39;: settings.iTabIndex,
                                                                             &#39;id&#39;: idx === 0 &amp;&amp; typeof button === &#39;string&#39; ?
                                                                                     settings.sTableId +&#39;_&#39;+ button :
                                                                                     null
                                                                     } )
                                                                     .html( btnDisplay )
                                                                     .appendTo( container );

                                                             _fnBindAction(
                                                                     node, {action: button}, clickHandler
                                                             );

                                                             counter++;
                                                     }
                                             }
                                     }
                             };

                             // IE9 throws an &#39;unknown error&#39; if document.activeElement is used
                             // inside an iframe or frame. Try / catch the error. Not good for
                             // accessibility, but neither are frames.
                             var activeEl;

                             try {
                                     // Because this approach is destroying and recreating the paging
                                     // elements, focus is lost on the select button which is bad for
                                     // accessibility. So we want to restore focus once the draw has
                                     // completed
                                     activeEl = $(document.activeElement).data(&#39;dt-idx&#39;);
                             }
                             catch (e) {}

                             attach( $(host).empty(), buttons );

                             if ( activeEl ) {
                                     $(host).find( &#39;[data-dt-idx=&#39;+activeEl+&#39;]&#39; ).focus();
                             }
                     }
             }
     } );

     // Built in type detection. See model.ext.aTypes for information about
     // what is required from this methods.
     $.extend( DataTable.ext.type.detect, [
             // Plain numbers - first since V8 detects some plain numbers as dates
             // e.g. Date.parse(&#39;55&#39;) (but not all, e.g. Date.parse(&#39;22&#39;)...).
             function ( d, settings )
             {
                     var decimal = settings.oLanguage.sDecimal;
                     return _isNumber( d, decimal ) ? &#39;num&#39;+decimal : null;
             },

             // Dates (only those recognised by the browser&#39;s Date.parse)
             function ( d, settings )
             {
                     // V8 will remove any unknown characters at the start and end of the
                     // expression, leading to false matches such as `$245.12` or `10%` being
                     // a valid date. See forum thread 18941 for detail.
                     if ( d &amp;&amp; !(d instanceof Date) &amp;&amp; ( ! _re_date_start.test(d) || ! _re_date_end.test(d) ) ) {
                             return null;
                     }
                     var parsed = Date.parse(d);
                     return (parsed !== null &amp;&amp; !isNaN(parsed)) || _empty(d) ? &#39;date&#39; : null;
             },

             // Formatted numbers
             function ( d, settings )
             {
                     var decimal = settings.oLanguage.sDecimal;
                     return _isNumber( d, decimal, true ) ? &#39;num-fmt&#39;+decimal : null;
             },

             // HTML numeric
             function ( d, settings )
             {
                     var decimal = settings.oLanguage.sDecimal;
                     return _htmlNumeric( d, decimal ) ? &#39;html-num&#39;+decimal : null;
             },

             // HTML numeric, formatted
             function ( d, settings )
             {
                     var decimal = settings.oLanguage.sDecimal;
                     return _htmlNumeric( d, decimal, true ) ? &#39;html-num-fmt&#39;+decimal : null;
             },

             // HTML (this is strict checking - there must be html)
             function ( d, settings )
             {
                     return _empty( d ) || (typeof d === &#39;string&#39; &amp;&amp; d.indexOf(&#39;&lt;&#39;) !== -1) ?
                             &#39;html&#39; : null;
             }
     ] );

     // Filter formatting functions. See model.ext.ofnSearch for information about
     // what is required from these methods.
     // 
     // Note that additional search methods are added for the html numbers and
     // html formatted numbers by `_addNumericSort()` when we know what the decimal
     // place is

     $.extend( DataTable.ext.type.search, {
             html: function ( data ) {
                     return _empty(data) ?
                             data :
                             typeof data === &#39;string&#39; ?
                                     data
                                             .replace( _re_new_lines, &quot; &quot; )
                                             .replace( _re_html, &quot;&quot; ) :
                                     &#39;&#39;;
             },

             string: function ( data ) {
                     return _empty(data) ?
                             data :
                             typeof data === &#39;string&#39; ?
                                     data.replace( _re_new_lines, &quot; &quot; ) :
                                     data;
             }
     } );

     var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
             if ( d !== 0 &amp;&amp; (!d || d === &#39;-&#39;) ) {
                     return -Infinity;
             }

             // If a decimal place other than `.` is used, it needs to be given to the
             // function so we can detect it and replace with a `.` which is the only
             // decimal place Javascript recognises - it is not locale aware.
             if ( decimalPlace ) {
                     d = _numToDecimal( d, decimalPlace );
             }

             if ( d.replace ) {
                     if ( re1 ) {
                             d = d.replace( re1, &#39;&#39; );
                     }

                     if ( re2 ) {
                             d = d.replace( re2, &#39;&#39; );
                     }
             }

             return d * 1;
     };

     // Add the numeric &#39;deformatting&#39; functions for sorting and search. This is done
     // in a function to provide an easy ability for the language options to add
     // additional methods if a non-period decimal place is used.
     function _addNumericSort ( decimalPlace ) {
             $.each(
                     {
                             // Plain numbers
                             &quot;num&quot;: function ( d ) {
                                     return __numericReplace( d, decimalPlace );
                             },

                             // Formatted numbers
                             &quot;num-fmt&quot;: function ( d ) {
                                     return __numericReplace( d, decimalPlace, _re_formatted_numeric );
                             },

                             // HTML numeric
                             &quot;html-num&quot;: function ( d ) {
                                     return __numericReplace( d, decimalPlace, _re_html );
                             },

                             // HTML numeric, formatted
                             &quot;html-num-fmt&quot;: function ( d ) {
                                     return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
                             }
                     },
                     function ( key, fn ) {
                             // Add the ordering method
                             _ext.type.order[ key+decimalPlace+&#39;-pre&#39; ] = fn;

                             // For HTML types add a search formatter that will strip the HTML
                             if ( key.match(/^html\-/) ) {
                                     _ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
                             }
                     }
             );
     }

     // Default sort methods
     $.extend( _ext.type.order, {
             // Dates
             &quot;date-pre&quot;: function ( d ) {
                     return Date.parse( d ) || 0;
             },

             // html
             &quot;html-pre&quot;: function ( a ) {
                     return _empty(a) ?
                             &#39;&#39; :
                             a.replace ?
                                     a.replace( /&lt;.*?&gt;/g, &quot;&quot; ).toLowerCase() :
                                     a+&#39;&#39;;
             },

             // string
             &quot;string-pre&quot;: function ( a ) {
                     // This is a little complex, but faster than always calling toString,
                     // http://jsperf.com/tostring-v-check
                     return _empty(a) ?
                             &#39;&#39; :
                             typeof a === &#39;string&#39; ?
                                     a.toLowerCase() :
                                     ! a.toString ?
                                             &#39;&#39; :
                                             a.toString();
             },

             // string-asc and -desc are retained only for compatibility with the old
             // sort methods
             &quot;string-asc&quot;: function ( x, y ) {
                     return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0));
             },

             &quot;string-desc&quot;: function ( x, y ) {
                     return ((x &lt; y) ? 1 : ((x &gt; y) ? -1 : 0));
             }
     } );

     // Numeric sorting types - order doesn&#39;t matter here
     _addNumericSort( &#39;&#39; );

     $.extend( true, DataTable.ext.renderer, {
             header: {
                     _: function ( settings, cell, column, classes ) {
                             // No additional mark-up required
                             // Attach a sort listener to update on sort - note that using the
                             // `DT` namespace will allow the event to be removed automatically
                             // on destroy, while the `dt` namespaced event is the one we are
                             // listening for
                             $(settings.nTable).on( &#39;order.dt.DT&#39;, function ( e, ctx, sorting, columns ) {
                                     if ( settings !== ctx ) { // need to check this this is the host
                                             return;               // table, not a nested one
                                     }

                                     var colIdx = column.idx;

                                     cell
                                             .removeClass(
                                                     column.sSortingClass +&#39; &#39;+
                                                     classes.sSortAsc +&#39; &#39;+
                                                     classes.sSortDesc
                                             )
                                             .addClass( columns[ colIdx ] == &#39;asc&#39; ?
                                                     classes.sSortAsc : columns[ colIdx ] == &#39;desc&#39; ?
                                                             classes.sSortDesc :
                                                             column.sSortingClass
                                             );
                             } );
                     },

                     jqueryui: function ( settings, cell, column, classes ) {
                             $(&#39;&lt;div/&gt;&#39;)
                                     .addClass( classes.sSortJUIWrapper )
                                     .append( cell.contents() )
                                     .append( $(&#39;&lt;span/&gt;&#39;)
                                             .addClass( classes.sSortIcon+&#39; &#39;+column.sSortingClassJUI )
                                     )
                                     .appendTo( cell );

                             // Attach a sort listener to update on sort
                             $(settings.nTable).on( &#39;order.dt.DT&#39;, function ( e, ctx, sorting, columns ) {
                                     if ( settings !== ctx ) {
                                             return;
                                     }

                                     var colIdx = column.idx;

                                     cell
                                             .removeClass( classes.sSortAsc +&quot; &quot;+classes.sSortDesc )
                                             .addClass( columns[ colIdx ] == &#39;asc&#39; ?
                                                     classes.sSortAsc : columns[ colIdx ] == &#39;desc&#39; ?
                                                             classes.sSortDesc :
                                                             column.sSortingClass
                                             );

                                     cell
                                             .find( &#39;span.&#39;+classes.sSortIcon )
                                             .removeClass(
                                                     classes.sSortJUIAsc +&quot; &quot;+
                                                     classes.sSortJUIDesc +&quot; &quot;+
                                                     classes.sSortJUI +&quot; &quot;+
                                                     classes.sSortJUIAscAllowed +&quot; &quot;+
                                                     classes.sSortJUIDescAllowed
                                             )
                                             .addClass( columns[ colIdx ] == &#39;asc&#39; ?
                                                     classes.sSortJUIAsc : columns[ colIdx ] == &#39;desc&#39; ?
                                                             classes.sSortJUIDesc :
                                                             column.sSortingClassJUI
                                             );
                             } );
                     }
             }
     } );

     /*
 Public helper functions. These aren&#39;t used internally by DataTables, or
 called by any of the options passed into DataTables, but they can be used
 externally by developers working with DataTables. They are helper functions
 to make working with DataTables a little bit easier.
/

     /**
 Helpers for `columns.render`.

 The options defined here can be used with the `columns.render` initialisation
 option to provide a display renderer. The following functions are defined:

   `number` - Will format numeric data (defined by `columns.data`) for
   display, retaining the original unformatted data for sorting and filtering.
   It takes 4 parameters:
     `string` - Thousands grouping separator
     `string` - Decimal point indicator
     `integer` - Number of decimal points to show
     `string` (optional) - Prefix.

 @example
   // Column definition using the number renderer
   {
     data: &quot;salary&quot;,
     render: $.fn.dataTable.render.number( &#39;\&#39;&#39;, &#39;.&#39;, 0, &#39;$&#39; )
   }

 @namespace
/
     DataTable.render = {
             number: function ( thousands, decimal, precision, prefix ) {
                     return {
                             display: function ( d ) {
                                     if ( typeof d !== &#39;number&#39; &amp;&amp; typeof d !== &#39;string&#39; ) {
                                             return d;
                                     }

                                     var negative = d &lt; 0 ? &#39;-&#39; : &#39;&#39;;
                                     d = Math.abs( parseFloat( d ) );

                                     var intPart = parseInt( d, 10 );
                                     var floatPart = precision ?
                                             decimal+(d - intPart).toFixed( precision ).substring( 2 ):
                                             &#39;&#39;;

                                     return negative + (prefix||&#39;&#39;) +
                                             intPart.toString().replace(
                                                     /\B(?=(\d{3})+(?!\d))/g, thousands
                                             ) +
                                             floatPart;
                             }
                     };
             }
     };

     /*
 This is really a good bit rubbish this method of exposing the internal methods
 publicly... - To be fixed in 2.0 using methods on the prototype
/

     /**
 Create a wrapper function for exporting an internal functions to an external API.
  @param {string} fn API function name
  @returns {function} wrapped function
  @memberof DataTable#internal
/
     function _fnExternApiFunc (fn)
     {
             return function() {
                     var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
                             Array.prototype.slice.call(arguments)
                     );
                     return DataTable.ext.internal[fn].apply( this, args );
             };
     }

     /**
 Reference to internal functions for use by plug-in developers. Note that
 these methods are references to internal functions and are considered to be
 private. If you use these methods, be aware that they are liable to change
 between versions.
  @namespace
/
     $.extend( DataTable.ext.internal, {
             _fnExternApiFunc: _fnExternApiFunc,
             _fnBuildAjax: _fnBuildAjax,
             _fnAjaxUpdate: _fnAjaxUpdate,
             _fnAjaxParameters: _fnAjaxParameters,
             _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
             _fnAjaxDataSrc: _fnAjaxDataSrc,
             _fnAddColumn: _fnAddColumn,
             _fnColumnOptions: _fnColumnOptions,
             _fnAdjustColumnSizing: _fnAdjustColumnSizing,
             _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
             _fnColumnIndexToVisible: _fnColumnIndexToVisible,
             _fnVisbleColumns: _fnVisbleColumns,
             _fnGetColumns: _fnGetColumns,
             _fnColumnTypes: _fnColumnTypes,
             _fnApplyColumnDefs: _fnApplyColumnDefs,
             _fnHungarianMap: _fnHungarianMap,
             _fnCamelToHungarian: _fnCamelToHungarian,
             _fnLanguageCompat: _fnLanguageCompat,
             _fnBrowserDetect: _fnBrowserDetect,
             _fnAddData: _fnAddData,
             _fnAddTr: _fnAddTr,
             _fnNodeToDataIndex: _fnNodeToDataIndex,
             _fnNodeToColumnIndex: _fnNodeToColumnIndex,
             _fnGetCellData: _fnGetCellData,
             _fnSetCellData: _fnSetCellData,
             _fnSplitObjNotation: _fnSplitObjNotation,
             _fnGetObjectDataFn: _fnGetObjectDataFn,
             _fnSetObjectDataFn: _fnSetObjectDataFn,
             _fnGetDataMaster: _fnGetDataMaster,
             _fnClearTable: _fnClearTable,
             _fnDeleteIndex: _fnDeleteIndex,
             _fnInvalidate: _fnInvalidate,
             _fnGetRowElements: _fnGetRowElements,
             _fnCreateTr: _fnCreateTr,
             _fnBuildHead: _fnBuildHead,
             _fnDrawHead: _fnDrawHead,
             _fnDraw: _fnDraw,
             _fnReDraw: _fnReDraw,
             _fnAddOptionsHtml: _fnAddOptionsHtml,
             _fnDetectHeader: _fnDetectHeader,
             _fnGetUniqueThs: _fnGetUniqueThs,
             _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
             _fnFilterComplete: _fnFilterComplete,
             _fnFilterCustom: _fnFilterCustom,
             _fnFilterColumn: _fnFilterColumn,
             _fnFilter: _fnFilter,
             _fnFilterCreateSearch: _fnFilterCreateSearch,
             _fnEscapeRegex: _fnEscapeRegex,
             _fnFilterData: _fnFilterData,
             _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
             _fnUpdateInfo: _fnUpdateInfo,
             _fnInfoMacros: _fnInfoMacros,
             _fnInitialise: _fnInitialise,
             _fnInitComplete: _fnInitComplete,
             _fnLengthChange: _fnLengthChange,
             _fnFeatureHtmlLength: _fnFeatureHtmlLength,
             _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
             _fnPageChange: _fnPageChange,
             _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
             _fnProcessingDisplay: _fnProcessingDisplay,
             _fnFeatureHtmlTable: _fnFeatureHtmlTable,
             _fnScrollDraw: _fnScrollDraw,
             _fnApplyToChildren: _fnApplyToChildren,
             _fnCalculateColumnWidths: _fnCalculateColumnWidths,
             _fnThrottle: _fnThrottle,
             _fnConvertToWidth: _fnConvertToWidth,
             _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,
             _fnGetWidestNode: _fnGetWidestNode,
             _fnGetMaxLenString: _fnGetMaxLenString,
             _fnStringToCss: _fnStringToCss,
             _fnScrollBarWidth: _fnScrollBarWidth,
             _fnSortFlatten: _fnSortFlatten,
             _fnSort: _fnSort,
             _fnSortAria: _fnSortAria,
             _fnSortListener: _fnSortListener,
             _fnSortAttachListener: _fnSortAttachListener,
             _fnSortingClasses: _fnSortingClasses,
             _fnSortData: _fnSortData,
             _fnSaveState: _fnSaveState,
             _fnLoadState: _fnLoadState,
             _fnSettingsFromNode: _fnSettingsFromNode,
             _fnLog: _fnLog,
             _fnMap: _fnMap,
             _fnBindAction: _fnBindAction,
             _fnCallbackReg: _fnCallbackReg,
             _fnCallbackFire: _fnCallbackFire,
             _fnLengthOverflow: _fnLengthOverflow,
             _fnRenderer: _fnRenderer,
             _fnDataSource: _fnDataSource,
             _fnRowAttributes: _fnRowAttributes,
             _fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
                                             // in 1.10, so this dead-end function is
                                             // added to prevent errors
     } );

     // jQuery access
     $.fn.dataTable = DataTable;

     // Legacy aliases
     $.fn.dataTableSettings = DataTable.settings;
     $.fn.dataTableExt = DataTable.ext;

     // With a capital `D` we return a DataTables API instance rather than a
     // jQuery object
     $.fn.DataTable = function ( opts ) {
             return $(this).dataTable( opts ).api();
     };

     // All properties that are available to $.fn.dataTable should also be
     // available on $.fn.DataTable
     $.each( DataTable, function ( prop, val ) {
             $.fn.DataTable[ prop ] = val;
     } );

     // Information about events fired by DataTables - for documentation.
     /**
 Draw event, fired whenever the table is redrawn on the page, at the same
 point as fnDrawCallback. This may be useful for binding events or
 performing calculations when the table is altered at all.
  @name DataTable#draw.dt
  @event
  @param {event} e jQuery event object
  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
/

     /**
 Search event, fired when the searching applied to the table (using the
 built-in global search, or column filters) is altered.
  @name DataTable#search.dt
  @event
  @param {event} e jQuery event object
  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
/

     /**
 Page change event, fired when the paging of the table is altered.
  @name DataTable#page.dt
  @event
  @param {event} e jQuery event object
  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
/

     /**
 Order event, fired when the ordering applied to the table is altered.
  @name DataTable#order.dt
  @event
  @param {event} e jQuery event object
  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
/

     /**
 DataTables initialisation complete event, fired when the table is fully
 drawn, including Ajax data loaded, if Ajax data is required.
  @name DataTable#init.dt
  @event
  @param {event} e jQuery event object
  @param {object} oSettings DataTables settings object
  @param {object} json The JSON object request from the server - only
    present if client-side Ajax sourced data is used&lt;/li&gt;&lt;/ol&gt;
/

     /**
 State save event, fired when the table has changed state a new state save
 is required. This event allows modification of the state saving object
 prior to actually doing the save, including addition or other state
 properties (for plug-ins) or modification of a DataTables core property.
  @name DataTable#stateSaveParams.dt
  @event
  @param {event} e jQuery event object
  @param {object} oSettings DataTables settings object
  @param {object} json The state information to be saved
/

     /**
 State load event, fired when the table is loading state from the stored
 data, but prior to the settings object being modified by the saved state
 - allowing modification of the saved state is required or loading of
 state for a plug-in.
  @name DataTable#stateLoadParams.dt
  @event
  @param {event} e jQuery event object
  @param {object} oSettings DataTables settings object
  @param {object} json The saved state information
/

     /**
 State loaded event, fired when state has been loaded from stored data and
 the settings object has been modified by the loaded data.
  @name DataTable#stateLoaded.dt
  @event
  @param {event} e jQuery event object
  @param {object} oSettings DataTables settings object
  @param {object} json The saved state information
/

     /**
 Processing event, fired when DataTables is doing some kind of processing
 (be it, order, searcg or anything else). It can be used to indicate to
 the end user that there is something happening, or that something has
 finished.
  @name DataTable#processing.dt
  @event
  @param {event} e jQuery event object
  @param {object} oSettings DataTables settings object
  @param {boolean} bShow Flag for if DataTables is doing processing or not
/

     /**
 Ajax (XHR) event, fired whenever an Ajax request is completed from a
 request to made to the server for new data. This event is called before
 DataTables processed the returned data, so it can also be used to pre-
 process the data returned from the server, if needed.

 Note that this trigger is called in `fnServerData`, if you override
 `fnServerData` and which to use this event, you need to trigger it in you
 success function.
  @name DataTable#xhr.dt
  @event
  @param {event} e jQuery event object
  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  @param {object} json JSON returned from the server

  @example
     // Use a custom property returned from the server in another DOM element
     $(&#39;#table&#39;).dataTable().on(&#39;xhr.dt&#39;, function (e, settings, json) {
       $(&#39;#status&#39;).html( json.status );
     } );

  @example
     // Pre-process the data returned from the server
     $(&#39;#table&#39;).dataTable().on(&#39;xhr.dt&#39;, function (e, settings, json) {
       for ( var i=0, ien=json.aaData.length ; i&lt;ien ; i++ ) {
         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
       }
       // Note no return - manipulate the data directly in the JSON object.
     } );
/

     /**
 Destroy event, fired when the DataTable is destroyed by calling fnDestroy
 or passing the bDestroy:true parameter in the initialisation object. This
 can be used to remove bound events, added DOM nodes, etc.
  @name DataTable#destroy.dt
  @event
  @param {event} e jQuery event object
  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
/

     /**
 Page length change event, fired when number of records to show on each
 page (the length) is changed.
  @name DataTable#length.dt
  @event
  @param {event} e jQuery event object
  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  @param {integer} len New length
/

     /**
 Column sizing has changed.
  @name DataTable#column-sizing.dt
  @event
  @param {event} e jQuery event object
  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
/

     /**
 Column visibility has changed.
  @name DataTable#column-visibility.dt
  @event
  @param {event} e jQuery event object
  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
  @param {int} column Column index
  @param {bool} vis `false` if column now hidden, or `true` if visible
/

     return $.fn.dataTable;</pre>

<p>}));</p>

<p>}(window, document));</p>

<p>(function() {</p>

<pre>var CSRFToken, Click, ComponentUrl, EVENTS, Link, ProgressBar, browserIsntBuggy, browserSupportsCustomEvents, browserSupportsPushState, browserSupportsTurbolinks, bypassOnLoadPopstate, cacheCurrentPage, cacheSize, changePage, clone, constrainPageCacheTo, createDocument, crossOriginRedirect, currentState, enableProgressBar, enableTransitionCache, executeScriptTags, extractTitleAndBody, fetch, fetchHistory, fetchReplacement, historyStateIsDefined, initializeTurbolinks, installDocumentReadyPageEventTriggers, installHistoryChangeHandler, installJqueryAjaxSuccessPageUpdateTrigger, loadedAssets, manuallyTriggerHashChangeForFirefox, pageCache, pageChangePrevented, pagesCached, popCookie, processResponse, progressBar, recallScrollPosition, ref, referer, reflectNewUrl, reflectRedirectedUrl, rememberCurrentState, rememberCurrentUrl, rememberReferer, removeNoscriptTags, requestMethodIsSafe, resetScrollPosition, setAutofocusElement, transitionCacheEnabled, transitionCacheFor, triggerEvent, visit, xhr,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

pageCache = {};

cacheSize = 10;

transitionCacheEnabled = false;

progressBar = null;

currentState = null;

loadedAssets = null;

referer = null;

xhr = null;

EVENTS = {
  BEFORE_CHANGE: &#39;page:before-change&#39;,
  FETCH: &#39;page:fetch&#39;,
  RECEIVE: &#39;page:receive&#39;,
  CHANGE: &#39;page:change&#39;,
  UPDATE: &#39;page:update&#39;,
  LOAD: &#39;page:load&#39;,
  RESTORE: &#39;page:restore&#39;,
  BEFORE_UNLOAD: &#39;page:before-unload&#39;,
  EXPIRE: &#39;page:expire&#39;
};

fetch = function(url) {
  var cachedPage;
  url = new ComponentUrl(url);
  rememberReferer();
  cacheCurrentPage();
  if (progressBar != null) {
    progressBar.start();
  }
  if (transitionCacheEnabled &amp;&amp; (cachedPage = transitionCacheFor(url.absolute))) {
    fetchHistory(cachedPage);
    return fetchReplacement(url, null, false);
  } else {
    return fetchReplacement(url, resetScrollPosition);
  }
};

transitionCacheFor = function(url) {
  var cachedPage;
  cachedPage = pageCache[url];
  if (cachedPage &amp;&amp; !cachedPage.transitionCacheDisabled) {
    return cachedPage;
  }
};

enableTransitionCache = function(enable) {
  if (enable == null) {
    enable = true;
  }
  return transitionCacheEnabled = enable;
};

enableProgressBar = function(enable) {
  if (enable == null) {
    enable = true;
  }
  if (!browserSupportsTurbolinks) {
    return;
  }
  if (enable) {
    return progressBar != null ? progressBar : progressBar = new ProgressBar(&#39;html&#39;);
  } else {
    if (progressBar != null) {
      progressBar.uninstall();
    }
    return progressBar = null;
  }
};

fetchReplacement = function(url, onLoadFunction, showProgressBar) {
  if (showProgressBar == null) {
    showProgressBar = true;
  }
  triggerEvent(EVENTS.FETCH, {
    url: url.absolute
  });
  if (xhr != null) {
    xhr.abort();
  }
  xhr = new XMLHttpRequest;
  xhr.open(&#39;GET&#39;, url.withoutHashForIE10compatibility(), true);
  xhr.setRequestHeader(&#39;Accept&#39;, &#39;text/html, application/xhtml+xml, application/xml&#39;);
  xhr.setRequestHeader(&#39;X-XHR-Referer&#39;, referer);
  xhr.onload = function() {
    var doc;
    triggerEvent(EVENTS.RECEIVE, {
      url: url.absolute
    });
    if (doc = processResponse()) {
      reflectNewUrl(url);
      reflectRedirectedUrl();
      changePage.apply(null, extractTitleAndBody(doc));
      manuallyTriggerHashChangeForFirefox();
      if (typeof onLoadFunction === &quot;function&quot;) {
        onLoadFunction();
      }
      return triggerEvent(EVENTS.LOAD);
    } else {
      return document.location.href = crossOriginRedirect() || url.absolute;
    }
  };
  if (progressBar &amp;&amp; showProgressBar) {
    xhr.onprogress = (function(_this) {
      return function(event) {
        var percent;
        percent = event.lengthComputable ? event.loaded / event.total * 100 : progressBar.value + (100 - progressBar.value) / 10;
        return progressBar.advanceTo(percent);
      };
    })(this);
  }
  xhr.onloadend = function() {
    return xhr = null;
  };
  xhr.onerror = function() {
    return document.location.href = url.absolute;
  };
  return xhr.send();
};

fetchHistory = function(cachedPage) {
  if (xhr != null) {
    xhr.abort();
  }
  changePage(cachedPage.title, cachedPage.body);
  recallScrollPosition(cachedPage);
  return triggerEvent(EVENTS.RESTORE);
};

cacheCurrentPage = function() {
  var currentStateUrl;
  currentStateUrl = new ComponentUrl(currentState.url);
  pageCache[currentStateUrl.absolute] = {
    url: currentStateUrl.relative,
    body: document.body,
    title: document.title,
    positionY: window.pageYOffset,
    positionX: window.pageXOffset,
    cachedAt: new Date().getTime(),
    transitionCacheDisabled: document.querySelector(&#39;[data-no-transition-cache]&#39;) != null
  };
  return constrainPageCacheTo(cacheSize);
};

pagesCached = function(size) {
  if (size == null) {
    size = cacheSize;
  }
  if (/^[\d]+$/.test(size)) {
    return cacheSize = parseInt(size);
  }
};

constrainPageCacheTo = function(limit) {
  var cacheTimesRecentFirst, i, key, len, pageCacheKeys, results;
  pageCacheKeys = Object.keys(pageCache);
  cacheTimesRecentFirst = pageCacheKeys.map(function(url) {
    return pageCache[url].cachedAt;
  }).sort(function(a, b) {
    return b - a;
  });
  results = [];
  for (i = 0, len = pageCacheKeys.length; i &lt; len; i++) {
    key = pageCacheKeys[i];
    if (!(pageCache[key].cachedAt &lt;= cacheTimesRecentFirst[limit])) {
      continue;
    }
    triggerEvent(EVENTS.EXPIRE, pageCache[key]);
    results.push(delete pageCache[key]);
  }
  return results;
};

changePage = function(title, body, csrfToken, runScripts) {
  triggerEvent(EVENTS.BEFORE_UNLOAD);
  document.title = title;
  document.documentElement.replaceChild(body, document.body);
  if (csrfToken != null) {
    CSRFToken.update(csrfToken);
  }
  setAutofocusElement();
  if (runScripts) {
    executeScriptTags();
  }
  currentState = window.history.state;
  if (progressBar != null) {
    progressBar.done();
  }
  triggerEvent(EVENTS.CHANGE);
  return triggerEvent(EVENTS.UPDATE);
};

executeScriptTags = function() {
  var attr, copy, i, j, len, len1, nextSibling, parentNode, ref, ref1, script, scripts;
  scripts = Array.prototype.slice.call(document.body.querySelectorAll(&#39;script:not([data-turbolinks-eval=&quot;false&quot;])&#39;));
  for (i = 0, len = scripts.length; i &lt; len; i++) {
    script = scripts[i];
    if (!((ref = script.type) === &#39;&#39; || ref === &#39;text/javascript&#39;)) {
      continue;
    }
    copy = document.createElement(&#39;script&#39;);
    ref1 = script.attributes;
    for (j = 0, len1 = ref1.length; j &lt; len1; j++) {
      attr = ref1[j];
      copy.setAttribute(attr.name, attr.value);
    }
    if (!script.hasAttribute(&#39;async&#39;)) {
      copy.async = false;
    }
    copy.appendChild(document.createTextNode(script.innerHTML));
    parentNode = script.parentNode, nextSibling = script.nextSibling;
    parentNode.removeChild(script);
    parentNode.insertBefore(copy, nextSibling);
  }
};

removeNoscriptTags = function(node) {
  node.innerHTML = node.innerHTML.replace(/&lt;noscript[\S\s]*?&lt;\/noscript&gt;/ig, &#39;&#39;);
  return node;
};

setAutofocusElement = function() {
  var autofocusElement, list;
  autofocusElement = (list = document.querySelectorAll(&#39;input[autofocus], textarea[autofocus]&#39;))[list.length - 1];
  if (autofocusElement &amp;&amp; document.activeElement !== autofocusElement) {
    return autofocusElement.focus();
  }
};

reflectNewUrl = function(url) {
  if ((url = new ComponentUrl(url)).absolute !== referer) {
    return window.history.pushState({
      turbolinks: true,
      url: url.absolute
    }, &#39;&#39;, url.absolute);
  }
};

reflectRedirectedUrl = function() {
  var location, preservedHash;
  if (location = xhr.getResponseHeader(&#39;X-XHR-Redirected-To&#39;)) {
    location = new ComponentUrl(location);
    preservedHash = location.hasNoHash() ? document.location.hash : &#39;&#39;;
    return window.history.replaceState(window.history.state, &#39;&#39;, location.href + preservedHash);
  }
};

crossOriginRedirect = function() {
  var redirect;
  if (((redirect = xhr.getResponseHeader(&#39;Location&#39;)) != null) &amp;&amp; (new ComponentUrl(redirect)).crossOrigin()) {
    return redirect;
  }
};

rememberReferer = function() {
  return referer = document.location.href;
};

rememberCurrentUrl = function() {
  return window.history.replaceState({
    turbolinks: true,
    url: document.location.href
  }, &#39;&#39;, document.location.href);
};

rememberCurrentState = function() {
  return currentState = window.history.state;
};

manuallyTriggerHashChangeForFirefox = function() {
  var url;
  if (navigator.userAgent.match(/Firefox/) &amp;&amp; !(url = new ComponentUrl).hasNoHash()) {
    window.history.replaceState(currentState, &#39;&#39;, url.withoutHash());
    return document.location.hash = url.hash;
  }
};

recallScrollPosition = function(page) {
  return window.scrollTo(page.positionX, page.positionY);
};

resetScrollPosition = function() {
  if (document.location.hash) {
    return document.location.href = document.location.href;
  } else {
    return window.scrollTo(0, 0);
  }
};

clone = function(original) {
  var copy, key, value;
  if ((original == null) || typeof original !== &#39;object&#39;) {
    return original;
  }
  copy = new original.constructor();
  for (key in original) {
    value = original[key];
    copy[key] = clone(value);
  }
  return copy;
};

popCookie = function(name) {
  var ref, value;
  value = ((ref = document.cookie.match(new RegExp(name + &quot;=(\\w+)&quot;))) != null ? ref[1].toUpperCase() : void 0) || &#39;&#39;;
  document.cookie = name + &#39;=; expires=Thu, 01-Jan-70 00:00:01 GMT; path=/&#39;;
  return value;
};

triggerEvent = function(name, data) {
  var event;
  if (typeof Prototype !== &#39;undefined&#39;) {
    Event.fire(document, name, data, true);
  }
  event = document.createEvent(&#39;Events&#39;);
  if (data) {
    event.data = data;
  }
  event.initEvent(name, true, true);
  return document.dispatchEvent(event);
};

pageChangePrevented = function(url) {
  return !triggerEvent(EVENTS.BEFORE_CHANGE, {
    url: url
  });
};

processResponse = function() {
  var assetsChanged, clientOrServerError, doc, extractTrackAssets, intersection, validContent;
  clientOrServerError = function() {
    var ref;
    return (400 &lt;= (ref = xhr.status) &amp;&amp; ref &lt; 600);
  };
  validContent = function() {
    var contentType;
    return ((contentType = xhr.getResponseHeader(&#39;Content-Type&#39;)) != null) &amp;&amp; contentType.match(/^(?:text\/html|application\/xhtml\+xml|application\/xml)(?:;|$)/);
  };
  extractTrackAssets = function(doc) {
    var i, len, node, ref, results;
    ref = doc.querySelector(&#39;head&#39;).childNodes;
    results = [];
    for (i = 0, len = ref.length; i &lt; len; i++) {
      node = ref[i];
      if ((typeof node.getAttribute === &quot;function&quot; ? node.getAttribute(&#39;data-turbolinks-track&#39;) : void 0) != null) {
        results.push(node.getAttribute(&#39;src&#39;) || node.getAttribute(&#39;href&#39;));
      }
    }
    return results;
  };
  assetsChanged = function(doc) {
    var fetchedAssets;
    loadedAssets || (loadedAssets = extractTrackAssets(document));
    fetchedAssets = extractTrackAssets(doc);
    return fetchedAssets.length !== loadedAssets.length || intersection(fetchedAssets, loadedAssets).length !== loadedAssets.length;
  };
  intersection = function(a, b) {
    var i, len, ref, results, value;
    if (a.length &gt; b.length) {
      ref = [b, a], a = ref[0], b = ref[1];
    }
    results = [];
    for (i = 0, len = a.length; i &lt; len; i++) {
      value = a[i];
      if (indexOf.call(b, value) &gt;= 0) {
        results.push(value);
      }
    }
    return results;
  };
  if (!clientOrServerError() &amp;&amp; validContent()) {
    doc = createDocument(xhr.responseText);
    if (doc &amp;&amp; !assetsChanged(doc)) {
      return doc;
    }
  }
};

extractTitleAndBody = function(doc) {
  var title;
  title = doc.querySelector(&#39;title&#39;);
  return [title != null ? title.textContent : void 0, removeNoscriptTags(doc.querySelector(&#39;body&#39;)), CSRFToken.get(doc).token, &#39;runScripts&#39;];
};

CSRFToken = {
  get: function(doc) {
    var tag;
    if (doc == null) {
      doc = document;
    }
    return {
      node: tag = doc.querySelector(&#39;meta[name=&quot;csrf-token&quot;]&#39;),
      token: tag != null ? typeof tag.getAttribute === &quot;function&quot; ? tag.getAttribute(&#39;content&#39;) : void 0 : void 0
    };
  },
  update: function(latest) {
    var current;
    current = this.get();
    if ((current.token != null) &amp;&amp; (latest != null) &amp;&amp; current.token !== latest) {
      return current.node.setAttribute(&#39;content&#39;, latest);
    }
  }
};

createDocument = function(html) {
  var doc;
  doc = document.documentElement.cloneNode();
  doc.innerHTML = html;
  doc.head = doc.querySelector(&#39;head&#39;);
  doc.body = doc.querySelector(&#39;body&#39;);
  return doc;
};

ComponentUrl = (function() {
  function ComponentUrl(original1) {
    this.original = original1 != null ? original1 : document.location.href;
    if (this.original.constructor === ComponentUrl) {
      return this.original;
    }
    this._parse();
  }

  ComponentUrl.prototype.withoutHash = function() {
    return this.href.replace(this.hash, &#39;&#39;).replace(&#39;#&#39;, &#39;&#39;);
  };

  ComponentUrl.prototype.withoutHashForIE10compatibility = function() {
    return this.withoutHash();
  };

  ComponentUrl.prototype.hasNoHash = function() {
    return this.hash.length === 0;
  };

  ComponentUrl.prototype.crossOrigin = function() {
    return this.origin !== (new ComponentUrl).origin;
  };

  ComponentUrl.prototype._parse = function() {
    var ref;
    (this.link != null ? this.link : this.link = document.createElement(&#39;a&#39;)).href = this.original;
    ref = this.link, this.href = ref.href, this.protocol = ref.protocol, this.host = ref.host, this.hostname = ref.hostname, this.port = ref.port, this.pathname = ref.pathname, this.search = ref.search, this.hash = ref.hash;
    this.origin = [this.protocol, &#39;//&#39;, this.hostname].join(&#39;&#39;);
    if (this.port.length !== 0) {
      this.origin += &quot;:&quot; + this.port;
    }
    this.relative = [this.pathname, this.search, this.hash].join(&#39;&#39;);
    return this.absolute = this.href;
  };

  return ComponentUrl;

})();

Link = (function(superClass) {
  extend(Link, superClass);

  Link.HTML_EXTENSIONS = [&#39;html&#39;];

  Link.allowExtensions = function() {
    var extension, extensions, i, len;
    extensions = 1 &lt;= arguments.length ? slice.call(arguments, 0) : [];
    for (i = 0, len = extensions.length; i &lt; len; i++) {
      extension = extensions[i];
      Link.HTML_EXTENSIONS.push(extension);
    }
    return Link.HTML_EXTENSIONS;
  };

  function Link(link1) {
    this.link = link1;
    if (this.link.constructor === Link) {
      return this.link;
    }
    this.original = this.link.href;
    this.originalElement = this.link;
    this.link = this.link.cloneNode(false);
    Link.__super__.constructor.apply(this, arguments);
  }

  Link.prototype.shouldIgnore = function() {
    return this.crossOrigin() || this._anchored() || this._nonHtml() || this._optOut() || this._target();
  };

  Link.prototype._anchored = function() {
    return (this.hash.length &gt; 0 || this.href.charAt(this.href.length - 1) === &#39;#&#39;) &amp;&amp; (this.withoutHash() === (new ComponentUrl).withoutHash());
  };

  Link.prototype._nonHtml = function() {
    return this.pathname.match(/\.[a-z]+$/g) &amp;&amp; !this.pathname.match(new RegExp(&quot;\\.(?:&quot; + (Link.HTML_EXTENSIONS.join(&#39;|&#39;)) + &quot;)?$&quot;, &#39;g&#39;));
  };

  Link.prototype._optOut = function() {
    var ignore, link;
    link = this.originalElement;
    while (!(ignore || link === document)) {
      ignore = link.getAttribute(&#39;data-no-turbolink&#39;) != null;
      link = link.parentNode;
    }
    return ignore;
  };

  Link.prototype._target = function() {
    return this.link.target.length !== 0;
  };

  return Link;

})(ComponentUrl);

Click = (function() {
  Click.installHandlerLast = function(event) {
    if (!event.defaultPrevented) {
      document.removeEventListener(&#39;click&#39;, Click.handle, false);
      return document.addEventListener(&#39;click&#39;, Click.handle, false);
    }
  };

  Click.handle = function(event) {
    return new Click(event);
  };

  function Click(event1) {
    this.event = event1;
    if (this.event.defaultPrevented) {
      return;
    }
    this._extractLink();
    if (this._validForTurbolinks()) {
      if (!pageChangePrevented(this.link.absolute)) {
        visit(this.link.href);
      }
      this.event.preventDefault();
    }
  }

  Click.prototype._extractLink = function() {
    var link;
    link = this.event.target;
    while (!(!link.parentNode || link.nodeName === &#39;A&#39;)) {
      link = link.parentNode;
    }
    if (link.nodeName === &#39;A&#39; &amp;&amp; link.href.length !== 0) {
      return this.link = new Link(link);
    }
  };

  Click.prototype._validForTurbolinks = function() {
    return (this.link != null) &amp;&amp; !(this.link.shouldIgnore() || this._nonStandardClick());
  };

  Click.prototype._nonStandardClick = function() {
    return this.event.which &gt; 1 || this.event.metaKey || this.event.ctrlKey || this.event.shiftKey || this.event.altKey;
  };

  return Click;

})();

ProgressBar = (function() {
  var className;

  className = &#39;turbolinks-progress-bar&#39;;

  function ProgressBar(elementSelector) {
    this.elementSelector = elementSelector;
    this._trickle = bind(this._trickle, this);
    this.value = 0;
    this.content = &#39;&#39;;
    this.speed = 300;
    this.opacity = 0.99;
    this.install();
  }

  ProgressBar.prototype.install = function() {
    this.element = document.querySelector(this.elementSelector);
    this.element.classList.add(className);
    this.styleElement = document.createElement(&#39;style&#39;);
    document.head.appendChild(this.styleElement);
    return this._updateStyle();
  };

  ProgressBar.prototype.uninstall = function() {
    this.element.classList.remove(className);
    return document.head.removeChild(this.styleElement);
  };

  ProgressBar.prototype.start = function() {
    return this.advanceTo(5);
  };

  ProgressBar.prototype.advanceTo = function(value) {
    var ref;
    if ((value &gt; (ref = this.value) &amp;&amp; ref &lt;= 100)) {
      this.value = value;
      this._updateStyle();
      if (this.value === 100) {
        return this._stopTrickle();
      } else if (this.value &gt; 0) {
        return this._startTrickle();
      }
    }
  };

  ProgressBar.prototype.done = function() {
    if (this.value &gt; 0) {
      this.advanceTo(100);
      return this._reset();
    }
  };

  ProgressBar.prototype._reset = function() {
    var originalOpacity;
    originalOpacity = this.opacity;
    setTimeout((function(_this) {
      return function() {
        _this.opacity = 0;
        return _this._updateStyle();
      };
    })(this), this.speed / 2);
    return setTimeout((function(_this) {
      return function() {
        _this.value = 0;
        _this.opacity = originalOpacity;
        return _this._withSpeed(0, function() {
          return _this._updateStyle(true);
        });
      };
    })(this), this.speed);
  };

  ProgressBar.prototype._startTrickle = function() {
    if (this.trickling) {
      return;
    }
    this.trickling = true;
    return setTimeout(this._trickle, this.speed);
  };

  ProgressBar.prototype._stopTrickle = function() {
    return delete this.trickling;
  };

  ProgressBar.prototype._trickle = function() {
    if (!this.trickling) {
      return;
    }
    this.advanceTo(this.value + Math.random() / 2);
    return setTimeout(this._trickle, this.speed);
  };

  ProgressBar.prototype._withSpeed = function(speed, fn) {
    var originalSpeed, result;
    originalSpeed = this.speed;
    this.speed = speed;
    result = fn();
    this.speed = originalSpeed;
    return result;
  };

  ProgressBar.prototype._updateStyle = function(forceRepaint) {
    if (forceRepaint == null) {
      forceRepaint = false;
    }
    if (forceRepaint) {
      this._changeContentToForceRepaint();
    }
    return this.styleElement.textContent = this._createCSSRule();
  };

  ProgressBar.prototype._changeContentToForceRepaint = function() {
    return this.content = this.content === &#39;&#39; ? &#39; &#39; : &#39;&#39;;
  };

  ProgressBar.prototype._createCSSRule = function() {
    return this.elementSelector + &quot;.&quot; + className + &quot;::before {\n  content: &#39;&quot; + this.content + &quot;&#39;;\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 2000;\n  background-color: #0076ff;\n  height: 3px;\n  opacity: &quot; + this.opacity + &quot;;\n  width: &quot; + this.value + &quot;%;\n  transition: width &quot; + this.speed + &quot;ms ease-out, opacity &quot; + (this.speed / 2) + &quot;ms ease-in;\n  transform: translate3d(0,0,0);\n}&quot;;
  };

  return ProgressBar;

})();

bypassOnLoadPopstate = function(fn) {
  return setTimeout(fn, 500);
};

installDocumentReadyPageEventTriggers = function() {
  return document.addEventListener(&#39;DOMContentLoaded&#39;, (function() {
    triggerEvent(EVENTS.CHANGE);
    return triggerEvent(EVENTS.UPDATE);
  }), true);
};

installJqueryAjaxSuccessPageUpdateTrigger = function() {
  if (typeof jQuery !== &#39;undefined&#39;) {
    return jQuery(document).on(&#39;ajaxSuccess&#39;, function(event, xhr, settings) {
      if (!jQuery.trim(xhr.responseText)) {
        return;
      }
      return triggerEvent(EVENTS.UPDATE);
    });
  }
};

installHistoryChangeHandler = function(event) {
  var cachedPage, ref;
  if ((ref = event.state) != null ? ref.turbolinks : void 0) {
    if (cachedPage = pageCache[(new ComponentUrl(event.state.url)).absolute]) {
      cacheCurrentPage();
      return fetchHistory(cachedPage);
    } else {
      return visit(event.target.location.href);
    }
  }
};

initializeTurbolinks = function() {
  rememberCurrentUrl();
  rememberCurrentState();
  document.addEventListener(&#39;click&#39;, Click.installHandlerLast, true);
  window.addEventListener(&#39;hashchange&#39;, function(event) {
    rememberCurrentUrl();
    return rememberCurrentState();
  }, false);
  return bypassOnLoadPopstate(function() {
    return window.addEventListener(&#39;popstate&#39;, installHistoryChangeHandler, false);
  });
};

historyStateIsDefined = window.history.state !== void 0 || navigator.userAgent.match(/Firefox\/2[6|7]/);

browserSupportsPushState = window.history &amp;&amp; window.history.pushState &amp;&amp; window.history.replaceState &amp;&amp; historyStateIsDefined;

browserIsntBuggy = !navigator.userAgent.match(/CriOS\//);

requestMethodIsSafe = (ref = popCookie(&#39;request_method&#39;)) === &#39;GET&#39; || ref === &#39;&#39;;

browserSupportsTurbolinks = browserSupportsPushState &amp;&amp; browserIsntBuggy &amp;&amp; requestMethodIsSafe;

browserSupportsCustomEvents = document.addEventListener &amp;&amp; document.createEvent;

if (browserSupportsCustomEvents) {
  installDocumentReadyPageEventTriggers();
  installJqueryAjaxSuccessPageUpdateTrigger();
}

if (browserSupportsTurbolinks) {
  visit = fetch;
  initializeTurbolinks();
} else {
  visit = function(url) {
    return document.location.href = url;
  };
}

this.Turbolinks = {
  visit: visit,
  pagesCached: pagesCached,
  enableTransitionCache: enableTransitionCache,
  enableProgressBar: enableProgressBar,
  allowLinkExtensions: Link.allowExtensions,
  supported: browserSupportsTurbolinks,
  EVENTS: clone(EVENTS)
};</pre>

<p>}).call(this); /*
========================================================================</p>

<pre>Bootstrap: affix.js v3.3.6
http://getbootstrap.com/javascript/#affix
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// AFFIX CLASS DEFINITION
// ======================

var Affix = function (element, options) {
  this.options = $.extend({}, Affix.DEFAULTS, options)

  this.$target = $(this.options.target)
    .on(&#39;scroll.bs.affix.data-api&#39;, $.proxy(this.checkPosition, this))
    .on(&#39;click.bs.affix.data-api&#39;,  $.proxy(this.checkPositionWithEventLoop, this))

  this.$element     = $(element)
  this.affixed      = null
  this.unpin        = null
  this.pinnedOffset = null

  this.checkPosition()
}

Affix.VERSION  = &#39;3.3.6&#39;

Affix.RESET    = &#39;affix affix-top affix-bottom&#39;

Affix.DEFAULTS = {
  offset: 0,
  target: window
}

Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
  var scrollTop    = this.$target.scrollTop()
  var position     = this.$element.offset()
  var targetHeight = this.$target.height()

  if (offsetTop != null &amp;&amp; this.affixed == &#39;top&#39;) return scrollTop &lt; offsetTop ? &#39;top&#39; : false

  if (this.affixed == &#39;bottom&#39;) {
    if (offsetTop != null) return (scrollTop + this.unpin &lt;= position.top) ? false : &#39;bottom&#39;
    return (scrollTop + targetHeight &lt;= scrollHeight - offsetBottom) ? false : &#39;bottom&#39;
  }

  var initializing   = this.affixed == null
  var colliderTop    = initializing ? scrollTop : position.top
  var colliderHeight = initializing ? targetHeight : height

  if (offsetTop != null &amp;&amp; scrollTop &lt;= offsetTop) return &#39;top&#39;
  if (offsetBottom != null &amp;&amp; (colliderTop + colliderHeight &gt;= scrollHeight - offsetBottom)) return &#39;bottom&#39;

  return false
}

Affix.prototype.getPinnedOffset = function () {
  if (this.pinnedOffset) return this.pinnedOffset
  this.$element.removeClass(Affix.RESET).addClass(&#39;affix&#39;)
  var scrollTop = this.$target.scrollTop()
  var position  = this.$element.offset()
  return (this.pinnedOffset = position.top - scrollTop)
}

Affix.prototype.checkPositionWithEventLoop = function () {
  setTimeout($.proxy(this.checkPosition, this), 1)
}

Affix.prototype.checkPosition = function () {
  if (!this.$element.is(&#39;:visible&#39;)) return

  var height       = this.$element.height()
  var offset       = this.options.offset
  var offsetTop    = offset.top
  var offsetBottom = offset.bottom
  var scrollHeight = Math.max($(document).height(), $(document.body).height())

  if (typeof offset != &#39;object&#39;)         offsetBottom = offsetTop = offset
  if (typeof offsetTop == &#39;function&#39;)    offsetTop    = offset.top(this.$element)
  if (typeof offsetBottom == &#39;function&#39;) offsetBottom = offset.bottom(this.$element)

  var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

  if (this.affixed != affix) {
    if (this.unpin != null) this.$element.css(&#39;top&#39;, &#39;&#39;)

    var affixType = &#39;affix&#39; + (affix ? &#39;-&#39; + affix : &#39;&#39;)
    var e         = $.Event(affixType + &#39;.bs.affix&#39;)

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    this.affixed = affix
    this.unpin = affix == &#39;bottom&#39; ? this.getPinnedOffset() : null

    this.$element
      .removeClass(Affix.RESET)
      .addClass(affixType)
      .trigger(affixType.replace(&#39;affix&#39;, &#39;affixed&#39;) + &#39;.bs.affix&#39;)
  }

  if (affix == &#39;bottom&#39;) {
    this.$element.offset({
      top: scrollHeight - height - offsetBottom
    })
  }
}

// AFFIX PLUGIN DEFINITION
// =======================

function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.affix&#39;)
    var options = typeof option == &#39;object&#39; &amp;&amp; option

    if (!data) $this.data(&#39;bs.affix&#39;, (data = new Affix(this, options)))
    if (typeof option == &#39;string&#39;) data[option]()
  })
}

var old = $.fn.affix

$.fn.affix             = Plugin
$.fn.affix.Constructor = Affix

// AFFIX NO CONFLICT
// =================

$.fn.affix.noConflict = function () {
  $.fn.affix = old
  return this
}

// AFFIX DATA-API
// ==============

$(window).on(&#39;load&#39;, function () {
  $(&#39;[data-spy=&quot;affix&quot;]&#39;).each(function () {
    var $spy = $(this)
    var data = $spy.data()

    data.offset = data.offset || {}

    if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
    if (data.offsetTop    != null) data.offset.top    = data.offsetTop

    Plugin.call($spy, data)
  })
})</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: alert.js v3.3.6
http://getbootstrap.com/javascript/#alerts
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// ALERT CLASS DEFINITION
// ======================

var dismiss = &#39;[data-dismiss=&quot;alert&quot;]&#39;
var Alert   = function (el) {
  $(el).on(&#39;click&#39;, dismiss, this.close)
}

Alert.VERSION = &#39;3.3.6&#39;

Alert.TRANSITION_DURATION = 150

Alert.prototype.close = function (e) {
  var $this    = $(this)
  var selector = $this.attr(&#39;data-target&#39;)

  if (!selector) {
    selector = $this.attr(&#39;href&#39;)
    selector = selector &amp;&amp; selector.replace(/.*(?=#[^\s]*$)/, &#39;&#39;) // strip for ie7
  }

  var $parent = $(selector)

  if (e) e.preventDefault()

  if (!$parent.length) {
    $parent = $this.closest(&#39;.alert&#39;)
  }

  $parent.trigger(e = $.Event(&#39;close.bs.alert&#39;))

  if (e.isDefaultPrevented()) return

  $parent.removeClass(&#39;in&#39;)

  function removeElement() {
    // detach from parent, fire event then clean up data
    $parent.detach().trigger(&#39;closed.bs.alert&#39;).remove()
  }

  $.support.transition &amp;&amp; $parent.hasClass(&#39;fade&#39;) ?
    $parent
      .one(&#39;bsTransitionEnd&#39;, removeElement)
      .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
    removeElement()
}

// ALERT PLUGIN DEFINITION
// =======================

function Plugin(option) {
  return this.each(function () {
    var $this = $(this)
    var data  = $this.data(&#39;bs.alert&#39;)

    if (!data) $this.data(&#39;bs.alert&#39;, (data = new Alert(this)))
    if (typeof option == &#39;string&#39;) data[option].call($this)
  })
}

var old = $.fn.alert

$.fn.alert             = Plugin
$.fn.alert.Constructor = Alert

// ALERT NO CONFLICT
// =================

$.fn.alert.noConflict = function () {
  $.fn.alert = old
  return this
}

// ALERT DATA-API
// ==============

$(document).on(&#39;click.bs.alert.data-api&#39;, dismiss, Alert.prototype.close)</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: button.js v3.3.6
http://getbootstrap.com/javascript/#buttons
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// BUTTON PUBLIC CLASS DEFINITION
// ==============================

var Button = function (element, options) {
  this.$element  = $(element)
  this.options   = $.extend({}, Button.DEFAULTS, options)
  this.isLoading = false
}

Button.VERSION  = &#39;3.3.6&#39;

Button.DEFAULTS = {
  loadingText: &#39;loading...&#39;
}

Button.prototype.setState = function (state) {
  var d    = &#39;disabled&#39;
  var $el  = this.$element
  var val  = $el.is(&#39;input&#39;) ? &#39;val&#39; : &#39;html&#39;
  var data = $el.data()

  state += &#39;Text&#39;

  if (data.resetText == null) $el.data(&#39;resetText&#39;, $el[val]())

  // push to event loop to allow forms to submit
  setTimeout($.proxy(function () {
    $el[val](data[state] == null ? this.options[state] : data[state])

    if (state == &#39;loadingText&#39;) {
      this.isLoading = true
      $el.addClass(d).attr(d, d)
    } else if (this.isLoading) {
      this.isLoading = false
      $el.removeClass(d).removeAttr(d)
    }
  }, this), 0)
}

Button.prototype.toggle = function () {
  var changed = true
  var $parent = this.$element.closest(&#39;[data-toggle=&quot;buttons&quot;]&#39;)

  if ($parent.length) {
    var $input = this.$element.find(&#39;input&#39;)
    if ($input.prop(&#39;type&#39;) == &#39;radio&#39;) {
      if ($input.prop(&#39;checked&#39;)) changed = false
      $parent.find(&#39;.active&#39;).removeClass(&#39;active&#39;)
      this.$element.addClass(&#39;active&#39;)
    } else if ($input.prop(&#39;type&#39;) == &#39;checkbox&#39;) {
      if (($input.prop(&#39;checked&#39;)) !== this.$element.hasClass(&#39;active&#39;)) changed = false
      this.$element.toggleClass(&#39;active&#39;)
    }
    $input.prop(&#39;checked&#39;, this.$element.hasClass(&#39;active&#39;))
    if (changed) $input.trigger(&#39;change&#39;)
  } else {
    this.$element.attr(&#39;aria-pressed&#39;, !this.$element.hasClass(&#39;active&#39;))
    this.$element.toggleClass(&#39;active&#39;)
  }
}

// BUTTON PLUGIN DEFINITION
// ========================

function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.button&#39;)
    var options = typeof option == &#39;object&#39; &amp;&amp; option

    if (!data) $this.data(&#39;bs.button&#39;, (data = new Button(this, options)))

    if (option == &#39;toggle&#39;) data.toggle()
    else if (option) data.setState(option)
  })
}

var old = $.fn.button

$.fn.button             = Plugin
$.fn.button.Constructor = Button

// BUTTON NO CONFLICT
// ==================

$.fn.button.noConflict = function () {
  $.fn.button = old
  return this
}

// BUTTON DATA-API
// ===============

$(document)
  .on(&#39;click.bs.button.data-api&#39;, &#39;[data-toggle^=&quot;button&quot;]&#39;, function (e) {
    var $btn = $(e.target)
    if (!$btn.hasClass(&#39;btn&#39;)) $btn = $btn.closest(&#39;.btn&#39;)
    Plugin.call($btn, &#39;toggle&#39;)
    if (!($(e.target).is(&#39;input[type=&quot;radio&quot;]&#39;) || $(e.target).is(&#39;input[type=&quot;checkbox&quot;]&#39;))) e.preventDefault()
  })
  .on(&#39;focus.bs.button.data-api blur.bs.button.data-api&#39;, &#39;[data-toggle^=&quot;button&quot;]&#39;, function (e) {
    $(e.target).closest(&#39;.btn&#39;).toggleClass(&#39;focus&#39;, /^focus(in)?$/.test(e.type))
  })</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: carousel.js v3.3.6
http://getbootstrap.com/javascript/#carousel
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// CAROUSEL CLASS DEFINITION
// =========================

var Carousel = function (element, options) {
  this.$element    = $(element)
  this.$indicators = this.$element.find(&#39;.carousel-indicators&#39;)
  this.options     = options
  this.paused      = null
  this.sliding     = null
  this.interval    = null
  this.$active     = null
  this.$items      = null

  this.options.keyboard &amp;&amp; this.$element.on(&#39;keydown.bs.carousel&#39;, $.proxy(this.keydown, this))

  this.options.pause == &#39;hover&#39; &amp;&amp; !(&#39;ontouchstart&#39; in document.documentElement) &amp;&amp; this.$element
    .on(&#39;mouseenter.bs.carousel&#39;, $.proxy(this.pause, this))
    .on(&#39;mouseleave.bs.carousel&#39;, $.proxy(this.cycle, this))
}

Carousel.VERSION  = &#39;3.3.6&#39;

Carousel.TRANSITION_DURATION = 600

Carousel.DEFAULTS = {
  interval: 5000,
  pause: &#39;hover&#39;,
  wrap: true,
  keyboard: true
}

Carousel.prototype.keydown = function (e) {
  if (/input|textarea/i.test(e.target.tagName)) return
  switch (e.which) {
    case 37: this.prev(); break
    case 39: this.next(); break
    default: return
  }

  e.preventDefault()
}

Carousel.prototype.cycle = function (e) {
  e || (this.paused = false)

  this.interval &amp;&amp; clearInterval(this.interval)

  this.options.interval
    &amp;&amp; !this.paused
    &amp;&amp; (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

  return this
}

Carousel.prototype.getItemIndex = function (item) {
  this.$items = item.parent().children(&#39;.item&#39;)
  return this.$items.index(item || this.$active)
}

Carousel.prototype.getItemForDirection = function (direction, active) {
  var activeIndex = this.getItemIndex(active)
  var willWrap = (direction == &#39;prev&#39; &amp;&amp; activeIndex === 0)
              || (direction == &#39;next&#39; &amp;&amp; activeIndex == (this.$items.length - 1))
  if (willWrap &amp;&amp; !this.options.wrap) return active
  var delta = direction == &#39;prev&#39; ? -1 : 1
  var itemIndex = (activeIndex + delta) % this.$items.length
  return this.$items.eq(itemIndex)
}

Carousel.prototype.to = function (pos) {
  var that        = this
  var activeIndex = this.getItemIndex(this.$active = this.$element.find(&#39;.item.active&#39;))

  if (pos &gt; (this.$items.length - 1) || pos &lt; 0) return

  if (this.sliding)       return this.$element.one(&#39;slid.bs.carousel&#39;, function () { that.to(pos) }) // yes, &quot;slid&quot;
  if (activeIndex == pos) return this.pause().cycle()

  return this.slide(pos &gt; activeIndex ? &#39;next&#39; : &#39;prev&#39;, this.$items.eq(pos))
}

Carousel.prototype.pause = function (e) {
  e || (this.paused = true)

  if (this.$element.find(&#39;.next, .prev&#39;).length &amp;&amp; $.support.transition) {
    this.$element.trigger($.support.transition.end)
    this.cycle(true)
  }

  this.interval = clearInterval(this.interval)

  return this
}

Carousel.prototype.next = function () {
  if (this.sliding) return
  return this.slide(&#39;next&#39;)
}

Carousel.prototype.prev = function () {
  if (this.sliding) return
  return this.slide(&#39;prev&#39;)
}

Carousel.prototype.slide = function (type, next) {
  var $active   = this.$element.find(&#39;.item.active&#39;)
  var $next     = next || this.getItemForDirection(type, $active)
  var isCycling = this.interval
  var direction = type == &#39;next&#39; ? &#39;left&#39; : &#39;right&#39;
  var that      = this

  if ($next.hasClass(&#39;active&#39;)) return (this.sliding = false)

  var relatedTarget = $next[0]
  var slideEvent = $.Event(&#39;slide.bs.carousel&#39;, {
    relatedTarget: relatedTarget,
    direction: direction
  })
  this.$element.trigger(slideEvent)
  if (slideEvent.isDefaultPrevented()) return

  this.sliding = true

  isCycling &amp;&amp; this.pause()

  if (this.$indicators.length) {
    this.$indicators.find(&#39;.active&#39;).removeClass(&#39;active&#39;)
    var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
    $nextIndicator &amp;&amp; $nextIndicator.addClass(&#39;active&#39;)
  }

  var slidEvent = $.Event(&#39;slid.bs.carousel&#39;, { relatedTarget: relatedTarget, direction: direction }) // yes, &quot;slid&quot;
  if ($.support.transition &amp;&amp; this.$element.hasClass(&#39;slide&#39;)) {
    $next.addClass(type)
    $next[0].offsetWidth // force reflow
    $active.addClass(direction)
    $next.addClass(direction)
    $active
      .one(&#39;bsTransitionEnd&#39;, function () {
        $next.removeClass([type, direction].join(&#39; &#39;)).addClass(&#39;active&#39;)
        $active.removeClass([&#39;active&#39;, direction].join(&#39; &#39;))
        that.sliding = false
        setTimeout(function () {
          that.$element.trigger(slidEvent)
        }, 0)
      })
      .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
  } else {
    $active.removeClass(&#39;active&#39;)
    $next.addClass(&#39;active&#39;)
    this.sliding = false
    this.$element.trigger(slidEvent)
  }

  isCycling &amp;&amp; this.cycle()

  return this
}

// CAROUSEL PLUGIN DEFINITION
// ==========================

function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.carousel&#39;)
    var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == &#39;object&#39; &amp;&amp; option)
    var action  = typeof option == &#39;string&#39; ? option : options.slide

    if (!data) $this.data(&#39;bs.carousel&#39;, (data = new Carousel(this, options)))
    if (typeof option == &#39;number&#39;) data.to(option)
    else if (action) data[action]()
    else if (options.interval) data.pause().cycle()
  })
}

var old = $.fn.carousel

$.fn.carousel             = Plugin
$.fn.carousel.Constructor = Carousel

// CAROUSEL NO CONFLICT
// ====================

$.fn.carousel.noConflict = function () {
  $.fn.carousel = old
  return this
}

// CAROUSEL DATA-API
// =================

var clickHandler = function (e) {
  var href
  var $this   = $(this)
  var $target = $($this.attr(&#39;data-target&#39;) || (href = $this.attr(&#39;href&#39;)) &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, &#39;&#39;)) // strip for ie7
  if (!$target.hasClass(&#39;carousel&#39;)) return
  var options = $.extend({}, $target.data(), $this.data())
  var slideIndex = $this.attr(&#39;data-slide-to&#39;)
  if (slideIndex) options.interval = false

  Plugin.call($target, options)

  if (slideIndex) {
    $target.data(&#39;bs.carousel&#39;).to(slideIndex)
  }

  e.preventDefault()
}

$(document)
  .on(&#39;click.bs.carousel.data-api&#39;, &#39;[data-slide]&#39;, clickHandler)
  .on(&#39;click.bs.carousel.data-api&#39;, &#39;[data-slide-to]&#39;, clickHandler)

$(window).on(&#39;load&#39;, function () {
  $(&#39;[data-ride=&quot;carousel&quot;]&#39;).each(function () {
    var $carousel = $(this)
    Plugin.call($carousel, $carousel.data())
  })
})</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: collapse.js v3.3.6
http://getbootstrap.com/javascript/#collapse
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// COLLAPSE PUBLIC CLASS DEFINITION
// ================================

var Collapse = function (element, options) {
  this.$element      = $(element)
  this.options       = $.extend({}, Collapse.DEFAULTS, options)
  this.$trigger      = $(&#39;[data-toggle=&quot;collapse&quot;][href=&quot;#&#39; + element.id + &#39;&quot;],&#39; +
                         &#39;[data-toggle=&quot;collapse&quot;][data-target=&quot;#&#39; + element.id + &#39;&quot;]&#39;)
  this.transitioning = null

  if (this.options.parent) {
    this.$parent = this.getParent()
  } else {
    this.addAriaAndCollapsedClass(this.$element, this.$trigger)
  }

  if (this.options.toggle) this.toggle()
}

Collapse.VERSION  = &#39;3.3.6&#39;

Collapse.TRANSITION_DURATION = 350

Collapse.DEFAULTS = {
  toggle: true
}

Collapse.prototype.dimension = function () {
  var hasWidth = this.$element.hasClass(&#39;width&#39;)
  return hasWidth ? &#39;width&#39; : &#39;height&#39;
}

Collapse.prototype.show = function () {
  if (this.transitioning || this.$element.hasClass(&#39;in&#39;)) return

  var activesData
  var actives = this.$parent &amp;&amp; this.$parent.children(&#39;.panel&#39;).children(&#39;.in, .collapsing&#39;)

  if (actives &amp;&amp; actives.length) {
    activesData = actives.data(&#39;bs.collapse&#39;)
    if (activesData &amp;&amp; activesData.transitioning) return
  }

  var startEvent = $.Event(&#39;show.bs.collapse&#39;)
  this.$element.trigger(startEvent)
  if (startEvent.isDefaultPrevented()) return

  if (actives &amp;&amp; actives.length) {
    Plugin.call(actives, &#39;hide&#39;)
    activesData || actives.data(&#39;bs.collapse&#39;, null)
  }

  var dimension = this.dimension()

  this.$element
    .removeClass(&#39;collapse&#39;)
    .addClass(&#39;collapsing&#39;)[dimension](0)
    .attr(&#39;aria-expanded&#39;, true)

  this.$trigger
    .removeClass(&#39;collapsed&#39;)
    .attr(&#39;aria-expanded&#39;, true)

  this.transitioning = 1

  var complete = function () {
    this.$element
      .removeClass(&#39;collapsing&#39;)
      .addClass(&#39;collapse in&#39;)[dimension](&#39;&#39;)
    this.transitioning = 0
    this.$element
      .trigger(&#39;shown.bs.collapse&#39;)
  }

  if (!$.support.transition) return complete.call(this)

  var scrollSize = $.camelCase([&#39;scroll&#39;, dimension].join(&#39;-&#39;))

  this.$element
    .one(&#39;bsTransitionEnd&#39;, $.proxy(complete, this))
    .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
}

Collapse.prototype.hide = function () {
  if (this.transitioning || !this.$element.hasClass(&#39;in&#39;)) return

  var startEvent = $.Event(&#39;hide.bs.collapse&#39;)
  this.$element.trigger(startEvent)
  if (startEvent.isDefaultPrevented()) return

  var dimension = this.dimension()

  this.$element[dimension](this.$element[dimension]())[0].offsetHeight

  this.$element
    .addClass(&#39;collapsing&#39;)
    .removeClass(&#39;collapse in&#39;)
    .attr(&#39;aria-expanded&#39;, false)

  this.$trigger
    .addClass(&#39;collapsed&#39;)
    .attr(&#39;aria-expanded&#39;, false)

  this.transitioning = 1

  var complete = function () {
    this.transitioning = 0
    this.$element
      .removeClass(&#39;collapsing&#39;)
      .addClass(&#39;collapse&#39;)
      .trigger(&#39;hidden.bs.collapse&#39;)
  }

  if (!$.support.transition) return complete.call(this)

  this.$element
    [dimension](0)
    .one(&#39;bsTransitionEnd&#39;, $.proxy(complete, this))
    .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
}

Collapse.prototype.toggle = function () {
  this[this.$element.hasClass(&#39;in&#39;) ? &#39;hide&#39; : &#39;show&#39;]()
}

Collapse.prototype.getParent = function () {
  return $(this.options.parent)
    .find(&#39;[data-toggle=&quot;collapse&quot;][data-parent=&quot;&#39; + this.options.parent + &#39;&quot;]&#39;)
    .each($.proxy(function (i, element) {
      var $element = $(element)
      this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
    }, this))
    .end()
}

Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
  var isOpen = $element.hasClass(&#39;in&#39;)

  $element.attr(&#39;aria-expanded&#39;, isOpen)
  $trigger
    .toggleClass(&#39;collapsed&#39;, !isOpen)
    .attr(&#39;aria-expanded&#39;, isOpen)
}

function getTargetFromTrigger($trigger) {
  var href
  var target = $trigger.attr(&#39;data-target&#39;)
    || (href = $trigger.attr(&#39;href&#39;)) &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, &#39;&#39;) // strip for ie7

  return $(target)
}

// COLLAPSE PLUGIN DEFINITION
// ==========================

function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.collapse&#39;)
    var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == &#39;object&#39; &amp;&amp; option)

    if (!data &amp;&amp; options.toggle &amp;&amp; /show|hide/.test(option)) options.toggle = false
    if (!data) $this.data(&#39;bs.collapse&#39;, (data = new Collapse(this, options)))
    if (typeof option == &#39;string&#39;) data[option]()
  })
}

var old = $.fn.collapse

$.fn.collapse             = Plugin
$.fn.collapse.Constructor = Collapse

// COLLAPSE NO CONFLICT
// ====================

$.fn.collapse.noConflict = function () {
  $.fn.collapse = old
  return this
}

// COLLAPSE DATA-API
// =================

$(document).on(&#39;click.bs.collapse.data-api&#39;, &#39;[data-toggle=&quot;collapse&quot;]&#39;, function (e) {
  var $this   = $(this)

  if (!$this.attr(&#39;data-target&#39;)) e.preventDefault()

  var $target = getTargetFromTrigger($this)
  var data    = $target.data(&#39;bs.collapse&#39;)
  var option  = data ? &#39;toggle&#39; : $this.data()

  Plugin.call($target, option)
})</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: dropdown.js v3.3.6
http://getbootstrap.com/javascript/#dropdowns
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// DROPDOWN CLASS DEFINITION
// =========================

var backdrop = &#39;.dropdown-backdrop&#39;
var toggle   = &#39;[data-toggle=&quot;dropdown&quot;]&#39;
var Dropdown = function (element) {
  $(element).on(&#39;click.bs.dropdown&#39;, this.toggle)
}

Dropdown.VERSION = &#39;3.3.6&#39;

function getParent($this) {
  var selector = $this.attr(&#39;data-target&#39;)

  if (!selector) {
    selector = $this.attr(&#39;href&#39;)
    selector = selector &amp;&amp; /#[A-Za-z]/.test(selector) &amp;&amp; selector.replace(/.*(?=#[^\s]*$)/, &#39;&#39;) // strip for ie7
  }

  var $parent = selector &amp;&amp; $(selector)

  return $parent &amp;&amp; $parent.length ? $parent : $this.parent()
}

function clearMenus(e) {
  if (e &amp;&amp; e.which === 3) return
  $(backdrop).remove()
  $(toggle).each(function () {
    var $this         = $(this)
    var $parent       = getParent($this)
    var relatedTarget = { relatedTarget: this }

    if (!$parent.hasClass(&#39;open&#39;)) return

    if (e &amp;&amp; e.type == &#39;click&#39; &amp;&amp; /input|textarea/i.test(e.target.tagName) &amp;&amp; $.contains($parent[0], e.target)) return

    $parent.trigger(e = $.Event(&#39;hide.bs.dropdown&#39;, relatedTarget))

    if (e.isDefaultPrevented()) return

    $this.attr(&#39;aria-expanded&#39;, &#39;false&#39;)
    $parent.removeClass(&#39;open&#39;).trigger($.Event(&#39;hidden.bs.dropdown&#39;, relatedTarget))
  })
}

Dropdown.prototype.toggle = function (e) {
  var $this = $(this)

  if ($this.is(&#39;.disabled, :disabled&#39;)) return

  var $parent  = getParent($this)
  var isActive = $parent.hasClass(&#39;open&#39;)

  clearMenus()

  if (!isActive) {
    if (&#39;ontouchstart&#39; in document.documentElement &amp;&amp; !$parent.closest(&#39;.navbar-nav&#39;).length) {
      // if mobile we use a backdrop because click events don&#39;t delegate
      $(document.createElement(&#39;div&#39;))
        .addClass(&#39;dropdown-backdrop&#39;)
        .insertAfter($(this))
        .on(&#39;click&#39;, clearMenus)
    }

    var relatedTarget = { relatedTarget: this }
    $parent.trigger(e = $.Event(&#39;show.bs.dropdown&#39;, relatedTarget))

    if (e.isDefaultPrevented()) return

    $this
      .trigger(&#39;focus&#39;)
      .attr(&#39;aria-expanded&#39;, &#39;true&#39;)

    $parent
      .toggleClass(&#39;open&#39;)
      .trigger($.Event(&#39;shown.bs.dropdown&#39;, relatedTarget))
  }

  return false
}

Dropdown.prototype.keydown = function (e) {
  if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

  var $this = $(this)

  e.preventDefault()
  e.stopPropagation()

  if ($this.is(&#39;.disabled, :disabled&#39;)) return

  var $parent  = getParent($this)
  var isActive = $parent.hasClass(&#39;open&#39;)

  if (!isActive &amp;&amp; e.which != 27 || isActive &amp;&amp; e.which == 27) {
    if (e.which == 27) $parent.find(toggle).trigger(&#39;focus&#39;)
    return $this.trigger(&#39;click&#39;)
  }

  var desc = &#39; li:not(.disabled):visible a&#39;
  var $items = $parent.find(&#39;.dropdown-menu&#39; + desc)

  if (!$items.length) return

  var index = $items.index(e.target)

  if (e.which == 38 &amp;&amp; index &gt; 0)                 index--         // up
  if (e.which == 40 &amp;&amp; index &lt; $items.length - 1) index++         // down
  if (!~index)                                    index = 0

  $items.eq(index).trigger(&#39;focus&#39;)
}

// DROPDOWN PLUGIN DEFINITION
// ==========================

function Plugin(option) {
  return this.each(function () {
    var $this = $(this)
    var data  = $this.data(&#39;bs.dropdown&#39;)

    if (!data) $this.data(&#39;bs.dropdown&#39;, (data = new Dropdown(this)))
    if (typeof option == &#39;string&#39;) data[option].call($this)
  })
}

var old = $.fn.dropdown

$.fn.dropdown             = Plugin
$.fn.dropdown.Constructor = Dropdown

// DROPDOWN NO CONFLICT
// ====================

$.fn.dropdown.noConflict = function () {
  $.fn.dropdown = old
  return this
}

// APPLY TO STANDARD DROPDOWN ELEMENTS
// ===================================

$(document)
  .on(&#39;click.bs.dropdown.data-api&#39;, clearMenus)
  .on(&#39;click.bs.dropdown.data-api&#39;, &#39;.dropdown form&#39;, function (e) { e.stopPropagation() })
  .on(&#39;click.bs.dropdown.data-api&#39;, toggle, Dropdown.prototype.toggle)
  .on(&#39;keydown.bs.dropdown.data-api&#39;, toggle, Dropdown.prototype.keydown)
  .on(&#39;keydown.bs.dropdown.data-api&#39;, &#39;.dropdown-menu&#39;, Dropdown.prototype.keydown)</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: modal.js v3.3.6
http://getbootstrap.com/javascript/#modals
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// MODAL CLASS DEFINITION
// ======================

var Modal = function (element, options) {
  this.options             = options
  this.$body               = $(document.body)
  this.$element            = $(element)
  this.$dialog             = this.$element.find(&#39;.modal-dialog&#39;)
  this.$backdrop           = null
  this.isShown             = null
  this.originalBodyPad     = null
  this.scrollbarWidth      = 0
  this.ignoreBackdropClick = false

  if (this.options.remote) {
    this.$element
      .find(&#39;.modal-content&#39;)
      .load(this.options.remote, $.proxy(function () {
        this.$element.trigger(&#39;loaded.bs.modal&#39;)
      }, this))
  }
}

Modal.VERSION  = &#39;3.3.6&#39;

Modal.TRANSITION_DURATION = 300
Modal.BACKDROP_TRANSITION_DURATION = 150

Modal.DEFAULTS = {
  backdrop: true,
  keyboard: true,
  show: true
}

Modal.prototype.toggle = function (_relatedTarget) {
  return this.isShown ? this.hide() : this.show(_relatedTarget)
}

Modal.prototype.show = function (_relatedTarget) {
  var that = this
  var e    = $.Event(&#39;show.bs.modal&#39;, { relatedTarget: _relatedTarget })

  this.$element.trigger(e)

  if (this.isShown || e.isDefaultPrevented()) return

  this.isShown = true

  this.checkScrollbar()
  this.setScrollbar()
  this.$body.addClass(&#39;modal-open&#39;)

  this.escape()
  this.resize()

  this.$element.on(&#39;click.dismiss.bs.modal&#39;, &#39;[data-dismiss=&quot;modal&quot;]&#39;, $.proxy(this.hide, this))

  this.$dialog.on(&#39;mousedown.dismiss.bs.modal&#39;, function () {
    that.$element.one(&#39;mouseup.dismiss.bs.modal&#39;, function (e) {
      if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
    })
  })

  this.backdrop(function () {
    var transition = $.support.transition &amp;&amp; that.$element.hasClass(&#39;fade&#39;)

    if (!that.$element.parent().length) {
      that.$element.appendTo(that.$body) // don&#39;t move modals dom position
    }

    that.$element
      .show()
      .scrollTop(0)

    that.adjustDialog()

    if (transition) {
      that.$element[0].offsetWidth // force reflow
    }

    that.$element.addClass(&#39;in&#39;)

    that.enforceFocus()

    var e = $.Event(&#39;shown.bs.modal&#39;, { relatedTarget: _relatedTarget })

    transition ?
      that.$dialog // wait for modal to slide in
        .one(&#39;bsTransitionEnd&#39;, function () {
          that.$element.trigger(&#39;focus&#39;).trigger(e)
        })
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      that.$element.trigger(&#39;focus&#39;).trigger(e)
  })
}

Modal.prototype.hide = function (e) {
  if (e) e.preventDefault()

  e = $.Event(&#39;hide.bs.modal&#39;)

  this.$element.trigger(e)

  if (!this.isShown || e.isDefaultPrevented()) return

  this.isShown = false

  this.escape()
  this.resize()

  $(document).off(&#39;focusin.bs.modal&#39;)

  this.$element
    .removeClass(&#39;in&#39;)
    .off(&#39;click.dismiss.bs.modal&#39;)
    .off(&#39;mouseup.dismiss.bs.modal&#39;)

  this.$dialog.off(&#39;mousedown.dismiss.bs.modal&#39;)

  $.support.transition &amp;&amp; this.$element.hasClass(&#39;fade&#39;) ?
    this.$element
      .one(&#39;bsTransitionEnd&#39;, $.proxy(this.hideModal, this))
      .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
    this.hideModal()
}

Modal.prototype.enforceFocus = function () {
  $(document)
    .off(&#39;focusin.bs.modal&#39;) // guard against infinite focus loop
    .on(&#39;focusin.bs.modal&#39;, $.proxy(function (e) {
      if (this.$element[0] !== e.target &amp;&amp; !this.$element.has(e.target).length) {
        this.$element.trigger(&#39;focus&#39;)
      }
    }, this))
}

Modal.prototype.escape = function () {
  if (this.isShown &amp;&amp; this.options.keyboard) {
    this.$element.on(&#39;keydown.dismiss.bs.modal&#39;, $.proxy(function (e) {
      e.which == 27 &amp;&amp; this.hide()
    }, this))
  } else if (!this.isShown) {
    this.$element.off(&#39;keydown.dismiss.bs.modal&#39;)
  }
}

Modal.prototype.resize = function () {
  if (this.isShown) {
    $(window).on(&#39;resize.bs.modal&#39;, $.proxy(this.handleUpdate, this))
  } else {
    $(window).off(&#39;resize.bs.modal&#39;)
  }
}

Modal.prototype.hideModal = function () {
  var that = this
  this.$element.hide()
  this.backdrop(function () {
    that.$body.removeClass(&#39;modal-open&#39;)
    that.resetAdjustments()
    that.resetScrollbar()
    that.$element.trigger(&#39;hidden.bs.modal&#39;)
  })
}

Modal.prototype.removeBackdrop = function () {
  this.$backdrop &amp;&amp; this.$backdrop.remove()
  this.$backdrop = null
}

Modal.prototype.backdrop = function (callback) {
  var that = this
  var animate = this.$element.hasClass(&#39;fade&#39;) ? &#39;fade&#39; : &#39;&#39;

  if (this.isShown &amp;&amp; this.options.backdrop) {
    var doAnimate = $.support.transition &amp;&amp; animate

    this.$backdrop = $(document.createElement(&#39;div&#39;))
      .addClass(&#39;modal-backdrop &#39; + animate)
      .appendTo(this.$body)

    this.$element.on(&#39;click.dismiss.bs.modal&#39;, $.proxy(function (e) {
      if (this.ignoreBackdropClick) {
        this.ignoreBackdropClick = false
        return
      }
      if (e.target !== e.currentTarget) return
      this.options.backdrop == &#39;static&#39;
        ? this.$element[0].focus()
        : this.hide()
    }, this))

    if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

    this.$backdrop.addClass(&#39;in&#39;)

    if (!callback) return

    doAnimate ?
      this.$backdrop
        .one(&#39;bsTransitionEnd&#39;, callback)
        .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
      callback()

  } else if (!this.isShown &amp;&amp; this.$backdrop) {
    this.$backdrop.removeClass(&#39;in&#39;)

    var callbackRemove = function () {
      that.removeBackdrop()
      callback &amp;&amp; callback()
    }
    $.support.transition &amp;&amp; this.$element.hasClass(&#39;fade&#39;) ?
      this.$backdrop
        .one(&#39;bsTransitionEnd&#39;, callbackRemove)
        .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
      callbackRemove()

  } else if (callback) {
    callback()
  }
}

// these following methods are used to handle overflowing modals

Modal.prototype.handleUpdate = function () {
  this.adjustDialog()
}

Modal.prototype.adjustDialog = function () {
  var modalIsOverflowing = this.$element[0].scrollHeight &gt; document.documentElement.clientHeight

  this.$element.css({
    paddingLeft:  !this.bodyIsOverflowing &amp;&amp; modalIsOverflowing ? this.scrollbarWidth : &#39;&#39;,
    paddingRight: this.bodyIsOverflowing &amp;&amp; !modalIsOverflowing ? this.scrollbarWidth : &#39;&#39;
  })
}

Modal.prototype.resetAdjustments = function () {
  this.$element.css({
    paddingLeft: &#39;&#39;,
    paddingRight: &#39;&#39;
  })
}

Modal.prototype.checkScrollbar = function () {
  var fullWindowWidth = window.innerWidth
  if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
    var documentElementRect = document.documentElement.getBoundingClientRect()
    fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
  }
  this.bodyIsOverflowing = document.body.clientWidth &lt; fullWindowWidth
  this.scrollbarWidth = this.measureScrollbar()
}

Modal.prototype.setScrollbar = function () {
  var bodyPad = parseInt((this.$body.css(&#39;padding-right&#39;) || 0), 10)
  this.originalBodyPad = document.body.style.paddingRight || &#39;&#39;
  if (this.bodyIsOverflowing) this.$body.css(&#39;padding-right&#39;, bodyPad + this.scrollbarWidth)
}

Modal.prototype.resetScrollbar = function () {
  this.$body.css(&#39;padding-right&#39;, this.originalBodyPad)
}

Modal.prototype.measureScrollbar = function () { // thx walsh
  var scrollDiv = document.createElement(&#39;div&#39;)
  scrollDiv.className = &#39;modal-scrollbar-measure&#39;
  this.$body.append(scrollDiv)
  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
  this.$body[0].removeChild(scrollDiv)
  return scrollbarWidth
}

// MODAL PLUGIN DEFINITION
// =======================

function Plugin(option, _relatedTarget) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.modal&#39;)
    var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == &#39;object&#39; &amp;&amp; option)

    if (!data) $this.data(&#39;bs.modal&#39;, (data = new Modal(this, options)))
    if (typeof option == &#39;string&#39;) data[option](_relatedTarget)
    else if (options.show) data.show(_relatedTarget)
  })
}

var old = $.fn.modal

$.fn.modal             = Plugin
$.fn.modal.Constructor = Modal

// MODAL NO CONFLICT
// =================

$.fn.modal.noConflict = function () {
  $.fn.modal = old
  return this
}

// MODAL DATA-API
// ==============

$(document).on(&#39;click.bs.modal.data-api&#39;, &#39;[data-toggle=&quot;modal&quot;]&#39;, function (e) {
  var $this   = $(this)
  var href    = $this.attr(&#39;href&#39;)
  var $target = $($this.attr(&#39;data-target&#39;) || (href &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, &#39;&#39;))) // strip for ie7
  var option  = $target.data(&#39;bs.modal&#39;) ? &#39;toggle&#39; : $.extend({ remote: !/#/.test(href) &amp;&amp; href }, $target.data(), $this.data())

  if ($this.is(&#39;a&#39;)) e.preventDefault()

  $target.one(&#39;show.bs.modal&#39;, function (showEvent) {
    if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
    $target.one(&#39;hidden.bs.modal&#39;, function () {
      $this.is(&#39;:visible&#39;) &amp;&amp; $this.trigger(&#39;focus&#39;)
    })
  })
  Plugin.call($target, option, this)
})</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: scrollspy.js v3.3.6
http://getbootstrap.com/javascript/#scrollspy
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// SCROLLSPY CLASS DEFINITION
// ==========================

function ScrollSpy(element, options) {
  this.$body          = $(document.body)
  this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
  this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
  this.selector       = (this.options.target || &#39;&#39;) + &#39; .nav li &gt; a&#39;
  this.offsets        = []
  this.targets        = []
  this.activeTarget   = null
  this.scrollHeight   = 0

  this.$scrollElement.on(&#39;scroll.bs.scrollspy&#39;, $.proxy(this.process, this))
  this.refresh()
  this.process()
}

ScrollSpy.VERSION  = &#39;3.3.6&#39;

ScrollSpy.DEFAULTS = {
  offset: 10
}

ScrollSpy.prototype.getScrollHeight = function () {
  return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
}

ScrollSpy.prototype.refresh = function () {
  var that          = this
  var offsetMethod  = &#39;offset&#39;
  var offsetBase    = 0

  this.offsets      = []
  this.targets      = []
  this.scrollHeight = this.getScrollHeight()

  if (!$.isWindow(this.$scrollElement[0])) {
    offsetMethod = &#39;position&#39;
    offsetBase   = this.$scrollElement.scrollTop()
  }

  this.$body
    .find(this.selector)
    .map(function () {
      var $el   = $(this)
      var href  = $el.data(&#39;target&#39;) || $el.attr(&#39;href&#39;)
      var $href = /^#./.test(href) &amp;&amp; $(href)

      return ($href
        &amp;&amp; $href.length
        &amp;&amp; $href.is(&#39;:visible&#39;)
        &amp;&amp; [[$href[offsetMethod]().top + offsetBase, href]]) || null
    })
    .sort(function (a, b) { return a[0] - b[0] })
    .each(function () {
      that.offsets.push(this[0])
      that.targets.push(this[1])
    })
}

ScrollSpy.prototype.process = function () {
  var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
  var scrollHeight = this.getScrollHeight()
  var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
  var offsets      = this.offsets
  var targets      = this.targets
  var activeTarget = this.activeTarget
  var i

  if (this.scrollHeight != scrollHeight) {
    this.refresh()
  }

  if (scrollTop &gt;= maxScroll) {
    return activeTarget != (i = targets[targets.length - 1]) &amp;&amp; this.activate(i)
  }

  if (activeTarget &amp;&amp; scrollTop &lt; offsets[0]) {
    this.activeTarget = null
    return this.clear()
  }

  for (i = offsets.length; i--;) {
    activeTarget != targets[i]
      &amp;&amp; scrollTop &gt;= offsets[i]
      &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])
      &amp;&amp; this.activate(targets[i])
  }
}

ScrollSpy.prototype.activate = function (target) {
  this.activeTarget = target

  this.clear()

  var selector = this.selector +
    &#39;[data-target=&quot;&#39; + target + &#39;&quot;],&#39; +
    this.selector + &#39;[href=&quot;&#39; + target + &#39;&quot;]&#39;

  var active = $(selector)
    .parents(&#39;li&#39;)
    .addClass(&#39;active&#39;)

  if (active.parent(&#39;.dropdown-menu&#39;).length) {
    active = active
      .closest(&#39;li.dropdown&#39;)
      .addClass(&#39;active&#39;)
  }

  active.trigger(&#39;activate.bs.scrollspy&#39;)
}

ScrollSpy.prototype.clear = function () {
  $(this.selector)
    .parentsUntil(this.options.target, &#39;.active&#39;)
    .removeClass(&#39;active&#39;)
}

// SCROLLSPY PLUGIN DEFINITION
// ===========================

function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.scrollspy&#39;)
    var options = typeof option == &#39;object&#39; &amp;&amp; option

    if (!data) $this.data(&#39;bs.scrollspy&#39;, (data = new ScrollSpy(this, options)))
    if (typeof option == &#39;string&#39;) data[option]()
  })
}

var old = $.fn.scrollspy

$.fn.scrollspy             = Plugin
$.fn.scrollspy.Constructor = ScrollSpy

// SCROLLSPY NO CONFLICT
// =====================

$.fn.scrollspy.noConflict = function () {
  $.fn.scrollspy = old
  return this
}

// SCROLLSPY DATA-API
// ==================

$(window).on(&#39;load.bs.scrollspy.data-api&#39;, function () {
  $(&#39;[data-spy=&quot;scroll&quot;]&#39;).each(function () {
    var $spy = $(this)
    Plugin.call($spy, $spy.data())
  })
})</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: tab.js v3.3.6
http://getbootstrap.com/javascript/#tabs
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// TAB CLASS DEFINITION
// ====================

var Tab = function (element) {
  // jscs:disable requireDollarBeforejQueryAssignment
  this.element = $(element)
  // jscs:enable requireDollarBeforejQueryAssignment
}

Tab.VERSION = &#39;3.3.6&#39;

Tab.TRANSITION_DURATION = 150

Tab.prototype.show = function () {
  var $this    = this.element
  var $ul      = $this.closest(&#39;ul:not(.dropdown-menu)&#39;)
  var selector = $this.data(&#39;target&#39;)

  if (!selector) {
    selector = $this.attr(&#39;href&#39;)
    selector = selector &amp;&amp; selector.replace(/.*(?=#[^\s]*$)/, &#39;&#39;) // strip for ie7
  }

  if ($this.parent(&#39;li&#39;).hasClass(&#39;active&#39;)) return

  var $previous = $ul.find(&#39;.active:last a&#39;)
  var hideEvent = $.Event(&#39;hide.bs.tab&#39;, {
    relatedTarget: $this[0]
  })
  var showEvent = $.Event(&#39;show.bs.tab&#39;, {
    relatedTarget: $previous[0]
  })

  $previous.trigger(hideEvent)
  $this.trigger(showEvent)

  if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

  var $target = $(selector)

  this.activate($this.closest(&#39;li&#39;), $ul)
  this.activate($target, $target.parent(), function () {
    $previous.trigger({
      type: &#39;hidden.bs.tab&#39;,
      relatedTarget: $this[0]
    })
    $this.trigger({
      type: &#39;shown.bs.tab&#39;,
      relatedTarget: $previous[0]
    })
  })
}

Tab.prototype.activate = function (element, container, callback) {
  var $active    = container.find(&#39;&gt; .active&#39;)
  var transition = callback
    &amp;&amp; $.support.transition
    &amp;&amp; ($active.length &amp;&amp; $active.hasClass(&#39;fade&#39;) || !!container.find(&#39;&gt; .fade&#39;).length)

  function next() {
    $active
      .removeClass(&#39;active&#39;)
      .find(&#39;&gt; .dropdown-menu &gt; .active&#39;)
        .removeClass(&#39;active&#39;)
      .end()
      .find(&#39;[data-toggle=&quot;tab&quot;]&#39;)
        .attr(&#39;aria-expanded&#39;, false)

    element
      .addClass(&#39;active&#39;)
      .find(&#39;[data-toggle=&quot;tab&quot;]&#39;)
        .attr(&#39;aria-expanded&#39;, true)

    if (transition) {
      element[0].offsetWidth // reflow for transition
      element.addClass(&#39;in&#39;)
    } else {
      element.removeClass(&#39;fade&#39;)
    }

    if (element.parent(&#39;.dropdown-menu&#39;).length) {
      element
        .closest(&#39;li.dropdown&#39;)
          .addClass(&#39;active&#39;)
        .end()
        .find(&#39;[data-toggle=&quot;tab&quot;]&#39;)
          .attr(&#39;aria-expanded&#39;, true)
    }

    callback &amp;&amp; callback()
  }

  $active.length &amp;&amp; transition ?
    $active
      .one(&#39;bsTransitionEnd&#39;, next)
      .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
    next()

  $active.removeClass(&#39;in&#39;)
}

// TAB PLUGIN DEFINITION
// =====================

function Plugin(option) {
  return this.each(function () {
    var $this = $(this)
    var data  = $this.data(&#39;bs.tab&#39;)

    if (!data) $this.data(&#39;bs.tab&#39;, (data = new Tab(this)))
    if (typeof option == &#39;string&#39;) data[option]()
  })
}

var old = $.fn.tab

$.fn.tab             = Plugin
$.fn.tab.Constructor = Tab

// TAB NO CONFLICT
// ===============

$.fn.tab.noConflict = function () {
  $.fn.tab = old
  return this
}

// TAB DATA-API
// ============

var clickHandler = function (e) {
  e.preventDefault()
  Plugin.call($(this), &#39;show&#39;)
}

$(document)
  .on(&#39;click.bs.tab.data-api&#39;, &#39;[data-toggle=&quot;tab&quot;]&#39;, clickHandler)
  .on(&#39;click.bs.tab.data-api&#39;, &#39;[data-toggle=&quot;pill&quot;]&#39;, clickHandler)</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: transition.js v3.3.6
http://getbootstrap.com/javascript/#transitions
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
// ============================================================

function transitionEnd() {
  var el = document.createElement(&#39;bootstrap&#39;)

  var transEndEventNames = {
    WebkitTransition : &#39;webkitTransitionEnd&#39;,
    MozTransition    : &#39;transitionend&#39;,
    OTransition      : &#39;oTransitionEnd otransitionend&#39;,
    transition       : &#39;transitionend&#39;
  }

  for (var name in transEndEventNames) {
    if (el.style[name] !== undefined) {
      return { end: transEndEventNames[name] }
    }
  }

  return false // explicit for ie8 (  ._.)
}

// http://blog.alexmaccaw.com/css-transitions
$.fn.emulateTransitionEnd = function (duration) {
  var called = false
  var $el = this
  $(this).one(&#39;bsTransitionEnd&#39;, function () { called = true })
  var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
  setTimeout(callback, duration)
  return this
}

$(function () {
  $.support.transition = transitionEnd()

  if (!$.support.transition) return

  $.event.special.bsTransitionEnd = {
    bindType: $.support.transition.end,
    delegateType: $.support.transition.end,
    handle: function (e) {
      if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
    }
  }
})</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: tooltip.js v3.3.6
http://getbootstrap.com/javascript/#tooltip
Inspired by the original jQuery.tipsy by Jason Frame
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// TOOLTIP PUBLIC CLASS DEFINITION
// ===============================

var Tooltip = function (element, options) {
  this.type       = null
  this.options    = null
  this.enabled    = null
  this.timeout    = null
  this.hoverState = null
  this.$element   = null
  this.inState    = null

  this.init(&#39;tooltip&#39;, element, options)
}

Tooltip.VERSION  = &#39;3.3.6&#39;

Tooltip.TRANSITION_DURATION = 150

Tooltip.DEFAULTS = {
  animation: true,
  placement: &#39;top&#39;,
  selector: false,
  template: &#39;&lt;div class=&quot;tooltip&quot; role=&quot;tooltip&quot;&gt;&lt;div class=&quot;tooltip-arrow&quot;&gt;&lt;/div&gt;&lt;div class=&quot;tooltip-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#39;,
  trigger: &#39;hover focus&#39;,
  title: &#39;&#39;,
  delay: 0,
  html: false,
  container: false,
  viewport: {
    selector: &#39;body&#39;,
    padding: 0
  }
}

Tooltip.prototype.init = function (type, element, options) {
  this.enabled   = true
  this.type      = type
  this.$element  = $(element)
  this.options   = this.getOptions(options)
  this.$viewport = this.options.viewport &amp;&amp; $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
  this.inState   = { click: false, hover: false, focus: false }

  if (this.$element[0] instanceof document.constructor &amp;&amp; !this.options.selector) {
    throw new Error(&#39;`selector` option must be specified when initializing &#39; + this.type + &#39; on the window.document object!&#39;)
  }

  var triggers = this.options.trigger.split(&#39; &#39;)

  for (var i = triggers.length; i--;) {
    var trigger = triggers[i]

    if (trigger == &#39;click&#39;) {
      this.$element.on(&#39;click.&#39; + this.type, this.options.selector, $.proxy(this.toggle, this))
    } else if (trigger != &#39;manual&#39;) {
      var eventIn  = trigger == &#39;hover&#39; ? &#39;mouseenter&#39; : &#39;focusin&#39;
      var eventOut = trigger == &#39;hover&#39; ? &#39;mouseleave&#39; : &#39;focusout&#39;

      this.$element.on(eventIn  + &#39;.&#39; + this.type, this.options.selector, $.proxy(this.enter, this))
      this.$element.on(eventOut + &#39;.&#39; + this.type, this.options.selector, $.proxy(this.leave, this))
    }
  }

  this.options.selector ?
    (this._options = $.extend({}, this.options, { trigger: &#39;manual&#39;, selector: &#39;&#39; })) :
    this.fixTitle()
}

Tooltip.prototype.getDefaults = function () {
  return Tooltip.DEFAULTS
}

Tooltip.prototype.getOptions = function (options) {
  options = $.extend({}, this.getDefaults(), this.$element.data(), options)

  if (options.delay &amp;&amp; typeof options.delay == &#39;number&#39;) {
    options.delay = {
      show: options.delay,
      hide: options.delay
    }
  }

  return options
}

Tooltip.prototype.getDelegateOptions = function () {
  var options  = {}
  var defaults = this.getDefaults()

  this._options &amp;&amp; $.each(this._options, function (key, value) {
    if (defaults[key] != value) options[key] = value
  })

  return options
}

Tooltip.prototype.enter = function (obj) {
  var self = obj instanceof this.constructor ?
    obj : $(obj.currentTarget).data(&#39;bs.&#39; + this.type)

  if (!self) {
    self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
    $(obj.currentTarget).data(&#39;bs.&#39; + this.type, self)
  }

  if (obj instanceof $.Event) {
    self.inState[obj.type == &#39;focusin&#39; ? &#39;focus&#39; : &#39;hover&#39;] = true
  }

  if (self.tip().hasClass(&#39;in&#39;) || self.hoverState == &#39;in&#39;) {
    self.hoverState = &#39;in&#39;
    return
  }

  clearTimeout(self.timeout)

  self.hoverState = &#39;in&#39;

  if (!self.options.delay || !self.options.delay.show) return self.show()

  self.timeout = setTimeout(function () {
    if (self.hoverState == &#39;in&#39;) self.show()
  }, self.options.delay.show)
}

Tooltip.prototype.isInStateTrue = function () {
  for (var key in this.inState) {
    if (this.inState[key]) return true
  }

  return false
}

Tooltip.prototype.leave = function (obj) {
  var self = obj instanceof this.constructor ?
    obj : $(obj.currentTarget).data(&#39;bs.&#39; + this.type)

  if (!self) {
    self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
    $(obj.currentTarget).data(&#39;bs.&#39; + this.type, self)
  }

  if (obj instanceof $.Event) {
    self.inState[obj.type == &#39;focusout&#39; ? &#39;focus&#39; : &#39;hover&#39;] = false
  }

  if (self.isInStateTrue()) return

  clearTimeout(self.timeout)

  self.hoverState = &#39;out&#39;

  if (!self.options.delay || !self.options.delay.hide) return self.hide()

  self.timeout = setTimeout(function () {
    if (self.hoverState == &#39;out&#39;) self.hide()
  }, self.options.delay.hide)
}

Tooltip.prototype.show = function () {
  var e = $.Event(&#39;show.bs.&#39; + this.type)

  if (this.hasContent() &amp;&amp; this.enabled) {
    this.$element.trigger(e)

    var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
    if (e.isDefaultPrevented() || !inDom) return
    var that = this

    var $tip = this.tip()

    var tipId = this.getUID(this.type)

    this.setContent()
    $tip.attr(&#39;id&#39;, tipId)
    this.$element.attr(&#39;aria-describedby&#39;, tipId)

    if (this.options.animation) $tip.addClass(&#39;fade&#39;)

    var placement = typeof this.options.placement == &#39;function&#39; ?
      this.options.placement.call(this, $tip[0], this.$element[0]) :
      this.options.placement

    var autoToken = /\s?auto?\s?/i
    var autoPlace = autoToken.test(placement)
    if (autoPlace) placement = placement.replace(autoToken, &#39;&#39;) || &#39;top&#39;

    $tip
      .detach()
      .css({ top: 0, left: 0, display: &#39;block&#39; })
      .addClass(placement)
      .data(&#39;bs.&#39; + this.type, this)

    this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
    this.$element.trigger(&#39;inserted.bs.&#39; + this.type)

    var pos          = this.getPosition()
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (autoPlace) {
      var orgPlacement = placement
      var viewportDim = this.getPosition(this.$viewport)

      placement = placement == &#39;bottom&#39; &amp;&amp; pos.bottom + actualHeight &gt; viewportDim.bottom ? &#39;top&#39;    :
                  placement == &#39;top&#39;    &amp;&amp; pos.top    - actualHeight &lt; viewportDim.top    ? &#39;bottom&#39; :
                  placement == &#39;right&#39;  &amp;&amp; pos.right  + actualWidth  &gt; viewportDim.width  ? &#39;left&#39;   :
                  placement == &#39;left&#39;   &amp;&amp; pos.left   - actualWidth  &lt; viewportDim.left   ? &#39;right&#39;  :
                  placement

      $tip
        .removeClass(orgPlacement)
        .addClass(placement)
    }

    var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

    this.applyPlacement(calculatedOffset, placement)

    var complete = function () {
      var prevHoverState = that.hoverState
      that.$element.trigger(&#39;shown.bs.&#39; + that.type)
      that.hoverState = null

      if (prevHoverState == &#39;out&#39;) that.leave(that)
    }

    $.support.transition &amp;&amp; this.$tip.hasClass(&#39;fade&#39;) ?
      $tip
        .one(&#39;bsTransitionEnd&#39;, complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()
  }
}

Tooltip.prototype.applyPlacement = function (offset, placement) {
  var $tip   = this.tip()
  var width  = $tip[0].offsetWidth
  var height = $tip[0].offsetHeight

  // manually read margins because getBoundingClientRect includes difference
  var marginTop = parseInt($tip.css(&#39;margin-top&#39;), 10)
  var marginLeft = parseInt($tip.css(&#39;margin-left&#39;), 10)

  // we must check for NaN for ie 8/9
  if (isNaN(marginTop))  marginTop  = 0
  if (isNaN(marginLeft)) marginLeft = 0

  offset.top  += marginTop
  offset.left += marginLeft

  // $.fn.offset doesn&#39;t round pixel values
  // so we use setOffset directly with our own function B-0
  $.offset.setOffset($tip[0], $.extend({
    using: function (props) {
      $tip.css({
        top: Math.round(props.top),
        left: Math.round(props.left)
      })
    }
  }, offset), 0)

  $tip.addClass(&#39;in&#39;)

  // check to see if placing tip in new offset caused the tip to resize itself
  var actualWidth  = $tip[0].offsetWidth
  var actualHeight = $tip[0].offsetHeight

  if (placement == &#39;top&#39; &amp;&amp; actualHeight != height) {
    offset.top = offset.top + height - actualHeight
  }

  var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

  if (delta.left) offset.left += delta.left
  else offset.top += delta.top

  var isVertical          = /top|bottom/.test(placement)
  var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
  var arrowOffsetPosition = isVertical ? &#39;offsetWidth&#39; : &#39;offsetHeight&#39;

  $tip.offset(offset)
  this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
}

Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
  this.arrow()
    .css(isVertical ? &#39;left&#39; : &#39;top&#39;, 50 * (1 - delta / dimension) + &#39;%&#39;)
    .css(isVertical ? &#39;top&#39; : &#39;left&#39;, &#39;&#39;)
}

Tooltip.prototype.setContent = function () {
  var $tip  = this.tip()
  var title = this.getTitle()

  $tip.find(&#39;.tooltip-inner&#39;)[this.options.html ? &#39;html&#39; : &#39;text&#39;](title)
  $tip.removeClass(&#39;fade in top bottom left right&#39;)
}

Tooltip.prototype.hide = function (callback) {
  var that = this
  var $tip = $(this.$tip)
  var e    = $.Event(&#39;hide.bs.&#39; + this.type)

  function complete() {
    if (that.hoverState != &#39;in&#39;) $tip.detach()
    that.$element
      .removeAttr(&#39;aria-describedby&#39;)
      .trigger(&#39;hidden.bs.&#39; + that.type)
    callback &amp;&amp; callback()
  }

  this.$element.trigger(e)

  if (e.isDefaultPrevented()) return

  $tip.removeClass(&#39;in&#39;)

  $.support.transition &amp;&amp; $tip.hasClass(&#39;fade&#39;) ?
    $tip
      .one(&#39;bsTransitionEnd&#39;, complete)
      .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
    complete()

  this.hoverState = null

  return this
}

Tooltip.prototype.fixTitle = function () {
  var $e = this.$element
  if ($e.attr(&#39;title&#39;) || typeof $e.attr(&#39;data-original-title&#39;) != &#39;string&#39;) {
    $e.attr(&#39;data-original-title&#39;, $e.attr(&#39;title&#39;) || &#39;&#39;).attr(&#39;title&#39;, &#39;&#39;)
  }
}

Tooltip.prototype.hasContent = function () {
  return this.getTitle()
}

Tooltip.prototype.getPosition = function ($element) {
  $element   = $element || this.$element

  var el     = $element[0]
  var isBody = el.tagName == &#39;BODY&#39;

  var elRect    = el.getBoundingClientRect()
  if (elRect.width == null) {
    // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
    elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
  }
  var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
  var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
  var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

  return $.extend({}, elRect, scroll, outerDims, elOffset)
}

Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
  return placement == &#39;bottom&#39; ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
         placement == &#39;top&#39;    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
         placement == &#39;left&#39;   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
      /* placement == &#39;right&#39; */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

}

Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
  var delta = { top: 0, left: 0 }
  if (!this.$viewport) return delta

  var viewportPadding = this.options.viewport &amp;&amp; this.options.viewport.padding || 0
  var viewportDimensions = this.getPosition(this.$viewport)

  if (/right|left/.test(placement)) {
    var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
    var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
    if (topEdgeOffset &lt; viewportDimensions.top) { // top overflow
      delta.top = viewportDimensions.top - topEdgeOffset
    } else if (bottomEdgeOffset &gt; viewportDimensions.top + viewportDimensions.height) { // bottom overflow
      delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
    }
  } else {
    var leftEdgeOffset  = pos.left - viewportPadding
    var rightEdgeOffset = pos.left + viewportPadding + actualWidth
    if (leftEdgeOffset &lt; viewportDimensions.left) { // left overflow
      delta.left = viewportDimensions.left - leftEdgeOffset
    } else if (rightEdgeOffset &gt; viewportDimensions.right) { // right overflow
      delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
    }
  }

  return delta
}

Tooltip.prototype.getTitle = function () {
  var title
  var $e = this.$element
  var o  = this.options

  title = $e.attr(&#39;data-original-title&#39;)
    || (typeof o.title == &#39;function&#39; ? o.title.call($e[0]) :  o.title)

  return title
}

Tooltip.prototype.getUID = function (prefix) {
  do prefix += ~~(Math.random() * 1000000)
  while (document.getElementById(prefix))
  return prefix
}

Tooltip.prototype.tip = function () {
  if (!this.$tip) {
    this.$tip = $(this.options.template)
    if (this.$tip.length != 1) {
      throw new Error(this.type + &#39; `template` option must consist of exactly 1 top-level element!&#39;)
    }
  }
  return this.$tip
}

Tooltip.prototype.arrow = function () {
  return (this.$arrow = this.$arrow || this.tip().find(&#39;.tooltip-arrow&#39;))
}

Tooltip.prototype.enable = function () {
  this.enabled = true
}

Tooltip.prototype.disable = function () {
  this.enabled = false
}

Tooltip.prototype.toggleEnabled = function () {
  this.enabled = !this.enabled
}

Tooltip.prototype.toggle = function (e) {
  var self = this
  if (e) {
    self = $(e.currentTarget).data(&#39;bs.&#39; + this.type)
    if (!self) {
      self = new this.constructor(e.currentTarget, this.getDelegateOptions())
      $(e.currentTarget).data(&#39;bs.&#39; + this.type, self)
    }
  }

  if (e) {
    self.inState.click = !self.inState.click
    if (self.isInStateTrue()) self.enter(self)
    else self.leave(self)
  } else {
    self.tip().hasClass(&#39;in&#39;) ? self.leave(self) : self.enter(self)
  }
}

Tooltip.prototype.destroy = function () {
  var that = this
  clearTimeout(this.timeout)
  this.hide(function () {
    that.$element.off(&#39;.&#39; + that.type).removeData(&#39;bs.&#39; + that.type)
    if (that.$tip) {
      that.$tip.detach()
    }
    that.$tip = null
    that.$arrow = null
    that.$viewport = null
  })
}

// TOOLTIP PLUGIN DEFINITION
// =========================

function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.tooltip&#39;)
    var options = typeof option == &#39;object&#39; &amp;&amp; option

    if (!data &amp;&amp; /destroy|hide/.test(option)) return
    if (!data) $this.data(&#39;bs.tooltip&#39;, (data = new Tooltip(this, options)))
    if (typeof option == &#39;string&#39;) data[option]()
  })
}

var old = $.fn.tooltip

$.fn.tooltip             = Plugin
$.fn.tooltip.Constructor = Tooltip

// TOOLTIP NO CONFLICT
// ===================

$.fn.tooltip.noConflict = function () {
  $.fn.tooltip = old
  return this
}</pre>

<p>}(jQuery); /*
========================================================================</p>

<pre>Bootstrap: popover.js v3.3.6
http://getbootstrap.com/javascript/#popovers
========================================================================
Copyright 2011-2015 Twitter, Inc.
Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
======================================================================== */</pre>

<p>+function ($) {</p>

<pre>&#39;use strict&#39;;

// POPOVER PUBLIC CLASS DEFINITION
// ===============================

var Popover = function (element, options) {
  this.init(&#39;popover&#39;, element, options)
}

if (!$.fn.tooltip) throw new Error(&#39;Popover requires tooltip.js&#39;)

Popover.VERSION  = &#39;3.3.6&#39;

Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
  placement: &#39;right&#39;,
  trigger: &#39;click&#39;,
  content: &#39;&#39;,
  template: &#39;&lt;div class=&quot;popover&quot; role=&quot;tooltip&quot;&gt;&lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;&lt;h3 class=&quot;popover-title&quot;&gt;&lt;/h3&gt;&lt;div class=&quot;popover-content&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#39;
})

// NOTE: POPOVER EXTENDS tooltip.js
// ================================

Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

Popover.prototype.constructor = Popover

Popover.prototype.getDefaults = function () {
  return Popover.DEFAULTS
}

Popover.prototype.setContent = function () {
  var $tip    = this.tip()
  var title   = this.getTitle()
  var content = this.getContent()

  $tip.find(&#39;.popover-title&#39;)[this.options.html ? &#39;html&#39; : &#39;text&#39;](title)
  $tip.find(&#39;.popover-content&#39;).children().detach().end()[ // we use append for html objects to maintain js events
    this.options.html ? (typeof content == &#39;string&#39; ? &#39;html&#39; : &#39;append&#39;) : &#39;text&#39;
  ](content)

  $tip.removeClass(&#39;fade top bottom left right in&#39;)

  // IE8 doesn&#39;t accept hiding via the `:empty` pseudo selector, we have to do
  // this manually by checking the contents.
  if (!$tip.find(&#39;.popover-title&#39;).html()) $tip.find(&#39;.popover-title&#39;).hide()
}

Popover.prototype.hasContent = function () {
  return this.getTitle() || this.getContent()
}

Popover.prototype.getContent = function () {
  var $e = this.$element
  var o  = this.options

  return $e.attr(&#39;data-content&#39;)
    || (typeof o.content == &#39;function&#39; ?
          o.content.call($e[0]) :
          o.content)
}

Popover.prototype.arrow = function () {
  return (this.$arrow = this.$arrow || this.tip().find(&#39;.arrow&#39;))
}

// POPOVER PLUGIN DEFINITION
// =========================

function Plugin(option) {
  return this.each(function () {
    var $this   = $(this)
    var data    = $this.data(&#39;bs.popover&#39;)
    var options = typeof option == &#39;object&#39; &amp;&amp; option

    if (!data &amp;&amp; /destroy|hide/.test(option)) return
    if (!data) $this.data(&#39;bs.popover&#39;, (data = new Popover(this, options)))
    if (typeof option == &#39;string&#39;) data[option]()
  })
}

var old = $.fn.popover

$.fn.popover             = Plugin
$.fn.popover.Constructor = Popover

// POPOVER NO CONFLICT
// ===================

$.fn.popover.noConflict = function () {
  $.fn.popover = old
  return this
}</pre>

<p>}(jQuery);</p>

<p>/*! jQuery Migrate v1.2.1 |  2005, 2013 jQuery Foundation, Inc. and other
contributors | jquery.org/license */</p>

<p>jQuery.migrateMute===void
0&amp;&amp;(jQuery.migrateMute=!0),function(e,t,n){function r(n){var <a
href="n">r=t.console;i</a>||(<a
href="n">i</a>=!0,e.migrateWarnings.push(n),r&amp;&amp;r.warn&amp;&amp;!e.migrateMute&amp;&amp;(r.warn(JQMIGRATE:
+n),e.migrateTrace&amp;&amp;r.trace&amp;&amp;r.trace()))}function
a(t,a,i,o){if(Object.defineProperty)try{return
Object.defineProperty(t,a,{configurable:!0,enumerable:!0,get:function(){return
r(o),i},set:function(e){r(o),i=e}}),n}catch(s){}<a
href="a">e._definePropertyBroken=!0,t</a>=i}var
i={};e.migrateWarnings=[],!e.migrateMute&amp;&amp;t.console&amp;&amp;t.console.log&amp;&amp;t.console.log(JQMIGRATE:
Logging is
active),e.migrateTrace===n&amp;&amp;(e.migrateTrace=!0),e.migrateReset=function(){i={},e.migrateWarnings.length=0},BackCompat===document.compatMode&amp;&amp;r(jQuery
is not compatible with Quirks Mode);var
o=e(&lt;input/&gt;,{size:1}).attr(size)&amp;&amp;e.attrFn,s=e.attr,u=e.attrHooks.value&amp;&amp;e.attrHooks.value.get||function(){return
null},c=e.attrHooks.value&amp;&amp;e.attrHooks.value.set||function(){return
n},<a
href="238">l=/^(?:input|button)$/i,d=/^</a>$/,p=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,f=/^(?:checked|selected)$/i;a(e,attrFn,o||{},jQuery.attrFn
is deprecated),e.attr=function(t,a,i,u){var
c=a.toLowerCase(),g=t&amp;&amp;t.nodeType;return
u&amp;&amp;(4&gt;s.length&amp;&amp;r(jQuery.fn.attr( props, pass ) is
deprecated),t&amp;&amp;!d.test(g)&amp;&amp;(o?a in <a
href="a">o:e.isFunction(e.fn</a>)))?<a
href="a">e(t)</a>(i):(type===a&amp;&amp;i!==n&amp;&amp;l.test(t.nodeName)&amp;&amp;t.parentNode&amp;&amp;r(Can&#39;t
change the &#39;type&#39; of an input or button in IE <a
href="c">6/7/8),!e.attrHooks</a>&amp;&amp;<a
href="c">p.test&&(e.attrHooks</a>={get:function(t,r){var
a,i=e.prop(t,r);return i===!0||boolean!=typeof
i&amp;&amp;(a=t.getAttributeNode)&amp;&amp;a.nodeValue!==!1?r.toLowerCase():n},set:function(t,n,r){var
a;return <a href="r">n===!1?e.removeAttr(t,r):(a=e.propFix</a>||r,a in <a
href="a">t&&(t</a>=!0),t.setAttribute(r,r.toLowerCase())),r}},f.test&amp;&amp;r(jQuery.fn.attr(&#39;<code>c</code>&#39;)
may use property instead of
attribute)),s.call(e,t,a,i))},e.attrHooks.value={get:function(e,t){var
n=(e.nodeName||).toLowerCase();returnbutton===n?u.apply(this,arguments):(input!==n&amp;&amp;option!==n&amp;&amp;r(jQuery.fn.attr(&#39;value&#39;)
no longer gets properties),t in e?e.value:null)},set:function(e,t){var
a=(e.nodeName||).toLowerCase();returnbutton===a?c.apply(this,arguments):(input!==a&amp;&amp;option!==a&amp;&amp;r(jQuery.fn.attr(&#39;value&#39;,
val) no longer sets properties),e.value=t,n)}};var <a
href="^<">g,h,v=e.fn.init,m=e.parseJSON,y=/^(</a>*)(&lt;[<a
href=^>>wW]+>)(</a>*)$/;e.fn.init=function(t,n,a){var i;return
t&amp;&amp;string==typeof <a
href="0">t&&!e.isPlainObject(n)&&(i=y.exec(e.trim(t)))&&i</a>&amp;&amp;(&lt;!==t.charAt(0)&amp;&amp;r($(html)
HTML strings must start with &#39;&lt;&#39; <a
href="3">character),i</a>&amp;&amp;r($(html) HTML text after last tag is
<a href="0">ignored),#===i</a>.charAt(0)&amp;&amp;(r(HTML string cannot
start with a &#39;#&#39; character),e.error(JQMIGRATE: Invalid selector
string (<a
href="2">XSS))),n&&n.context&&(n=n.context),e.parseHTML)?v.call(this,e.parseHTML(i</a>,n,!0),n,a):v.apply(this,arguments)},e.fn.init.prototype=e.fn,e.parseJSON=function(e){return
e||null===e?m.apply(this,arguments):(r(jQuery.parseJSON requires a valid
JSON string),null)},e.uaMatch=function(e){e=e.toLowerCase();var
t=/(chrome)[ /]([w.]+)/.exec(e)||/(webkit)[
/]([w.]+)/.exec(e)||/(opera)(?:.*version|)[ /]([w.]+)/.exec(e)||/(msie)
([w.]+)/.exec(e)||0&gt;e.indexOf(compatible)&amp;&amp;/(mozilla)(?:.*? <a
href="\w.">rv:(</a>+)|)/.<a
href="1">exec(e)||[];return{browser:t</a>||,<a
href="2">version:t</a>||0}},e.browser||(g=e.uaMatch(navigator.userAgent),h={},<a
href="g.browser">g.browser&&(h</a>=!0,h.version=g.version),h.chrome?h.webkit=!0:h.webkit&amp;&amp;(h.safari=!0),e.browser=h),a(e,browser,e.browser,jQuery.browser
is deprecated),e.sub=function(){function t(e,n){return new
t.fn.init(e,n)}e.extend(!0,t,this),t.superclass=this,t.fn=t.prototype=this(),t.fn.constructor=t,t.sub=this.sub,t.fn.init=function(r,a){return
a&amp;&amp;a instanceof e&amp;&amp;!(a instanceof
t)&amp;&amp;(a=t(a)),e.fn.init.call(this,r,a,n)},t.fn.init.prototype=t.fn;var
n=t(document);return r(jQuery.sub() is
deprecated),t},e.ajaxSetup({converters:{text json:e.parseJSON}});var
b=e.fn.data;e.fn.data=function(t){var <a
href="0">a,i,o=this</a>;return!o||events!==t||1!==arguments.length||(a=e.data(o,t),i=e._data(o,t),a!==n&amp;&amp;a!==i||i===n)?b.apply(this,arguments):(r(Use
of jQuery.fn.data(&#39;events&#39;) is deprecated),i)};var
j=//(java|ecma)script/i,w=e.fn.andSelf||e.fn.addBack;e.fn.andSelf=function(){return
r(jQuery.fn.andSelf() replaced by
jQuery.fn.addBack()),w.apply(this,arguments)},e.clean||(e.clean=function(t,a,i,o){<a
href="0">a=a||document,a=!a.nodeType&&a</a>||a,a=a.ownerDocument||a,r(jQuery.clean()
is deprecated);var <a
href="s">s,u,c,l,d=[];if(e.merge(d,e.buildFragment(t,a).childNodes),i)for(c=function(e){return!e.type||j.test(e.type)?o?o.push(e.parentNode?e.parentNode.removeChild(e):e):i.appendChild(e):n},s=0;null!=(u=d</a>);<a
href="s+1,0">s++)e.nodeName(u,script)&&c(u)||(i.appendChild(u),u.getElementsByTagName!==n&&(l=e.grep(e.merge([],u.getElementsByTagName(script)),c),d.splice.apply(d,</a>.concat(l)),s+=l.length));return
d});var
Q=e.event.add,x=e.event.remove,k=e.event.trigger,N=e.fn.toggle,T=e.fn.live,M=e.fn.die,S=ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess,C=RegExp(\b(?:<code>S</code>)\b),H=/(?:^|s)hover(.S+|)b/,A=function(t){returnstring!=typeof
t||e.event.special.hover?t:(H.test(t)&amp;&amp;r(&#39;hover&#39;
pseudo-event is deprecated, use &#39;mouseenter
mouseleave&#39;),t&amp;&amp;t.replace(H,mouseenter$1 mouseleave$1))};<a
href="0">e.event.props&&attrChange!==e.event.props</a>&amp;&amp;e.event.props.unshift(attrChange,attrName,relatedNode,srcElement),e.event.dispatch&amp;&amp;a(e.event,handle,e.event.dispatch,jQuery.event.handle
is undocumented and
deprecated),e.event.add=function(e,t,n,a,i){e!==document&amp;&amp;C.test(t)&amp;&amp;r(AJAX
events should be attached to document:
+t),Q.call(this,e,A(t||),n,a,i)},e.event.remove=function(e,t,n,r,a){x.call(this,e,A(t)||,n,r,a)},e.fn.error=function(){var
e=Array.prototype.slice.call(arguments,0);return r(jQuery.fn.error() is
deprecated),e.splice(0,0,error),arguments.length?this.bind.apply(this,e):(this.triggerHandler.apply(this,e),this)},e.fn.toggle=function(t,n){if(!e.isFunction(t)||!e.isFunction(n))return
N.apply(this,arguments);r(jQuery.fn.toggle(handler, handler) is
deprecated);var a=arguments,i=t.guid||e.guid++,o=0,s=function(n){var
r=(e._data(this,lastToggle+t.guid)||0)%o;return <a
href="r">e._data(this,lastToggle+t.guid,r+1),n.preventDefault(),a</a>.apply(this,arguments)||!1};<a
href="o++">for(s.guid=i;a.length>o;)a</a>.guid=i;return
this.click(s)},e.fn.live=function(t,n,a){return r(jQuery.fn.live() is
deprecated),T?T.apply(this,arguments):(e(this.context).on(t,this.selector,n,a),this)},e.fn.die=function(t,n){return
r(jQuery.fn.die() is
deprecated),M?M.apply(this,arguments):(e(this.context).off(t,this.selector||**,n),this)},e.event.trigger=function(e,t,n,a){return
n||C.test(e)||r(Global events are undocumented and
deprecated),k.call(this,e,t,n||document,a)},e.each(S.split(|),function(t,n){<a
href="n">e.event.special</a>={setup:function(){var t=this;return
t!==document&amp;&amp;(e.event.add(document,n+.+e.guid,function(){e.event.trigger(n,null,t,!0)}),e._data(this,n,e.guid++)),!1},teardown:function(){return
this!==document&amp;&amp;e.event.remove(document,n+.+e._data(this,n)),!1}}})}(jQuery,window);
/*! Backstretch - v2.0.4 - 2013-06-19</p>

<pre>http://srobbin.com/jquery-plugins/backstretch/
Copyright (c) 2013 Scott Robbin; Licensed MIT */</pre>

<p>(function(a,d,p){a.fn.backstretch=function(c,b){(c===p||0===c.length)&amp;&amp;a.error(No
images were supplied for
Backstretch);0===a(d).scrollTop()&amp;&amp;d.scrollTo(0,0);return
this.each(function(){var
d=a(this),g=d.data(backstretch);if(g){if(string==typeof
c&amp;&amp;function==typeof <a href="c">g</a>){<a
href="c">g</a>(b);return}b=a.extend(g.options,b);g.destroy(!0)}g=new
q(this,c,b);d.data(backstretch,g)})};a.backstretch=function(c,b){return
a(body).backstretch(c,b).data(backstretch)};<a
href="":"">a.expr</a>.backstretch=function{return
a.data(backstretch)!==p};a.fn.backstretch.defaults={centeredX:!0,centeredY:!0,duration:5E3,fade:0};var
r={left:0,top:0,overflow:hidden,margin:0,padding:0,height:100%,width:100%,zIndex:-999999},s={position:absolute,display:none,margin:0,padding:0,border:none,width:auto,height:auto,maxHeight:none,maxWidth:none,zIndex:-999999},q=function(c,b,e){this.options=a.extend({},a.fn.backstretch.defaults,e||{});<a
href="b">this.images=a.isArray(b)?b:</a>;a.each(this.images,function(){a(&lt;img
/&gt;)[0].src=this});this.isBody=c===document.body;this.$container=a;this.$root=this.isBody?l?a(d):a(document):this.$container;c=this.$container.children(.backstretch).first();this.$wrap=c.length?c:a(&#39;&lt;div
class=backstretch&gt;&lt;/div&gt;&#39;).css.appendTo(this.$container);this.isBody||(c=this.$container.css(position),b=this.$container.css(zIndex),this.$container.css({position:static===c?relative:c,zIndex:auto===b?0:b,background:none}),this.$wrap.css({zIndex:-999998}));this.$wrap.css({position:this.isBody&amp;&amp;l?fixed:absolute});this.index=0;this.show(this.index);a(d).on(resize.backstretch,a.proxy(this.resize,this)).on(orientationchange.backstretch,a.proxy(function(){this.isBody&amp;&amp;0===d.pageYOffset&amp;&amp;(d.scrollTo(0,1),this.resize())},this))};q.prototype={resize:function(){try{var
a={left:0,top:0},b=this.isBody?this.$root.width():this.$root.innerWidth(),e=b,g=this.isBody?d.innerHeight?d.innerHeight:this.$root.height():this.$root.innerHeight(),j=e/this.$img.data(ratio),f;j&gt;=g?(f=(j-g)/2,this.options.centeredY&amp;&amp;(a.top=-<code>f</code>px)):(j=g,e=j*this.$img.data(ratio),f=(e-b)/2,this.options.centeredX&amp;&amp;(a.left=-<code>f</code>px));this.$wrap.css({width:b,height:g}).find(img:not(.deleteable)).css({width:e,height:j}).css(a)}catch(h){}return
this},show:function{if(!(Math.abs&gt;this.images.length-1)){var
b=this,e=b.$wrap.find(img).addClass(deleteable),d={<a
href="0">relatedTarget:b.$container</a>};<a
href="b,c">b.$container.trigger(a.Event(backstretch.before,d),</a>);this.index=c;clearInterval(b.interval);b.$img=a(&lt;img
/&gt;).css(s).bind(load,function(f){var
h=this.width||a(f.target).width();f=this.height||a(f.target).height();a(this).data(ratio,h/f);a(this).fadeIn(b.options.speed||b.options.fade,function(){<a
href=""after","show"">e.remove();b.paused||b.cycle();a(</a>).each(function(){<a
href="b,c">b.$container.trigger(a.Event(backstretch.+this,d),</a>)})});b.resize()}).<a
href="c">appendTo(b.$wrap);b.$img.attr(src,b.images</a>);return
b}},next:function(){return
this.show(this.index&lt;this.images.length-1?this.index+1:0)},prev:function(){return
this.show(0===this.index?this.images.length-1:this.index-1)},pause:function(){this.paused=!0;return
this},resume:function(){this.paused=!1;this.next();return
this},cycle:function(){1&lt;this.images.length&amp;&amp;(clearInterval(this.interval),this.interval=setInterval(a.proxy(function(){this.paused||this.next()},this),this.options.duration));return
this},destroy:function{a(d).off(resize.backstretch
orientationchange.backstretch);clearInterval(this.interval);c||this.$wrap.remove();this.$container.removeData(backstretch)}};var
<a
href="0-9">l,f=navigator.userAgent,m=navigator.platform,e=f.match(/AppleWebKit/(</a>+)/),<a
href="1">e=!!e&&e</a>,<a href="0-9">h=f.match(/Fennec/(</a>+)/),<a
href="1">h=!!h&&h</a>,n=f.match(/Opera <a href="0-9">Mobi/(</a>+)/),<a
href="1">t=!!n&&n</a>,k=f.match(/MSIE ([<a
href="1">0-9]+)/),k=!!k&&k</a>;l=!((-1&lt;m.indexOf(iPhone)||-1&lt;m.indexOf(iPad)||-1&lt;m.indexOf(iPod))&amp;&amp;e&amp;&amp;534&gt;e||d.operamini&amp;&amp;[object
OperaMini]==={}.toString.call(d.operamini)||n&amp;&amp;7458&gt;t||-1&lt;f.indexOf(Android)&amp;&amp;e&amp;&amp;533&gt;e||h&amp;&amp;6&gt;h||palmGetResourcein
d&amp;&amp;e&amp;&amp;534&gt;e||-1&lt;f.indexOf(MeeGo)&amp;&amp;-1&lt;f.indexOf(NokiaBrowser/8.5.0)||k&amp;&amp;6&gt;=k)})(jQuery,window);
// ==ClosureCompiler== // @compilation_level SIMPLE_OPTIMIZATIONS</p>

<p>/**</p>

<pre> @license Highcharts JS v4.0.4 (2014-09-02)

 (c) 2009-2014 Torstein Honsi

 License: www.highcharts.com/license
/</pre>

<p>// JSLint options: /*global Highcharts, HighchartsAdapter, document,
window, navigator, setInterval, clearInterval, clearTimeout, setTimeout,
location, jQuery, $, console, each, grep */ /*jslint ass: true, sloppy:
true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true,
newcap: true, browser: true, continue: true, white: true */</p>

<p>(function () { // encapsulated variables var UNDEFINED,</p>

<pre>doc = document,
win = window,
math = Math,
mathRound = math.round,
mathFloor = math.floor,
mathCeil = math.ceil,
mathMax = math.max,
mathMin = math.min,
mathAbs = math.abs,
mathCos = math.cos,
mathSin = math.sin,
mathPI = math.PI,
deg2rad = mathPI * 2 / 360,

// some variables
userAgent = navigator.userAgent,
isOpera = win.opera,
isIE = /msie/i.test(userAgent) &amp;&amp; !isOpera,
docMode8 = doc.documentMode === 8,
isWebKit = /AppleWebKit/.test(userAgent),
isFirefox = /Firefox/.test(userAgent),
isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
SVG_NS = &#39;http://www.w3.org/2000/svg&#39;,
hasSVG = !!doc.createElementNS &amp;&amp; !!doc.createElementNS(SVG_NS, &#39;svg&#39;).createSVGRect,
hasBidiBug = isFirefox &amp;&amp; parseInt(userAgent.split(&#39;Firefox/&#39;)[1], 10) &lt; 4, // issue #38
useCanVG = !hasSVG &amp;&amp; !isIE &amp;&amp; !!doc.createElement(&#39;canvas&#39;).getContext,
Renderer,
hasTouch,
symbolSizes = {},
idCounter = 0,
garbageBin,
defaultOptions,
dateFormat, // function
globalAnimation,
pathAnim,
timeUnits,
error,
noop = function () { return UNDEFINED; },
charts = [],
chartCount = 0,
PRODUCT = &#39;Highcharts&#39;,
VERSION = &#39;4.0.4&#39;,

// some constants for frequently used strings
DIV = &#39;div&#39;,
ABSOLUTE = &#39;absolute&#39;,
RELATIVE = &#39;relative&#39;,
HIDDEN = &#39;hidden&#39;,
PREFIX = &#39;highcharts-&#39;,
VISIBLE = &#39;visible&#39;,
PX = &#39;px&#39;,
NONE = &#39;none&#39;,
M = &#39;M&#39;,
L = &#39;L&#39;,
numRegex = /^[0-9]+$/,
NORMAL_STATE = &#39;&#39;,
HOVER_STATE = &#39;hover&#39;,
SELECT_STATE = &#39;select&#39;,

// Object for extending Axis
AxisPlotLineOrBandExtension,

// constants for attributes
STROKE_WIDTH = &#39;stroke-width&#39;,

// time methods, changed based on whether or not UTC is used
Date,  // Allow using a different Date class
makeTime,
timezoneOffset,
getMinutes,
getHours,
getDay,
getDate,
getMonth,
getFullYear,
setMinutes,
setHours,
setDate,
setMonth,
setFullYear,

// lookup over the types and the associated classes
seriesTypes = {},
Highcharts;</pre>

<p>// The Highcharts namespace if (win.Highcharts) {</p>

<pre class="ruby"><span class="ruby-identifier">error</span>(<span class="ruby-value">16</span>, <span class="ruby-keyword">true</span>);
</pre>

<p>} else {</p>

<pre class="ruby"><span class="ruby-constant">Highcharts</span> = <span class="ruby-identifier">win</span>.<span class="ruby-constant">Highcharts</span> = {};
</pre>

<p>} /**</p>

<pre> Extend an object with the members of another
 @param {Object} a The object to be extended
 @param {Object} b The object to add to the first one
/</pre>

<p>function extend(a, b) {</p>

<pre>var n;
if (!a) {
        a = {};
}
for (n in b) {
        a[n] = b[n];
}
return a;</pre>

<p>}</p>

<p>/**</p>

<pre> Deep merge two or more objects and return a third object. If the first argument is
 true, the contents of the second object is copied into the first object.
 Previously this function redirected to jQuery.extend(true), but this had two limitations.
 First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
 it copied properties from extended prototypes. 
/</pre>

<p>function merge() {</p>

<pre>var i,
        args = arguments,
        len,
        ret = {},
        doCopy = function (copy, original) {
                var value, key;

                // An object is replacing a primitive
                if (typeof copy !== &#39;object&#39;) {
                        copy = {};
                }

                for (key in original) {
                        if (original.hasOwnProperty(key)) {
                                value = original[key];

                                // Copy the contents of objects, but not arrays or DOM nodes
                                if (value &amp;&amp; typeof value === &#39;object&#39; &amp;&amp; Object.prototype.toString.call(value) !== &#39;[object Array]&#39;
                                                &amp;&amp; key !== &#39;renderTo&#39; &amp;&amp; typeof value.nodeType !== &#39;number&#39;) {
                                        copy[key] = doCopy(copy[key] || {}, value);

                                // Primitives and arrays are copied over directly
                                } else {
                                        copy[key] = original[key];
                                }
                        }
                }
                return copy;
        };

// If first argument is true, copy into the existing object. Used in setOptions.
if (args[0] === true) {
        ret = args[1];
        args = Array.prototype.slice.call(args, 2);
}

// For each argument, extend the return
len = args.length;
for (i = 0; i &lt; len; i++) {
        ret = doCopy(ret, args[i]);
}

return ret;</pre>

<p>}</p>

<p>/**</p>

<pre> Shortcut for parseInt
 @param {Object} s
 @param {Number} mag Magnitude
/</pre>

<p>function pInt(s, mag) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">parseInt</span>(<span class="ruby-identifier">s</span>, <span class="ruby-identifier">mag</span> <span class="ruby-operator">||</span> <span class="ruby-value">10</span>);
</pre>

<p>}</p>

<p>/**</p>

<pre> Check for string
 @param {Object} s
/</pre>

<p>function isString(s) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">typeof</span> <span class="ruby-identifier">s</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;string&#39;</span>;
</pre>

<p>}</p>

<p>/**</p>

<pre> Check for object
 @param {Object} obj
/</pre>

<p>function isObject(obj) {</p>

<pre>return obj &amp;&amp; typeof obj === &#39;object&#39;;</pre>

<p>}</p>

<p>/**</p>

<pre> Check for array
 @param {Object} obj
/</pre>

<p>function isArray(obj) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">Object</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">toString</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">obj</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;[object Array]&#39;</span>;
</pre>

<p>}</p>

<p>/**</p>

<pre> Check for number
 @param {Object} n
/</pre>

<p>function isNumber(n) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">typeof</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;number&#39;</span>;
</pre>

<p>}</p>

<p>function log2lin(num) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">math</span>.<span class="ruby-identifier">log</span>(<span class="ruby-identifier">num</span>) <span class="ruby-operator">/</span> <span class="ruby-identifier">math</span>.<span class="ruby-constant">LN10</span>;
</pre>

<p>} function lin2log(num) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">math</span>.<span class="ruby-identifier">pow</span>(<span class="ruby-value">10</span>, <span class="ruby-identifier">num</span>);
</pre>

<p>}</p>

<p>/**</p>

<pre> Remove last occurence of an item from an array
 @param {Array} arr
 @param {Mixed} item
/</pre>

<p>function erase(arr, item) {</p>

<pre>var i = arr.length;
while (i--) {
        if (arr[i] === item) {
                arr.splice(i, 1);
                break;
        }
}
//return arr;</pre>

<p>}</p>

<p>/**</p>

<pre> Returns true if the object is not null or undefined. Like MooTools&#39; $.defined.
 @param {Object} obj
/</pre>

<p>function defined(obj) {</p>

<pre>return obj !== UNDEFINED &amp;&amp; obj !== null;</pre>

<p>}</p>

<p>/**</p>

<pre> Set or get an attribute or an object of attributes. Can&#39;t use jQuery attr because
 it attempts to set expando properties on the SVG element, which is not allowed.

 @param {Object} elem The DOM element to receive the attribute(s)
 @param {String|Object} prop The property or an abject of key-value pairs
 @param {String} value The value if a single property is set
/</pre>

<p>function attr(elem, prop, value) {</p>

<pre>var key,
        ret;

// if the prop is a string
if (isString(prop)) {
        // set the value
        if (defined(value)) {
                elem.setAttribute(prop, value);

        // get the value
        } else if (elem &amp;&amp; elem.getAttribute) { // elem not defined when printing pie demo...
                ret = elem.getAttribute(prop);
        }

// else if prop is defined, it is a hash of key/value pairs
} else if (defined(prop) &amp;&amp; isObject(prop)) {
        for (key in prop) {
                elem.setAttribute(key, prop[key]);
        }
}
return ret;</pre>

<p>} /**</p>

<pre> Check if an element is an array, and if not, make it into an array. Like
 MooTools&#39; $.splat.
/</pre>

<p>function splat(obj) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">isArray</span>(<span class="ruby-identifier">obj</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">obj</span> <span class="ruby-operator">:</span> [<span class="ruby-identifier">obj</span>];
</pre>

<p>}</p>

<p>/**</p>

<pre> Return the first value that is defined. Like MooTools&#39; $.pick.
/</pre>

<p>function pick() {</p>

<pre>var args = arguments,
        i,
        arg,
        length = args.length;
for (i = 0; i &lt; length; i++) {
        arg = args[i];
        if (arg !== UNDEFINED &amp;&amp; arg !== null) {
                return arg;
        }
}</pre>

<p>}</p>

<p>/**</p>

<pre> Set CSS on a given element
 @param {Object} el
 @param {Object} styles Style object with camel case property names
/</pre>

<p>function css(el, styles) {</p>

<pre>if (isIE &amp;&amp; !hasSVG) { // #2686
        if (styles &amp;&amp; styles.opacity !== UNDEFINED) {
                styles.filter = &#39;alpha(opacity=&#39; + (styles.opacity * 100) + &#39;)&#39;;
        }
}
extend(el.style, styles);</pre>

<p>}</p>

<p>/**</p>

<pre> Utility function to create element with attributes and styles
 @param {Object} tag
 @param {Object} attribs
 @param {Object} styles
 @param {Object} parent
 @param {Object} nopad
/</pre>

<p>function createElement(tag, attribs, styles, parent, nopad) {</p>

<pre>var el = doc.createElement(tag);
if (attribs) {
        extend(el, attribs);
}
if (nopad) {
        css(el, {padding: 0, border: NONE, margin: 0});
}
if (styles) {
        css(el, styles);
}
if (parent) {
        parent.appendChild(el);
}
return el;</pre>

<p>}</p>

<p>/**</p>

<pre> Extend a prototyped class by new members
 @param {Object} parent
 @param {Object} members
/</pre>

<p>function extendClass(parent, members) {</p>

<pre>var object = function () { return UNDEFINED; };
object.prototype = new parent();
extend(object.prototype, members);
return object;</pre>

<p>}</p>

<p>/**</p>

<pre> Format a number and return a string based on input settings
 @param {Number} number The input number to format
 @param {Number} decimals The amount of decimals
 @param {String} decPoint The decimal point, defaults to the one given in the lang options
 @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
/</pre>

<p>function numberFormat(number, decimals, decPoint, thousandsSep) {</p>

<pre>var externalFn = Highcharts.numberFormat,
        lang = defaultOptions.lang,
        // http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
        n = +number || 0,
        c = decimals === -1 ?
                (n.toString().split(&#39;.&#39;)[1] || &#39;&#39;).length : // preserve decimals
                (isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),
        d = decPoint === undefined ? lang.decimalPoint : decPoint,
        t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
        s = n &lt; 0 ? &quot;-&quot; : &quot;&quot;,
        i = String(pInt(n = mathAbs(n).toFixed(c))),
        j = i.length &gt; 3 ? i.length % 3 : 0;

return externalFn !== numberFormat ? 
        externalFn(number, decimals, decPoint, thousandsSep) :
        (s + (j ? i.substr(0, j) + t : &quot;&quot;) + i.substr(j).replace(/(\d{3})(?=\d)/g, &quot;$1&quot; + t) +
                (c ? d + mathAbs(n - i).toFixed(c).slice(2) : &quot;&quot;));</pre>

<p>}</p>

<p>/**</p>

<pre> Pad a string to a given length by adding 0 to the beginning
 @param {Number} number
 @param {Number} length
/</pre>

<p>function pad(number, length) {</p>

<pre>// Create an array of the remaining length +1 and join it with 0&#39;s
return new Array((length || 2) + 1 - String(number).length).join(0) + number;</pre>

<p>}</p>

<p>/**</p>

<pre> Wrap a method with extended functionality, preserving the original function
 @param {Object} obj The context object that the method belongs to 
 @param {String} method The name of the method to extend
 @param {Function} func A wrapper function callback. This function is called with the same arguments
 as the original function, except that the original function is unshifted and passed as the first 
 argument. 
/</pre>

<p>function wrap(obj, method, func) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">proceed</span> = <span class="ruby-identifier">obj</span>[<span class="ruby-identifier">method</span>];
<span class="ruby-identifier">obj</span>[<span class="ruby-identifier">method</span>] = <span class="ruby-identifier">function</span> () {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">args</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">arguments</span>);
        <span class="ruby-identifier">args</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">proceed</span>);
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">func</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">args</span>);
};
</pre>

<p>}</p>

<p>/**</p>

<pre> Based on http://www.php.net/manual/en/function.strftime.php
 @param {String} format
 @param {Number} timestamp
 @param {Boolean} capitalize
/</pre>

<p>dateFormat = function (format, timestamp, capitalize) {</p>

<pre>if (!defined(timestamp) || isNaN(timestamp)) {
        return &#39;Invalid date&#39;;
}
format = pick(format, &#39;%Y-%m-%d %H:%M:%S&#39;);

var date = new Date(timestamp - timezoneOffset),
        key, // used in for constuct below
        // get the basic time values
        hours = date[getHours](),
        day = date[getDay](),
        dayOfMonth = date[getDate](),
        month = date[getMonth](),
        fullYear = date[getFullYear](),
        lang = defaultOptions.lang,
        langWeekdays = lang.weekdays,

        // List all format keys. Custom formats can be added from the outside. 
        replacements = extend({

                // Day
                &#39;a&#39;: langWeekdays[day].substr(0, 3), // Short weekday, like &#39;Mon&#39;
                &#39;A&#39;: langWeekdays[day], // Long weekday, like &#39;Monday&#39;
                &#39;d&#39;: pad(dayOfMonth), // Two digit day of the month, 01 to 31
                &#39;e&#39;: dayOfMonth, // Day of the month, 1 through 31

                // Week (none implemented)
                //&#39;W&#39;: weekNumber(),

                // Month
                &#39;b&#39;: lang.shortMonths[month], // Short month, like &#39;Jan&#39;
                &#39;B&#39;: lang.months[month], // Long month, like &#39;January&#39;
                &#39;m&#39;: pad(month + 1), // Two digit month number, 01 through 12

                // Year
                &#39;y&#39;: fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
                &#39;Y&#39;: fullYear, // Four digits year, like 2009

                // Time
                &#39;H&#39;: pad(hours), // Two digits hours in 24h format, 00 through 23
                &#39;I&#39;: pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
                &#39;l&#39;: (hours % 12) || 12, // Hours in 12h format, 1 through 12
                &#39;M&#39;: pad(date[getMinutes]()), // Two digits minutes, 00 through 59
                &#39;p&#39;: hours &lt; 12 ? &#39;AM&#39; : &#39;PM&#39;, // Upper case AM or PM
                &#39;P&#39;: hours &lt; 12 ? &#39;am&#39; : &#39;pm&#39;, // Lower case AM or PM
                &#39;S&#39;: pad(date.getSeconds()), // Two digits seconds, 00 through  59
                &#39;L&#39;: pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
        }, Highcharts.dateFormats);

// do the replaces
for (key in replacements) {
        while (format.indexOf(&#39;%&#39; + key) !== -1) { // regex would do it in one line, but this is faster
                format = format.replace(&#39;%&#39; + key, typeof replacements[key] === &#39;function&#39; ? replacements[key](timestamp) : replacements[key]);
        }
}

// Optionally capitalize the string and return
return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;</pre>

<p>};</p>

<p>/**</p>

<pre> Format a single variable. Similar to sprintf, without the % prefix.
/</pre>

<p>function formatSingle(format, val) {</p>

<pre>var floatRegex = /f$/,
        decRegex = /\.([0-9])/,
        lang = defaultOptions.lang,
        decimals;

if (floatRegex.test(format)) { // float
        decimals = format.match(decRegex);
        decimals = decimals ? decimals[1] : -1;
        if (val !== null) {
                val = numberFormat(
                        val,
                        decimals,
                        lang.decimalPoint,
                        format.indexOf(&#39;,&#39;) &gt; -1 ? lang.thousandsSep : &#39;&#39;
                );
        }
} else {
        val = dateFormat(format, val);
}
return val;</pre>

<p>}</p>

<p>/**</p>

<pre> Format a string according to a subset of the rules of Python&#39;s String.format method.
/</pre>

<p>function format(str, ctx) {</p>

<pre>var splitter = &#39;{&#39;,
        isInside = false,
        segment,
        valueAndFormat,
        path,
        i,
        len,
        ret = [],
        val,
        index;

while ((index = str.indexOf(splitter)) !== -1) {

        segment = str.slice(0, index);
        if (isInside) { // we&#39;re on the closing bracket looking back

                valueAndFormat = segment.split(&#39;:&#39;);
                path = valueAndFormat.shift().split(&#39;.&#39;); // get first and leave format
                len = path.length;
                val = ctx;

                // Assign deeper paths
                for (i = 0; i &lt; len; i++) {
                        val = val[path[i]];
                }

                // Format the replacement
                if (valueAndFormat.length) {
                        val = formatSingle(valueAndFormat.join(&#39;:&#39;), val);
                }

                // Push the result and advance the cursor
                ret.push(val);

        } else {
                ret.push(segment);

        }
        str = str.slice(index + 1); // the rest
        isInside = !isInside; // toggle
        splitter = isInside ? &#39;}&#39; : &#39;{&#39;; // now look for next matching bracket
}
ret.push(str);
return ret.join(&#39;&#39;);</pre>

<p>}</p>

<p>/**</p>

<pre> Get the magnitude of a number
/</pre>

<p>function getMagnitude(num) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">math</span>.<span class="ruby-identifier">pow</span>(<span class="ruby-value">10</span>, <span class="ruby-identifier">mathFloor</span>(<span class="ruby-identifier">math</span>.<span class="ruby-identifier">log</span>(<span class="ruby-identifier">num</span>) <span class="ruby-operator">/</span> <span class="ruby-identifier">math</span>.<span class="ruby-constant">LN10</span>));
</pre>

<p>}</p>

<p>/**</p>

<pre> Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
 @param {Number} interval
 @param {Array} multiples
 @param {Number} magnitude
 @param {Object} options
/</pre>

<p>function normalizeTickInterval(interval, multiples, magnitude,
allowDecimals) {</p>

<pre>var normalized, i;

// round to a tenfold of 1, 2, 2.5 or 5
magnitude = pick(magnitude, 1);
normalized = interval / magnitude;

// multiples for a linear scale
if (!multiples) {
        multiples = [1, 2, 2.5, 5, 10];

        // the allowDecimals option
        if (allowDecimals === false) {
                if (magnitude === 1) {
                        multiples = [1, 2, 5, 10];
                } else if (magnitude &lt;= 0.1) {
                        multiples = [1 / magnitude];
                }
        }
}

// normalize the interval to the nearest multiple
for (i = 0; i &lt; multiples.length; i++) {
        interval = multiples[i];
        if (normalized &lt;= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
                break;
        }
}

// multiply back to the correct magnitude
interval *= magnitude;

return interval;</pre>

<p>}</p>

<p>/**</p>

<pre> Utility method that sorts an object array and keeping the order of equal items.
 ECMA script standard does not specify the behaviour when items are equal.
/</pre>

<p>function stableSort(arr, sortFunction) {</p>

<pre>var length = arr.length,
        sortValue,
        i;

// Add index to each item
for (i = 0; i &lt; length; i++) {
        arr[i].ss_i = i; // stable sort index
}

arr.sort(function (a, b) {
        sortValue = sortFunction(a, b);
        return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
});

// Remove index from items
for (i = 0; i &lt; length; i++) {
        delete arr[i].ss_i; // stable sort index
}</pre>

<p>}</p>

<p>/**</p>

<pre> Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 method is slightly slower, but safe.
/</pre>

<p>function arrayMin(data) {</p>

<pre>var i = data.length,
        min = data[0];

while (i--) {
        if (data[i] &lt; min) {
                min = data[i];
        }
}
return min;</pre>

<p>}</p>

<p>/**</p>

<pre> Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 method is slightly slower, but safe.
/</pre>

<p>function arrayMax(data) {</p>

<pre>var i = data.length,
        max = data[0];

while (i--) {
        if (data[i] &gt; max) {
                max = data[i];
        }
}
return max;</pre>

<p>}</p>

<p>/**</p>

<pre> Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
 It loops all properties and invokes destroy if there is a destroy method. The property is
 then delete&#39;ed.
 @param {Object} The object to destroy properties on
 @param {Object} Exception, do not destroy this property, only delete it.
/</pre>

<p>function destroyObjectProperties(obj, except) {</p>

<pre>var n;
for (n in obj) {
        // If the object is non-null and destroy is defined
        if (obj[n] &amp;&amp; obj[n] !== except &amp;&amp; obj[n].destroy) {
                // Invoke the destroy
                obj[n].destroy();
        }

        // Delete the property from the object.
        delete obj[n];
}</pre>

<p>}</p>

<p>/**</p>

<pre> Discard an element by moving it to the bin and delete
 @param {Object} The HTML node to discard
/</pre>

<p>function discardElement(element) {</p>

<pre>// create a garbage bin element, not part of the DOM
if (!garbageBin) {
        garbageBin = createElement(DIV);
}

// move the node and empty bin
if (element) {
        garbageBin.appendChild(element);
}
garbageBin.innerHTML = &#39;&#39;;</pre>

<p>}</p>

<p>/**</p>

<pre> Provide error messages for debugging, with links to online explanation 
/</pre>

<p>error = function (code, stop) {</p>

<pre>var msg = &#39;Highcharts error #&#39; + code + &#39;: www.highcharts.com/errors/&#39; + code;
if (stop) {
        throw msg;
}
// else ...
if (win.console) {
        console.log(msg);
}</pre>

<p>};</p>

<p>/**</p>

<pre> Fix JS round off float errors
 @param {Number} num
/</pre>

<p>function correctFloat(num) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">parseFloat</span>(
        <span class="ruby-identifier">num</span>.<span class="ruby-identifier">toPrecision</span>(<span class="ruby-value">14</span>)
);
</pre>

<p>}</p>

<p>/**</p>

<pre> Set the global animation to either a given value, or fall back to the
 given chart&#39;s animation option
 @param {Object} animation
 @param {Object} chart
/</pre>

<p>function setAnimation(animation, chart) {</p>

<pre class="ruby"><span class="ruby-identifier">globalAnimation</span> = <span class="ruby-identifier">pick</span>(<span class="ruby-identifier">animation</span>, <span class="ruby-identifier">chart</span>.<span class="ruby-identifier">animation</span>);
</pre>

<p>}</p>

<p>/**</p>

<pre> The time unit lookup
/</pre>

<p>timeUnits = {</p>

<pre>millisecond: 1,
second: 1000,
minute: 60000,
hour: 3600000,
day: 24 * 3600000,
week: 7 * 24 * 3600000,
month: 31 * 24 * 3600000,
year: 31556952000</pre>

<p>}; /**</p>

<pre> Path interpolation algorithm used across adapters
/</pre>

<p>pathAnim = {</p>

<pre>     /**
 Prepare start and end values so that the path can be animated one to one
/
     init: function (elem, fromD, toD) {
             fromD = fromD || &#39;&#39;;
             var shift = elem.shift,
                     bezier = fromD.indexOf(&#39;C&#39;) &gt; -1,
                     numParams = bezier ? 7 : 3,
                     endLength,
                     slice,
                     i,
                     start = fromD.split(&#39; &#39;),
                     end = [].concat(toD), // copy
                     startBaseLine,
                     endBaseLine,
                     sixify = function (arr) { // in splines make move points have six parameters like bezier curves
                             i = arr.length;
                             while (i--) {
                                     if (arr[i] === M) {
                                             arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
                                     }
                             }
                     };

             if (bezier) {
                     sixify(start);
                     sixify(end);
             }

             // pull out the base lines before padding
             if (elem.isArea) {
                     startBaseLine = start.splice(start.length - 6, 6);
                     endBaseLine = end.splice(end.length - 6, 6);
             }

             // if shifting points, prepend a dummy point to the end path
             if (shift &lt;= end.length / numParams &amp;&amp; start.length === end.length) {
                     while (shift--) {
                             end = [].concat(end).splice(0, numParams).concat(end);
                     }
             }
             elem.shift = 0; // reset for following animations

             // copy and append last point until the length matches the end length
             if (start.length) {
                     endLength = end.length;
                     while (start.length &lt; endLength) {

                             //bezier &amp;&amp; sixify(start);
                             slice = [].concat(start).splice(start.length - numParams, numParams);
                             if (bezier) { // disable first control point
                                     slice[numParams - 6] = slice[numParams - 2];
                                     slice[numParams - 5] = slice[numParams - 1];
                             }
                             start = start.concat(slice);
                     }
             }

             if (startBaseLine) { // append the base lines for areas
                     start = start.concat(startBaseLine);
                     end = end.concat(endBaseLine);
             }
             return [start, end];
     },

     /**
 Interpolate each value of the path and return the array
/
     step: function (start, end, pos, complete) {
             var ret = [],
                     i = start.length,
                     startVal;

             if (pos === 1) { // land on the final path without adjustment points appended in the ends
                     ret = complete;

             } else if (i === end.length &amp;&amp; pos &lt; 1) {
                     while (i--) {
                             startVal = parseFloat(start[i]);
                             ret[i] =
                                     isNaN(startVal) ? // a letter instruction like M or L
                                             start[i] :
                                             pos * (parseFloat(end[i] - startVal)) + startVal;

                     }
             } else { // if animation is finished or length not matching, land on right value
                     ret = end;
             }
             return ret;
     }</pre>

<p>};</p>

<p>(function ($) {</p>

<pre>     /**
 The default HighchartsAdapter for jQuery
/
     win.HighchartsAdapter = win.HighchartsAdapter || ($ &amp;&amp; {

             /**
  Initialize the adapter by applying some extensions to jQuery
 /
             init: function (pathAnim) {

                     // extend the animate function to allow SVG animations
                     var Fx = $.fx;

                     /*jslint unparam: true*//* allow unused param x in this function */
                     $.extend($.easing, {
                             easeOutQuad: function (x, t, b, c, d) {
                                     return -c * (t /= d) * (t - 2) + b;
                             }
                     });
                     /*jslint unparam: false*/

                     // extend some methods to check for elem.attr, which means it is a Highcharts SVG object
                     $.each([&#39;cur&#39;, &#39;_default&#39;, &#39;width&#39;, &#39;height&#39;, &#39;opacity&#39;], function (i, fn) {
                             var obj = Fx.step,
                                     base;

                             // Handle different parent objects
                             if (fn === &#39;cur&#39;) {
                                     obj = Fx.prototype; // &#39;cur&#39;, the getter, relates to Fx.prototype

                             } else if (fn === &#39;_default&#39; &amp;&amp; $.Tween) { // jQuery 1.8 model
                                     obj = $.Tween.propHooks[fn];
                                     fn = &#39;set&#39;;
                             }

                             // Overwrite the method
                             base = obj[fn];
                             if (base) { // step.width and step.height don&#39;t exist in jQuery &lt; 1.7

                                     // create the extended function replacement
                                     obj[fn] = function (fx) {

                                             var elem;

                                             // Fx.prototype.cur does not use fx argument
                                             fx = i ? fx : this;

                                             // Don&#39;t run animations on textual properties like align (#1821)
                                             if (fx.prop === &#39;align&#39;) {
                                                     return;
                                             }

                                             // shortcut
                                             elem = fx.elem;

                                             // Fx.prototype.cur returns the current value. The other ones are setters
                                             // and returning a value has no effect.
                                             return elem.attr ? // is SVG element wrapper
                                                     elem.attr(fx.prop, fn === &#39;cur&#39; ? UNDEFINED : fx.now) : // apply the SVG wrapper&#39;s method
                                                     base.apply(this, arguments); // use jQuery&#39;s built-in method
                                     };
                             }
                     });

                     // Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+
                     wrap($.cssHooks.opacity, &#39;get&#39;, function (proceed, elem, computed) {
                             return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);
                     });

                     // Define the setter function for d (path definitions)
                     this.addAnimSetter(&#39;d&#39;, function (fx) {
                             var elem = fx.elem,
                                     ends;

                             // Normally start and end should be set in state == 0, but sometimes,
                             // for reasons unknown, this doesn&#39;t happen. Perhaps state == 0 is skipped
                             // in these cases
                             if (!fx.started) {
                                     ends = pathAnim.init(elem, elem.d, elem.toD);
                                     fx.start = ends[0];
                                     fx.end = ends[1];
                                     fx.started = true;
                             }

                             // Interpolate each value of the path
                             elem.attr(&#39;d&#39;, pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
                     });

                     /**
   Utility for iterating over an array. Parameters are reversed compared to jQuery.
   @param {Array} arr
   @param {Function} fn
  /
                     this.each = Array.prototype.forEach ?
                             function (arr, fn) { // modern browsers
                                     return Array.prototype.forEach.call(arr, fn);

                             } : 
                             function (arr, fn) { // legacy
                                     var i, 
                                             len = arr.length;
                                     for (i = 0; i &lt; len; i++) {
                                             if (fn.call(arr[i], arr[i], i, arr) === false) {
                                                     return i;
                                             }
                                     }
                             };

                     /**
   Register Highcharts as a plugin in the respective framework
  /
                     $.fn.highcharts = function () {
                             var constr = &#39;Chart&#39;, // default constructor
                                     args = arguments,
                                     options,
                                     ret,
                                     chart;

                             if (this[0]) {

                                     if (isString(args[0])) {
                                             constr = args[0];
                                             args = Array.prototype.slice.call(args, 1); 
                                     }
                                     options = args[0];

                                     // Create the chart
                                     if (options !== UNDEFINED) {
                                             /*jslint unused:false*/
                                             options.chart = options.chart || {};
                                             options.chart.renderTo = this[0];
                                             chart = new Highcharts[constr](options, args[1]);
                                             ret = this;
                                             /*jslint unused:true*/
                                     }

                                     // When called without parameters or with the return argument, get a predefined chart
                                     if (options === UNDEFINED) {
                                             ret = charts[attr(this[0], &#39;data-highcharts-chart&#39;)];
                                     }
                             }

                             return ret;
                     };

             },

             /**
  Add an animation setter for a specific property
 /
             addAnimSetter: function (prop, setter) {
                     // jQuery 1.8 style
                     if ($.Tween) {
                             $.Tween.propHooks[prop] = {
                                     set: setter
                             };
                     // pre 1.8
                     } else {
                             $.fx.step[prop] = setter;
                     }
             },

             /**
  Downloads a script and executes a callback when done.
  @param {String} scriptLocation
  @param {Function} callback
 /
             getScript: $.getScript,

             /**
  Return the index of an item in an array, or -1 if not found
 /
             inArray: $.inArray,

             /**
  A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.
  @param {Object} elem The HTML element
  @param {String} method Which method to run on the wrapped element
 /
             adapterRun: function (elem, method) {
                     return $(elem)[method]();
             },

             /**
  Filter an array
 /
             grep: $.grep,

             /**
  Map an array
  @param {Array} arr
  @param {Function} fn
 /
             map: function (arr, fn) {
                     //return jQuery.map(arr, fn);
                     var results = [],
                             i = 0,
                             len = arr.length;
                     for (; i &lt; len; i++) {
                             results[i] = fn.call(arr[i], arr[i], i, arr);
                     }
                     return results;

             },

             /**
  Get the position of an element relative to the top left of the page
 /
             offset: function (el) {
                     return $(el).offset();
             },

             /**
  Add an event listener
  @param {Object} el A HTML element or custom object
  @param {String} event The event type
  @param {Function} fn The event handler
 /
             addEvent: function (el, event, fn) {
                     $(el).bind(event, fn);
             },

             /**
  Remove event added with addEvent
  @param {Object} el The object
  @param {String} eventType The event type. Leave blank to remove all events.
  @param {Function} handler The function to remove
 /
             removeEvent: function (el, eventType, handler) {
                     // workaround for jQuery issue with unbinding custom events:
                     // http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2
                     var func = doc.removeEventListener ? &#39;removeEventListener&#39; : &#39;detachEvent&#39;;
                     if (doc[func] &amp;&amp; el &amp;&amp; !el[func]) {
                             el[func] = function () {};
                     }

                     $(el).unbind(eventType, handler);
             },

             /**
  Fire an event on a custom object
  @param {Object} el
  @param {String} type
  @param {Object} eventArguments
  @param {Function} defaultFunction
 /
             fireEvent: function (el, type, eventArguments, defaultFunction) {
                     var event = $.Event(type),
                             detachedType = &#39;detached&#39; + type,
                             defaultPrevented;

                     // Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts
                     // never uses these properties, Chrome includes them in the default click event and
                     // raises the warning when they are copied over in the extend statement below.
                     //
                     // To avoid problems in IE (see #1010) where we cannot delete the properties and avoid
                     // testing if they are there (warning in chrome) the only option is to test if running IE.
                     if (!isIE &amp;&amp; eventArguments) {
                             delete eventArguments.layerX;
                             delete eventArguments.layerY;
                             delete eventArguments.returnValue;
                     }

                     extend(event, eventArguments);

                     // Prevent jQuery from triggering the object method that is named the
                     // same as the event. For example, if the event is &#39;select&#39;, jQuery
                     // attempts calling el.select and it goes into a loop.
                     if (el[type]) {
                             el[detachedType] = el[type];
                             el[type] = null;
                     }

                     // Wrap preventDefault and stopPropagation in try/catch blocks in
                     // order to prevent JS errors when cancelling events on non-DOM
                     // objects. #615.
                     /*jslint unparam: true*/
                     $.each([&#39;preventDefault&#39;, &#39;stopPropagation&#39;], function (i, fn) {
                             var base = event[fn];
                             event[fn] = function () {
                                     try {
                                             base.call(event);
                                     } catch (e) {
                                             if (fn === &#39;preventDefault&#39;) {
                                                     defaultPrevented = true;
                                             }
                                     }
                             };
                     });
                     /*jslint unparam: false*/

                     // trigger it
                     $(el).trigger(event);

                     // attach the method
                     if (el[detachedType]) {
                             el[type] = el[detachedType];
                             el[detachedType] = null;
                     }

                     if (defaultFunction &amp;&amp; !event.isDefaultPrevented() &amp;&amp; !defaultPrevented) {
                             defaultFunction(event);
                     }
             },

             /**
  Extension method needed for MooTools
 /
             washMouseEvent: function (e) {
                     var ret = e.originalEvent || e;

                     // computed by jQuery, needed by IE8
                     if (ret.pageX === UNDEFINED) { // #1236
                             ret.pageX = e.pageX;
                             ret.pageY = e.pageY;
                     }

                     return ret;
             },

             /**
  Animate a HTML element or SVG element wrapper
  @param {Object} el
  @param {Object} params
  @param {Object} options jQuery-like animation options: duration, easing, callback
 /
             animate: function (el, params, options) {
                     var $el = $(el);
                     if (!el.style) {
                             el.style = {}; // #1881
                     }
                     if (params.d) {
                             el.toD = params.d; // keep the array form for paths, used in $.fx.step.d
                             params.d = 1; // because in jQuery, animating to an array has a different meaning
                     }

                     $el.stop();
                     if (params.opacity !== UNDEFINED &amp;&amp; el.attr) {
                             params.opacity += &#39;px&#39;; // force jQuery to use same logic as width and height (#2161)
                     }
                     el.hasAnim = 1; // #3342
                     $el.animate(params, options);

             },
             /**
  Stop running animation
 /
             stop: function (el) {
                     if (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy
                             $(el).stop();
                     }
             }
     });</pre>

<p>}(win.jQuery));</p>

<p>// check for a custom HighchartsAdapter defined prior to this file var
globalAdapter = win.HighchartsAdapter,</p>

<pre class="ruby"><span class="ruby-identifier">adapter</span> = <span class="ruby-identifier">globalAdapter</span> <span class="ruby-operator">||</span> {};
</pre>

<p>// Initialize the adapter if (globalAdapter) {</p>

<pre class="ruby"><span class="ruby-identifier">globalAdapter</span>.<span class="ruby-identifier">init</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">globalAdapter</span>, <span class="ruby-identifier">pathAnim</span>);
</pre>

<p>}</p>

<p>// Utility functions. If the HighchartsAdapter is not defined, adapter is
an empty object // and all the utility functions will be null. In that case
they are populated by the // default adapters below. var adapterRun =
adapter.adapterRun,</p>

<pre class="ruby"><span class="ruby-identifier">getScript</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">getScript</span>,
<span class="ruby-identifier">inArray</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">inArray</span>,
<span class="ruby-identifier">each</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">each</span>,
<span class="ruby-identifier">grep</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">grep</span>,
<span class="ruby-identifier">offset</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">offset</span>,
<span class="ruby-identifier">map</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">map</span>,
<span class="ruby-identifier">addEvent</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">addEvent</span>,
<span class="ruby-identifier">removeEvent</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">removeEvent</span>,
<span class="ruby-identifier">fireEvent</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">fireEvent</span>,
<span class="ruby-identifier">washMouseEvent</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">washMouseEvent</span>,
<span class="ruby-identifier">animate</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">animate</span>,
<span class="ruby-identifier">stop</span> = <span class="ruby-identifier">adapter</span>.<span class="ruby-identifier">stop</span>;
</pre>

<p>/*
****************************************************************************</p>

<pre>Handle the options                                                         *
***************************************************************************/</pre>

<p>var</p>

<p>defaultLabelOptions = {</p>

<pre>enabled: true,
// rotation: 0,
// align: &#39;center&#39;,
x: 0,
y: 15,
/*formatter: function () {
        return this.value;
},*/
style: {
        color: &#39;#606060&#39;,
        cursor: &#39;default&#39;,
        fontSize: &#39;11px&#39;
}</pre>

<p>};</p>

<p>defaultOptions = {</p>

<pre>colors: [&#39;#7cb5ec&#39;, &#39;#434348&#39;, &#39;#90ed7d&#39;, &#39;#f7a35c&#39;, 
            &#39;#8085e9&#39;, &#39;#f15c80&#39;, &#39;#e4d354&#39;, &#39;#8085e8&#39;, &#39;#8d4653&#39;, &#39;#91e8e1&#39;],
symbols: [&#39;circle&#39;, &#39;diamond&#39;, &#39;square&#39;, &#39;triangle&#39;, &#39;triangle-down&#39;],
lang: {
        loading: &#39;Loading...&#39;,
        months: [&#39;January&#39;, &#39;February&#39;, &#39;March&#39;, &#39;April&#39;, &#39;May&#39;, &#39;June&#39;, &#39;July&#39;,
                        &#39;August&#39;, &#39;September&#39;, &#39;October&#39;, &#39;November&#39;, &#39;December&#39;],
        shortMonths: [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;],
        weekdays: [&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;],
        decimalPoint: &#39;.&#39;,
        numericSymbols: [&#39;k&#39;, &#39;M&#39;, &#39;G&#39;, &#39;T&#39;, &#39;P&#39;, &#39;E&#39;], // SI prefixes used in axis labels
        resetZoom: &#39;Reset zoom&#39;,
        resetZoomTitle: &#39;Reset zoom level 1:1&#39;,
        thousandsSep: &#39;,&#39;
},
global: {
        useUTC: true,
        //timezoneOffset: 0,
        canvasToolsURL: &#39;http://code.highcharts.com/4.0.4/modules/canvas-tools.js&#39;,
        VMLRadialGradientURL: &#39;http://code.highcharts.com/4.0.4/gfx/vml-radial-gradient.png&#39;
},
chart: {
        //animation: true,
        //alignTicks: false,
        //reflow: true,
        //className: null,
        //events: { load, selection },
        //margin: [null],
        //marginTop: null,
        //marginRight: null,
        //marginBottom: null,
        //marginLeft: null,
        borderColor: &#39;#4572A7&#39;,
        //borderWidth: 0,
        borderRadius: 0,
        defaultSeriesType: &#39;line&#39;,
        ignoreHiddenSeries: true,
        //inverted: false,
        //shadow: false,
        spacing: [10, 10, 15, 10],
        //spacingTop: 10,
        //spacingRight: 10,
        //spacingBottom: 15,
        //spacingLeft: 10,
        //style: {
        //      fontFamily: &#39;&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif&#39;, // default font
        //      fontSize: &#39;12px&#39;
        //},
        backgroundColor: &#39;#FFFFFF&#39;,
        //plotBackgroundColor: null,
        plotBorderColor: &#39;#C0C0C0&#39;,
        //plotBorderWidth: 0,
        //plotShadow: false,
        //zoomType: &#39;&#39;
        resetZoomButton: {
                theme: {
                        zIndex: 20
                },
                position: {
                        align: &#39;right&#39;,
                        x: -10,
                        //verticalAlign: &#39;top&#39;,
                        y: 10
                }
                // relativeTo: &#39;plot&#39;
        }
},
title: {
        text: &#39;Chart title&#39;,
        align: &#39;center&#39;,
        // floating: false,
        margin: 15,
        // x: 0,
        // verticalAlign: &#39;top&#39;,
        // y: null,
        style: {
                color: &#39;#333333&#39;,
                fontSize: &#39;18px&#39;
        }

},
subtitle: {
        text: &#39;&#39;,
        align: &#39;center&#39;,
        // floating: false
        // x: 0,
        // verticalAlign: &#39;top&#39;,
        // y: null,
        style: {
                color: &#39;#555555&#39;
        }
},

plotOptions: {
        line: { // base series options
                allowPointSelect: false,
                showCheckbox: false,
                animation: {
                        duration: 1000
                },
                //connectNulls: false,
                //cursor: &#39;default&#39;,
                //clip: true,
                //dashStyle: null,
                //enableMouseTracking: true,
                events: {},
                //legendIndex: 0,
                //linecap: &#39;round&#39;,
                lineWidth: 2,
                //shadow: false,
                // stacking: null,
                marker: {
                        //enabled: true,
                        //symbol: null,
                        lineWidth: 0,
                        radius: 4,
                        lineColor: &#39;#FFFFFF&#39;,
                        //fillColor: null,
                        states: { // states for a single point
                                hover: {
                                        enabled: true,
                                        lineWidthPlus: 1,
                                        radiusPlus: 2
                                },
                                select: {
                                        fillColor: &#39;#FFFFFF&#39;,
                                        lineColor: &#39;#000000&#39;,
                                        lineWidth: 2
                                }
                        }
                },
                point: {
                        events: {}
                },
                dataLabels: merge(defaultLabelOptions, {
                        align: &#39;center&#39;,
                        //defer: true,
                        enabled: false,
                        formatter: function () {
                                return this.y === null ? &#39;&#39; : numberFormat(this.y, -1);
                        },
                        verticalAlign: &#39;bottom&#39;, // above singular point
                        y: 0
                        // backgroundColor: undefined,
                        // borderColor: undefined,
                        // borderRadius: undefined,
                        // borderWidth: undefined,
                        // padding: 3,
                        // shadow: false
                }),
                cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
                pointRange: 0,
                //pointStart: 0,
                //pointInterval: 1,
                //showInLegend: null, // auto: true for standalone series, false for linked series
                states: { // states for the entire series
                        hover: {
                                //enabled: false,
                                lineWidthPlus: 1,
                                marker: {
                                        // lineWidth: base + 1,
                                        // radius: base + 1
                                },
                                halo: {
                                        size: 10,
                                        opacity: 0.25
                                }
                        },
                        select: {
                                marker: {}
                        }
                },
                stickyTracking: true,
                //tooltip: {
                        //pointFormat: &#39;&lt;span style=&quot;color:{series.color}&quot;&gt;\u25CF&lt;/span&gt; {series.name}: &lt;b&gt;{point.y}&lt;/b&gt;&#39;
                        //valueDecimals: null,
                        //xDateFormat: &#39;%A, %b %e, %Y&#39;,
                        //valuePrefix: &#39;&#39;,
                        //ySuffix: &#39;&#39;                           
                //}
                turboThreshold: 1000
                // zIndex: null
        }
},
labels: {
        //items: [],
        style: {
                //font: defaultFont,
                position: ABSOLUTE,
                color: &#39;#3E576F&#39;
        }
},
legend: {
        enabled: true,
        align: &#39;center&#39;,
        //floating: false,
        layout: &#39;horizontal&#39;,
        labelFormatter: function () {
                return this.name;
        },
        //borderWidth: 0,
        borderColor: &#39;#909090&#39;,
        borderRadius: 0,
        navigation: {
                // animation: true,
                activeColor: &#39;#274b6d&#39;,
                // arrowSize: 12
                inactiveColor: &#39;#CCC&#39;
                // style: {} // text styles
        },
        // margin: 20,
        // reversed: false,
        shadow: false,
        // backgroundColor: null,
        /*style: {
                padding: &#39;5px&#39;
        },*/
        itemStyle: {                    
                color: &#39;#333333&#39;,
                fontSize: &#39;12px&#39;,
                fontWeight: &#39;bold&#39;
        },
        itemHoverStyle: {
                //cursor: &#39;pointer&#39;, removed as of #601
                color: &#39;#000&#39;
        },
        itemHiddenStyle: {
                color: &#39;#CCC&#39;
        },
        itemCheckboxStyle: {
                position: ABSOLUTE,
                width: &#39;13px&#39;, // for IE precision
                height: &#39;13px&#39;
        },
        // itemWidth: undefined,
        // symbolRadius: 0,
        // symbolWidth: 16,
        symbolPadding: 5,
        verticalAlign: &#39;bottom&#39;,
        // width: undefined,
        x: 0,
        y: 0,
        title: {
                //text: null,
                style: {
                        fontWeight: &#39;bold&#39;
                }
        }                       
},

loading: {
        // hideDuration: 100,
        labelStyle: {
                fontWeight: &#39;bold&#39;,
                position: RELATIVE,
                top: &#39;45%&#39;
        },
        // showDuration: 0,
        style: {
                position: ABSOLUTE,
                backgroundColor: &#39;white&#39;,
                opacity: 0.5,
                textAlign: &#39;center&#39;
        }
},

tooltip: {
        enabled: true,
        animation: hasSVG,
        //crosshairs: null,
        backgroundColor: &#39;rgba(249, 249, 249, .85)&#39;,
        borderWidth: 1,
        borderRadius: 3,
        dateTimeLabelFormats: { 
                millisecond: &#39;%A, %b %e, %H:%M:%S.%L&#39;,
                second: &#39;%A, %b %e, %H:%M:%S&#39;,
                minute: &#39;%A, %b %e, %H:%M&#39;,
                hour: &#39;%A, %b %e, %H:%M&#39;,
                day: &#39;%A, %b %e, %Y&#39;,
                week: &#39;Week from %A, %b %e, %Y&#39;,
                month: &#39;%B %Y&#39;,
                year: &#39;%Y&#39;
        },
        //formatter: defaultFormatter,
        headerFormat: &#39;&lt;span style=&quot;font-size: 10px&quot;&gt;{point.key}&lt;/span&gt;&lt;br/&gt;&#39;,
        pointFormat: &#39;&lt;span style=&quot;color:{series.color}&quot;&gt;\u25CF&lt;/span&gt; {series.name}: &lt;b&gt;{point.y}&lt;/b&gt;&lt;br/&gt;&#39;,
        shadow: true,
        //shape: &#39;callout&#39;,
        //shared: false,
        snap: isTouchDevice ? 25 : 10,
        style: {
                color: &#39;#333333&#39;,
                cursor: &#39;default&#39;,
                fontSize: &#39;12px&#39;,
                padding: &#39;8px&#39;,
                whiteSpace: &#39;nowrap&#39;
        }
        //xDateFormat: &#39;%A, %b %e, %Y&#39;,
        //valueDecimals: null,
        //valuePrefix: &#39;&#39;,
        //valueSuffix: &#39;&#39;
},

credits: {
        enabled: true,
        text: &#39;Highcharts.com&#39;,
        href: &#39;http://www.highcharts.com&#39;,
        position: {
                align: &#39;right&#39;,
                x: -10,
                verticalAlign: &#39;bottom&#39;,
                y: -5
        },
        style: {
                cursor: &#39;pointer&#39;,
                color: &#39;#909090&#39;,
                fontSize: &#39;9px&#39;
        }
}</pre>

<p>};</p>

<p>// Series defaults var defaultPlotOptions = defaultOptions.plotOptions,</p>

<pre class="ruby"><span class="ruby-identifier">defaultSeriesOptions</span> = <span class="ruby-identifier">defaultPlotOptions</span>.<span class="ruby-identifier">line</span>;
</pre>

<p>// set the default time methods setTimeMethods();</p>

<p>/**</p>

<pre class="ruby"> <span class="ruby-constant">Set</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">time</span> <span class="ruby-identifier">methods</span> <span class="ruby-identifier">globally</span> <span class="ruby-identifier">based</span> <span class="ruby-identifier">on</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">useUTC</span> <span class="ruby-identifier">option</span>. <span class="ruby-constant">Time</span> <span class="ruby-identifier">method</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">either</span>
 <span class="ruby-identifier">local</span> <span class="ruby-identifier">time</span> <span class="ruby-keyword">or</span> <span class="ruby-constant">UTC</span> (<span class="ruby-identifier">default</span>).
<span class="ruby-operator">/</span>
</pre>

<p>function setTimeMethods() {</p>

<pre>var useUTC = defaultOptions.global.useUTC,
        GET = useUTC ? &#39;getUTC&#39; : &#39;get&#39;,
        SET = useUTC ? &#39;setUTC&#39; : &#39;set&#39;;

Date = defaultOptions.global.Date || window.Date;
timezoneOffset = ((useUTC &amp;&amp; defaultOptions.global.timezoneOffset) || 0) * 60000;
makeTime = useUTC ? Date.UTC : function (year, month, date, hours, minutes, seconds) {
        return new Date(
                year,
                month,
                pick(date, 1),
                pick(hours, 0),
                pick(minutes, 0),
                pick(seconds, 0)
        ).getTime();
};
getMinutes =  GET + &#39;Minutes&#39;;
getHours =    GET + &#39;Hours&#39;;
getDay =      GET + &#39;Day&#39;;
getDate =     GET + &#39;Date&#39;;
getMonth =    GET + &#39;Month&#39;;
getFullYear = GET + &#39;FullYear&#39;;
setMinutes =  SET + &#39;Minutes&#39;;
setHours =    SET + &#39;Hours&#39;;
setDate =     SET + &#39;Date&#39;;
setMonth =    SET + &#39;Month&#39;;
setFullYear = SET + &#39;FullYear&#39;;</pre>

<p>}</p>

<p>/**</p>

<pre> Merge the default options with custom options and return the new options structure
 @param {Object} options The new custom options
/</pre>

<p>function setOptions(options) {</p>

<pre>// Copy in the default options
defaultOptions = merge(true, defaultOptions, options);

// Apply UTC
setTimeMethods();

return defaultOptions;</pre>

<p>}</p>

<p>/**</p>

<pre> Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
 wasn&#39;t enough because the setOptions method created a new object.
/</pre>

<p>function getOptions() {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">defaultOptions</span>;
</pre>

<p>}</p>

<p>/**</p>

<pre> Handle color operations. The object methods are chainable.
 @param {String} input The input color in either rbga or hex format
/</pre>

<p>var rgbaRegEx = /<a href="0-9">rgba(s*(</a>{1,3})<a
href=0-9>s*,s*(</a>{1,3})<a href=0-9>s*,s*(</a>{1,3})<a
href=0-9>s*,s*(</a>?(?:.[0-9]+)?)s*)/,</p>

<pre class="ruby"><span class="ruby-identifier">hexRegEx</span> = <span class="ruby-node">/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/</span>,
<span class="ruby-identifier">rgbRegEx</span> = <span class="ruby-regexp">/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/</span>;
</pre>

<p>var Color = function (input) {</p>

<pre>     // declare variables
     var rgba = [], result, stops;

     /**
 Parse the input color to rgba array
 @param {String} input
/
     function init(input) {

             // Gradients
             if (input &amp;&amp; input.stops) {
                     stops = map(input.stops, function (stop) {
                             return Color(stop[1]);
                     });

             // Solid colors
             } else {
                     // rgba
                     result = rgbaRegEx.exec(input);
                     if (result) {
                             rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
                     } else { 
                             // hex
                             result = hexRegEx.exec(input);
                             if (result) {
                                     rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
                             } else {
                                     // rgb
                                     result = rgbRegEx.exec(input);
                                     if (result) {
                                             rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
                                     }
                             }
                     }
             }               

     }
     /**
 Return the color a specified format
 @param {String} format
/
     function get(format) {
             var ret;

             if (stops) {
                     ret = merge(input);
                     ret.stops = [].concat(ret.stops);
                     each(stops, function (stop, i) {
                             ret.stops[i] = [ret.stops[i][0], stop.get(format)];
                     });

             // it&#39;s NaN if gradient colors on a column chart
             } else if (rgba &amp;&amp; !isNaN(rgba[0])) {
                     if (format === &#39;rgb&#39;) {
                             ret = &#39;rgb(&#39; + rgba[0] + &#39;,&#39; + rgba[1] + &#39;,&#39; + rgba[2] + &#39;)&#39;;
                     } else if (format === &#39;a&#39;) {
                             ret = rgba[3];
                     } else {
                             ret = &#39;rgba(&#39; + rgba.join(&#39;,&#39;) + &#39;)&#39;;
                     }
             } else {
                     ret = input;
             }
             return ret;
     }

     /**
 Brighten the color
 @param {Number} alpha
/
     function brighten(alpha) {
             if (stops) {
                     each(stops, function (stop) {
                             stop.brighten(alpha);
                     });

             } else if (isNumber(alpha) &amp;&amp; alpha !== 0) {
                     var i;
                     for (i = 0; i &lt; 3; i++) {
                             rgba[i] += pInt(alpha * 255);

                             if (rgba[i] &lt; 0) {
                                     rgba[i] = 0;
                             }
                             if (rgba[i] &gt; 255) {
                                     rgba[i] = 255;
                             }
                     }
             }
             return this;
     }
     /**
 Set the color&#39;s opacity to a given alpha value
 @param {Number} alpha
/
     function setOpacity(alpha) {
             rgba[3] = alpha;
             return this;
     }

     // initialize: parse the input
     init(input);

     // public methods
     return {
             get: get,
             brighten: brighten,
             rgba: rgba,
             setOpacity: setOpacity
     };</pre>

<p>};</p>

<p>/**</p>

<pre> A wrapper object for SVG elements
/</pre>

<p>function SVGElement() {}</p>

<p>SVGElement.prototype = {</p>

<pre>      // Default base for animation
      opacity: 1,
      // For labels, these CSS properties are applied to the &lt;text&gt; node directly
      textProps: [&#39;fontSize&#39;, &#39;fontWeight&#39;, &#39;fontFamily&#39;, &#39;color&#39;, 
              &#39;lineHeight&#39;, &#39;width&#39;, &#39;textDecoration&#39;, &#39;textShadow&#39;, &#39;HcTextStroke&#39;],

      /**
  Initialize the SVG renderer
  @param {Object} renderer
  @param {String} nodeName
 /
      init: function (renderer, nodeName) {
              var wrapper = this;
              wrapper.element = nodeName === &#39;span&#39; ?
                      createElement(nodeName) :
                      doc.createElementNS(SVG_NS, nodeName);
              wrapper.renderer = renderer;
      },

      /**
  Animate a given attribute
  @param {Object} params
  @param {Number} options The same options as in jQuery animation
  @param {Function} complete Function to perform at the end of animation
 /
      animate: function (params, options, complete) {
              var animOptions = pick(options, globalAnimation, true);
              stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
              if (animOptions) {
                      animOptions = merge(animOptions, {}); //#2625
                      if (complete) { // allows using a callback with the global animation without overwriting it
                              animOptions.complete = complete;
                      }
                      animate(this, params, animOptions);
              } else {
                      this.attr(params);
                      if (complete) {
                              complete();
                      }
              }
              return this;
      },

      /**
  Build an SVG gradient out of a common JavaScript configuration object
 /
      colorGradient: function (color, prop, elem) {
              var renderer = this.renderer,
                      colorObject,
                      gradName,
                      gradAttr,
                      gradients,
                      gradientObject,
                      stops,
                      stopColor,
                      stopOpacity,
                      radialReference,
                      n,
                      id,
                      key = [];

              // Apply linear or radial gradients
              if (color.linearGradient) {
                      gradName = &#39;linearGradient&#39;;
              } else if (color.radialGradient) {
                      gradName = &#39;radialGradient&#39;;
              }

              if (gradName) {
                      gradAttr = color[gradName];
                      gradients = renderer.gradients;
                      stops = color.stops;
                      radialReference = elem.radialReference;

                      // Keep &lt; 2.2 kompatibility
                      if (isArray(gradAttr)) {
                              color[gradName] = gradAttr = {
                                      x1: gradAttr[0],
                                      y1: gradAttr[1],
                                      x2: gradAttr[2],
                                      y2: gradAttr[3],
                                      gradientUnits: &#39;userSpaceOnUse&#39;
                              };
                      }

                      // Correct the radial gradient for the radial reference system
                      if (gradName === &#39;radialGradient&#39; &amp;&amp; radialReference &amp;&amp; !defined(gradAttr.gradientUnits)) {
                              gradAttr = merge(gradAttr, {
                                      cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
                                      cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
                                      r: gradAttr.r * radialReference[2],
                                      gradientUnits: &#39;userSpaceOnUse&#39;
                              });
                      }

                      // Build the unique key to detect whether we need to create a new element (#1282)
                      for (n in gradAttr) {
                              if (n !== &#39;id&#39;) {
                                      key.push(n, gradAttr[n]);
                              }
                      }
                      for (n in stops) {
                              key.push(stops[n]);
                      }
                      key = key.join(&#39;,&#39;);

                      // Check if a gradient object with the same config object is created within this renderer
                      if (gradients[key]) {
                              id = gradients[key].attr(&#39;id&#39;);

                      } else {

                              // Set the id and create the element
                              gradAttr.id = id = PREFIX + idCounter++;
                              gradients[key] = gradientObject = renderer.createElement(gradName)
                                      .attr(gradAttr)
                                      .add(renderer.defs);

                              // The gradient needs to keep a list of stops to be able to destroy them
                              gradientObject.stops = [];
                              each(stops, function (stop) {
                                      var stopObject;
                                      if (stop[1].indexOf(&#39;rgba&#39;) === 0) {
                                              colorObject = Color(stop[1]);
                                              stopColor = colorObject.get(&#39;rgb&#39;);
                                              stopOpacity = colorObject.get(&#39;a&#39;);
                                      } else {
                                              stopColor = stop[1];
                                              stopOpacity = 1;
                                      }
                                      stopObject = renderer.createElement(&#39;stop&#39;).attr({
                                              offset: stop[0],
                                              &#39;stop-color&#39;: stopColor,
                                              &#39;stop-opacity&#39;: stopOpacity
                                      }).add(gradientObject);

                                      // Add the stop element to the gradient
                                      gradientObject.stops.push(stopObject);
                              });
                      }

                      // Set the reference to the gradient object
                      elem.setAttribute(prop, &#39;url(&#39; + renderer.url + &#39;#&#39; + id + &#39;)&#39;);
              } 
      },

      /**
  Set or get a given attribute
  @param {Object|String} hash
  @param {Mixed|Undefined} val
 /
      attr: function (hash, val) {
              var key,
                      value,
                      element = this.element,
                      hasSetSymbolSize,
                      ret = this,
                      skipAttr;

              // single key-value pair
              if (typeof hash === &#39;string&#39; &amp;&amp; val !== UNDEFINED) {
                      key = hash;
                      hash = {};
                      hash[key] = val;
              }

              // used as a getter: first argument is a string, second is undefined
              if (typeof hash === &#39;string&#39;) {
                      ret = (this[hash + &#39;Getter&#39;] || this._defaultGetter).call(this, hash, element);

              // setter
              } else {

                      for (key in hash) {
                              value = hash[key];
                              skipAttr = false;

                              if (this.symbolName &amp;&amp; /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
                                      if (!hasSetSymbolSize) {
                                              this.symbolAttr(hash);
                                              hasSetSymbolSize = true;
                                      }
                                      skipAttr = true;
                              }

                              if (this.rotation &amp;&amp; (key === &#39;x&#39; || key === &#39;y&#39;)) {
                                      this.doTransform = true;
                              }

                              if (!skipAttr) {
                                      (this[key + &#39;Setter&#39;] || this._defaultSetter).call(this, value, key, element);
                              }

                              // Let the shadow follow the main element
                              if (this.shadows &amp;&amp; /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
                                      this.updateShadows(key, value);
                              }
                      }

                      // Update transform. Do this outside the loop to prevent redundant updating for batch setting
                      // of attributes.
                      if (this.doTransform) {
                              this.updateTransform();
                              this.doTransform = false;
                      }

              }

              return ret;
      },

      updateShadows: function (key, value) {
              var shadows = this.shadows,
                      i = shadows.length;
              while (i--) {
                      shadows[i].setAttribute(
                              key,
                              key === &#39;height&#39; ?
                                      mathMax(value - (shadows[i].cutHeight || 0), 0) :
                                      key === &#39;d&#39; ? this.d : value
                      );
              }
      },

      /**
  Add a class name to an element
 /
      addClass: function (className) {
              var element = this.element,
                      currentClassName = attr(element, &#39;class&#39;) || &#39;&#39;;

              if (currentClassName.indexOf(className) === -1) {
                      attr(element, &#39;class&#39;, currentClassName + &#39; &#39; + className);
              }
              return this;
      },
      /* hasClass and removeClass are not (yet) needed
      hasClass: function (className) {
              return attr(this.element, &#39;class&#39;).indexOf(className) !== -1;
      },
      removeClass: function (className) {
              attr(this.element, &#39;class&#39;, attr(this.element, &#39;class&#39;).replace(className, &#39;&#39;));
              return this;
      },
/

      /**
  If one of the symbol size affecting parameters are changed,
  check all the others only once for each call to an element&#39;s
  .attr() method
  @param {Object} hash
 /
      symbolAttr: function (hash) {
              var wrapper = this;

              each([&#39;x&#39;, &#39;y&#39;, &#39;r&#39;, &#39;start&#39;, &#39;end&#39;, &#39;width&#39;, &#39;height&#39;, &#39;innerR&#39;, &#39;anchorX&#39;, &#39;anchorY&#39;], function (key) {
                      wrapper[key] = pick(hash[key], wrapper[key]);
              });

              wrapper.attr({
                      d: wrapper.renderer.symbols[wrapper.symbolName](
                              wrapper.x,
                              wrapper.y,
                              wrapper.width,
                              wrapper.height,
                              wrapper
                      )
              });
      },

      /**
  Apply a clipping path to this object
  @param {String} id
 /
      clip: function (clipRect) {
              return this.attr(&#39;clip-path&#39;, clipRect ? &#39;url(&#39; + this.renderer.url + &#39;#&#39; + clipRect.id + &#39;)&#39; : NONE);
      },

      /**
  Calculate the coordinates needed for drawing a rectangle crisply and return the
  calculated attributes
  @param {Number} strokeWidth
  @param {Number} x
  @param {Number} y
  @param {Number} width
  @param {Number} height
 /
      crisp: function (rect) {

              var wrapper = this,
                      key,
                      attribs = {},
                      normalizer,
                      strokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;

              normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

              // normalize for crisp edges
              rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
              rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
              rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
              rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
              rect.strokeWidth = strokeWidth;

              for (key in rect) {
                      if (wrapper[key] !== rect[key]) { // only set attribute if changed
                              wrapper[key] = attribs[key] = rect[key];
                      }
              }

              return attribs;
      },

      /**
  Set styles for the element
  @param {Object} styles
 /
      css: function (styles) {
              var elemWrapper = this,
                      oldStyles = elemWrapper.styles,
                      newStyles = {},
                      elem = elemWrapper.element,
                      textWidth,
                      n,
                      serializedCss = &#39;&#39;,
                      hyphenate,
                      hasNew = !oldStyles;

              // convert legacy
              if (styles &amp;&amp; styles.color) {
                      styles.fill = styles.color;
              }

              // Filter out existing styles to increase performance (#2640)
              if (oldStyles) {
                      for (n in styles) {
                              if (styles[n] !== oldStyles[n]) {
                                      newStyles[n] = styles[n];
                                      hasNew = true;
                              }
                      }
              }
              if (hasNew) {
                      textWidth = elemWrapper.textWidth = styles &amp;&amp; styles.width &amp;&amp; elem.nodeName.toLowerCase() === &#39;text&#39; &amp;&amp; pInt(styles.width);

                      // Merge the new styles with the old ones
                      if (oldStyles) {
                              styles = extend(
                                      oldStyles,
                                      newStyles
                              );
                      }               

                      // store object
                      elemWrapper.styles = styles;

                      if (textWidth &amp;&amp; (useCanVG || (!hasSVG &amp;&amp; elemWrapper.renderer.forExport))) {
                              delete styles.width;
                      }

                      // serialize and set style attribute
                      if (isIE &amp;&amp; !hasSVG) {
                              css(elemWrapper.element, styles);
                      } else {
                              /*jslint unparam: true*/
                              hyphenate = function (a, b) { return &#39;-&#39; + b.toLowerCase(); };
                              /*jslint unparam: false*/
                              for (n in styles) {
                                      serializedCss += n.replace(/([A-Z])/g, hyphenate) + &#39;:&#39; + styles[n] + &#39;;&#39;;
                              }
                              attr(elem, &#39;style&#39;, serializedCss); // #1881
                      }

                      // re-build text
                      if (textWidth &amp;&amp; elemWrapper.added) {
                              elemWrapper.renderer.buildText(elemWrapper);
                      }
              }

              return elemWrapper;
      },

      /**
  Add an event listener
  @param {String} eventType
  @param {Function} handler
 /
      on: function (eventType, handler) {
              var svgElement = this,
                      element = svgElement.element;

              // touch
              if (hasTouch &amp;&amp; eventType === &#39;click&#39;) {
                      element.ontouchstart = function (e) {                   
                              svgElement.touchEventFired = Date.now();                                
                              e.preventDefault();
                              handler.call(element, e);
                      };
                      element.onclick = function (e) {                                                                                                
                              if (userAgent.indexOf(&#39;Android&#39;) === -1 || Date.now() - (svgElement.touchEventFired || 0) &gt; 1100) { // #2269
                                      handler.call(element, e);
                              }
                      };                      
              } else {
                      // simplest possible event model for internal use
                      element[&#39;on&#39; + eventType] = handler;
              }
              return this;
      },

      /**
  Set the coordinates needed to draw a consistent radial gradient across
  pie slices regardless of positioning inside the chart. The format is
  [centerX, centerY, diameter] in pixels.
 /
      setRadialReference: function (coordinates) {
              this.element.radialReference = coordinates;
              return this;
      },

      /**
  Move an object and its children by x and y values
  @param {Number} x
  @param {Number} y
 /
      translate: function (x, y) {
              return this.attr({
                      translateX: x,
                      translateY: y
              });
      },

      /**
  Invert a group, rotate and flip
 /
      invert: function () {
              var wrapper = this;
              wrapper.inverted = true;
              wrapper.updateTransform();
              return wrapper;
      },

      /**
  Private method to update the transform attribute based on internal
  properties
 /
      updateTransform: function () {
              var wrapper = this,
                      translateX = wrapper.translateX || 0,
                      translateY = wrapper.translateY || 0,
                      scaleX = wrapper.scaleX,
                      scaleY = wrapper.scaleY,
                      inverted = wrapper.inverted,
                      rotation = wrapper.rotation,
                      element = wrapper.element,
                      transform;

              // flipping affects translate as adjustment for flipping around the group&#39;s axis
              if (inverted) {
                      translateX += wrapper.attr(&#39;width&#39;);
                      translateY += wrapper.attr(&#39;height&#39;);
              }

              // Apply translate. Nearly all transformed elements have translation, so instead
              // of checking for translate = 0, do it always (#1767, #1846).
              transform = [&#39;translate(&#39; + translateX + &#39;,&#39; + translateY + &#39;)&#39;];

              // apply rotation
              if (inverted) {
                      transform.push(&#39;rotate(90) scale(-1,1)&#39;);
              } else if (rotation) { // text rotation
                      transform.push(&#39;rotate(&#39; + rotation + &#39; &#39; + (element.getAttribute(&#39;x&#39;) || 0) + &#39; &#39; + (element.getAttribute(&#39;y&#39;) || 0) + &#39;)&#39;);
              }

              // apply scale
              if (defined(scaleX) || defined(scaleY)) {
                      transform.push(&#39;scale(&#39; + pick(scaleX, 1) + &#39; &#39; + pick(scaleY, 1) + &#39;)&#39;);
              }

              if (transform.length) {
                      element.setAttribute(&#39;transform&#39;, transform.join(&#39; &#39;));
              }
      },
      /**
  Bring the element to the front
 /
      toFront: function () {
              var element = this.element;
              element.parentNode.appendChild(element);
              return this;
      },

      /**
  Break down alignment options like align, verticalAlign, x and y
  to x and y relative to the chart.

  @param {Object} alignOptions
  @param {Boolean} alignByTranslate
  @param {String[Object} box The box to align to, needs a width and height. When the
         box is a string, it refers to an object in the Renderer. For example, when
         box is &#39;spacingBox&#39;, it refers to Renderer.spacingBox which holds width, height
         x and y properties.

 /
      align: function (alignOptions, alignByTranslate, box) {
              var align,
                      vAlign,
                      x,
                      y,
                      attribs = {},
                      alignTo,
                      renderer = this.renderer,
                      alignedObjects = renderer.alignedObjects;

              // First call on instanciate
              if (alignOptions) {
                      this.alignOptions = alignOptions;
                      this.alignByTranslate = alignByTranslate;
                      if (!box || isString(box)) { // boxes other than renderer handle this internally
                              this.alignTo = alignTo = box || &#39;renderer&#39;;
                              erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
                              alignedObjects.push(this);
                              box = null; // reassign it below
                      }

              // When called on resize, no arguments are supplied
              } else {
                      alignOptions = this.alignOptions;
                      alignByTranslate = this.alignByTranslate;
                      alignTo = this.alignTo;
              }

              box = pick(box, renderer[alignTo], renderer);

              // Assign variables
              align = alignOptions.align;
              vAlign = alignOptions.verticalAlign;
              x = (box.x || 0) + (alignOptions.x || 0); // default: left align
              y = (box.y || 0) + (alignOptions.y || 0); // default: top align

              // Align
              if (align === &#39;right&#39; || align === &#39;center&#39;) {
                      x += (box.width - (alignOptions.width || 0)) /
                                      { right: 1, center: 2 }[align];
              }
              attribs[alignByTranslate ? &#39;translateX&#39; : &#39;x&#39;] = mathRound(x);

              // Vertical align
              if (vAlign === &#39;bottom&#39; || vAlign === &#39;middle&#39;) {
                      y += (box.height - (alignOptions.height || 0)) /
                                      ({ bottom: 1, middle: 2 }[vAlign] || 1);

              }
              attribs[alignByTranslate ? &#39;translateY&#39; : &#39;y&#39;] = mathRound(y);

              // Animate only if already placed
              this[this.placed ? &#39;animate&#39; : &#39;attr&#39;](attribs);
              this.placed = true;
              this.alignAttr = attribs;

              return this;
      },

      /**
  Get the bounding box (width, height, x and y) for the element
 /
      getBBox: function () {
              var wrapper = this,
                      bBox = wrapper.bBox,
                      renderer = wrapper.renderer,
                      width,
                      height,
                      rotation = wrapper.rotation,
                      element = wrapper.element,
                      styles = wrapper.styles,
                      rad = rotation * deg2rad,
                      textStr = wrapper.textStr,
                      cacheKey;

              // Since numbers are monospaced, and numerical labels appear a lot in a chart,
              // we assume that a label of n characters has the same bounding box as others 
              // of the same length.
              if (textStr === &#39;&#39; || numRegex.test(textStr)) {
                      cacheKey = &#39;num.&#39; + textStr.toString().length + (styles ? (&#39;|&#39; + styles.fontSize + &#39;|&#39; + styles.fontFamily) : &#39;&#39;);

              } //else { // This code block made demo/waterfall fail, related to buildText
                      // Caching all strings reduces rendering time by 4-5%. 
                      // TODO: Check how this affects places where bBox is found on the element
                      //cacheKey = textStr + (styles ? (&#39;|&#39; + styles.fontSize + &#39;|&#39; + styles.fontFamily) : &#39;&#39;);
              //}
              if (cacheKey) {
                      bBox = renderer.cache[cacheKey];
              }

              // No cache found
              if (!bBox) {

                      // SVG elements
                      if (element.namespaceURI === SVG_NS || renderer.forExport) {
                              try { // Fails in Firefox if the container has display: none.

                                      bBox = element.getBBox ?
                                              // SVG: use extend because IE9 is not allowed to change width and height in case
                                              // of rotation (below)
                                              extend({}, element.getBBox()) :
                                              // Canvas renderer and legacy IE in export mode
                                              {
                                                      width: element.offsetWidth,
                                                      height: element.offsetHeight
                                              };
                              } catch (e) {}

                              // If the bBox is not set, the try-catch block above failed. The other condition
                              // is for Opera that returns a width of -Infinity on hidden elements.
                              if (!bBox || bBox.width &lt; 0) {
                                      bBox = { width: 0, height: 0 };
                              }

                      // VML Renderer or useHTML within SVG
                      } else {

                              bBox = wrapper.htmlGetBBox();

                      }

                      // True SVG elements as well as HTML elements in modern browsers using the .useHTML option
                      // need to compensated for rotation
                      if (renderer.isSVG) {
                              width = bBox.width;
                              height = bBox.height;

                              // Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
                              if (isIE &amp;&amp; styles &amp;&amp; styles.fontSize === &#39;11px&#39; &amp;&amp; height.toPrecision(3) === &#39;16.9&#39;) {
                                      bBox.height = height = 14;
                              }

                              // Adjust for rotated text
                              if (rotation) {
                                      bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
                                      bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
                              }
                      }

                      // Cache it
                      wrapper.bBox = bBox;
                      if (cacheKey) {
                              renderer.cache[cacheKey] = bBox;
                      }
              }
              return bBox;
      },

      /**
  Show the element
 /
      show: function (inherit) {
              // IE9-11 doesn&#39;t handle visibilty:inherit well, so we remove the attribute instead (#2881)
              if (inherit &amp;&amp; this.element.namespaceURI === SVG_NS) {
                      this.element.removeAttribute(&#39;visibility&#39;);
              } else {
                      this.attr({ visibility: inherit ? &#39;inherit&#39; : VISIBLE });
              }
              return this;
      },

      /**
  Hide the element
 /
      hide: function () {
              return this.attr({ visibility: HIDDEN });
      },

      fadeOut: function (duration) {
              var elemWrapper = this;
              elemWrapper.animate({
                      opacity: 0
              }, {
                      duration: duration || 150,
                      complete: function () {
                              elemWrapper.attr({ y: -9999 }); // #3088, assuming we&#39;re only using this for tooltips
                      }
              });
      },

      /**
  Add the element
  @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
     to append the element to the renderer.box.
 /
      add: function (parent) {

              var renderer = this.renderer,
                      parentWrapper = parent || renderer,
                      parentNode = parentWrapper.element || renderer.box,
                      childNodes,
                      element = this.element,
                      zIndex = this.zIndex,
                      otherElement,
                      otherZIndex,
                      i,
                      inserted;

              if (parent) {
                      this.parentGroup = parent;
              }

              // mark as inverted
              this.parentInverted = parent &amp;&amp; parent.inverted;

              // build formatted text
              if (this.textStr !== undefined) {
                      renderer.buildText(this);
              }

              // mark the container as having z indexed children
              if (zIndex) {
                      parentWrapper.handleZ = true;
                      zIndex = pInt(zIndex);
              }

              // insert according to this and other elements&#39; zIndex
              if (parentWrapper.handleZ) { // this element or any of its siblings has a z index
                      childNodes = parentNode.childNodes;
                      for (i = 0; i &lt; childNodes.length; i++) {
                              otherElement = childNodes[i];
                              otherZIndex = attr(otherElement, &#39;zIndex&#39;);
                              if (otherElement !== element &amp;&amp; (
                                              // insert before the first element with a higher zIndex
                                              pInt(otherZIndex) &gt; zIndex ||
                                              // if no zIndex given, insert before the first element with a zIndex
                                              (!defined(zIndex) &amp;&amp; defined(otherZIndex))

                                              )) {
                                      parentNode.insertBefore(element, otherElement);
                                      inserted = true;
                                      break;
                              }
                      }
              }

              // default: append at the end
              if (!inserted) {
                      parentNode.appendChild(element);
              }

              // mark as added
              this.added = true;

              // fire an event for internal hooks
              if (this.onAdd) {
                      this.onAdd();
              }

              return this;
      },

      /**
  Removes a child either by removeChild or move to garbageBin.
  Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
 /
      safeRemoveChild: function (element) {
              var parentNode = element.parentNode;
              if (parentNode) {
                      parentNode.removeChild(element);
              }
      },

      /**
  Destroy the element and element wrapper
 /
      destroy: function () {
              var wrapper = this,
                      element = wrapper.element || {},
                      shadows = wrapper.shadows,
                      parentToClean = wrapper.renderer.isSVG &amp;&amp; element.nodeName === &#39;SPAN&#39; &amp;&amp; wrapper.parentGroup,
                      grandParent,
                      key,
                      i;

              // remove events
              element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
              stop(wrapper); // stop running animations

              if (wrapper.clipPath) {
                      wrapper.clipPath = wrapper.clipPath.destroy();
              }

              // Destroy stops in case this is a gradient object
              if (wrapper.stops) {
                      for (i = 0; i &lt; wrapper.stops.length; i++) {
                              wrapper.stops[i] = wrapper.stops[i].destroy();
                      }
                      wrapper.stops = null;
              }

              // remove element
              wrapper.safeRemoveChild(element);

              // destroy shadows
              if (shadows) {
                      each(shadows, function (shadow) {
                              wrapper.safeRemoveChild(shadow);
                      });
              }

              // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
              while (parentToClean &amp;&amp; parentToClean.div &amp;&amp; parentToClean.div.childNodes.length === 0) {
                      grandParent = parentToClean.parentGroup;
                      wrapper.safeRemoveChild(parentToClean.div);
                      delete parentToClean.div;
                      parentToClean = grandParent;
              }

              // remove from alignObjects
              if (wrapper.alignTo) {
                      erase(wrapper.renderer.alignedObjects, wrapper);
              }

              for (key in wrapper) {
                      delete wrapper[key];
              }

              return null;
      },

      /**
  Add a shadow to the element. Must be done after the element is added to the DOM
  @param {Boolean|Object} shadowOptions
 /
      shadow: function (shadowOptions, group, cutOff) {
              var shadows = [],
                      i,
                      shadow,
                      element = this.element,
                      strokeWidth,
                      shadowWidth,
                      shadowElementOpacity,

                      // compensate for inverted plot area
                      transform;

              if (shadowOptions) {
                      shadowWidth = pick(shadowOptions.width, 3);
                      shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
                      transform = this.parentInverted ?
                              &#39;(-1,-1)&#39; :
                              &#39;(&#39; + pick(shadowOptions.offsetX, 1) + &#39;, &#39; + pick(shadowOptions.offsetY, 1) + &#39;)&#39;;
                      for (i = 1; i &lt;= shadowWidth; i++) {
                              shadow = element.cloneNode(0);
                              strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
                              attr(shadow, {
                                      &#39;isShadow&#39;: &#39;true&#39;,
                                      &#39;stroke&#39;: shadowOptions.color || &#39;black&#39;,
                                      &#39;stroke-opacity&#39;: shadowElementOpacity * i,
                                      &#39;stroke-width&#39;: strokeWidth,
                                      &#39;transform&#39;: &#39;translate&#39; + transform,
                                      &#39;fill&#39;: NONE
                              });
                              if (cutOff) {
                                      attr(shadow, &#39;height&#39;, mathMax(attr(shadow, &#39;height&#39;) - strokeWidth, 0));
                                      shadow.cutHeight = strokeWidth;
                              }

                              if (group) {
                                      group.element.appendChild(shadow);
                              } else {
                                      element.parentNode.insertBefore(shadow, element);
                              }

                              shadows.push(shadow);
                      }

                      this.shadows = shadows;
              }
              return this;

      },

      xGetter: function (key) {
              if (this.element.nodeName === &#39;circle&#39;) {
                      key = { x: &#39;cx&#39;, y: &#39;cy&#39; }[key] || key;
              }
              return this._defaultGetter(key);
      },

      /** 
  Get the current value of an attribute or pseudo attribute, used mainly
  for animation.
 /
      _defaultGetter: function (key) {
              var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

              if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
                      ret = parseFloat(ret);
              }
              return ret;
      },

      dSetter: function (value, key, element) {
              if (value &amp;&amp; value.join) { // join path
                      value = value.join(&#39; &#39;);
              }
              if (/(NaN| {2}|^$)/.test(value)) {
                      value = &#39;M 0 0&#39;;
              }
              element.setAttribute(key, value);

              this[key] = value;
      },
      dashstyleSetter: function (value) {
              var i;
              value = value &amp;&amp; value.toLowerCase();
              if (value) {
                      value = value
                              .replace(&#39;shortdashdotdot&#39;, &#39;3,1,1,1,1,1,&#39;)
                              .replace(&#39;shortdashdot&#39;, &#39;3,1,1,1&#39;)
                              .replace(&#39;shortdot&#39;, &#39;1,1,&#39;)
                              .replace(&#39;shortdash&#39;, &#39;3,1,&#39;)
                              .replace(&#39;longdash&#39;, &#39;8,3,&#39;)
                              .replace(/dot/g, &#39;1,3,&#39;)
                              .replace(&#39;dash&#39;, &#39;4,3,&#39;)
                              .replace(/,$/, &#39;&#39;)
                              .split(&#39;,&#39;); // ending comma

                      i = value.length;
                      while (i--) {
                              value[i] = pInt(value[i]) * this[&#39;stroke-width&#39;];
                      }
                      value = value.join(&#39;,&#39;)
                              .replace(&#39;NaN&#39;, &#39;none&#39;); // #3226
                      this.element.setAttribute(&#39;stroke-dasharray&#39;, value);
              }
      },
      alignSetter: function (value) {
              this.element.setAttribute(&#39;text-anchor&#39;, { left: &#39;start&#39;, center: &#39;middle&#39;, right: &#39;end&#39; }[value]);
      },
      opacitySetter: function (value, key, element) {
              this[key] = value;
              element.setAttribute(key, value);
      },
      titleSetter: function (value) {
              var titleNode = this.element.getElementsByTagName(&#39;title&#39;)[0];
              if (!titleNode) {
                      titleNode = doc.createElementNS(SVG_NS, &#39;title&#39;);
                      this.element.appendChild(titleNode);
              }
              titleNode.textContent = pick(value, &#39;&#39;).replace(/&lt;[^&gt;]*&gt;/g, &#39;&#39;); // #3276
      },
      textSetter: function (value) {
              if (value !== this.textStr) {
                      // Delete bBox memo when the text changes
                      delete this.bBox;

                      this.textStr = value;
                      if (this.added) {
                              this.renderer.buildText(this);
                      }
              }
      },
      fillSetter: function (value, key, element) {
              if (typeof value === &#39;string&#39;) {
                      element.setAttribute(key, value);
              } else if (value) {
                      this.colorGradient(value, key, element);
              }
      },
      zIndexSetter: function (value, key, element) {
              element.setAttribute(key, value);
              this[key] = value;
      },
      _defaultSetter: function (value, key, element) {
              element.setAttribute(key, value);
      }</pre>

<p>};</p>

<p>// Some shared setters and getters SVGElement.prototype.yGetter =
SVGElement.prototype.xGetter; SVGElement.prototype.translateXSetter =
SVGElement.prototype.translateYSetter =</p>

<pre>        SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = 
        SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
this[key] = value;
this.doTransform = true;</pre>

<p>};</p>

<p>// WebKit and Batik have problems with a stroke-width of zero, so in this
case we remove the  // stroke attribute altogether. #1270, #1369, #3065,
#3072. <a href="'stroke-widthSetter'">SVGElement.prototype</a> =
SVGElement.prototype.strokeSetter = function (value, key, element) {</p>

<pre>this[key] = value;
// Only apply the stroke attribute if the stroke width is defined and larger than 0
if (this.stroke &amp;&amp; this[&#39;stroke-width&#39;]) {
        this.strokeWidth = this[&#39;stroke-width&#39;];
        SVGElement.prototype.fillSetter.call(this, this.stroke, &#39;stroke&#39;, element); // use prototype as instance may be overridden
        element.setAttribute(&#39;stroke-width&#39;, this[&#39;stroke-width&#39;]);
        this.hasStroke = true;
} else if (key === &#39;stroke-width&#39; &amp;&amp; value === 0 &amp;&amp; this.hasStroke) {
        element.removeAttribute(&#39;stroke&#39;);
        this.hasStroke = false;
}</pre>

<p>};</p>

<p>/**</p>

<pre> The default SVG renderer
/</pre>

<p>var SVGRenderer = function () {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">init</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
</pre>

<p>}; SVGRenderer.prototype = {</p>

<pre>     Element: SVGElement,

     /**
 Initialize the SVGRenderer
 @param {Object} container
 @param {Number} width
 @param {Number} height
 @param {Boolean} forExport
/
     init: function (container, width, height, style, forExport) {
             var renderer = this,
                     loc = location,
                     boxWrapper,
                     element,
                     desc;

             boxWrapper = renderer.createElement(&#39;svg&#39;)
                     .attr({
                             version: &#39;1.1&#39;
                     })
                     .css(this.getStyle(style));
             element = boxWrapper.element;
             container.appendChild(element);

             // For browsers other than IE, add the namespace attribute (#1978)
             if (container.innerHTML.indexOf(&#39;xmlns&#39;) === -1) {
                     attr(element, &#39;xmlns&#39;, SVG_NS);
             }

             // object properties
             renderer.isSVG = true;
             renderer.box = element;
             renderer.boxWrapper = boxWrapper;
             renderer.alignedObjects = [];

             // Page url used for internal references. #24, #672, #1070
             renderer.url = (isFirefox || isWebKit) &amp;&amp; doc.getElementsByTagName(&#39;base&#39;).length ?
                     loc.href
                             .replace(/#.*?$/, &#39;&#39;) // remove the hash
                             .replace(/([\(&#39;\)])/g, &#39;\\$1&#39;) // escape parantheses and quotes
                             .replace(/ /g, &#39;%20&#39;) : // replace spaces (needed for Safari only)
                     &#39;&#39;;

             // Add description
             desc = this.createElement(&#39;desc&#39;).add();
             desc.element.appendChild(doc.createTextNode(&#39;Created with &#39; + PRODUCT + &#39; &#39; + VERSION));

             renderer.defs = this.createElement(&#39;defs&#39;).add();
             renderer.forExport = forExport;
             renderer.gradients = {}; // Object where gradient SvgElements are stored
             renderer.cache = {}; // Cache for numerical bounding boxes

             renderer.setSize(width, height, false);

             // Issue 110 workaround:
             // In Firefox, if a div is positioned by percentage, its pixel position may land
             // between pixels. The container itself doesn&#39;t display this, but an SVG element
             // inside this container will be drawn at subpixel precision. In order to draw
             // sharp lines, this must be compensated for. This doesn&#39;t seem to work inside
             // iframes though (like in jsFiddle).
             var subPixelFix, rect;
             if (isFirefox &amp;&amp; container.getBoundingClientRect) {
                     renderer.subPixelFix = subPixelFix = function () {
                             css(container, { left: 0, top: 0 });
                             rect = container.getBoundingClientRect();
                             css(container, {
                                     left: (mathCeil(rect.left) - rect.left) + PX,
                                     top: (mathCeil(rect.top) - rect.top) + PX
                             });
                     };

                     // run the fix now
                     subPixelFix();

                     // run it on resize
                     addEvent(win, &#39;resize&#39;, subPixelFix);
             }
     },

     getStyle: function (style) {
             return (this.style = extend({
                     fontFamily: &#39;&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Arial, Helvetica, sans-serif&#39;, // default font
                     fontSize: &#39;12px&#39;
             }, style));
     },

     /**
 Detect whether the renderer is hidden. This happens when one of the parent elements
 has display: none. #608.
/
     isHidden: function () {
             return !this.boxWrapper.getBBox().width;
     },

     /**
 Destroys the renderer and its allocated members.
/
     destroy: function () {
             var renderer = this,
                     rendererDefs = renderer.defs;
             renderer.box = null;
             renderer.boxWrapper = renderer.boxWrapper.destroy();

             // Call destroy on all gradient elements
             destroyObjectProperties(renderer.gradients || {});
             renderer.gradients = null;

             // Defs are null in VMLRenderer
             // Otherwise, destroy them here.
             if (rendererDefs) {
                     renderer.defs = rendererDefs.destroy();
             }

             // Remove sub pixel fix handler
             // We need to check that there is a handler, otherwise all functions that are registered for event &#39;resize&#39; are removed
             // See issue #982
             if (renderer.subPixelFix) {
                     removeEvent(win, &#39;resize&#39;, renderer.subPixelFix);
             }

             renderer.alignedObjects = null;

             return null;
     },

     /**
 Create a wrapper for an SVG element
 @param {Object} nodeName
/
     createElement: function (nodeName) {
             var wrapper = new this.Element();
             wrapper.init(this, nodeName);
             return wrapper;
     },

     /**
 Dummy function for use in canvas renderer
/
     draw: function () {},

     /**
 Parse a simple HTML string into SVG tspans

 @param {Object} textNode The parent text SVG node
/
     buildText: function (wrapper) {
             var textNode = wrapper.element,
                     renderer = this,
                     forExport = renderer.forExport,
                     textStr = pick(wrapper.textStr, &#39;&#39;).toString(),
                     hasMarkup = textStr.indexOf(&#39;&lt;&#39;) !== -1,
                     lines,
                     childNodes = textNode.childNodes,
                     styleRegex,
                     hrefRegex,
                     parentX = attr(textNode, &#39;x&#39;),
                     textStyles = wrapper.styles,
                     width = wrapper.textWidth,
                     textLineHeight = textStyles &amp;&amp; textStyles.lineHeight,
                     textStroke = textStyles &amp;&amp; textStyles.HcTextStroke,
                     i = childNodes.length,
                     getLineHeight = function (tspan) {
                             return textLineHeight ? 
                                     pInt(textLineHeight) :
                                     renderer.fontMetrics(
                                             /(px|em)$/.test(tspan &amp;&amp; tspan.style.fontSize) ?
                                                     tspan.style.fontSize :
                                                     ((textStyles &amp;&amp; textStyles.fontSize) || renderer.style.fontSize || 12),
                                             tspan
                                     ).h;
                     };

             /// remove old text
             while (i--) {
                     textNode.removeChild(childNodes[i]);
             }

             // Skip tspans, add text directly to text node. The forceTSpan is a hook 
             // used in text outline hack.
             if (!hasMarkup &amp;&amp; !textStroke &amp;&amp; textStr.indexOf(&#39; &#39;) === -1) {
                     textNode.appendChild(doc.createTextNode(textStr));
                     return;

             // Complex strings, add more logic
             } else {

                     styleRegex = /&lt;.*style=&quot;([^&quot;]+)&quot;.*&gt;/;
                     hrefRegex = /&lt;.*href=&quot;(http[^&quot;]+)&quot;.*&gt;/;

                     if (width &amp;&amp; !wrapper.added) {
                             this.box.appendChild(textNode); // attach it to the DOM to read offset width
                     }

                     if (hasMarkup) {
                             lines = textStr
                                     .replace(/&lt;(b|strong)&gt;/g, &#39;&lt;span style=&quot;font-weight:bold&quot;&gt;&#39;)
                                     .replace(/&lt;(i|em)&gt;/g, &#39;&lt;span style=&quot;font-style:italic&quot;&gt;&#39;)
                                     .replace(/&lt;a/g, &#39;&lt;span&#39;)
                                     .replace(/&lt;\/(b|strong|i|em|a)&gt;/g, &#39;&lt;/span&gt;&#39;)
                                     .split(/&lt;br.*?&gt;/g);

                     } else {
                             lines = [textStr];
                     }

                     // remove empty line at end
                     if (lines[lines.length - 1] === &#39;&#39;) {
                             lines.pop();
                     }

                     // build the lines
                     each(lines, function (line, lineNo) {
                             var spans, spanNo = 0;

                             line = line.replace(/&lt;span/g, &#39;|||&lt;span&#39;).replace(/&lt;\/span&gt;/g, &#39;&lt;/span&gt;|||&#39;);
                             spans = line.split(&#39;|||&#39;);

                             each(spans, function (span) {
                                     if (span !== &#39;&#39; || spans.length === 1) {
                                             var attributes = {},
                                                     tspan = doc.createElementNS(SVG_NS, &#39;tspan&#39;),
                                                     spanStyle; // #390
                                             if (styleRegex.test(span)) {
                                                     spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, &#39;$1fill$2&#39;);
                                                     attr(tspan, &#39;style&#39;, spanStyle);
                                             }
                                             if (hrefRegex.test(span) &amp;&amp; !forExport) { // Not for export - #1529
                                                     attr(tspan, &#39;onclick&#39;, &#39;location.href=\&quot;&#39; + span.match(hrefRegex)[1] + &#39;\&quot;&#39;);
                                                     css(tspan, { cursor: &#39;pointer&#39; });
                                             }

                                             span = (span.replace(/&lt;(.|\n)*?&gt;/g, &#39;&#39;) || &#39; &#39;)
                                                     .replace(/&amp;lt;/g, &#39;&lt;&#39;)
                                                     .replace(/&amp;gt;/g, &#39;&gt;&#39;);

                                             // Nested tags aren&#39;t supported, and cause crash in Safari (#1596)
                                             if (span !== &#39; &#39;) {

                                                     // add the text node
                                                     tspan.appendChild(doc.createTextNode(span));

                                                     if (!spanNo) { // first span in a line, align it to the left
                                                             if (lineNo &amp;&amp; parentX !== null) {
                                                                     attributes.x = parentX;
                                                             }
                                                     } else {
                                                             attributes.dx = 0; // #16
                                                     }

                                                     // add attributes
                                                     attr(tspan, attributes);

                                                     // Append it
                                                     textNode.appendChild(tspan);

                                                     // first span on subsequent line, add the line height
                                                     if (!spanNo &amp;&amp; lineNo) {

                                                             // allow getting the right offset height in exporting in IE
                                                             if (!hasSVG &amp;&amp; forExport) {
                                                                     css(tspan, { display: &#39;block&#39; });
                                                             }

                                                             // Set the line height based on the font size of either
                                                             // the text element or the tspan element
                                                             attr(
                                                                     tspan,
                                                                     &#39;dy&#39;,
                                                                     getLineHeight(tspan)
                                                             );
                                                     }

                                                     // check width and apply soft breaks
                                                     if (width) {
                                                             var words = span.replace(/([^\^])-/g, &#39;$1- &#39;).split(&#39; &#39;), // #1273
                                                                     hasWhiteSpace = spans.length &gt; 1 || (words.length &gt; 1 &amp;&amp; textStyles.whiteSpace !== &#39;nowrap&#39;),
                                                                     tooLong,
                                                                     actualWidth,
                                                                     hcHeight = textStyles.HcHeight,
                                                                     rest = [],
                                                                     dy = getLineHeight(tspan),
                                                                     softLineNo = 1,
                                                                     bBox;

                                                             while (hasWhiteSpace &amp;&amp; (words.length || rest.length)) {
                                                                     delete wrapper.bBox; // delete cache
                                                                     bBox = wrapper.getBBox();
                                                                     actualWidth = bBox.width;

                                                                     // Old IE cannot measure the actualWidth for SVG elements (#2314)
                                                                     if (!hasSVG &amp;&amp; renderer.forExport) {
                                                                             actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
                                                                     }

                                                                     tooLong = actualWidth &gt; width;
                                                                     if (!tooLong || words.length === 1) { // new line needed
                                                                             words = rest;
                                                                             rest = [];
                                                                             if (words.length) {
                                                                                     softLineNo++;
                                                                                     if (hcHeight &amp;&amp; softLineNo * dy &gt; hcHeight) {
                                                                                             words = [&#39;...&#39;];
                                                                                             wrapper.attr(&#39;title&#39;, wrapper.textStr);
                                                                                     } else {

                                                                                             tspan = doc.createElementNS(SVG_NS, &#39;tspan&#39;);
                                                                                             attr(tspan, {
                                                                                                     dy: dy,
                                                                                                     x: parentX
                                                                                             });
                                                                                             if (spanStyle) { // #390
                                                                                                     attr(tspan, &#39;style&#39;, spanStyle);
                                                                                             }
                                                                                             textNode.appendChild(tspan);
                                                                                     }
                                                                             }
                                                                             if (actualWidth &gt; width) { // a single word is pressing it out
                                                                                     width = actualWidth;
                                                                             }
                                                                     } else { // append to existing line tspan
                                                                             tspan.removeChild(tspan.firstChild);
                                                                             rest.unshift(words.pop());
                                                                     }
                                                                     if (words.length) {
                                                                             tspan.appendChild(doc.createTextNode(words.join(&#39; &#39;).replace(/- /g, &#39;-&#39;)));
                                                                     }
                                                             }
                                                     }

                                                     spanNo++;
                                             }
                                     }
                             });
                     });
             }
     },

     /**
 Create a button with preset states
 @param {String} text
 @param {Number} x
 @param {Number} y
 @param {Function} callback
 @param {Object} normalState
 @param {Object} hoverState
 @param {Object} pressedState
/
     button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
             var label = this.label(text, x, y, shape, null, null, null, null, &#39;button&#39;),
                     curState = 0,
                     stateOptions,
                     stateStyle,
                     normalStyle,
                     hoverStyle,
                     pressedStyle,
                     disabledStyle,
                     verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

             // Normal state - prepare the attributes
             normalState = merge({
                     &#39;stroke-width&#39;: 1,
                     stroke: &#39;#CCCCCC&#39;,
                     fill: {
                             linearGradient: verticalGradient,
                             stops: [
                                     [0, &#39;#FEFEFE&#39;],
                                     [1, &#39;#F6F6F6&#39;]
                             ]
                     },
                     r: 2,
                     padding: 5,
                     style: {
                             color: &#39;black&#39;
                     }
             }, normalState);
             normalStyle = normalState.style;
             delete normalState.style;

             // Hover state
             hoverState = merge(normalState, {
                     stroke: &#39;#68A&#39;,
                     fill: {
                             linearGradient: verticalGradient,
                             stops: [
                                     [0, &#39;#FFF&#39;],
                                     [1, &#39;#ACF&#39;]
                             ]
                     }
             }, hoverState);
             hoverStyle = hoverState.style;
             delete hoverState.style;

             // Pressed state
             pressedState = merge(normalState, {
                     stroke: &#39;#68A&#39;,
                     fill: {
                             linearGradient: verticalGradient,
                             stops: [
                                     [0, &#39;#9BD&#39;],
                                     [1, &#39;#CDF&#39;]
                             ]
                     }
             }, pressedState);
             pressedStyle = pressedState.style;
             delete pressedState.style;

             // Disabled state
             disabledState = merge(normalState, {
                     style: {
                             color: &#39;#CCC&#39;
                     }
             }, disabledState);
             disabledStyle = disabledState.style;
             delete disabledState.style;

             // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
             addEvent(label.element, isIE ? &#39;mouseover&#39; : &#39;mouseenter&#39;, function () {
                     if (curState !== 3) {
                             label.attr(hoverState)
                                     .css(hoverStyle);
                     }
             });
             addEvent(label.element, isIE ? &#39;mouseout&#39; : &#39;mouseleave&#39;, function () {
                     if (curState !== 3) {
                             stateOptions = [normalState, hoverState, pressedState][curState];
                             stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
                             label.attr(stateOptions)
                                     .css(stateStyle);
                     }
             });

             label.setState = function (state) {
                     label.state = curState = state;
                     if (!state) {
                             label.attr(normalState)
                                     .css(normalStyle);
                     } else if (state === 2) {
                             label.attr(pressedState)
                                     .css(pressedStyle);
                     } else if (state === 3) {
                             label.attr(disabledState)
                                     .css(disabledStyle);
                     }
             };

             return label
                     .on(&#39;click&#39;, function () {
                             if (curState !== 3) {
                                     callback.call(label);
                             }
                     })
                     .attr(normalState)
                     .css(extend({ cursor: &#39;default&#39; }, normalStyle));
     },

     /**
 Make a straight line crisper by not spilling out to neighbour pixels
 @param {Array} points
 @param {Number} width
/
     crispLine: function (points, width) {
             // points format: [M, 0, 0, L, 100, 0]
             // normalize to a crisp line
             if (points[1] === points[4]) {
                     // Substract due to #1129. Now bottom and left axis gridlines behave the same.
                     points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
             }
             if (points[2] === points[5]) {
                     points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
             }
             return points;
     },

     /**
 Draw a path
 @param {Array} path An SVG path in array form
/
     path: function (path) {
             var attr = {
                     fill: NONE
             };
             if (isArray(path)) {
                     attr.d = path;
             } else if (isObject(path)) { // attributes
                     extend(attr, path);
             }
             return this.createElement(&#39;path&#39;).attr(attr);
     },

     /**
 Draw and return an SVG circle
 @param {Number} x The x position
 @param {Number} y The y position
 @param {Number} r The radius
/
     circle: function (x, y, r) {
             var attr = isObject(x) ?
                     x :
                     {
                             x: x,
                             y: y,
                             r: r
                     },
                     wrapper = this.createElement(&#39;circle&#39;);

             wrapper.xSetter = function (value) {
                     this.element.setAttribute(&#39;cx&#39;, value);
             };
             wrapper.ySetter = function (value) {
                     this.element.setAttribute(&#39;cy&#39;, value);
             };
             return wrapper.attr(attr);
     },

     /**
 Draw and return an arc
 @param {Number} x X position
 @param {Number} y Y position
 @param {Number} r Radius
 @param {Number} innerR Inner radius like used in donut charts
 @param {Number} start Starting angle
 @param {Number} end Ending angle
/
     arc: function (x, y, r, innerR, start, end) {
             var arc;

             if (isObject(x)) {
                     y = x.y;
                     r = x.r;
                     innerR = x.innerR;
                     start = x.start;
                     end = x.end;
                     x = x.x;
             }

             // Arcs are defined as symbols for the ability to set
             // attributes in attr and animate
             arc = this.symbol(&#39;arc&#39;, x || 0, y || 0, r || 0, r || 0, {
                     innerR: innerR || 0,
                     start: start || 0,
                     end: end || 0
             });
             arc.r = r; // #959
             return arc;
     },

     /**
 Draw and return a rectangle
 @param {Number} x Left position
 @param {Number} y Top position
 @param {Number} width
 @param {Number} height
 @param {Number} r Border corner radius
 @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
/
     rect: function (x, y, width, height, r, strokeWidth) {

             r = isObject(x) ? x.r : r;

             var wrapper = this.createElement(&#39;rect&#39;),
                     attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
                             x: x,
                             y: y,
                             width: mathMax(width, 0),
                             height: mathMax(height, 0)
                     };

             if (strokeWidth !== UNDEFINED) {
                     attribs.strokeWidth = strokeWidth;
                     attribs = wrapper.crisp(attribs);
             }

             if (r) {
                     attribs.r = r;
             }

             wrapper.rSetter = function (value) {
                     attr(this.element, {
                             rx: value,
                             ry: value
                     });
             };

             return wrapper.attr(attribs);
     },

     /**
 Resize the box and re-align all aligned elements
 @param {Object} width
 @param {Object} height
 @param {Boolean} animate

/
     setSize: function (width, height, animate) {
             var renderer = this,
                     alignedObjects = renderer.alignedObjects,
                     i = alignedObjects.length;

             renderer.width = width;
             renderer.height = height;

             renderer.boxWrapper[pick(animate, true) ? &#39;animate&#39; : &#39;attr&#39;]({
                     width: width,
                     height: height
             });

             while (i--) {
                     alignedObjects[i].align();
             }
     },

     /**
 Create a group
 @param {String} name The group will be given a class name of &#39;highcharts-{name}&#39;.
     This can be used for styling and scripting.
/
     g: function (name) {
             var elem = this.createElement(&#39;g&#39;);
             return defined(name) ? elem.attr({ &#39;class&#39;: PREFIX + name }) : elem;
     },

     /**
 Display an image
 @param {String} src
 @param {Number} x
 @param {Number} y
 @param {Number} width
 @param {Number} height
/
     image: function (src, x, y, width, height) {
             var attribs = {
                             preserveAspectRatio: NONE
                     },
                     elemWrapper;

             // optional properties
             if (arguments.length &gt; 1) {
                     extend(attribs, {
                             x: x,
                             y: y,
                             width: width,
                             height: height
                     });
             }

             elemWrapper = this.createElement(&#39;image&#39;).attr(attribs);

             // set the href in the xlink namespace
             if (elemWrapper.element.setAttributeNS) {
                     elemWrapper.element.setAttributeNS(&#39;http://www.w3.org/1999/xlink&#39;,
                             &#39;href&#39;, src);
             } else {
                     // could be exporting in IE
                     // using href throws &quot;not supported&quot; in ie7 and under, requries regex shim to fix later
                     elemWrapper.element.setAttribute(&#39;hc-svg-href&#39;, src);
             }
             return elemWrapper;
     },

     /**
 Draw a symbol out of pre-defined shape paths from the namespace &#39;symbol&#39; object.

 @param {Object} symbol
 @param {Object} x
 @param {Object} y
 @param {Object} radius
 @param {Object} options
/
     symbol: function (symbol, x, y, width, height, options) {

             var obj,

                     // get the symbol definition function
                     symbolFn = this.symbols[symbol],

                     // check if there&#39;s a path defined for this symbol
                     path = symbolFn &amp;&amp; symbolFn(
                             mathRound(x),
                             mathRound(y),
                             width,
                             height,
                             options
                     ),

                     imageElement,
                     imageRegex = /^url\((.*?)\)$/,
                     imageSrc,
                     imageSize,
                     centerImage;

             if (path) {

                     obj = this.path(path);
                     // expando properties for use in animate and attr
                     extend(obj, {
                             symbolName: symbol,
                             x: x,
                             y: y,
                             width: width,
                             height: height
                     });
                     if (options) {
                             extend(obj, options);
                     }

             // image symbols
             } else if (imageRegex.test(symbol)) {

                     // On image load, set the size and position
                     centerImage = function (img, size) {
                             if (img.element) { // it may be destroyed in the meantime (#1390)
                                     img.attr({
                                             width: size[0],
                                             height: size[1]
                                     });

                                     if (!img.alignByTranslate) { // #185
                                             img.translate(
                                                     mathRound((width - size[0]) / 2), // #1378
                                                     mathRound((height - size[1]) / 2)
                                             );
                                     }
                             }
                     };

                     imageSrc = symbol.match(imageRegex)[1];
                     imageSize = symbolSizes[imageSrc] || (options &amp;&amp; options.width &amp;&amp; options.height &amp;&amp; [options.width, options.height]);

                     // Ireate the image synchronously, add attribs async
                     obj = this.image(imageSrc)
                             .attr({
                                     x: x,
                                     y: y
                             });
                     obj.isImg = true;

                     if (imageSize) {
                             centerImage(obj, imageSize);
                     } else {
                             // Initialize image to be 0 size so export will still function if there&#39;s no cached sizes.
                             obj.attr({ width: 0, height: 0 });

                             // Create a dummy JavaScript image to get the width and height. Due to a bug in IE &lt; 8,
                             // the created element must be assigned to a variable in order to load (#292).
                             imageElement = createElement(&#39;img&#39;, {
                                     onload: function () {
                                             centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);
                                     },
                                     src: imageSrc
                             });
                     }
             }

             return obj;
     },

     /**
 An extendable collection of functions for defining symbol paths.
/
     symbols: {
             &#39;circle&#39;: function (x, y, w, h) {
                     var cpw = 0.166 * w;
                     return [
                             M, x + w / 2, y,
                             &#39;C&#39;, x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
                             &#39;C&#39;, x - cpw, y + h, x - cpw, y, x + w / 2, y,
                             &#39;Z&#39;
                     ];
             },

             &#39;square&#39;: function (x, y, w, h) {
                     return [
                             M, x, y,
                             L, x + w, y,
                             x + w, y + h,
                             x, y + h,
                             &#39;Z&#39;
                     ];
             },

             &#39;triangle&#39;: function (x, y, w, h) {
                     return [
                             M, x + w / 2, y,
                             L, x + w, y + h,
                             x, y + h,
                             &#39;Z&#39;
                     ];
             },

             &#39;triangle-down&#39;: function (x, y, w, h) {
                     return [
                             M, x, y,
                             L, x + w, y,
                             x + w / 2, y + h,
                             &#39;Z&#39;
                     ];
             },
             &#39;diamond&#39;: function (x, y, w, h) {
                     return [
                             M, x + w / 2, y,
                             L, x + w, y + h / 2,
                             x + w / 2, y + h,
                             x, y + h / 2,
                             &#39;Z&#39;
                     ];
             },
             &#39;arc&#39;: function (x, y, w, h, options) {
                     var start = options.start,
                             radius = options.r || w || h,
                             end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
                             innerRadius = options.innerR,
                             open = options.open,
                             cosStart = mathCos(start),
                             sinStart = mathSin(start),
                             cosEnd = mathCos(end),
                             sinEnd = mathSin(end),
                             longArc = options.end - start &lt; mathPI ? 0 : 1;

                     return [
                             M,
                             x + radius * cosStart,
                             y + radius * sinStart,
                             &#39;A&#39;, // arcTo
                             radius, // x radius
                             radius, // y radius
                             0, // slanting
                             longArc, // long or short arc
                             1, // clockwise
                             x + radius * cosEnd,
                             y + radius * sinEnd,
                             open ? M : L,
                             x + innerRadius * cosEnd,
                             y + innerRadius * sinEnd,
                             &#39;A&#39;, // arcTo
                             innerRadius, // x radius
                             innerRadius, // y radius
                             0, // slanting
                             longArc, // long or short arc
                             0, // clockwise
                             x + innerRadius * cosStart,
                             y + innerRadius * sinStart,

                             open ? &#39;&#39; : &#39;Z&#39; // close
                     ];
             },

             /**
  Callout shape used for default tooltips, also used for rounded rectangles in VML
 /
             callout: function (x, y, w, h, options) {
                     var arrowLength = 6,
                             halfDistance = 6,
                             r = mathMin((options &amp;&amp; options.r) || 0, w, h),
                             safeDistance = r + halfDistance,
                             anchorX = options &amp;&amp; options.anchorX,
                             anchorY = options &amp;&amp; options.anchorY,
                             path,
                             normalizer = mathRound(options.strokeWidth || 0) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors;

                     x += normalizer;
                     y += normalizer;
                     path = [
                             &#39;M&#39;, x + r, y, 
                             &#39;L&#39;, x + w - r, y, // top side
                             &#39;C&#39;, x + w, y, x + w, y, x + w, y + r, // top-right corner
                             &#39;L&#39;, x + w, y + h - r, // right side
                             &#39;C&#39;, x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
                             &#39;L&#39;, x + r, y + h, // bottom side
                             &#39;C&#39;, x, y + h, x, y + h, x, y + h - r, // bottom-left corner
                             &#39;L&#39;, x, y + r, // left side
                             &#39;C&#39;, x, y, x, y, x + r, y // top-right corner
                     ];

                     if (anchorX &amp;&amp; anchorX &gt; w &amp;&amp; anchorY &gt; y + safeDistance &amp;&amp; anchorY &lt; y + h - safeDistance) { // replace right side
                             path.splice(13, 3,
                                     &#39;L&#39;, x + w, anchorY - halfDistance, 
                                     x + w + arrowLength, anchorY,
                                     x + w, anchorY + halfDistance,
                                     x + w, y + h - r
                             );
                     } else if (anchorX &amp;&amp; anchorX &lt; 0 &amp;&amp; anchorY &gt; y + safeDistance &amp;&amp; anchorY &lt; y + h - safeDistance) { // replace left side
                             path.splice(33, 3, 
                                     &#39;L&#39;, x, anchorY + halfDistance, 
                                     x - arrowLength, anchorY,
                                     x, anchorY - halfDistance,
                                     x, y + r
                             );
                     } else if (anchorY &amp;&amp; anchorY &gt; h &amp;&amp; anchorX &gt; x + safeDistance &amp;&amp; anchorX &lt; x + w - safeDistance) { // replace bottom
                             path.splice(23, 3,
                                     &#39;L&#39;, anchorX + halfDistance, y + h,
                                     anchorX, y + h + arrowLength,
                                     anchorX - halfDistance, y + h,
                                     x + r, y + h
                             );
                     } else if (anchorY &amp;&amp; anchorY &lt; 0 &amp;&amp; anchorX &gt; x + safeDistance &amp;&amp; anchorX &lt; x + w - safeDistance) { // replace top
                             path.splice(3, 3,
                                     &#39;L&#39;, anchorX - halfDistance, y,
                                     anchorX, y - arrowLength,
                                     anchorX + halfDistance, y,
                                     w - r, y
                             );
                     }
                     return path;
             }
     },

     /**
 Define a clipping rectangle
 @param {String} id
 @param {Number} x
 @param {Number} y
 @param {Number} width
 @param {Number} height
/
     clipRect: function (x, y, width, height) {
             var wrapper,
                     id = PREFIX + idCounter++,

                     clipPath = this.createElement(&#39;clipPath&#39;).attr({
                             id: id
                     }).add(this.defs);

             wrapper = this.rect(x, y, width, height, 0).add(clipPath);
             wrapper.id = id;
             wrapper.clipPath = clipPath;

             return wrapper;
     },

     /**
 Add text to the SVG object
 @param {String} str
 @param {Number} x Left position
 @param {Number} y Top position
 @param {Boolean} useHTML Use HTML to render the text
/
     text: function (str, x, y, useHTML) {

             // declare variables
             var renderer = this,
                     fakeSVG = useCanVG || (!hasSVG &amp;&amp; renderer.forExport),
                     wrapper,
                     attr = {};

             if (useHTML &amp;&amp; !renderer.forExport) {
                     return renderer.html(str, x, y);
             }

             attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
             if (y) {
                     attr.y = Math.round(y);
             }
             if (str || str === 0) {
                     attr.text = str;
             }

             wrapper = renderer.createElement(&#39;text&#39;)
                     .attr(attr);

             // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
             if (fakeSVG) {
                     wrapper.css({
                             position: ABSOLUTE
                     });
             }

             if (!useHTML) {
                     wrapper.xSetter = function (value, key, element) {
                             var tspans = element.getElementsByTagName(&#39;tspan&#39;),
                                     tspan,
                                     parentVal = element.getAttribute(key),
                                     i;
                             for (i = 0; i &lt; tspans.length; i++) {
                                     tspan = tspans[i];
                                     // If the x values are equal, the tspan represents a linebreak
                                     if (tspan.getAttribute(key) === parentVal) {
                                             tspan.setAttribute(key, value);
                                     }
                             }
                             element.setAttribute(key, value);
                     };
             }

             return wrapper;
     },

     /**
 Utility to return the baseline offset and total line height from the font size
/
     fontMetrics: function (fontSize, elem) {
             fontSize = fontSize || this.style.fontSize;
             if (elem &amp;&amp; win.getComputedStyle) {
                     elem = elem.element || elem; // SVGElement
                     fontSize = win.getComputedStyle(elem, &quot;&quot;).fontSize;
             }
             fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

             // Empirical values found by comparing font size and bounding box height.
             // Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
             var lineHeight = fontSize &lt; 24 ? fontSize + 4 : mathRound(fontSize * 1.2),
                     baseline = mathRound(lineHeight * 0.8);

             return {
                     h: lineHeight,
                     b: baseline,
                     f: fontSize
             };
     },

     /**
 Add a label, a text item that can hold a colored or gradient background
 as well as a border and shadow.
 @param {string} str
 @param {Number} x
 @param {Number} y
 @param {String} shape
 @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
    coordinates it should be pinned to
 @param {Number} anchorY
 @param {Boolean} baseline Whether to position the label relative to the text baseline,
    like renderer.text, or to the upper border of the rectangle.
 @param {String} className Class name for the group
/
     label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

             var renderer = this,
                     wrapper = renderer.g(className),
                     text = renderer.text(&#39;&#39;, 0, 0, useHTML)
                             .attr({
                                     zIndex: 1
                             }),
                             //.add(wrapper),
                     box,
                     bBox,
                     alignFactor = 0,
                     padding = 3,
                     paddingLeft = 0,
                     width,
                     height,
                     wrapperX,
                     wrapperY,
                     crispAdjust = 0,
                     deferredAttr = {},
                     baselineOffset,
                     needsBox;

             /**
  This function runs after the label is added to the DOM (when the bounding box is
  available), and after the text of the label is updated to detect the new bounding
  box and reflect it in the border box.
 /
             function updateBoxSize() {
                     var boxX,
                             boxY,
                             style = text.element.style;

                     bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) &amp;&amp; text.textStr &amp;&amp; 
                             text.getBBox();
                     wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
                     wrapper.height = (height || bBox.height || 0) + 2 * padding;

                     // update the label-scoped y offset
                     baselineOffset = padding + renderer.fontMetrics(style &amp;&amp; style.fontSize, text).b;

                     if (needsBox) {

                             // create the border box if it is not already present
                             if (!box) {
                                     boxX = mathRound(-alignFactor * padding);
                                     boxY = baseline ? -baselineOffset : 0;

                                     wrapper.box = box = shape ?
                                             renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
                                             renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
                                     box.attr(&#39;fill&#39;, NONE).add(wrapper);
                             }

                             // apply the box attributes
                             if (!box.isImg) { // #1630
                                     box.attr(extend({
                                             width: mathRound(wrapper.width),
                                             height: mathRound(wrapper.height)
                                     }, deferredAttr));
                             }
                             deferredAttr = null;
                     }
             }

             /**
  This function runs after setting text or padding, but only if padding is changed
 /
             function updateTextPadding() {
                     var styles = wrapper.styles,
                             textAlign = styles &amp;&amp; styles.textAlign,
                             x = paddingLeft + padding * (1 - alignFactor),
                             y;

                     // determin y based on the baseline
                     y = baseline ? 0 : baselineOffset;

                     // compensate for alignment
                     if (defined(width) &amp;&amp; bBox &amp;&amp; (textAlign === &#39;center&#39; || textAlign === &#39;right&#39;)) {
                             x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
                     }

                     // update if anything changed
                     if (x !== text.x || y !== text.y) {
                             text.attr(&#39;x&#39;, x);
                             if (y !== UNDEFINED) {
                                     text.attr(&#39;y&#39;, y);
                             }
                     }

                     // record current values
                     text.x = x;
                     text.y = y;
             }

             /**
  Set a box attribute, or defer it if the box is not yet created
  @param {Object} key
  @param {Object} value
 /
             function boxAttr(key, value) {
                     if (box) {
                             box.attr(key, value);
                     } else {
                             deferredAttr[key] = value;
                     }
             }

             /**
  After the text element is added, get the desired size of the border box
  and add it before the text in the DOM.
 /
             wrapper.onAdd = function () {
                     text.add(wrapper);
                     wrapper.attr({
                             text: (str || str === 0) ? str : &#39;&#39;, // alignment is available now // #3295: 0 not rendered if given as a value
                             x: x,
                             y: y
                     });

                     if (box &amp;&amp; defined(anchorX)) {
                             wrapper.attr({
                                     anchorX: anchorX,
                                     anchorY: anchorY
                             });
                     }
             };

             /*
  Add specific attribute setters.
 /

             // only change local variables
             wrapper.widthSetter = function (value) {
                     width = value;
             };
             wrapper.heightSetter = function (value) {
                     height = value;
             };
             wrapper.paddingSetter =  function (value) {
                     if (defined(value) &amp;&amp; value !== padding) {
                             padding = value;
                             updateTextPadding();
                     }
             };
             wrapper.paddingLeftSetter =  function (value) {
                     if (defined(value) &amp;&amp; value !== paddingLeft) {
                             paddingLeft = value;
                             updateTextPadding();
                     }
             };

             // change local variable and prevent setting attribute on the group
             wrapper.alignSetter = function (value) {
                     alignFactor = { left: 0, center: 0.5, right: 1 }[value];
             };

             // apply these to the box and the text alike
             wrapper.textSetter = function (value) {
                     if (value !== UNDEFINED) {
                             text.textSetter(value);
                     }
                     updateBoxSize();
                     updateTextPadding();
             };

             // apply these to the box but not to the text
             wrapper[&#39;stroke-widthSetter&#39;] = function (value, key) {
                     if (value) {
                             needsBox = true;
                     }
                     crispAdjust = value % 2 / 2;
                     boxAttr(key, value);
             };
             wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
                     if (key === &#39;fill&#39; &amp;&amp; value) {
                             needsBox = true;
                     }
                     boxAttr(key, value);
             };
             wrapper.anchorXSetter = function (value, key) {
                     anchorX = value;
                     boxAttr(key, value + crispAdjust - wrapperX);
             };
             wrapper.anchorYSetter = function (value, key) {
                     anchorY = value;
                     boxAttr(key, value - wrapperY);
             };

             // rename attributes
             wrapper.xSetter = function (value) {
                     wrapper.x = value; // for animation getter
                     if (alignFactor) {
                             value -= alignFactor * ((width || bBox.width) + padding);
                     }
                     wrapperX = mathRound(value);
                     wrapper.attr(&#39;translateX&#39;, wrapperX);
             };
             wrapper.ySetter = function (value) {
                     wrapperY = wrapper.y = mathRound(value);
                     wrapper.attr(&#39;translateY&#39;, wrapperY);
             };

             // Redirect certain methods to either the box or the text
             var baseCss = wrapper.css;
             return extend(wrapper, {
                     /**
   Pick up some properties and apply them to the text instead of the wrapper
  /
                     css: function (styles) {
                             if (styles) {
                                     var textStyles = {};
                                     styles = merge(styles); // create a copy to avoid altering the original object (#537)
                                     each(wrapper.textProps, function (prop) {
                                             if (styles[prop] !== UNDEFINED) {
                                                     textStyles[prop] = styles[prop];
                                                     delete styles[prop];
                                             }
                                     });
                                     text.css(textStyles);
                             }
                             return baseCss.call(wrapper, styles);
                     },
                     /**
   Return the bounding box of the box, not the group
  /
                     getBBox: function () {
                             return {
                                     width: bBox.width + 2 * padding,
                                     height: bBox.height + 2 * padding,
                                     x: bBox.x - padding,
                                     y: bBox.y - padding
                             };
                     },
                     /**
   Apply the shadow to the box
  /
                     shadow: function (b) {
                             if (box) {
                                     box.shadow(b);
                             }
                             return wrapper;
                     },
                     /**
   Destroy and release memory.
  /
                     destroy: function () {

                             // Added by button implementation
                             removeEvent(wrapper.element, &#39;mouseenter&#39;);
                             removeEvent(wrapper.element, &#39;mouseleave&#39;);

                             if (text) {
                                     text = text.destroy();
                             }
                             if (box) {
                                     box = box.destroy();
                             }
                             // Call base implementation to destroy the rest
                             SVGElement.prototype.destroy.call(wrapper);

                             // Release local pointers (#1298)
                             wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
                     }
             });
     }</pre>

<p>}; // end SVGRenderer</p>

<p>// general renderer Renderer = SVGRenderer; // extend SvgElement for
useHTML option extend(SVGElement.prototype, {</p>

<pre>     /**
 Apply CSS to HTML elements. This is used in text within SVG rendering and
 by the VML renderer
/
     htmlCss: function (styles) {
             var wrapper = this,
                     element = wrapper.element,
                     textWidth = styles &amp;&amp; element.tagName === &#39;SPAN&#39; &amp;&amp; styles.width;

             if (textWidth) {
                     delete styles.width;
                     wrapper.textWidth = textWidth;
                     wrapper.updateTransform();
             }

             wrapper.styles = extend(wrapper.styles, styles);
             css(wrapper.element, styles);

             return wrapper;
     },

     /**
 VML and useHTML method for calculating the bounding box based on offsets
 @param {Boolean} refresh Whether to force a fresh value from the DOM or to
 use the cached value

 @return {Object} A hash containing values for x, y, width and height
/

     htmlGetBBox: function () {
             var wrapper = this,
                     element = wrapper.element,
                     bBox = wrapper.bBox;

             // faking getBBox in exported SVG in legacy IE
             if (!bBox) {
                     // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
                     if (element.nodeName === &#39;text&#39;) {
                             element.style.position = ABSOLUTE;
                     }

                     bBox = wrapper.bBox = {
                             x: element.offsetLeft,
                             y: element.offsetTop,
                             width: element.offsetWidth,
                             height: element.offsetHeight
                     };
             }

             return bBox;
     },

     /**
 VML override private method to update elements based on internal
 properties based on SVG transform
/
     htmlUpdateTransform: function () {
             // aligning non added elements is expensive
             if (!this.added) {
                     this.alignOnAdd = true;
                     return;
             }

             var wrapper = this,
                     renderer = wrapper.renderer,
                     elem = wrapper.element,
                     translateX = wrapper.translateX || 0,
                     translateY = wrapper.translateY || 0,
                     x = wrapper.x || 0,
                     y = wrapper.y || 0,
                     align = wrapper.textAlign || &#39;left&#39;,
                     alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
                     shadows = wrapper.shadows;

             // apply translate
             css(elem, {
                     marginLeft: translateX,
                     marginTop: translateY
             });
             if (shadows) { // used in labels/tooltip
                     each(shadows, function (shadow) {
                             css(shadow, {
                                     marginLeft: translateX + 1,
                                     marginTop: translateY + 1
                             });
                     });
             }

             // apply inversion
             if (wrapper.inverted) { // wrapper is a group
                     each(elem.childNodes, function (child) {
                             renderer.invertChild(child, elem);
                     });
             }

             if (elem.tagName === &#39;SPAN&#39;) {

                     var width,
                             rotation = wrapper.rotation,
                             baseline,
                             textWidth = pInt(wrapper.textWidth),
                             currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(&#39;,&#39;);

                     if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed

                             baseline = renderer.fontMetrics(elem.style.fontSize).b;

                             // Renderer specific handling of span rotation
                             if (defined(rotation)) {
                                     wrapper.setSpanRotation(rotation, alignCorrection, baseline);
                             }

                             width = pick(wrapper.elemWidth, elem.offsetWidth);

                             // Update textWidth
                             if (width &gt; textWidth &amp;&amp; /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
                                     css(elem, {
                                             width: textWidth + PX,
                                             display: &#39;block&#39;,
                                             whiteSpace: &#39;normal&#39;
                                     });
                                     width = textWidth;
                             }

                             wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);
                     }

                     // apply position with correction
                     css(elem, {
                             left: (x + (wrapper.xCorr || 0)) + PX,
                             top: (y + (wrapper.yCorr || 0)) + PX
                     });

                     // force reflow in webkit to apply the left and top on useHTML element (#1249)
                     if (isWebKit) {
                             baseline = elem.offsetHeight; // assigned to baseline for JSLint purpose
                     }

                     // record current text transform
                     wrapper.cTT = currentTextTransform;
             }
     },

     /**
 Set the rotation of an individual HTML span
/
     setSpanRotation: function (rotation, alignCorrection, baseline) {
             var rotationStyle = {},
                     cssTransformKey = isIE ? &#39;-ms-transform&#39; : isWebKit ? &#39;-webkit-transform&#39; : isFirefox ? &#39;MozTransform&#39; : isOpera ? &#39;-o-transform&#39; : &#39;&#39;;

             rotationStyle[cssTransformKey] = rotationStyle.transform = &#39;rotate(&#39; + rotation + &#39;deg)&#39;;
             rotationStyle[cssTransformKey + (isFirefox ? &#39;Origin&#39; : &#39;-origin&#39;)] = rotationStyle.transformOrigin = (alignCorrection * 100) + &#39;% &#39; + baseline + &#39;px&#39;;
             css(this.element, rotationStyle);
     },

     /**
 Get the correction in X and Y positioning as the element is rotated.
/
     getSpanCorrection: function (width, baseline, alignCorrection) {
             this.xCorr = -width * alignCorrection;
             this.yCorr = -baseline;
     }</pre>

<p>});</p>

<p>// Extend SvgRenderer for useHTML option. extend(SVGRenderer.prototype, {</p>

<pre>     /**
 Create HTML text node. This is used by the VML renderer as well as the SVG
 renderer through the useHTML option.

 @param {String} str
 @param {Number} x
 @param {Number} y
/
     html: function (str, x, y) {
             var wrapper = this.createElement(&#39;span&#39;),
                     element = wrapper.element,
                     renderer = wrapper.renderer;

             // Text setter
             wrapper.textSetter = function (value) {
                     if (value !== element.innerHTML) {
                             delete this.bBox;
                     }
                     element.innerHTML = this.textStr = value;
             };

             // Various setters which rely on update transform
             wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
                     if (key === &#39;align&#39;) {
                             key = &#39;textAlign&#39;; // Do not overwrite the SVGElement.align method. Same as VML.
                     }
                     wrapper[key] = value;
                     wrapper.htmlUpdateTransform();
             };

             // Set the default attributes
             wrapper.attr({
                             text: str,
                             x: mathRound(x),
                             y: mathRound(y)
                     })
                     .css({
                             position: ABSOLUTE,
                             whiteSpace: &#39;nowrap&#39;,
                             fontFamily: this.style.fontFamily,
                             fontSize: this.style.fontSize
                     });

             // Use the HTML specific .css method
             wrapper.css = wrapper.htmlCss;

             // This is specific for HTML within SVG
             if (renderer.isSVG) {
                     wrapper.add = function (svgGroupWrapper) {

                             var htmlGroup,
                                     container = renderer.box.parentNode,
                                     parentGroup,
                                     parents = [];

                             this.parentGroup = svgGroupWrapper;

                             // Create a mock group to hold the HTML elements
                             if (svgGroupWrapper) {
                                     htmlGroup = svgGroupWrapper.div;
                                     if (!htmlGroup) {

                                             // Read the parent chain into an array and read from top down
                                             parentGroup = svgGroupWrapper;
                                             while (parentGroup) {

                                                     parents.push(parentGroup);

                                                     // Move up to the next parent group
                                                     parentGroup = parentGroup.parentGroup;
                                             }

                                             // Ensure dynamically updating position when any parent is translated
                                             each(parents.reverse(), function (parentGroup) {
                                                     var htmlGroupStyle;

                                                     // Create a HTML div and append it to the parent div to emulate
                                                     // the SVG group structure
                                                     htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {
                                                             className: attr(parentGroup.element, &#39;class&#39;)
                                                     }, {
                                                             position: ABSOLUTE,
                                                             left: (parentGroup.translateX || 0) + PX,
                                                             top: (parentGroup.translateY || 0) + PX
                                                     }, htmlGroup || container); // the top group is appended to container

                                                     // Shortcut
                                                     htmlGroupStyle = htmlGroup.style;

                                                     // Set listeners to update the HTML div&#39;s position whenever the SVG group
                                                     // position is changed
                                                     extend(parentGroup, {
                                                             translateXSetter: function (value, key) {
                                                                     htmlGroupStyle.left = value + PX;
                                                                     parentGroup[key] = value;
                                                                     parentGroup.doTransform = true;
                                                             },
                                                             translateYSetter: function (value, key) {
                                                                     htmlGroupStyle.top = value + PX;
                                                                     parentGroup[key] = value;
                                                                     parentGroup.doTransform = true;
                                                             },
                                                             visibilitySetter: function (value, key) {
                                                                     htmlGroupStyle[key] = value;
                                                             }
                                                     });
                                             });

                                     }
                             } else {
                                     htmlGroup = container;
                             }

                             htmlGroup.appendChild(element);

                             // Shared with VML:
                             wrapper.added = true;
                             if (wrapper.alignOnAdd) {
                                     wrapper.htmlUpdateTransform();
                             }

                             return wrapper;
                     };
             }
             return wrapper;
     }</pre>

<p>});</p>

<p>/*
****************************************************************************</p>

<pre>START OF INTERNET EXPLORER &lt;= 8 SPECIFIC CODE                              *

For applications and websites that don&#39;t need IE support, like platform    *
targeted mobile apps and web apps, this code can be removed.               *

***************************************************************************/</pre>

<p>/**</p>

<pre> @constructor
/</pre>

<p>var VMLRenderer, VMLElement; if (!hasSVG &amp;&amp; !useCanVG) {</p>

<p>/**</p>

<pre class="ruby"> <span class="ruby-constant">The</span> <span class="ruby-constant">VML</span> <span class="ruby-identifier">element</span> <span class="ruby-identifier">wrapper</span>.
<span class="ruby-operator">/</span>
</pre>

<p>VMLElement = {</p>

<pre>     /**
 Initialize a new VML element wrapper. It builds the markup as a string
 to minimize DOM traffic.
 @param {Object} renderer
 @param {Object} nodeName
/
     init: function (renderer, nodeName) {
             var wrapper = this,
                     markup =  [&#39;&lt;&#39;, nodeName, &#39; filled=&quot;f&quot; stroked=&quot;f&quot;&#39;],
                     style = [&#39;position: &#39;, ABSOLUTE, &#39;;&#39;],
                     isDiv = nodeName === DIV;

             // divs and shapes need size
             if (nodeName === &#39;shape&#39; || isDiv) {
                     style.push(&#39;left:0;top:0;width:1px;height:1px;&#39;);
             }
             style.push(&#39;visibility: &#39;, isDiv ? HIDDEN : VISIBLE);

             markup.push(&#39; style=&quot;&#39;, style.join(&#39;&#39;), &#39;&quot;/&gt;&#39;);

             // create element with default attributes and style
             if (nodeName) {
                     markup = isDiv || nodeName === &#39;span&#39; || nodeName === &#39;img&#39; ?
                             markup.join(&#39;&#39;)
                             : renderer.prepVML(markup);
                     wrapper.element = createElement(markup);
             }

             wrapper.renderer = renderer;
     },

     /**
 Add the node to the given parent
 @param {Object} parent
/
     add: function (parent) {
             var wrapper = this,
                     renderer = wrapper.renderer,
                     element = wrapper.element,
                     box = renderer.box,
                     inverted = parent &amp;&amp; parent.inverted,

                     // get the parent node
                     parentNode = parent ?
                             parent.element || parent :
                             box;

             // if the parent group is inverted, apply inversion on all children
             if (inverted) { // only on groups
                     renderer.invertChild(element, parentNode);
             }

             // append it
             parentNode.appendChild(element);

             // align text after adding to be able to read offset
             wrapper.added = true;
             if (wrapper.alignOnAdd &amp;&amp; !wrapper.deferUpdateTransform) {
                     wrapper.updateTransform();
             }

             // fire an event for internal hooks
             if (wrapper.onAdd) {
                     wrapper.onAdd();
             }

             return wrapper;
     },

     /**
 VML always uses htmlUpdateTransform
/
     updateTransform: SVGElement.prototype.htmlUpdateTransform,

     /**
 Set the rotation of a span with oldIE&#39;s filter
/
     setSpanRotation: function () {
             // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
             // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
             // has support for CSS3 transform. The getBBox method also needs to be updated
             // to compensate for the rotation, like it currently does for SVG.
             // Test case: http://jsfiddle.net/highcharts/Ybt44/

             var rotation = this.rotation,
                     costheta = mathCos(rotation * deg2rad),
                     sintheta = mathSin(rotation * deg2rad);

             css(this.element, {
                     filter: rotation ? [&#39;progid:DXImageTransform.Microsoft.Matrix(M11=&#39;, costheta,
                             &#39;, M12=&#39;, -sintheta, &#39;, M21=&#39;, sintheta, &#39;, M22=&#39;, costheta,
                             &#39;, sizingMethod=\&#39;auto expand\&#39;)&#39;].join(&#39;&#39;) : NONE
             });
     },

     /**
 Get the positioning correction for the span after rotating. 
/
     getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

             var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
                     sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
                     height = pick(this.elemHeight, this.element.offsetHeight),
                     quad,
                     nonLeft = align &amp;&amp; align !== &#39;left&#39;;

             // correct x and y
             this.xCorr = costheta &lt; 0 &amp;&amp; -width;
             this.yCorr = sintheta &lt; 0 &amp;&amp; -height;

             // correct for baseline and corners spilling out after rotation
             quad = costheta * sintheta &lt; 0;
             this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
             this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
             // correct for the length/height of the text
             if (nonLeft) {
                     this.xCorr -= width * alignCorrection * (costheta &lt; 0 ? -1 : 1);
                     if (rotation) {
                             this.yCorr -= height * alignCorrection * (sintheta &lt; 0 ? -1 : 1);
                     }
                     css(this.element, {
                             textAlign: align
                     });
             }
     },

     /**
 Converts a subset of an SVG path definition to its VML counterpart. Takes an array
 as the parameter and returns a string.
/
     pathToVML: function (value) {
             // convert paths
             var i = value.length,
                     path = [];

             while (i--) {

                     // Multiply by 10 to allow subpixel precision.
                     // Substracting half a pixel seems to make the coordinates
                     // align with SVG, but this hasn&#39;t been tested thoroughly
                     if (isNumber(value[i])) {
                             path[i] = mathRound(value[i] * 10) - 5;
                     } else if (value[i] === &#39;Z&#39;) { // close the path
                             path[i] = &#39;x&#39;;
                     } else {
                             path[i] = value[i];

                             // When the start X and end X coordinates of an arc are too close,
                             // they are rounded to the same value above. In this case, substract or 
                             // add 1 from the end X and Y positions. #186, #760, #1371, #1410.
                             if (value.isArc &amp;&amp; (value[i] === &#39;wa&#39; || value[i] === &#39;at&#39;)) {
                                     // Start and end X
                                     if (path[i + 5] === path[i + 7]) {
                                             path[i + 7] += value[i + 7] &gt; value[i + 5] ? 1 : -1;
                                     }
                                     // Start and end Y
                                     if (path[i + 6] === path[i + 8]) {
                                             path[i + 8] += value[i + 8] &gt; value[i + 6] ? 1 : -1;
                                     }
                             }
                     }
             }

             // Loop up again to handle path shortcuts (#2132)
             /*while (i++ &lt; path.length) {
                     if (path[i] === &#39;H&#39;) { // horizontal line to
                             path[i] = &#39;L&#39;;
                             path.splice(i + 2, 0, path[i - 1]);
                     } else if (path[i] === &#39;V&#39;) { // vertical line to
                             path[i] = &#39;L&#39;;
                             path.splice(i + 1, 0, path[i - 2]);
                     }
             }*/
             return path.join(&#39; &#39;) || &#39;x&#39;;
     },

     /**
 Set the element&#39;s clipping to a predefined rectangle

 @param {String} id The id of the clip rectangle
/
     clip: function (clipRect) {
             var wrapper = this,
                     clipMembers,
                     cssRet;

             if (clipRect) {
                     clipMembers = clipRect.members;
                     erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
                     clipMembers.push(wrapper);
                     wrapper.destroyClip = function () {
                             erase(clipMembers, wrapper);
                     };
                     cssRet = clipRect.getCSS(wrapper);

             } else {
                     if (wrapper.destroyClip) {
                             wrapper.destroyClip();
                     }
                     cssRet = { clip: docMode8 ? &#39;inherit&#39; : &#39;rect(auto)&#39; }; // #1214
             }

             return wrapper.css(cssRet);

     },

     /**
 Set styles for the element
 @param {Object} styles
/
     css: SVGElement.prototype.htmlCss,

     /**
 Removes a child either by removeChild or move to garbageBin.
 Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
/
     safeRemoveChild: function (element) {
             // discardElement will detach the node from its parent before attaching it
             // to the garbage bin. Therefore it is important that the node is attached and have parent.
             if (element.parentNode) {
                     discardElement(element);
             }
     },

     /**
 Extend element.destroy by removing it from the clip members array
/
     destroy: function () {
             if (this.destroyClip) {
                     this.destroyClip();
             }

             return SVGElement.prototype.destroy.apply(this);
     },

     /**
 Add an event listener. VML override for normalizing event parameters.
 @param {String} eventType
 @param {Function} handler
/
     on: function (eventType, handler) {
             // simplest possible event model for internal use
             this.element[&#39;on&#39; + eventType] = function () {
                     var evt = win.event;
                     evt.target = evt.srcElement;
                     handler(evt);
             };
             return this;
     },

     /**
 In stacked columns, cut off the shadows so that they don&#39;t overlap
/
     cutOffPath: function (path, length) {

             var len;

             path = path.split(/[ ,]/);
             len = path.length;

             if (len === 9 || len === 11) {
                     path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
             }
             return path.join(&#39; &#39;);
     },

     /**
 Apply a drop shadow by copying elements and giving them different strokes
 @param {Boolean|Object} shadowOptions
/
     shadow: function (shadowOptions, group, cutOff) {
             var shadows = [],
                     i,
                     element = this.element,
                     renderer = this.renderer,
                     shadow,
                     elemStyle = element.style,
                     markup,
                     path = element.path,
                     strokeWidth,
                     modifiedPath,
                     shadowWidth,
                     shadowElementOpacity;

             // some times empty paths are not strings
             if (path &amp;&amp; typeof path.value !== &#39;string&#39;) {
                     path = &#39;x&#39;;
             }
             modifiedPath = path;

             if (shadowOptions) {
                     shadowWidth = pick(shadowOptions.width, 3);
                     shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
                     for (i = 1; i &lt;= 3; i++) {

                             strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

                             // Cut off shadows for stacked column items
                             if (cutOff) {
                                     modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
                             }

                             markup = [&#39;&lt;shape isShadow=&quot;true&quot; strokeweight=&quot;&#39;, strokeWidth,
                                     &#39;&quot; filled=&quot;false&quot; path=&quot;&#39;, modifiedPath,
                                     &#39;&quot; coordsize=&quot;10 10&quot; style=&quot;&#39;, element.style.cssText, &#39;&quot; /&gt;&#39;];

                             shadow = createElement(renderer.prepVML(markup),
                                     null, {
                                             left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
                                             top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
                                     }
                             );
                             if (cutOff) {
                                     shadow.cutOff = strokeWidth + 1;
                             }

                             // apply the opacity
                             markup = [&#39;&lt;stroke color=&quot;&#39;, shadowOptions.color || &#39;black&#39;, &#39;&quot; opacity=&quot;&#39;, shadowElementOpacity * i, &#39;&quot;/&gt;&#39;];
                             createElement(renderer.prepVML(markup), null, null, shadow);

                             // insert it
                             if (group) {
                                     group.element.appendChild(shadow);
                             } else {
                                     element.parentNode.insertBefore(shadow, element);
                             }

                             // record it
                             shadows.push(shadow);

                     }

                     this.shadows = shadows;
             }
             return this;
     },
     updateShadows: noop, // Used in SVG only

     setAttr: function (key, value) {
             if (docMode8) { // IE8 setAttribute bug
                     this.element[key] = value;
             } else {
                     this.element.setAttribute(key, value);
             }
     },
     classSetter: function (value) {
             // IE8 Standards mode has problems retrieving the className unless set like this
             this.element.className = value;
     },
     dashstyleSetter: function (value, key, element) {
             var strokeElem = element.getElementsByTagName(&#39;stroke&#39;)[0] ||
                     createElement(this.renderer.prepVML([&#39;&lt;stroke/&gt;&#39;]), null, null, element);
             strokeElem[key] = value || &#39;solid&#39;;
             this[key] = value; /* because changing stroke-width will change the dash length
                     and cause an epileptic effect */
     },
     dSetter: function (value, key, element) {
             var i,
                     shadows = this.shadows;
             value = value || [];
             this.d = value.join &amp;&amp; value.join(&#39; &#39;); // used in getter for animation

             element.path = value = this.pathToVML(value);

             // update shadows
             if (shadows) {
                     i = shadows.length;
                     while (i--) {
                             shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
                     }
             }
             this.setAttr(key, value);
     },
     fillSetter: function (value, key, element) {
             var nodeName = element.nodeName;
             if (nodeName === &#39;SPAN&#39;) { // text color
                     element.style.color = value;
             } else if (nodeName !== &#39;IMG&#39;) { // #1336
                     element.filled = value !== NONE;
                     this.setAttr(&#39;fillcolor&#39;, this.renderer.color(value, element, key, this));
             }
     },
     opacitySetter: noop, // Don&#39;t bother - animation is too slow and filters introduce artifacts
     rotationSetter: function (value, key, element) {
             var style = element.style;
             this[key] = style[key] = value; // style is for #1873

             // Correction for the 1x1 size of the shape container. Used in gauge needles.
             style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
             style.top = mathRound(mathCos(value * deg2rad)) + PX;
     },
     strokeSetter: function (value, key, element) {
             this.setAttr(&#39;strokecolor&#39;, this.renderer.color(value, element, key));
     },
     &#39;stroke-widthSetter&#39;: function (value, key, element) {
             element.stroked = !!value; // VML &quot;stroked&quot; attribute
             this[key] = value; // used in getter, issue #113
             if (isNumber(value)) {
                     value += PX;
             }
             this.setAttr(&#39;strokeweight&#39;, value);
     },
     titleSetter: function (value, key) {
             this.setAttr(key, value);
     },
     visibilitySetter: function (value, key, element) {

             // Handle inherited visibility
             if (value === &#39;inherit&#39;) {
                     value = VISIBLE;
             }

             // Let the shadow follow the main element
             if (this.shadows) {
                     each(this.shadows, function (shadow) {
                             shadow.style[key] = value;
                     });
             }

             // Instead of toggling the visibility CSS property, move the div out of the viewport.
             // This works around #61 and #586
             if (element.nodeName === &#39;DIV&#39;) {
                     value = value === HIDDEN ? &#39;-999em&#39; : 0;

                     // In order to redraw, IE7 needs the div to be visible when tucked away
                     // outside the viewport. So the visibility is actually opposite of
                     // the expected value. This applies to the tooltip only.
                     if (!docMode8) {
                             element.style[key] = value ? VISIBLE : HIDDEN;
                     }
                     key = &#39;top&#39;;
             }
             element.style[key] = value;
     },
     xSetter: function (value, key, element) {
             this[key] = value; // used in getter

             if (key === &#39;x&#39;) {
                     key = &#39;left&#39;;
             } else if (key === &#39;y&#39;) {
                     key = &#39;top&#39;;
             }/* else {
                     value = mathMax(0, value); // don&#39;t set width or height below zero (#311)
             }*/

             // clipping rectangle special
             if (this.updateClipping) {
                     this[key] = value; // the key is now &#39;left&#39; or &#39;top&#39; for &#39;x&#39; and &#39;y&#39;
                     this.updateClipping();
             } else {
                     // normal
                     element.style[key] = value;
             }
     },
     zIndexSetter: function (value, key, element) {
             element.style[key] = value;
     }</pre>

<p>}; Highcharts.VMLElement = VMLElement = extendClass(SVGElement,
VMLElement);</p>

<p>// Some shared setters VMLElement.prototype.ySetter =</p>

<pre class="ruby"><span class="ruby-constant">VMLElement</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">widthSetter</span> = 
<span class="ruby-constant">VMLElement</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">heightSetter</span> = 
<span class="ruby-constant">VMLElement</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">xSetter</span>;
</pre>

<p>/**</p>

<pre> The VML renderer
/</pre>

<p>var VMLRendererExtension = { // inherit SVGRenderer</p>

<pre>     Element: VMLElement,
     isIE8: userAgent.indexOf(&#39;MSIE 8.0&#39;) &gt; -1,

     /**
 Initialize the VMLRenderer
 @param {Object} container
 @param {Number} width
 @param {Number} height
/
     init: function (container, width, height, style) {
             var renderer = this,
                     boxWrapper,
                     box,
                     css;

             renderer.alignedObjects = [];

             boxWrapper = renderer.createElement(DIV)
                     .css(extend(this.getStyle(style), { position: RELATIVE}));
             box = boxWrapper.element;
             container.appendChild(boxWrapper.element);

             // generate the containing box
             renderer.isVML = true;
             renderer.box = box;
             renderer.boxWrapper = boxWrapper;
             renderer.cache = {};

             renderer.setSize(width, height, false);

             // The only way to make IE6 and IE7 print is to use a global namespace. However,
             // with IE8 the only way to make the dynamic shapes visible in screen and print mode
             // seems to be to add the xmlns attribute and the behaviour style inline.
             if (!doc.namespaces.hcv) {

                     doc.namespaces.add(&#39;hcv&#39;, &#39;urn:schemas-microsoft-com:vml&#39;);

                     // Setup default CSS (#2153, #2368, #2384)
                     css = &#39;hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke&#39; +
                             &#39;{ behavior:url(#default#VML); display: inline-block; } &#39;;
                     try {
                             doc.createStyleSheet().cssText = css;
                     } catch (e) {
                             doc.styleSheets[0].cssText += css;
                     }

             }
     },

     /**
 Detect whether the renderer is hidden. This happens when one of the parent elements
 has display: none
/
     isHidden: function () {
             return !this.box.offsetWidth;
     },

     /**
 Define a clipping rectangle. In VML it is accomplished by storing the values
 for setting the CSS style to all associated members.

 @param {Number} x
 @param {Number} y
 @param {Number} width
 @param {Number} height
/
     clipRect: function (x, y, width, height) {

             // create a dummy element
             var clipRect = this.createElement(),
                     isObj = isObject(x);

             // mimic a rectangle with its style object for automatic updating in attr
             return extend(clipRect, {
                     members: [],
                     left: (isObj ? x.x : x) + 1,
                     top: (isObj ? x.y : y) + 1,
                     width: (isObj ? x.width : width) - 1,
                     height: (isObj ? x.height : height) - 1,
                     getCSS: function (wrapper) {
                             var element = wrapper.element,
                                     nodeName = element.nodeName,
                                     isShape = nodeName === &#39;shape&#39;,
                                     inverted = wrapper.inverted,
                                     rect = this,
                                     top = rect.top - (isShape ? element.offsetTop : 0),
                                     left = rect.left,
                                     right = left + rect.width,
                                     bottom = top + rect.height,
                                     ret = {
                                             clip: &#39;rect(&#39; +
                                                     mathRound(inverted ? left : top) + &#39;px,&#39; +
                                                     mathRound(inverted ? bottom : right) + &#39;px,&#39; +
                                                     mathRound(inverted ? right : bottom) + &#39;px,&#39; +
                                                     mathRound(inverted ? top : left) + &#39;px)&#39;
                                     };

                             // issue 74 workaround
                             if (!inverted &amp;&amp; docMode8 &amp;&amp; nodeName === &#39;DIV&#39;) {
                                     extend(ret, {
                                             width: right + PX,
                                             height: bottom + PX
                                     });
                             }
                             return ret;
                     },

                     // used in attr and animation to update the clipping of all members
                     updateClipping: function () {
                             each(clipRect.members, function (member) {
                                     if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
                                             member.css(clipRect.getCSS(member));
                                     }
                             });
                     }
             });

     },

     /**
 Take a color and return it if it&#39;s a string, make it a gradient if it&#39;s a
 gradient configuration object, and apply opacity.

 @param {Object} color The color or config object
/
     color: function (color, elem, prop, wrapper) {
             var renderer = this,
                     colorObject,
                     regexRgba = /^rgba/,
                     markup,
                     fillType,
                     ret = NONE;

             // Check for linear or radial gradient
             if (color &amp;&amp; color.linearGradient) {
                     fillType = &#39;gradient&#39;;
             } else if (color &amp;&amp; color.radialGradient) {
                     fillType = &#39;pattern&#39;;
             }

             if (fillType) {

                     var stopColor,
                             stopOpacity,
                             gradient = color.linearGradient || color.radialGradient,
                             x1,
                             y1,
                             x2,
                             y2,
                             opacity1,
                             opacity2,
                             color1,
                             color2,
                             fillAttr = &#39;&#39;,
                             stops = color.stops,
                             firstStop,
                             lastStop,
                             colors = [],
                             addFillNode = function () {
                                     // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
                                     // are reversed.
                                     markup = [&#39;&lt;fill colors=&quot;&#39; + colors.join(&#39;,&#39;) + &#39;&quot; opacity=&quot;&#39;, opacity2, &#39;&quot; o:opacity2=&quot;&#39;, opacity1,
                                             &#39;&quot; type=&quot;&#39;, fillType, &#39;&quot; &#39;, fillAttr, &#39;focus=&quot;100%&quot; method=&quot;any&quot; /&gt;&#39;];
                                     createElement(renderer.prepVML(markup), null, null, elem);
                             };

                     // Extend from 0 to 1
                     firstStop = stops[0];
                     lastStop = stops[stops.length - 1];
                     if (firstStop[0] &gt; 0) {
                             stops.unshift([
                                     0,
                                     firstStop[1]
                             ]);
                     }
                     if (lastStop[0] &lt; 1) {
                             stops.push([
                                     1,
                                     lastStop[1]
                             ]);
                     }

                     // Compute the stops
                     each(stops, function (stop, i) {
                             if (regexRgba.test(stop[1])) {
                                     colorObject = Color(stop[1]);
                                     stopColor = colorObject.get(&#39;rgb&#39;);
                                     stopOpacity = colorObject.get(&#39;a&#39;);
                             } else {
                                     stopColor = stop[1];
                                     stopOpacity = 1;
                             }

                             // Build the color attribute
                             colors.push((stop[0] * 100) + &#39;% &#39; + stopColor);

                             // Only start and end opacities are allowed, so we use the first and the last
                             if (!i) {
                                     opacity1 = stopOpacity;
                                     color2 = stopColor;
                             } else {
                                     opacity2 = stopOpacity;
                                     color1 = stopColor;
                             }
                     });

                     // Apply the gradient to fills only.
                     if (prop === &#39;fill&#39;) {

                             // Handle linear gradient angle
                             if (fillType === &#39;gradient&#39;) {
                                     x1 = gradient.x1 || gradient[0] || 0;
                                     y1 = gradient.y1 || gradient[1] || 0;
                                     x2 = gradient.x2 || gradient[2] || 0;
                                     y2 = gradient.y2 || gradient[3] || 0;
                                     fillAttr = &#39;angle=&quot;&#39; + (90  - math.atan(
                                             (y2 - y1) / // y vector
                                             (x2 - x1) // x vector
                                             ) * 180 / mathPI) + &#39;&quot;&#39;;

                                     addFillNode();

                             // Radial (circular) gradient
                             } else {

                                     var r = gradient.r,
                                             sizex = r * 2,
                                             sizey = r * 2,
                                             cx = gradient.cx,
                                             cy = gradient.cy,
                                             radialReference = elem.radialReference,
                                             bBox,
                                             applyRadialGradient = function () {
                                                     if (radialReference) {
                                                             bBox = wrapper.getBBox();
                                                             cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
                                                             cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
                                                             sizex *= radialReference[2] / bBox.width;
                                                             sizey *= radialReference[2] / bBox.height;
                                                     }
                                                     fillAttr = &#39;src=&quot;&#39; + defaultOptions.global.VMLRadialGradientURL + &#39;&quot; &#39; +
                                                             &#39;size=&quot;&#39; + sizex + &#39;,&#39; + sizey + &#39;&quot; &#39; +
                                                             &#39;origin=&quot;0.5,0.5&quot; &#39; +
                                                             &#39;position=&quot;&#39; + cx + &#39;,&#39; + cy + &#39;&quot; &#39; +
                                                             &#39;color2=&quot;&#39; + color2 + &#39;&quot; &#39;;

                                                     addFillNode();
                                             };

                                     // Apply radial gradient
                                     if (wrapper.added) {
                                             applyRadialGradient();
                                     } else {
                                             // We need to know the bounding box to get the size and position right
                                             wrapper.onAdd = applyRadialGradient;
                                     }

                                     // The fill element&#39;s color attribute is broken in IE8 standards mode, so we
                                     // need to set the parent shape&#39;s fillcolor attribute instead.
                                     ret = color1;
                             }

                     // Gradients are not supported for VML stroke, return the first color. #722.
                     } else {
                             ret = stopColor;
                     }

             // if the color is an rgba color, split it and add a fill node
             // to hold the opacity component
             } else if (regexRgba.test(color) &amp;&amp; elem.tagName !== &#39;IMG&#39;) {

                     colorObject = Color(color);

                     markup = [&#39;&lt;&#39;, prop, &#39; opacity=&quot;&#39;, colorObject.get(&#39;a&#39;), &#39;&quot;/&gt;&#39;];
                     createElement(this.prepVML(markup), null, null, elem);

                     ret = colorObject.get(&#39;rgb&#39;);

             } else {
                     var propNodes = elem.getElementsByTagName(prop); // &#39;stroke&#39; or &#39;fill&#39; node
                     if (propNodes.length) {
                             propNodes[0].opacity = 1;
                             propNodes[0].type = &#39;solid&#39;;
                     }
                     ret = color;
             }

             return ret;
     },

     /**
 Take a VML string and prepare it for either IE8 or IE6/IE7.
 @param {Array} markup A string array of the VML markup to prepare
/
     prepVML: function (markup) {
             var vmlStyle = &#39;display:inline-block;behavior:url(#default#VML);&#39;,
                     isIE8 = this.isIE8;

             markup = markup.join(&#39;&#39;);

             if (isIE8) { // add xmlns and style inline
                     markup = markup.replace(&#39;/&gt;&#39;, &#39; xmlns=&quot;urn:schemas-microsoft-com:vml&quot; /&gt;&#39;);
                     if (markup.indexOf(&#39;style=&quot;&#39;) === -1) {
                             markup = markup.replace(&#39;/&gt;&#39;, &#39; style=&quot;&#39; + vmlStyle + &#39;&quot; /&gt;&#39;);
                     } else {
                             markup = markup.replace(&#39;style=&quot;&#39;, &#39;style=&quot;&#39; + vmlStyle);
                     }

             } else { // add namespace
                     markup = markup.replace(&#39;&lt;&#39;, &#39;&lt;hcv:&#39;);
             }

             return markup;
     },

     /**
 Create rotated and aligned text
 @param {String} str
 @param {Number} x
 @param {Number} y
/
     text: SVGRenderer.prototype.html,

     /**
 Create and return a path element
 @param {Array} path
/
     path: function (path) {
             var attr = {
                     // subpixel precision down to 0.1 (width and height = 1px)
                     coordsize: &#39;10 10&#39;
             };
             if (isArray(path)) {
                     attr.d = path;
             } else if (isObject(path)) { // attributes
                     extend(attr, path);
             }
             // create the shape
             return this.createElement(&#39;shape&#39;).attr(attr);
     },

     /**
 Create and return a circle element. In VML circles are implemented as
 shapes, which is faster than v:oval
 @param {Number} x
 @param {Number} y
 @param {Number} r
/
     circle: function (x, y, r) {
             var circle = this.symbol(&#39;circle&#39;);
             if (isObject(x)) {
                     r = x.r;
                     y = x.y;
                     x = x.x;
             }
             circle.isCircle = true; // Causes x and y to mean center (#1682)
             circle.r = r;
             return circle.attr({ x: x, y: y });
     },

     /**
 Create a group using an outer div and an inner v:group to allow rotating
 and flipping. A simple v:group would have problems with positioning
 child HTML elements and CSS clip.

 @param {String} name The name of the group
/
     g: function (name) {
             var wrapper,
                     attribs;

             // set the class name
             if (name) {
                     attribs = { &#39;className&#39;: PREFIX + name, &#39;class&#39;: PREFIX + name };
             }

             // the div to hold HTML and clipping
             wrapper = this.createElement(DIV).attr(attribs);

             return wrapper;
     },

     /**
 VML override to create a regular HTML image
 @param {String} src
 @param {Number} x
 @param {Number} y
 @param {Number} width
 @param {Number} height
/
     image: function (src, x, y, width, height) {
             var obj = this.createElement(&#39;img&#39;)
                     .attr({ src: src });

             if (arguments.length &gt; 1) {
                     obj.attr({
                             x: x,
                             y: y,
                             width: width,
                             height: height
                     });
             }
             return obj;
     },

     /**
 For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
/
     createElement: function (nodeName) {
             return nodeName === &#39;rect&#39; ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);  
     },

     /**
 In the VML renderer, each child of an inverted div (group) is inverted
 @param {Object} element
 @param {Object} parentNode
/
     invertChild: function (element, parentNode) {
             var ren = this,
                     parentStyle = parentNode.style,
                     imgStyle = element.tagName === &#39;IMG&#39; &amp;&amp; element.style; // #1111

             css(element, {
                     flip: &#39;x&#39;,
                     left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
                     top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
                     rotation: -90
             });

             // Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
             each(element.childNodes, function (child) {
                     ren.invertChild(child, element);
             });
     },

     /**
 Symbol definitions that override the parent SVG renderer&#39;s symbols

/
     symbols: {
             // VML specific arc function
             arc: function (x, y, w, h, options) {
                     var start = options.start,
                             end = options.end,
                             radius = options.r || w || h,
                             innerRadius = options.innerR,
                             cosStart = mathCos(start),
                             sinStart = mathSin(start),
                             cosEnd = mathCos(end),
                             sinEnd = mathSin(end),
                             ret;

                     if (end - start === 0) { // no angle, don&#39;t show it.
                             return [&#39;x&#39;];
                     }

                     ret = [
                             &#39;wa&#39;, // clockwise arc to
                             x - radius, // left
                             y - radius, // top
                             x + radius, // right
                             y + radius, // bottom
                             x + radius * cosStart, // start x
                             y + radius * sinStart, // start y
                             x + radius * cosEnd, // end x
                             y + radius * sinEnd  // end y
                     ];

                     if (options.open &amp;&amp; !innerRadius) {
                             ret.push(
                                     &#39;e&#39;,
                                     M,
                                     x,// - innerRadius,
                                     y// - innerRadius
                             );
                     }

                     ret.push(
                             &#39;at&#39;, // anti clockwise arc to
                             x - innerRadius, // left
                             y - innerRadius, // top
                             x + innerRadius, // right
                             y + innerRadius, // bottom
                             x + innerRadius * cosEnd, // start x
                             y + innerRadius * sinEnd, // start y
                             x + innerRadius * cosStart, // end x
                             y + innerRadius * sinStart, // end y
                             &#39;x&#39;, // finish path
                             &#39;e&#39; // close
                     );

                     ret.isArc = true;
                     return ret;

             },
             // Add circle symbol path. This performs significantly faster than v:oval.
             circle: function (x, y, w, h, wrapper) {

                     if (wrapper) {
                             w = h = 2 * wrapper.r;
                     }

                     // Center correction, #1682
                     if (wrapper &amp;&amp; wrapper.isCircle) {
                             x -= w / 2;
                             y -= h / 2;
                     }

                     // Return the path
                     return [
                             &#39;wa&#39;, // clockwisearcto
                             x, // left
                             y, // top
                             x + w, // right
                             y + h, // bottom
                             x + w, // start x
                             y + h / 2,     // start y
                             x + w, // end x
                             y + h / 2,     // end y
                             //&#39;x&#39;, // finish path
                             &#39;e&#39; // close
                     ];
             },
             /**
  Add rectangle symbol path which eases rotation and omits arcsize problems
  compared to the built-in VML roundrect shape. When borders are not rounded,
  use the simpler square path, else use the callout path without the arrow.
 /
             rect: function (x, y, w, h, options) {
                     return SVGRenderer.prototype.symbols[
                             !defined(options) || !options.r ? &#39;square&#39; : &#39;callout&#39;
                     ].call(0, x, y, w, h, options);
             }
     }</pre>

<p>}; Highcharts.VMLRenderer = VMLRenderer = function () {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">init</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
</pre>

<p>}; VMLRenderer.prototype = merge(SVGRenderer.prototype,
VMLRendererExtension);</p>

<pre>// general renderer
Renderer = VMLRenderer;</pre>

<p>}</p>

<p>// This method is used with exporting in old IE, when emulating SVG (see
#2314) SVGRenderer.prototype.measureSpanWidth = function (text, styles) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">measuringSpan</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">createElement</span>(<span class="ruby-string">&#39;span&#39;</span>),
        <span class="ruby-identifier">offsetWidth</span>,
<span class="ruby-identifier">textNode</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">createTextNode</span>(<span class="ruby-identifier">text</span>);

<span class="ruby-identifier">measuringSpan</span>.<span class="ruby-identifier">appendChild</span>(<span class="ruby-identifier">textNode</span>);
<span class="ruby-identifier">css</span>(<span class="ruby-identifier">measuringSpan</span>, <span class="ruby-identifier">styles</span>);
<span class="ruby-identifier">this</span>.<span class="ruby-identifier">box</span>.<span class="ruby-identifier">appendChild</span>(<span class="ruby-identifier">measuringSpan</span>);
<span class="ruby-identifier">offsetWidth</span> = <span class="ruby-identifier">measuringSpan</span>.<span class="ruby-identifier">offsetWidth</span>;
<span class="ruby-identifier">discardElement</span>(<span class="ruby-identifier">measuringSpan</span>); <span class="ruby-regexp">//</span> <span class="ruby-comment">#2463</span>
<span class="ruby-keyword">return</span> <span class="ruby-identifier">offsetWidth</span>;
</pre>

<p>};</p>

<p>/*
****************************************************************************</p>

<pre>END OF INTERNET EXPLORER &lt;= 8 SPECIFIC CODE                                *

***************************************************************************/</pre>

<p>/*
****************************************************************************</p>

<pre>START OF ANDROID &lt; 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU&#39;RE NOT      *
TARGETING THAT SYSTEM.                                                     *

***************************************************************************/</pre>

<p>var CanVGRenderer,</p>

<pre class="ruby"><span class="ruby-constant">CanVGController</span>;
</pre>

<p>if (useCanVG) {</p>

<pre>     /**
 The CanVGRenderer is empty from start to keep the source footprint small.
 When requested, the CanVGController downloads the rest of the source packaged
 together with the canvg library.
/
     Highcharts.CanVGRenderer = CanVGRenderer = function () {
             // Override the global SVG namespace to fake SVG/HTML that accepts CSS
             SVG_NS = &#39;http://www.w3.org/1999/xhtml&#39;;
     };

     /**
 Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but 
 the implementation from SvgRenderer will not be merged in until first render.
/
     CanVGRenderer.prototype.symbols = {};

     /**
 Handles on demand download of canvg rendering support.
/
     CanVGController = (function () {
             // List of renderering calls
             var deferredRenderCalls = [];

             /**
  When downloaded, we are ready to draw deferred charts.
 /
             function drawDeferred() {
                     var callLength = deferredRenderCalls.length,
                             callIndex;

                     // Draw all pending render calls
                     for (callIndex = 0; callIndex &lt; callLength; callIndex++) {
                             deferredRenderCalls[callIndex]();
                     }
                     // Clear the list
                     deferredRenderCalls = [];
             }

             return {
                     push: function (func, scriptLocation) {
                             // Only get the script once
                             if (deferredRenderCalls.length === 0) {
                                     getScript(scriptLocation, drawDeferred);
                             }
                             // Register render call
                             deferredRenderCalls.push(func);
                     }
             };
     }());

     Renderer = CanVGRenderer;</pre>

<p>} // end CanVGRenderer</p>

<p>/*
****************************************************************************</p>

<pre>END OF ANDROID &lt; 3 SPECIFIC CODE                                           *

***************************************************************************/</pre>

<p>/**</p>

<pre> The Tick class
/</pre>

<p>function Tick(axis, pos, type, noLabel) {</p>

<pre>this.axis = axis;
this.pos = pos;
this.type = type || &#39;&#39;;
this.isNew = true;

if (!type &amp;&amp; !noLabel) {
        this.addLabel();
}</pre>

<p>}</p>

<p>Tick.prototype = {</p>

<pre>     /**
 Write the tick label
/
     addLabel: function () {
             var tick = this,
                     axis = tick.axis,
                     options = axis.options,
                     chart = axis.chart,
                     horiz = axis.horiz,
                     categories = axis.categories,
                     names = axis.names,
                     pos = tick.pos,
                     labelOptions = options.labels,
                     rotation = labelOptions.rotation,
                     str,
                     tickPositions = axis.tickPositions,
                     width = (horiz &amp;&amp; categories &amp;&amp;
                             !labelOptions.step &amp;&amp; !labelOptions.staggerLines &amp;&amp;
                             !labelOptions.rotation &amp;&amp;
                             chart.plotWidth / tickPositions.length) ||
                             (!horiz &amp;&amp; (chart.margin[3] || chart.chartWidth * 0.33)), // #1580, #1931
                     isFirst = pos === tickPositions[0],
                     isLast = pos === tickPositions[tickPositions.length - 1],
                     css,
                     attr,
                     value = categories ?
                             pick(categories[pos], names[pos], pos) :
                             pos,
                     label = tick.label,
                     tickPositionInfo = tickPositions.info,
                     dateTimeLabelFormat;

             // Set the datetime label format. If a higher rank is set for this position, use that. If not,
             // use the general format.
             if (axis.isDatetimeAxis &amp;&amp; tickPositionInfo) {
                     dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
             }
             // set properties for access in render method
             tick.isFirst = isFirst;
             tick.isLast = isLast;

             // get the string
             str = axis.labelFormatter.call({
                     axis: axis,
                     chart: chart,
                     isFirst: isFirst,
                     isLast: isLast,
                     dateTimeLabelFormat: dateTimeLabelFormat,
                     value: axis.isLog ? correctFloat(lin2log(value)) : value
             });

             // prepare CSS
             css = width &amp;&amp; { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };

             // first call
             if (!defined(label)) {
                     attr = {
                             align: axis.labelAlign
                     };
                     if (isNumber(rotation)) {
                             attr.rotation = rotation;
                     }
                     if (width &amp;&amp; labelOptions.ellipsis) {
                             css.HcHeight = axis.len / tickPositions.length;
                     }

                     tick.label = label =
                             defined(str) &amp;&amp; labelOptions.enabled ?
                                     chart.renderer.text(
                                                     str,
                                                     0,
                                                     0,
                                                     labelOptions.useHTML
                                             )
                                             .attr(attr)
                                             // without position absolute, IE export sometimes is wrong
                                             .css(extend(css, labelOptions.style))
                                             .add(axis.labelGroup) :
                                     null;

                     // Set the tick baseline and correct for rotation (#1764)
                     axis.tickBaseline = chart.renderer.fontMetrics(labelOptions.style.fontSize, label).b;
                     if (rotation &amp;&amp; axis.side === 2) {
                             axis.tickBaseline *= mathCos(rotation * deg2rad);
                     }

             // update
             } else if (label) {
                     label.attr({
                                     text: str
                             })
                             .css(css);
             }
             tick.yOffset = label ? pick(labelOptions.y, axis.tickBaseline + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))) : 0;
     },

     /**
 Get the offset height or width of the label
/
     getLabelSize: function () {
             var label = this.label,
                     axis = this.axis;
             return label ?
                     label.getBBox()[axis.horiz ? &#39;height&#39; : &#39;width&#39;] :
                     0;
     },

     /**
 Find how far the labels extend to the right and left of the tick&#39;s x position. Used for anti-collision
 detection with overflow logic.
/
     getLabelSides: function () {
             var bBox = this.label.getBBox(),
                     axis = this.axis,
                     horiz = axis.horiz,
                     options = axis.options,
                     labelOptions = options.labels,
                     size = horiz ? bBox.width : bBox.height,
                     leftSide = horiz ?
                             labelOptions.x - size * { left: 0, center: 0.5, right: 1 }[axis.labelAlign] :
                             0,
                     rightSide = horiz ?
                             size + leftSide :
                             size;

             return [leftSide, rightSide];
     },

     /**
 Handle the label overflow by adjusting the labels to the left and right edge, or
 hide them if they collide into the neighbour label.
/
     handleOverflow: function (index, xy) {
             var show = true,
                     axis = this.axis,
                     isFirst = this.isFirst,
                     isLast = this.isLast,
                     horiz = axis.horiz,
                     pxPos = horiz ? xy.x : xy.y,
                     reversed = axis.reversed,
                     tickPositions = axis.tickPositions,
                     sides = this.getLabelSides(),
                     leftSide = sides[0],
                     rightSide = sides[1],
                     axisLeft,
                     axisRight,
                     neighbour,
                     neighbourEdge,
                     line = this.label.line,
                     lineIndex = line || 0,
                     labelEdge = axis.labelEdge,
                     justifyLabel = axis.justifyLabels &amp;&amp; (isFirst || isLast),
                     justifyToPlot;

             // Hide it if it now overlaps the neighbour label
             if (labelEdge[lineIndex] === UNDEFINED || pxPos + leftSide &gt; labelEdge[lineIndex]) {
                     labelEdge[lineIndex] = pxPos + rightSide;

             } else if (!justifyLabel) {
                     show = false;
             }

             if (justifyLabel) {
                     justifyToPlot = axis.justifyToPlot;
                     axisLeft = justifyToPlot ? axis.pos : 0;
                     axisRight = justifyToPlot ? axisLeft + axis.len : axis.chart.chartWidth;

                     // Find the firsth neighbour on the same line
                     do {
                             index += (isFirst ? 1 : -1);
                             neighbour = axis.ticks[tickPositions[index]];
                     } while (tickPositions[index] &amp;&amp; (!neighbour || !neighbour.label || neighbour.label.line !== line)); // #3044

                     neighbourEdge = neighbour &amp;&amp; neighbour.label.xy &amp;&amp; neighbour.label.xy.x + neighbour.getLabelSides()[isFirst ? 0 : 1];

                     if ((isFirst &amp;&amp; !reversed) || (isLast &amp;&amp; reversed)) {
                             // Is the label spilling out to the left of the plot area?
                             if (pxPos + leftSide &lt; axisLeft) {

                                     // Align it to plot left
                                     pxPos = axisLeft - leftSide;

                                     // Hide it if it now overlaps the neighbour label
                                     if (neighbour &amp;&amp; pxPos + rightSide &gt; neighbourEdge) {
                                             show = false;
                                     }
                             }

                     } else {
                             // Is the label spilling out to the right of the plot area?
                             if (pxPos + rightSide &gt; axisRight) {

                                     // Align it to plot right
                                     pxPos = axisRight - rightSide;

                                     // Hide it if it now overlaps the neighbour label
                                     if (neighbour &amp;&amp; pxPos + leftSide &lt; neighbourEdge) {
                                             show = false;
                                     }

                             }
                     }

                     // Set the modified x position of the label
                     xy.x = pxPos;
             }
             return show;
     },

     /**
 Get the x and y position for ticks and labels
/
     getPosition: function (horiz, pos, tickmarkOffset, old) {
             var axis = this.axis,
                     chart = axis.chart,
                     cHeight = (old &amp;&amp; chart.oldChartHeight) || chart.chartHeight;

             return {
                     x: horiz ?
                             axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
                             axis.left + axis.offset + (axis.opposite ? ((old &amp;&amp; chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

                     y: horiz ?
                             cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
                             cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
             };

     },

     /**
 Get the x, y position of the tick label
/
     getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
             var axis = this.axis,
                     transA = axis.transA,
                     reversed = axis.reversed,
                     staggerLines = axis.staggerLines;

             x = x + labelOptions.x - (tickmarkOffset &amp;&amp; horiz ?
                     tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
             y = y + this.yOffset - (tickmarkOffset &amp;&amp; !horiz ?
                     tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

             // Correct for staggered labels
             if (staggerLines) {
                     label.line = (index / (step || 1) % staggerLines);
                     y += label.line * (axis.labelOffset / staggerLines);
             }

             return {
                     x: x,
                     y: y
             };
     },

     /**
 Extendible method to return the path of the marker
/
     getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
             return renderer.crispLine([
                             M,
                             x,
                             y,
                             L,
                             x + (horiz ? 0 : -tickLength),
                             y + (horiz ? tickLength : 0)
                     ], tickWidth);
     },

     /**
 Put everything in place

 @param index {Number}
 @param old {Boolean} Use old coordinates to prepare an animation into new position
/
     render: function (index, old, opacity) {
             var tick = this,
                     axis = tick.axis,
                     options = axis.options,
                     chart = axis.chart,
                     renderer = chart.renderer,
                     horiz = axis.horiz,
                     type = tick.type,
                     label = tick.label,
                     pos = tick.pos,
                     labelOptions = options.labels,
                     gridLine = tick.gridLine,
                     gridPrefix = type ? type + &#39;Grid&#39; : &#39;grid&#39;,
                     tickPrefix = type ? type + &#39;Tick&#39; : &#39;tick&#39;,
                     gridLineWidth = options[gridPrefix + &#39;LineWidth&#39;],
                     gridLineColor = options[gridPrefix + &#39;LineColor&#39;],
                     dashStyle = options[gridPrefix + &#39;LineDashStyle&#39;],
                     tickLength = options[tickPrefix + &#39;Length&#39;],
                     tickWidth = options[tickPrefix + &#39;Width&#39;] || 0,
                     tickColor = options[tickPrefix + &#39;Color&#39;],
                     tickPosition = options[tickPrefix + &#39;Position&#39;],
                     gridLinePath,
                     mark = tick.mark,
                     markPath,
                     step = labelOptions.step,
                     attribs,
                     show = true,
                     tickmarkOffset = axis.tickmarkOffset,
                     xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
                     x = xy.x,
                     y = xy.y,
                     reverseCrisp = ((horiz &amp;&amp; x === axis.pos + axis.len) || (!horiz &amp;&amp; y === axis.pos)) ? -1 : 1; // #1480, #1687

             opacity = pick(opacity, 1);
             this.isActive = true;

             // create the grid line
             if (gridLineWidth) {
                     gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

                     if (gridLine === UNDEFINED) {
                             attribs = {
                                     stroke: gridLineColor,
                                     &#39;stroke-width&#39;: gridLineWidth
                             };
                             if (dashStyle) {
                                     attribs.dashstyle = dashStyle;
                             }
                             if (!type) {
                                     attribs.zIndex = 1;
                             }
                             if (old) {
                                     attribs.opacity = 0;
                             }
                             tick.gridLine = gridLine =
                                     gridLineWidth ?
                                             renderer.path(gridLinePath)
                                                     .attr(attribs).add(axis.gridGroup) :
                                             null;
                     }

                     // If the parameter &#39;old&#39; is set, the current call will be followed
                     // by another call, therefore do not do any animations this time
                     if (!old &amp;&amp; gridLine &amp;&amp; gridLinePath) {
                             gridLine[tick.isNew ? &#39;attr&#39; : &#39;animate&#39;]({
                                     d: gridLinePath,
                                     opacity: opacity
                             });
                     }
             }

             // create the tick mark
             if (tickWidth &amp;&amp; tickLength) {

                     // negate the length
                     if (tickPosition === &#39;inside&#39;) {
                             tickLength = -tickLength;
                     }
                     if (axis.opposite) {
                             tickLength = -tickLength;
                     }

                     markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
                     if (mark) { // updating
                             mark.animate({
                                     d: markPath,
                                     opacity: opacity
                             });
                     } else { // first time
                             tick.mark = renderer.path(
                                     markPath
                             ).attr({
                                     stroke: tickColor,
                                     &#39;stroke-width&#39;: tickWidth,
                                     opacity: opacity
                             }).add(axis.axisGroup);
                     }
             }

             // the label is created on init - now move it into place
             if (label &amp;&amp; !isNaN(x)) {
                     label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

                     // Apply show first and show last. If the tick is both first and last, it is
                     // a single centered tick, in which case we show the label anyway (#2100).
                     if ((tick.isFirst &amp;&amp; !tick.isLast &amp;&amp; !pick(options.showFirstLabel, 1)) ||
                                     (tick.isLast &amp;&amp; !tick.isFirst &amp;&amp; !pick(options.showLastLabel, 1))) {
                             show = false;

                     // Handle label overflow and show or hide accordingly
                     } else if (!axis.isRadial &amp;&amp; !labelOptions.step &amp;&amp; !labelOptions.rotation &amp;&amp; !old &amp;&amp; opacity !== 0) {
                             show = tick.handleOverflow(index, xy);
                     }

                     // apply step
                     if (step &amp;&amp; index % step) {
                             // show those indices dividable by step
                             show = false;
                     }

                     // Set the new position, and show or hide
                     if (show &amp;&amp; !isNaN(xy.y)) {
                             xy.opacity = opacity;
                             label[tick.isNew ? &#39;attr&#39; : &#39;animate&#39;](xy);
                             tick.isNew = false;
                     } else {
                             label.attr(&#39;y&#39;, -9999); // #1338
                     }
             }
     },

     /**
 Destructor for the tick prototype
/
     destroy: function () {
             destroyObjectProperties(this, this.axis);
     }</pre>

<p>};</p>

<p>/**</p>

<pre> The object wrapper for plot lines and plot bands
 @param {Object} options
/</pre>

<p>Highcharts.PlotLineOrBand = function (axis, options) {</p>

<pre>this.axis = axis;

if (options) {
        this.options = options;
        this.id = options.id;
}</pre>

<p>};</p>

<p>Highcharts.PlotLineOrBand.prototype = {</p>

<pre>     /**
 Render the plot line or plot band. If it is already existing,
 move it.
/
     render: function () {
             var plotLine = this,
                     axis = plotLine.axis,
                     horiz = axis.horiz,
                     halfPointRange = (axis.pointRange || 0) / 2,
                     options = plotLine.options,
                     optionsLabel = options.label,
                     label = plotLine.label,
                     width = options.width,
                     to = options.to,
                     from = options.from,
                     isBand = defined(from) &amp;&amp; defined(to),
                     value = options.value,
                     dashStyle = options.dashStyle,
                     svgElem = plotLine.svgElem,
                     path = [],
                     addEvent,
                     eventType,
                     xs,
                     ys,
                     x,
                     y,
                     color = options.color,
                     zIndex = options.zIndex,
                     events = options.events,
                     attribs = {},
                     renderer = axis.chart.renderer;

             // logarithmic conversion
             if (axis.isLog) {
                     from = log2lin(from);
                     to = log2lin(to);
                     value = log2lin(value);
             }

             // plot line
             if (width) {
                     path = axis.getPlotLinePath(value, width);
                     attribs = {
                             stroke: color,
                             &#39;stroke-width&#39;: width
                     };
                     if (dashStyle) {
                             attribs.dashstyle = dashStyle;
                     }
             } else if (isBand) { // plot band

                     // keep within plot area
                     from = mathMax(from, axis.min - halfPointRange);
                     to = mathMin(to, axis.max + halfPointRange);

                     path = axis.getPlotBandPath(from, to, options);
                     if (color) {
                             attribs.fill = color;
                     }
                     if (options.borderWidth) {
                             attribs.stroke = options.borderColor;
                             attribs[&#39;stroke-width&#39;] = options.borderWidth;
                     }
             } else {
                     return;
             }
             // zIndex
             if (defined(zIndex)) {
                     attribs.zIndex = zIndex;
             }

             // common for lines and bands
             if (svgElem) {
                     if (path) {
                             svgElem.animate({
                                     d: path
                             }, null, svgElem.onGetPath);
                     } else {
                             svgElem.hide();
                             svgElem.onGetPath = function () {
                                     svgElem.show();
                             };
                             if (label) {
                                     plotLine.label = label = label.destroy();
                             }
                     }
             } else if (path &amp;&amp; path.length) {
                     plotLine.svgElem = svgElem = renderer.path(path)
                             .attr(attribs).add();

                     // events
                     if (events) {
                             addEvent = function (eventType) {
                                     svgElem.on(eventType, function (e) {
                                             events[eventType].apply(plotLine, [e]);
                                     });
                             };
                             for (eventType in events) {
                                     addEvent(eventType);
                             }
                     }
             }

             // the plot band/line label
             if (optionsLabel &amp;&amp; defined(optionsLabel.text) &amp;&amp; path &amp;&amp; path.length &amp;&amp; axis.width &gt; 0 &amp;&amp; axis.height &gt; 0) {
                     // apply defaults
                     optionsLabel = merge({
                             align: horiz &amp;&amp; isBand &amp;&amp; &#39;center&#39;,
                             x: horiz ? !isBand &amp;&amp; 4 : 10,
                             verticalAlign : !horiz &amp;&amp; isBand &amp;&amp; &#39;middle&#39;,
                             y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
                             rotation: horiz &amp;&amp; !isBand &amp;&amp; 90
                     }, optionsLabel);

                     // add the SVG element
                     if (!label) {
                             attribs = {
                                     align: optionsLabel.textAlign || optionsLabel.align,
                                     rotation: optionsLabel.rotation
                             };
                             if (defined(zIndex)) {
                                     attribs.zIndex = zIndex;
                             }
                             plotLine.label = label = renderer.text(
                                             optionsLabel.text,
                                             0,
                                             0,
                                             optionsLabel.useHTML
                                     )
                                     .attr(attribs)
                                     .css(optionsLabel.style)
                                     .add();
                     }

                     // get the bounding box and align the label
                     // #3000 changed to better handle choice between plotband or plotline
                     xs = [path[1], path[4], (isBand ? path[6] : path[1])];
                     ys = [path[2], path[5], (isBand ? path[7] : path[2])];
                     x = arrayMin(xs);
                     y = arrayMin(ys);

                     label.align(optionsLabel, false, {
                             x: x,
                             y: y,
                             width: arrayMax(xs) - x,
                             height: arrayMax(ys) - y
                     });
                     label.show();

             } else if (label) { // move out of sight
                     label.hide();
             }

             // chainable
             return plotLine;
     },

     /**
 Remove the plot line or band
/
     destroy: function () {
             // remove it from the lookup
             erase(this.axis.plotLinesAndBands, this);

             delete this.axis;
             destroyObjectProperties(this);
     }</pre>

<p>};</p>

<p>/**</p>

<pre> Object with members for extending the Axis prototype
/</pre>

<p>AxisPlotLineOrBandExtension = {</p>

<pre>     /**
 Create the path for a plot band
/ 
     getPlotBandPath: function (from, to) {
             var toPath = this.getPlotLinePath(to),
                     path = this.getPlotLinePath(from);

             if (path &amp;&amp; toPath) {
                     path.push(
                             toPath[4],
                             toPath[5],
                             toPath[1],
                             toPath[2]
                     );
             } else { // outside the axis area
                     path = null;
             }

             return path;
     },

     addPlotBand: function (options) {
             return this.addPlotBandOrLine(options, &#39;plotBands&#39;);
     },

     addPlotLine: function (options) {
             return this.addPlotBandOrLine(options, &#39;plotLines&#39;);
     },

     /**
 Add a plot band or plot line after render time

 @param options {Object} The plotBand or plotLine configuration object
/
     addPlotBandOrLine: function (options, coll) {
             var obj = new Highcharts.PlotLineOrBand(this, options).render(),
                     userOptions = this.userOptions;

             if (obj) { // #2189
                     // Add it to the user options for exporting and Axis.update
                     if (coll) {
                             userOptions[coll] = userOptions[coll] || [];
                             userOptions[coll].push(options); 
                     }
                     this.plotLinesAndBands.push(obj); 
             }

             return obj;
     },

     /**
 Remove a plot band or plot line from the chart by id
 @param {Object} id
/
     removePlotBandOrLine: function (id) {
             var plotLinesAndBands = this.plotLinesAndBands,
                     options = this.options,
                     userOptions = this.userOptions,
                     i = plotLinesAndBands.length;
             while (i--) {
                     if (plotLinesAndBands[i].id === id) {
                             plotLinesAndBands[i].destroy();
                     }
             }
             each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
                     i = arr.length;
                     while (i--) {
                             if (arr[i].id === id) {
                                     erase(arr, arr[i]);
                             }
                     }
             });
     }</pre>

<p>};</p>

<p>/**</p>

<pre> Create a new axis object
 @param {Object} chart
 @param {Object} options
/</pre>

<p>function Axis() {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">init</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
</pre>

<p>}</p>

<p>Axis.prototype = {</p>

<pre>     /**
 Default options for the X axis - the Y axis has extended defaults
/
     defaultOptions: {
             // allowDecimals: null,
             // alternateGridColor: null,
             // categories: [],
             dateTimeLabelFormats: {
                     millisecond: &#39;%H:%M:%S.%L&#39;,
                     second: &#39;%H:%M:%S&#39;,
                     minute: &#39;%H:%M&#39;,
                     hour: &#39;%H:%M&#39;,
                     day: &#39;%e. %b&#39;,
                     week: &#39;%e. %b&#39;,
                     month: &#39;%b \&#39;%y&#39;,
                     year: &#39;%Y&#39;
             },
             endOnTick: false,
             gridLineColor: &#39;#C0C0C0&#39;,
             // gridLineDashStyle: &#39;solid&#39;,
             // gridLineWidth: 0,
             // reversed: false,

             labels: defaultLabelOptions,
                     // { step: null },
             lineColor: &#39;#C0D0E0&#39;,
             lineWidth: 1,
             //linkedTo: null,
             //max: undefined,
             //min: undefined,
             minPadding: 0.01,
             maxPadding: 0.01,
             //minRange: null,
             minorGridLineColor: &#39;#E0E0E0&#39;,
             // minorGridLineDashStyle: null,
             minorGridLineWidth: 1,
             minorTickColor: &#39;#A0A0A0&#39;,
             //minorTickInterval: null,
             minorTickLength: 2,
             minorTickPosition: &#39;outside&#39;, // inside or outside
             //minorTickWidth: 0,
             //opposite: false,
             //offset: 0,
             //plotBands: [{
             //      events: {},
             //      zIndex: 1,
             //      labels: { align, x, verticalAlign, y, style, rotation, textAlign }
             //}],
             //plotLines: [{
             //      events: {}
             //  dashStyle: {}
             //      zIndex:
             //      labels: { align, x, verticalAlign, y, style, rotation, textAlign }
             //}],
             //reversed: false,
             // showFirstLabel: true,
             // showLastLabel: true,
             startOfWeek: 1,
             startOnTick: false,
             tickColor: &#39;#C0D0E0&#39;,
             //tickInterval: null,
             tickLength: 10,
             tickmarkPlacement: &#39;between&#39;, // on or between
             tickPixelInterval: 100,
             tickPosition: &#39;outside&#39;,
             tickWidth: 1,
             title: {
                     //text: null,
                     align: &#39;middle&#39;, // low, middle or high
                     //margin: 0 for horizontal, 10 for vertical axes,
                     //rotation: 0,
                     //side: &#39;outside&#39;,
                     style: {
                             color: &#39;#707070&#39;
                     }
                     //x: 0,
                     //y: 0
             },
             type: &#39;linear&#39; // linear, logarithmic or datetime
     },

     /**
 This options set extends the defaultOptions for Y axes
/
     defaultYAxisOptions: {
             endOnTick: true,
             gridLineWidth: 1,
             tickPixelInterval: 72,
             showLastLabel: true,
             labels: {
                     x: -8,
                     y: 3
             },
             lineWidth: 0,
             maxPadding: 0.05,
             minPadding: 0.05,
             startOnTick: true,
             tickWidth: 0,
             title: {
                     rotation: 270,
                     text: &#39;Values&#39;
             },
             stackLabels: {
                     enabled: false,
                     //align: dynamic,
                     //y: dynamic,
                     //x: dynamic,
                     //verticalAlign: dynamic,
                     //textAlign: dynamic,
                     //rotation: 0,
                     formatter: function () {
                             return numberFormat(this.total, -1);
                     },
                     style: defaultLabelOptions.style
             }
     },

     /**
 These options extend the defaultOptions for left axes
/
     defaultLeftAxisOptions: {
             labels: {
                     x: -15,
                     y: null
             },
             title: {
                     rotation: 270
             }
     },

     /**
 These options extend the defaultOptions for right axes
/
     defaultRightAxisOptions: {
             labels: {
                     x: 15,
                     y: null
             },
             title: {
                     rotation: 90
             }
     },

     /**
 These options extend the defaultOptions for bottom axes
/
     defaultBottomAxisOptions: {
             labels: {
                     x: 0,
                     y: null // based on font size
                     // overflow: undefined,
                     // staggerLines: null
             },
             title: {
                     rotation: 0
             }
     },
     /**
 These options extend the defaultOptions for left axes
/
     defaultTopAxisOptions: {
             labels: {
                     x: 0,
                     y: -15
                     // overflow: undefined
                     // staggerLines: null
             },
             title: {
                     rotation: 0
             }
     },

     /**
 Initialize the axis
/
     init: function (chart, userOptions) {

             var isXAxis = userOptions.isX,
                     axis = this;

             // Flag, is the axis horizontal
             axis.horiz = chart.inverted ? !isXAxis : isXAxis;

             // Flag, isXAxis
             axis.isXAxis = isXAxis;
             axis.coll = isXAxis ? &#39;xAxis&#39; : &#39;yAxis&#39;;

             axis.opposite = userOptions.opposite; // needed in setOptions
             axis.side = userOptions.side || (axis.horiz ?
                             (axis.opposite ? 0 : 2) : // top : bottom
                             (axis.opposite ? 1 : 3));  // right : left

             axis.setOptions(userOptions);

             var options = this.options,
                     type = options.type,
                     isDatetimeAxis = type === &#39;datetime&#39;;

             axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format

             // Flag, stagger lines or not
             axis.userOptions = userOptions;

             //axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
             axis.minPixelPadding = 0;
             //axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series
             //axis.ignoreMaxPadding = UNDEFINED;

             axis.chart = chart;
             axis.reversed = options.reversed;
             axis.zoomEnabled = options.zoomEnabled !== false;

             // Initial categories
             axis.categories = options.categories || type === &#39;category&#39;;
             axis.names = [];

             // Elements
             //axis.axisGroup = UNDEFINED;
             //axis.gridGroup = UNDEFINED;
             //axis.axisTitle = UNDEFINED;
             //axis.axisLine = UNDEFINED;

             // Shorthand types
             axis.isLog = type === &#39;logarithmic&#39;;
             axis.isDatetimeAxis = isDatetimeAxis;

             // Flag, if axis is linked to another axis
             axis.isLinked = defined(options.linkedTo);
             // Linked axis.
             //axis.linkedParent = UNDEFINED;

             // Tick positions
             //axis.tickPositions = UNDEFINED; // array containing predefined positions
             // Tick intervals
             //axis.tickInterval = UNDEFINED;
             //axis.minorTickInterval = UNDEFINED;

             axis.tickmarkOffset = (axis.categories &amp;&amp; options.tickmarkPlacement === &#39;between&#39; &amp;&amp; 
                     pick(options.tickInterval, 1) === 1) ? 0.5 : 0; // #3202

             // Major ticks
             axis.ticks = {};
             axis.labelEdge = [];
             // Minor ticks
             axis.minorTicks = {};
             //axis.tickAmount = UNDEFINED;

             // List of plotLines/Bands
             axis.plotLinesAndBands = [];

             // Alternate bands
             axis.alternateBands = {};

             // Axis metrics
             //axis.left = UNDEFINED;
             //axis.top = UNDEFINED;
             //axis.width = UNDEFINED;
             //axis.height = UNDEFINED;
             //axis.bottom = UNDEFINED;
             //axis.right = UNDEFINED;
             //axis.transA = UNDEFINED;
             //axis.transB = UNDEFINED;
             //axis.oldTransA = UNDEFINED;
             axis.len = 0;
             //axis.oldMin = UNDEFINED;
             //axis.oldMax = UNDEFINED;
             //axis.oldUserMin = UNDEFINED;
             //axis.oldUserMax = UNDEFINED;
             //axis.oldAxisLength = UNDEFINED;
             axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
             axis.range = options.range;
             axis.offset = options.offset || 0;

             // Dictionary for stacks
             axis.stacks = {};
             axis.oldStacks = {};

             // Min and max in the data
             //axis.dataMin = UNDEFINED,
             //axis.dataMax = UNDEFINED,

             // The axis range
             axis.max = null;
             axis.min = null;

             // User set min and max
             //axis.userMin = UNDEFINED,
             //axis.userMax = UNDEFINED,

             // Crosshair options
             axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
             // Run Axis

             var eventType,
                     events = axis.options.events;

             // Register
             if (inArray(axis, chart.axes) === -1) { // don&#39;t add it again on Axis.update()
                     if (isXAxis &amp;&amp; !this.isColorAxis) { // #2713
                             chart.axes.splice(chart.xAxis.length, 0, axis);
                     } else {
                             chart.axes.push(axis);
                     }

                     chart[axis.coll].push(axis);
             }

             axis.series = axis.series || []; // populated by Series

             // inverted charts have reversed xAxes as default
             if (chart.inverted &amp;&amp; isXAxis &amp;&amp; axis.reversed === UNDEFINED) {
                     axis.reversed = true;
             }

             axis.removePlotBand = axis.removePlotBandOrLine;
             axis.removePlotLine = axis.removePlotBandOrLine;

             // register event listeners
             for (eventType in events) {
                     addEvent(axis, eventType, events[eventType]);
             }

             // extend logarithmic axis
             if (axis.isLog) {
                     axis.val2lin = log2lin;
                     axis.lin2val = lin2log;
             }
     },

     /**
 Merge and set options
/
     setOptions: function (userOptions) {
             this.options = merge(
                     this.defaultOptions,
                     this.isXAxis ? {} : this.defaultYAxisOptions,
                     [this.defaultTopAxisOptions, this.defaultRightAxisOptions,
                             this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
                     merge(
                             defaultOptions[this.coll], // if set in setOptions (#1053)
                             userOptions
                     )
             );
     },

     /**
 The default label formatter. The context is a special config object for the label.
/
     defaultLabelFormatter: function () {
             var axis = this.axis,
                     value = this.value,
                     categories = axis.categories,
                     dateTimeLabelFormat = this.dateTimeLabelFormat,
                     numericSymbols = defaultOptions.lang.numericSymbols,
                     i = numericSymbols &amp;&amp; numericSymbols.length,
                     multi,
                     ret,
                     formatOption = axis.options.labels.format,

                     // make sure the same symbol is added for all labels on a linear axis
                     numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

             if (formatOption) {
                     ret = format(formatOption, this);

             } else if (categories) {
                     ret = value;

             } else if (dateTimeLabelFormat) { // datetime axis
                     ret = dateFormat(dateTimeLabelFormat, value);

             } else if (i &amp;&amp; numericSymbolDetector &gt;= 1000) {
                     // Decide whether we should add a numeric symbol like k (thousands) or M (millions).
                     // If we are to enable this in tooltip or other places as well, we can move this
                     // logic to the numberFormatter and enable it by a parameter.
                     while (i-- &amp;&amp; ret === UNDEFINED) {
                             multi = Math.pow(1000, i + 1);
                             if (numericSymbolDetector &gt;= multi &amp;&amp; numericSymbols[i] !== null) {
                                     ret = numberFormat(value / multi, -1) + numericSymbols[i];
                             }
                     }
             }

             if (ret === UNDEFINED) {
                     if (mathAbs(value) &gt;= 10000) { // add thousands separators
                             ret = numberFormat(value, 0);

                     } else { // small numbers
                             ret = numberFormat(value, -1, UNDEFINED, &#39;&#39;); // #2466
                     }
             }

             return ret;
     },

     /**
 Get the minimum and maximum for the series of each axis
/
     getSeriesExtremes: function () {
             var axis = this,
                     chart = axis.chart;

             axis.hasVisibleSeries = false;

             // Reset properties in case we&#39;re redrawing (#3353)
             axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;

             if (axis.buildStacks) {
                     axis.buildStacks();
             }

             // loop through this axis&#39; series
             each(axis.series, function (series) {

                     if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

                             var seriesOptions = series.options,
                                     xData,
                                     threshold = seriesOptions.threshold,
                                     seriesDataMin,
                                     seriesDataMax;

                             axis.hasVisibleSeries = true;

                             // Validate threshold in logarithmic axes
                             if (axis.isLog &amp;&amp; threshold &lt;= 0) {
                                     threshold = null;
                             }

                             // Get dataMin and dataMax for X axes
                             if (axis.isXAxis) {
                                     xData = series.xData;
                                     if (xData.length) {
                                             axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
                                             axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
                                     }

                             // Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
                             } else {

                                     // Get this particular series extremes
                                     series.getExtremes();
                                     seriesDataMax = series.dataMax;
                                     seriesDataMin = series.dataMin;

                                     // Get the dataMin and dataMax so far. If percentage is used, the min and max are
                                     // always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
                                     // doesn&#39;t have active y data, we continue with nulls
                                     if (defined(seriesDataMin) &amp;&amp; defined(seriesDataMax)) {
                                             axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                                             axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
                                     }

                                     // Adjust to threshold
                                     if (defined(threshold)) {
                                             if (axis.dataMin &gt;= threshold) {
                                                     axis.dataMin = threshold;
                                                     axis.ignoreMinPadding = true;
                                             } else if (axis.dataMax &lt; threshold) {
                                                     axis.dataMax = threshold;
                                                     axis.ignoreMaxPadding = true;
                                             }
                                     }
                             }
                     }
             });
     },

     /**
 Translate from axis value to pixel position on the chart, or back

/
     translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
             var axis = this,
                     sign = 1,
                     cvsOffset = 0,
                     localA = old ? axis.oldTransA : axis.transA,
                     localMin = old ? axis.oldMin : axis.min,
                     returnValue,
                     minPixelPadding = axis.minPixelPadding,
                     postTranslate = (axis.options.ordinal || (axis.isLog &amp;&amp; handleLog)) &amp;&amp; axis.lin2val;

             if (!localA) {
                     localA = axis.transA;
             }

             // In vertical axes, the canvas coordinates start from 0 at the top like in
             // SVG.
             if (cvsCoord) {
                     sign *= -1; // canvas coordinates inverts the value
                     cvsOffset = axis.len;
             }

             // Handle reversed axis
             if (axis.reversed) {
                     sign *= -1;
                     cvsOffset -= sign * (axis.sector || axis.len);
             }

             // From pixels to value
             if (backwards) { // reverse translation

                     val = val * sign + cvsOffset;
                     val -= minPixelPadding;
                     returnValue = val / localA + localMin; // from chart pixel to value
                     if (postTranslate) { // log and ordinal axes
                             returnValue = axis.lin2val(returnValue);
                     }

             // From value to pixels
             } else {
                     if (postTranslate) { // log and ordinal axes
                             val = axis.val2lin(val);
                     }
                     if (pointPlacement === &#39;between&#39;) {
                             pointPlacement = 0.5;
                     }
                     returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
                             (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
             }

             return returnValue;
     },

     /**
 Utility method to translate an axis value to pixel position.
 @param {Number} value A value in terms of axis units
 @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
        or just the axis/pane itself.
/
     toPixels: function (value, paneCoordinates) {
             return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
     },

     /*
 Utility method to translate a pixel position in to an axis value
 @param {Number} pixel The pixel value coordinate
 @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
        axis/pane itself.
/
     toValue: function (pixel, paneCoordinates) {
             return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
     },

     /**
 Create the path for a plot line that goes from the given value on
 this axis, across the plot to the opposite side
 @param {Number} value
 @param {Number} lineWidth Used for calculation crisp line
 @param {Number] old Use old coordinates (for resizing and rescaling)
/
     getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
             var axis = this,
                     chart = axis.chart,
                     axisLeft = axis.left,
                     axisTop = axis.top,
                     x1,
                     y1,
                     x2,
                     y2,
                     cHeight = (old &amp;&amp; chart.oldChartHeight) || chart.chartHeight,
                     cWidth = (old &amp;&amp; chart.oldChartWidth) || chart.chartWidth,
                     skip,
                     transB = axis.transB;

             translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
             x1 = x2 = mathRound(translatedValue + transB);
             y1 = y2 = mathRound(cHeight - translatedValue - transB);

             if (isNaN(translatedValue)) { // no min or max
                     skip = true;

             } else if (axis.horiz) {
                     y1 = axisTop;
                     y2 = cHeight - axis.bottom;
                     if (x1 &lt; axisLeft || x1 &gt; axisLeft + axis.width) {
                             skip = true;
                     }
             } else {
                     x1 = axisLeft;
                     x2 = cWidth - axis.right;

                     if (y1 &lt; axisTop || y1 &gt; axisTop + axis.height) {
                             skip = true;
                     }
             }
             return skip &amp;&amp; !force ?
                     null :
                     chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
     },

     /**
 Set the tick positions of a linear axis to round values like whole tens or every five.
/
     getLinearTickPositions: function (tickInterval, min, max) {
             var pos,
                     lastPos,
                     roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
                     roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
                     tickPositions = [];

             // For single points, add a tick regardless of the relative position (#2662)
             if (min === max &amp;&amp; isNumber(min)) {
                     return [min];
             }

             // Populate the intermediate values
             pos = roundedMin;
             while (pos &lt;= roundedMax) {

                     // Place the tick on the rounded value
                     tickPositions.push(pos);

                     // Always add the raw tickInterval, not the corrected one.
                     pos = correctFloat(pos + tickInterval);

                     // If the interval is not big enough in the current min - max range to actually increase
                     // the loop variable, we need to break out to prevent endless loop. Issue #619
                     if (pos === lastPos) {
                             break;
                     }

                     // Record the last value
                     lastPos = pos;
             }
             return tickPositions;
     },

     /**
 Return the minor tick positions. For logarithmic axes, reuse the same logic
 as for major ticks.
/
     getMinorTickPositions: function () {
             var axis = this,
                     options = axis.options,
                     tickPositions = axis.tickPositions,
                     minorTickInterval = axis.minorTickInterval,
                     minorTickPositions = [],
                     pos,
                     i,
                     len;

             if (axis.isLog) {
                     len = tickPositions.length;
                     for (i = 1; i &lt; len; i++) {
                             minorTickPositions = minorTickPositions.concat(
                                     axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
                             );
                     }
             } else if (axis.isDatetimeAxis &amp;&amp; options.minorTickInterval === &#39;auto&#39;) { // #1314
                     minorTickPositions = minorTickPositions.concat(
                             axis.getTimeTicks(
                                     axis.normalizeTimeTickInterval(minorTickInterval),
                                     axis.min,
                                     axis.max,
                                     options.startOfWeek
                             )
                     );
                     if (minorTickPositions[0] &lt; axis.min) {
                             minorTickPositions.shift();
                     }
             } else {
                     for (pos = axis.min + (tickPositions[0] - axis.min) % minorTickInterval; pos &lt;= axis.max; pos += minorTickInterval) {
                             minorTickPositions.push(pos);
                     }
             }
             return minorTickPositions;
     },

     /**
 Adjust the min and max for the minimum range. Keep in mind that the series data is
 not yet processed, so we don&#39;t have information on data cropping and grouping, or
 updated axis.pointRange or series.pointRange. The data can&#39;t be processed until
 we have finally established min and max.
/
     adjustForMinRange: function () {
             var axis = this,
                     options = axis.options,
                     min = axis.min,
                     max = axis.max,
                     zoomOffset,
                     spaceAvailable = axis.dataMax - axis.dataMin &gt;= axis.minRange,
                     closestDataRange,
                     i,
                     distance,
                     xData,
                     loopLength,
                     minArgs,
                     maxArgs;

             // Set the automatic minimum range based on the closest point distance
             if (axis.isXAxis &amp;&amp; axis.minRange === UNDEFINED &amp;&amp; !axis.isLog) {

                     if (defined(options.min) || defined(options.max)) {
                             axis.minRange = null; // don&#39;t do this again

                     } else {

                             // Find the closest distance between raw data points, as opposed to
                             // closestPointRange that applies to processed points (cropped and grouped)
                             each(axis.series, function (series) {
                                     xData = series.xData;
                                     loopLength = series.xIncrement ? 1 : xData.length - 1;
                                     for (i = loopLength; i &gt; 0; i--) {
                                             distance = xData[i] - xData[i - 1];
                                             if (closestDataRange === UNDEFINED || distance &lt; closestDataRange) {
                                                     closestDataRange = distance;
                                             }
                                     }
                             });
                             axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
                     }
             }

             // if minRange is exceeded, adjust
             if (max - min &lt; axis.minRange) {
                     var minRange = axis.minRange;
                     zoomOffset = (minRange - max + min) / 2;

                     // if min and max options have been set, don&#39;t go beyond it
                     minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
                     if (spaceAvailable) { // if space is available, stay within the data range
                             minArgs[2] = axis.dataMin;
                     }
                     min = arrayMax(minArgs);

                     maxArgs = [min + minRange, pick(options.max, min + minRange)];
                     if (spaceAvailable) { // if space is availabe, stay within the data range
                             maxArgs[2] = axis.dataMax;
                     }

                     max = arrayMin(maxArgs);

                     // now if the max is adjusted, adjust the min back
                     if (max - min &lt; minRange) {
                             minArgs[0] = max - minRange;
                             minArgs[1] = pick(options.min, max - minRange);
                             min = arrayMax(minArgs);
                     }
             }

             // Record modified extremes
             axis.min = min;
             axis.max = max;
     },

     /**
 Update translation information
/
     setAxisTranslation: function (saveOld) {
             var axis = this,
                     range = axis.max - axis.min,
                     pointRange = axis.axisPointRange || 0,
                     closestPointRange,
                     minPointOffset = 0,
                     pointRangePadding = 0,
                     linkedParent = axis.linkedParent,
                     ordinalCorrection,
                     hasCategories = !!axis.categories,
                     transA = axis.transA;

             // Adjust translation for padding. Y axis with categories need to go through the same (#1784).
             if (axis.isXAxis || hasCategories || pointRange) {
                     if (linkedParent) {
                             minPointOffset = linkedParent.minPointOffset;
                             pointRangePadding = linkedParent.pointRangePadding;

                     } else {
                             each(axis.series, function (series) {
                                     var seriesPointRange = hasCategories ? 1 : (axis.isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806
                                             pointPlacement = series.options.pointPlacement,
                                             seriesClosestPointRange = series.closestPointRange;

                                     if (seriesPointRange &gt; range) { // #1446
                                             seriesPointRange = 0;
                                     }
                                     pointRange = mathMax(pointRange, seriesPointRange);

                                     // minPointOffset is the value padding to the left of the axis in order to make
                                     // room for points with a pointRange, typically columns. When the pointPlacement option
                                     // is &#39;between&#39; or &#39;on&#39;, this padding does not apply.
                                     minPointOffset = mathMax(
                                             minPointOffset,
                                             isString(pointPlacement) ? 0 : seriesPointRange / 2
                                     );

                                     // Determine the total padding needed to the length of the axis to make room for the
                                     // pointRange. If the series&#39; pointPlacement is &#39;on&#39;, no padding is added.
                                     pointRangePadding = mathMax(
                                             pointRangePadding,
                                             pointPlacement === &#39;on&#39; ? 0 : seriesPointRange
                                     );

                                     // Set the closestPointRange
                                     if (!series.noSharedTooltip &amp;&amp; defined(seriesClosestPointRange)) {
                                             closestPointRange = defined(closestPointRange) ?
                                                     mathMin(closestPointRange, seriesClosestPointRange) :
                                                     seriesClosestPointRange;
                                     }
                             });
                     }

                     // Record minPointOffset and pointRangePadding
                     ordinalCorrection = axis.ordinalSlope &amp;&amp; closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
                     axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
                     axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

                     // pointRange means the width reserved for each point, like in a column chart
                     axis.pointRange = mathMin(pointRange, range);

                     // closestPointRange means the closest distance between points. In columns
                     // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
                     // is some other value
                     axis.closestPointRange = closestPointRange;
             }

             // Secondary values
             if (saveOld) {
                     axis.oldTransA = transA;
             }
             axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
             axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
             axis.minPixelPadding = transA * minPointOffset;
     },

     /**
 Set the tick positions to round values and optionally extend the extremes
 to the nearest tick
/
     setTickPositions: function (secondPass) {
             var axis = this,
                     chart = axis.chart,
                     options = axis.options,
                     startOnTick = options.startOnTick,
                     endOnTick = options.endOnTick,
                     isLog = axis.isLog,
                     isDatetimeAxis = axis.isDatetimeAxis,
                     isXAxis = axis.isXAxis,
                     isLinked = axis.isLinked,
                     tickPositioner = axis.options.tickPositioner,
                     maxPadding = options.maxPadding,
                     minPadding = options.minPadding,
                     length,
                     linkedParentExtremes,
                     tickIntervalOption = options.tickInterval,
                     minTickIntervalOption = options.minTickInterval,
                     tickPixelIntervalOption = options.tickPixelInterval,
                     tickPositions,
                     keepTwoTicksOnly,
                     categories = axis.categories;

             // linked axis gets the extremes from the parent axis
             if (isLinked) {
                     axis.linkedParent = chart[axis.coll][options.linkedTo];
                     linkedParentExtremes = axis.linkedParent.getExtremes();
                     axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                     axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                     if (options.type !== axis.linkedParent.options.type) {
                             error(11, 1); // Can&#39;t link axes of different type
                     }
             } else { // initial min and max from the extreme data values
                     axis.min = pick(axis.userMin, options.min, axis.dataMin);
                     axis.max = pick(axis.userMax, options.max, axis.dataMax);
             }

             if (isLog) {
                     if (!secondPass &amp;&amp; mathMin(axis.min, pick(axis.dataMin, axis.min)) &lt;= 0) { // #978
                             error(10, 1); // Can&#39;t plot negative values on log axis
                     }
                     axis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934
                     axis.max = correctFloat(log2lin(axis.max));
             }

             // handle zoomed range
             if (axis.range &amp;&amp; defined(axis.max)) {
                     axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618
                     axis.userMax = axis.max;

                     axis.range = null;  // don&#39;t use it when running setExtremes
             }

             // Hook for adjusting this.min and this.max. Used by bubble series.
             if (axis.beforePadding) {
                     axis.beforePadding();
             }

             // adjust min and max for the minimum range
             axis.adjustForMinRange();

             // Pad the values to get clear of the chart&#39;s edges. To avoid tickInterval taking the padding
             // into account, we do this after computing tick interval (#1337).
             if (!categories &amp;&amp; !axis.axisPointRange &amp;&amp; !axis.usePercentage &amp;&amp; !isLinked &amp;&amp; defined(axis.min) &amp;&amp; defined(axis.max)) {
                     length = axis.max - axis.min;
                     if (length) {
                             if (!defined(options.min) &amp;&amp; !defined(axis.userMin) &amp;&amp; minPadding &amp;&amp; (axis.dataMin &lt; 0 || !axis.ignoreMinPadding)) {
                                     axis.min -= length * minPadding;
                             }
                             if (!defined(options.max) &amp;&amp; !defined(axis.userMax)  &amp;&amp; maxPadding &amp;&amp; (axis.dataMax &gt; 0 || !axis.ignoreMaxPadding)) {
                                     axis.max += length * maxPadding;
                             }
                     }
             }

             // Stay within floor and ceiling
             if (isNumber(options.floor)) {
                     axis.min = mathMax(axis.min, options.floor);
             }
             if (isNumber(options.ceiling)) {
                     axis.max = mathMin(axis.max, options.ceiling);
             }

             // get tickInterval
             if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
                     axis.tickInterval = 1;
             } else if (isLinked &amp;&amp; !tickIntervalOption &amp;&amp;
                             tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
                     axis.tickInterval = axis.linkedParent.tickInterval;
             } else {
                     axis.tickInterval = pick(
                             tickIntervalOption,
                             categories ? // for categoried axis, 1 is default, for linear axis use tickPix
                                     1 :
                                     // don&#39;t let it be more than the data range
                                     (axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
                     );
                     // For squished axes, set only two ticks
                     if (!defined(tickIntervalOption) &amp;&amp; axis.len &lt; tickPixelIntervalOption &amp;&amp; !this.isRadial &amp;&amp;
                                     !this.isLog &amp;&amp; !categories &amp;&amp; startOnTick &amp;&amp; endOnTick) {
                             keepTwoTicksOnly = true;
                             axis.tickInterval /= 4; // tick extremes closer to the real values
                     }
             }

             // Now we&#39;re finished detecting min and max, crop and group series data. This
             // is in turn needed in order to find tick positions in ordinal axes.
             if (isXAxis &amp;&amp; !secondPass) {
                     each(axis.series, function (series) {
                             series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
                     });
             }

             // set the translation factor used in translate function
             axis.setAxisTranslation(true);

             // hook for ordinal axes and radial axes
             if (axis.beforeSetTickPositions) {
                     axis.beforeSetTickPositions();
             }

             // hook for extensions, used in Highstock ordinal axes
             if (axis.postProcessTickInterval) {
                     axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
             }

             // In column-like charts, don&#39;t cramp in more ticks than there are points (#1943)
             if (axis.pointRange) {
                     axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
             }

             // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
             if (!tickIntervalOption &amp;&amp; axis.tickInterval &lt; minTickIntervalOption) {
                     axis.tickInterval = minTickIntervalOption;
             }

             // for linear axes, get magnitude and normalize the interval
             if (!isDatetimeAxis &amp;&amp; !isLog) { // linear
                     if (!tickIntervalOption) {
                             axis.tickInterval = normalizeTickInterval(
                                     axis.tickInterval, 
                                     null, 
                                     getMagnitude(axis.tickInterval), 
                                     // If the tick interval is between 1 and 5 and the axis max is in the order of
                                     // thousands, chances are we are dealing with years. Don&#39;t allow decimals. #3363.
                                     pick(options.allowDecimals, !(axis.tickInterval &gt; 1 &amp;&amp; axis.tickInterval &lt; 5 &amp;&amp; axis.max &gt; 1000 &amp;&amp; axis.max &lt; 9999))
                             );
                     }
             }

             // get minorTickInterval
             axis.minorTickInterval = options.minorTickInterval === &#39;auto&#39; &amp;&amp; axis.tickInterval ?
                             axis.tickInterval / 5 : options.minorTickInterval;

             // find the tick positions
             axis.tickPositions = tickPositions = options.tickPositions ?
                     [].concat(options.tickPositions) : // Work on a copy (#1565)
                     (tickPositioner &amp;&amp; tickPositioner.apply(axis, [axis.min, axis.max]));
             if (!tickPositions) {

                     // Too many ticks
                     if (!axis.ordinalPositions &amp;&amp; (axis.max - axis.min) / axis.tickInterval &gt; mathMax(2 * axis.len, 200)) {
                             error(19, true);
                     }

                     if (isDatetimeAxis) {
                             tickPositions = axis.getTimeTicks(
                                     axis.normalizeTimeTickInterval(axis.tickInterval, options.units),
                                     axis.min,
                                     axis.max,
                                     options.startOfWeek,
                                     axis.ordinalPositions,
                                     axis.closestPointRange,
                                     true
                             );
                     } else if (isLog) {
                             tickPositions = axis.getLogTickPositions(axis.tickInterval, axis.min, axis.max);
                     } else {
                             tickPositions = axis.getLinearTickPositions(axis.tickInterval, axis.min, axis.max);
                     }

                     if (keepTwoTicksOnly) {
                             tickPositions.splice(1, tickPositions.length - 2);
                     }

                     axis.tickPositions = tickPositions;
             }

             if (!isLinked) {

                     // reset min/max or remove extremes based on start/end on tick
                     var roundedMin = tickPositions[0],
                             roundedMax = tickPositions[tickPositions.length - 1],
                             minPointOffset = axis.minPointOffset || 0,
                             singlePad;

                     if (startOnTick) {
                             axis.min = roundedMin;
                     } else if (axis.min - minPointOffset &gt; roundedMin) {
                             tickPositions.shift();
                     }

                     if (endOnTick) {
                             axis.max = roundedMax;
                     } else if (axis.max + minPointOffset &lt; roundedMax) {
                             tickPositions.pop();
                     }

                     // If no tick are left, set one tick in the middle (#3195) 
                     if (tickPositions.length === 0 &amp;&amp; defined(roundedMin)) {
                             tickPositions.push((roundedMax + roundedMin) / 2);
                     }

                     // When there is only one point, or all points have the same value on this axis, then min
                     // and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
                     // in order to center the point, but leave it with one tick. #1337.
                     if (tickPositions.length === 1) {
                             singlePad = mathAbs(axis.max) &gt; 10e12 ? 1 : 0.001; // The lowest possible number to avoid extra padding on columns (#2619, #2846)
                             axis.min -= singlePad;
                             axis.max += singlePad;
                     }
             }
     },

     /**
 Set the max ticks of either the x and y axis collection
/
     setMaxTicks: function () {

             var chart = this.chart,
                     maxTicks = chart.maxTicks || {},
                     tickPositions = this.tickPositions,
                     key = this._maxTicksKey = [this.coll, this.pos, this.len].join(&#39;-&#39;);

             if (!this.isLinked &amp;&amp; !this.isDatetimeAxis &amp;&amp; tickPositions &amp;&amp; tickPositions.length &gt; (maxTicks[key] || 0) &amp;&amp; this.options.alignTicks !== false) {
                     maxTicks[key] = tickPositions.length;
             }
             chart.maxTicks = maxTicks;
     },

     /**
 When using multiple axes, adjust the number of ticks to match the highest
 number of ticks in that group
/
     adjustTickAmount: function () {
             var axis = this,
                     chart = axis.chart,
                     key = axis._maxTicksKey,
                     tickPositions = axis.tickPositions,
                     maxTicks = chart.maxTicks;

             if (maxTicks &amp;&amp; maxTicks[key] &amp;&amp; !axis.isDatetimeAxis &amp;&amp; !axis.categories &amp;&amp; !axis.isLinked &amp;&amp;
                             axis.options.alignTicks !== false &amp;&amp; this.min !== UNDEFINED) {
                     var oldTickAmount = axis.tickAmount,
                             calculatedTickAmount = tickPositions.length,
                             tickAmount;

                     // set the axis-level tickAmount to use below
                     axis.tickAmount = tickAmount = maxTicks[key];

                     if (calculatedTickAmount &lt; tickAmount) {
                             while (tickPositions.length &lt; tickAmount) {
                                     tickPositions.push(correctFloat(
                                             tickPositions[tickPositions.length - 1] + axis.tickInterval
                                     ));
                             }
                             axis.transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
                             axis.max = tickPositions[tickPositions.length - 1];

                     }
                     if (defined(oldTickAmount) &amp;&amp; tickAmount !== oldTickAmount) {
                             axis.isDirty = true;
                     }
             }
     },

     /**
 Set the scale based on data min and max, user set min and max or options

/
     setScale: function () {
             var axis = this,
                     stacks = axis.stacks,
                     type,
                     i,
                     isDirtyData,
                     isDirtyAxisLength;

             axis.oldMin = axis.min;
             axis.oldMax = axis.max;
             axis.oldAxisLength = axis.len;

             // set the new axisLength
             axis.setAxisSize();
             //axisLength = horiz ? axisWidth : axisHeight;
             isDirtyAxisLength = axis.len !== axis.oldAxisLength;

             // is there new data?
             each(axis.series, function (series) {
                     if (series.isDirtyData || series.isDirty ||
                                     series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
                             isDirtyData = true;
                     }
             });

             // do we really need to go through all this?
             if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
                     axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {

                     // reset stacks
                     if (!axis.isXAxis) {
                             for (type in stacks) {
                                     for (i in stacks[type]) {
                                             stacks[type][i].total = null;
                                             stacks[type][i].cum = 0;
                                     }
                             }
                     }

                     axis.forceRedraw = false;

                     // get data extremes if needed
                     axis.getSeriesExtremes();

                     // get fixed positions based on tickInterval
                     axis.setTickPositions();

                     // record old values to decide whether a rescale is necessary later on (#540)
                     axis.oldUserMin = axis.userMin;
                     axis.oldUserMax = axis.userMax;

                     // Mark as dirty if it is not already set to dirty and extremes have changed. #595.
                     if (!axis.isDirty) {
                             axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
                     }
             } else if (!axis.isXAxis) {
                     if (axis.oldStacks) {
                             stacks = axis.stacks = axis.oldStacks;
                     }

                     // reset stacks
                     for (type in stacks) {
                             for (i in stacks[type]) {
                                     stacks[type][i].cum = stacks[type][i].total;
                             }
                     }
             }

             // Set the maximum tick amount
             axis.setMaxTicks();
     },

     /**
 Set the extremes and optionally redraw
 @param {Number} newMin
 @param {Number} newMax
 @param {Boolean} redraw
 @param {Boolean|Object} animation Whether to apply animation, and optionally animation
    configuration
 @param {Object} eventArguments

/
     setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
             var axis = this,
                     chart = axis.chart;

             redraw = pick(redraw, true); // defaults to true

             // Extend the arguments with min and max
             eventArguments = extend(eventArguments, {
                     min: newMin,
                     max: newMax
             });

             // Fire the event
             fireEvent(axis, &#39;setExtremes&#39;, eventArguments, function () { // the default event handler

                     axis.userMin = newMin;
                     axis.userMax = newMax;
                     axis.eventArgs = eventArguments;

                     // Mark for running afterSetExtremes
                     axis.isDirtyExtremes = true;

                     // redraw
                     if (redraw) {
                             chart.redraw(animation);
                     }
             });
     },

     /**
 Overridable method for zooming chart. Pulled out in a separate method to allow overriding
 in stock charts.
/
     zoom: function (newMin, newMax) {
             var dataMin = this.dataMin,
                     dataMax = this.dataMax,
                     options = this.options;

             // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
             if (!this.allowZoomOutside) {
                     if (defined(dataMin) &amp;&amp; newMin &lt;= mathMin(dataMin, pick(options.min, dataMin))) {
                             newMin = UNDEFINED;
                     }
                     if (defined(dataMax) &amp;&amp; newMax &gt;= mathMax(dataMax, pick(options.max, dataMax))) {
                             newMax = UNDEFINED;
                     }
             }

             // In full view, displaying the reset zoom button is not required
             this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

             // Do it
             this.setExtremes(
                     newMin,
                     newMax,
                     false,
                     UNDEFINED,
                     { trigger: &#39;zoom&#39; }
             );
             return true;
     },

     /**
 Update the axis metrics
/
     setAxisSize: function () {
             var chart = this.chart,
                     options = this.options,
                     offsetLeft = options.offsetLeft || 0,
                     offsetRight = options.offsetRight || 0,
                     horiz = this.horiz,
                     width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
                     height = pick(options.height, chart.plotHeight),
                     top = pick(options.top, chart.plotTop),
                     left = pick(options.left, chart.plotLeft + offsetLeft),
                     percentRegex = /%$/;

             // Check for percentage based input values
             if (percentRegex.test(height)) {
                     height = parseInt(height, 10) / 100 * chart.plotHeight;
             }
             if (percentRegex.test(top)) {
                     top = parseInt(top, 10) / 100 * chart.plotHeight + chart.plotTop;
             }

             // Expose basic values to use in Series object and navigator
             this.left = left;
             this.top = top;
             this.width = width;
             this.height = height;
             this.bottom = chart.chartHeight - height - top;
             this.right = chart.chartWidth - width - left;

             // Direction agnostic properties
             this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
             this.pos = horiz ? left : top; // distance from SVG origin
     },

     /**
 Get the actual axis extremes
/
     getExtremes: function () {
             var axis = this,
                     isLog = axis.isLog;

             return {
                     min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
                     max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
                     dataMin: axis.dataMin,
                     dataMax: axis.dataMax,
                     userMin: axis.userMin,
                     userMax: axis.userMax
             };
     },

     /**
 Get the zero plane either based on zero or on the min or max value.
 Used in bar and area plots
/
     getThreshold: function (threshold) {
             var axis = this,
                     isLog = axis.isLog;

             var realMin = isLog ? lin2log(axis.min) : axis.min,
                     realMax = isLog ? lin2log(axis.max) : axis.max;

             if (realMin &gt; threshold || threshold === null) {
                     threshold = realMin;
             } else if (realMax &lt; threshold) {
                     threshold = realMax;
             }

             return axis.translate(threshold, 0, 1, 0, 1);
     },

     /**
 Compute auto alignment for the axis label based on which side the axis is on
 and the given rotation for the label
/
     autoLabelAlign: function (rotation) {
             var ret,
                     angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

             if (angle &gt; 15 &amp;&amp; angle &lt; 165) {
                     ret = &#39;right&#39;;
             } else if (angle &gt; 195 &amp;&amp; angle &lt; 345) {
                     ret = &#39;left&#39;;
             } else {
                     ret = &#39;center&#39;;
             }
             return ret;
     },

     /**
 Render the tick labels to a preliminary position to get their sizes
/
     getOffset: function () {
             var axis = this,
                     chart = axis.chart,
                     renderer = chart.renderer,
                     options = axis.options,
                     tickPositions = axis.tickPositions,
                     ticks = axis.ticks,
                     horiz = axis.horiz,
                     side = axis.side,
                     invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
                     hasData,
                     showAxis,
                     titleOffset = 0,
                     titleOffsetOption,
                     titleMargin = 0,
                     axisTitleOptions = options.title,
                     labelOptions = options.labels,
                     labelOffset = 0, // reset
                     labelOffsetPadded,
                     axisOffset = chart.axisOffset,
                     clipOffset = chart.clipOffset,
                     directionFactor = [-1, 1, 1, -1][side],
                     n,
                     i,
                     autoStaggerLines = 1,
                     maxStaggerLines = pick(labelOptions.maxStaggerLines, 5),
                     sortedPositions,
                     lastRight,
                     overlap,
                     pos,
                     bBox,
                     x,
                     w,
                     lineNo,
                     lineHeightCorrection;

             // For reuse in Axis.render
             axis.hasData = hasData = (axis.hasVisibleSeries || (defined(axis.min) &amp;&amp; defined(axis.max) &amp;&amp; !!tickPositions));
             axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

             // Set/reset staggerLines
             axis.staggerLines = axis.horiz &amp;&amp; labelOptions.staggerLines;

             // Create the axisGroup and gridGroup elements on first iteration
             if (!axis.axisGroup) {
                     axis.gridGroup = renderer.g(&#39;grid&#39;)
                             .attr({ zIndex: options.gridZIndex || 1 })
                             .add();
                     axis.axisGroup = renderer.g(&#39;axis&#39;)
                             .attr({ zIndex: options.zIndex || 2 })
                             .add();
                     axis.labelGroup = renderer.g(&#39;axis-labels&#39;)
                             .attr({ zIndex: labelOptions.zIndex || 7 })
                             .addClass(PREFIX + axis.coll.toLowerCase() + &#39;-labels&#39;)
                             .add();
             }

             if (hasData || axis.isLinked) {

                     // Set the explicit or automatic label alignment
                     axis.labelAlign = pick(labelOptions.align || axis.autoLabelAlign(labelOptions.rotation));

                     // Generate ticks
                     each(tickPositions, function (pos) {
                             if (!ticks[pos]) {
                                     ticks[pos] = new Tick(axis, pos);
                             } else {
                                     ticks[pos].addLabel(); // update labels depending on tick interval
                             }
                     });

                     // Handle automatic stagger lines
                     if (axis.horiz &amp;&amp; !axis.staggerLines &amp;&amp; maxStaggerLines &amp;&amp; !labelOptions.rotation) {
                             sortedPositions = axis.reversed ? [].concat(tickPositions).reverse() : tickPositions;
                             while (autoStaggerLines &lt; maxStaggerLines) {
                                     lastRight = [];
                                     overlap = false;

                                     for (i = 0; i &lt; sortedPositions.length; i++) {
                                             pos = sortedPositions[i];
                                             bBox = ticks[pos].label &amp;&amp; ticks[pos].label.getBBox();
                                             w = bBox ? bBox.width : 0;
                                             lineNo = i % autoStaggerLines;

                                             if (w) {
                                                     x = axis.translate(pos); // don&#39;t handle log
                                                     if (lastRight[lineNo] !== UNDEFINED &amp;&amp; x &lt; lastRight[lineNo]) {
                                                             overlap = true;
                                                     }
                                                     lastRight[lineNo] = x + w;
                                             }
                                     }
                                     if (overlap) {
                                             autoStaggerLines++;
                                     } else {
                                             break;
                                     }
                             }

                             if (autoStaggerLines &gt; 1) {
                                     axis.staggerLines = autoStaggerLines;
                             }
                     }

                     each(tickPositions, function (pos) {
                             // left side must be align: right and right side must have align: left for labels
                             if (side === 0 || side === 2 || { 1: &#39;left&#39;, 3: &#39;right&#39; }[side] === axis.labelAlign) {

                                     // get the highest offset
                                     labelOffset = mathMax(
                                             ticks[pos].getLabelSize(),
                                             labelOffset
                                     );
                             }
                     });

                     if (axis.staggerLines) {
                             labelOffset *= axis.staggerLines;
                             axis.labelOffset = labelOffset;
                     }

             } else { // doesn&#39;t have data
                     for (n in ticks) {
                             ticks[n].destroy();
                             delete ticks[n];
                     }
             }

             if (axisTitleOptions &amp;&amp; axisTitleOptions.text &amp;&amp; axisTitleOptions.enabled !== false) {
                     if (!axis.axisTitle) {
                             axis.axisTitle = renderer.text(
                                     axisTitleOptions.text,
                                     0,
                                     0,
                                     axisTitleOptions.useHTML
                             )
                             .attr({
                                     zIndex: 7,
                                     rotation: axisTitleOptions.rotation || 0,
                                     align:
                                             axisTitleOptions.textAlign ||
                                             { low: &#39;left&#39;, middle: &#39;center&#39;, high: &#39;right&#39; }[axisTitleOptions.align]
                             })
                             .addClass(PREFIX + this.coll.toLowerCase() + &#39;-title&#39;)
                             .css(axisTitleOptions.style)
                             .add(axis.axisGroup);
                             axis.axisTitle.isNew = true;
                     }

                     if (showAxis) {
                             titleOffset = axis.axisTitle.getBBox()[horiz ? &#39;height&#39; : &#39;width&#39;];
                             titleOffsetOption = axisTitleOptions.offset;
                             titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
                     }

                     // hide or show the title depending on whether showEmpty is set
                     axis.axisTitle[showAxis ? &#39;show&#39; : &#39;hide&#39;]();
             }

             // handle automatic or user set offset
             axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

             lineHeightCorrection = side === 2 ? axis.tickBaseline : 0;
             labelOffsetPadded = labelOffset + titleMargin +
                     (labelOffset &amp;&amp; (directionFactor * (horiz ? pick(labelOptions.y, axis.tickBaseline + 8) : labelOptions.x) - lineHeightCorrection));
             axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

             axisOffset[side] = mathMax(
                     axisOffset[side],
                     axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
                     labelOffsetPadded // #3027
             );
             clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);
     },

     /**
 Get the path for the axis line
/
     getLinePath: function (lineWidth) {
             var chart = this.chart,
                     opposite = this.opposite,
                     offset = this.offset,
                     horiz = this.horiz,
                     lineLeft = this.left + (opposite ? this.width : 0) + offset,
                     lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

             if (opposite) {
                     lineWidth *= -1; // crispify the other way - #1480, #1687
             }

             return chart.renderer.crispLine([
                             M,
                             horiz ?
                                     this.left :
                                     lineLeft,
                             horiz ?
                                     lineTop :
                                     this.top,
                             L,
                             horiz ?
                                     chart.chartWidth - this.right :
                                     lineLeft,
                             horiz ?
                                     lineTop :
                                     chart.chartHeight - this.bottom
                     ], lineWidth);
     },

     /**
 Position the title
/
     getTitlePosition: function () {
             // compute anchor points for each of the title align options
             var horiz = this.horiz,
                     axisLeft = this.left,
                     axisTop = this.top,
                     axisLength = this.len,
                     axisTitleOptions = this.options.title,
                     margin = horiz ? axisLeft : axisTop,
                     opposite = this.opposite,
                     offset = this.offset,
                     fontSize = pInt(axisTitleOptions.style.fontSize || 12),

                     // the position in the length direction of the axis
                     alongAxis = {
                             low: margin + (horiz ? 0 : axisLength),
                             middle: margin + axisLength / 2,
                             high: margin + (horiz ? axisLength : 0)
                     }[axisTitleOptions.align],

                     // the position in the perpendicular direction of the axis
                     offAxis = (horiz ? axisTop + this.height : axisLeft) +
                             (horiz ? 1 : -1) * // horizontal axis reverses the margin
                             (opposite ? -1 : 1) * // so does opposite axes
                             this.axisTitleMargin +
                             (this.side === 2 ? fontSize : 0);

             return {
                     x: horiz ?
                             alongAxis :
                             offAxis + (opposite ? this.width : 0) + offset +
                                     (axisTitleOptions.x || 0), // x
                     y: horiz ?
                             offAxis - (opposite ? this.height : 0) + offset :
                             alongAxis + (axisTitleOptions.y || 0) // y
             };
     },

     /**
 Render the axis
/
     render: function () {
             var axis = this,
                     horiz = axis.horiz,
                     reversed = axis.reversed,
                     chart = axis.chart,
                     renderer = chart.renderer,
                     options = axis.options,
                     isLog = axis.isLog,
                     isLinked = axis.isLinked,
                     tickPositions = axis.tickPositions,
                     sortedPositions,
                     axisTitle = axis.axisTitle,                     
                     ticks = axis.ticks,
                     minorTicks = axis.minorTicks,
                     alternateBands = axis.alternateBands,
                     stackLabelOptions = options.stackLabels,
                     alternateGridColor = options.alternateGridColor,
                     tickmarkOffset = axis.tickmarkOffset,
                     lineWidth = options.lineWidth,
                     linePath,
                     hasRendered = chart.hasRendered,
                     slideInTicks = hasRendered &amp;&amp; defined(axis.oldMin) &amp;&amp; !isNaN(axis.oldMin),
                     hasData = axis.hasData,
                     showAxis = axis.showAxis,
                     from,
                     overflow = options.labels.overflow,
                     justifyLabels = axis.justifyLabels = horiz &amp;&amp; overflow !== false,
                     to;

             // Reset
             axis.labelEdge.length = 0;
             axis.justifyToPlot = overflow === &#39;justify&#39;;

             // Mark all elements inActive before we go over and mark the active ones
             each([ticks, minorTicks, alternateBands], function (coll) {
                     var pos;
                     for (pos in coll) {
                             coll[pos].isActive = false;
                     }
             });

             // If the series has data draw the ticks. Else only the line and title
             if (hasData || isLinked) {

                     // minor ticks
                     if (axis.minorTickInterval &amp;&amp; !axis.categories) {
                             each(axis.getMinorTickPositions(), function (pos) {
                                     if (!minorTicks[pos]) {
                                             minorTicks[pos] = new Tick(axis, pos, &#39;minor&#39;);
                                     }

                                     // render new ticks in old position
                                     if (slideInTicks &amp;&amp; minorTicks[pos].isNew) {
                                             minorTicks[pos].render(null, true);
                                     }

                                     minorTicks[pos].render(null, false, 1);
                             });
                     }

                     // Major ticks. Pull out the first item and render it last so that
                     // we can get the position of the neighbour label. #808.
                     if (tickPositions.length) { // #1300
                             sortedPositions = tickPositions.slice();
                             if ((horiz &amp;&amp; reversed) || (!horiz &amp;&amp; !reversed)) {
                                     sortedPositions.reverse();
                             }
                             if (justifyLabels) {
                                     sortedPositions = sortedPositions.slice(1).concat([sortedPositions[0]]);
                             }
                             each(sortedPositions, function (pos, i) {

                                     // Reorganize the indices
                                     if (justifyLabels) {
                                             i = (i === sortedPositions.length - 1) ? 0 : i + 1;
                                     }

                                     // linked axes need an extra check to find out if
                                     if (!isLinked || (pos &gt;= axis.min &amp;&amp; pos &lt;= axis.max)) {

                                             if (!ticks[pos]) {
                                                     ticks[pos] = new Tick(axis, pos);
                                             }

                                             // render new ticks in old position
                                             if (slideInTicks &amp;&amp; ticks[pos].isNew) {
                                                     ticks[pos].render(i, true, 0.1);
                                             }

                                             ticks[pos].render(i);
                                     }

                             });
                             // In a categorized axis, the tick marks are displayed between labels. So
                             // we need to add a tick mark and grid line at the left edge of the X axis.
                             if (tickmarkOffset &amp;&amp; axis.min === 0) {
                                     if (!ticks[-1]) {
                                             ticks[-1] = new Tick(axis, -1, null, true);
                                     }
                                     ticks[-1].render(-1);
                             }

                     }

                     // alternate grid color
                     if (alternateGridColor) {
                             each(tickPositions, function (pos, i) {
                                     if (i % 2 === 0 &amp;&amp; pos &lt; axis.max) {
                                             if (!alternateBands[pos]) {
                                                     alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
                                             }
                                             from = pos + tickmarkOffset; // #949
                                             to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
                                             alternateBands[pos].options = {
                                                     from: isLog ? lin2log(from) : from,
                                                     to: isLog ? lin2log(to) : to,
                                                     color: alternateGridColor
                                             };
                                             alternateBands[pos].render();
                                             alternateBands[pos].isActive = true;
                                     }
                             });
                     }

                     // custom plot lines and bands
                     if (!axis._addedPlotLB) { // only first time
                             each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
                                     axis.addPlotBandOrLine(plotLineOptions);
                             });
                             axis._addedPlotLB = true;
                     }

             } // end if hasData

             // Remove inactive ticks
             each([ticks, minorTicks, alternateBands], function (coll) {
                     var pos,
                             i,
                             forDestruction = [],
                             delay = globalAnimation ? globalAnimation.duration || 500 : 0,
                             destroyInactiveItems = function () {
                                     i = forDestruction.length;
                                     while (i--) {
                                             // When resizing rapidly, the same items may be destroyed in different timeouts,
                                             // or the may be reactivated
                                             if (coll[forDestruction[i]] &amp;&amp; !coll[forDestruction[i]].isActive) {
                                                     coll[forDestruction[i]].destroy();
                                                     delete coll[forDestruction[i]];
                                             }
                                     }

                             };

                     for (pos in coll) {

                             if (!coll[pos].isActive) {
                                     // Render to zero opacity
                                     coll[pos].render(pos, false, 0);
                                     coll[pos].isActive = false;
                                     forDestruction.push(pos);
                             }
                     }

                     // When the objects are finished fading out, destroy them
                     if (coll === alternateBands || !chart.hasRendered || !delay) {
                             destroyInactiveItems();
                     } else if (delay) {
                             setTimeout(destroyInactiveItems, delay);
                     }
             });

             // Static items. As the axis group is cleared on subsequent calls
             // to render, these items are added outside the group.
             // axis line
             if (lineWidth) {
                     linePath = axis.getLinePath(lineWidth);
                     if (!axis.axisLine) {
                             axis.axisLine = renderer.path(linePath)
                                     .attr({
                                             stroke: options.lineColor,
                                             &#39;stroke-width&#39;: lineWidth,
                                             zIndex: 7
                                     })
                                     .add(axis.axisGroup);
                     } else {
                             axis.axisLine.animate({ d: linePath });
                     }

                     // show or hide the line depending on options.showEmpty
                     axis.axisLine[showAxis ? &#39;show&#39; : &#39;hide&#39;]();
             }

             if (axisTitle &amp;&amp; showAxis) {

                     axisTitle[axisTitle.isNew ? &#39;attr&#39; : &#39;animate&#39;](
                             axis.getTitlePosition()
                     );
                     axisTitle.isNew = false;
             }

             // Stacked totals:
             if (stackLabelOptions &amp;&amp; stackLabelOptions.enabled) {
                     axis.renderStackTotals();
             }
             // End stacked totals

             axis.isDirty = false;
     },

     /**
 Redraw the axis to reflect changes in the data or axis extremes
/
     redraw: function () {

             // render the axis
             this.render();

             // move plot lines and bands
             each(this.plotLinesAndBands, function (plotLine) {
                     plotLine.render();
             });

             // mark associated series as dirty and ready for redraw
             each(this.series, function (series) {
                     series.isDirty = true;
             });

     },

     /**
 Destroys an Axis instance.
/
     destroy: function (keepEvents) {
             var axis = this,
                     stacks = axis.stacks,
                     stackKey,
                     plotLinesAndBands = axis.plotLinesAndBands,
                     i;

             // Remove the events
             if (!keepEvents) {
                     removeEvent(axis);
             }

             // Destroy each stack total
             for (stackKey in stacks) {
                     destroyObjectProperties(stacks[stackKey]);

                     stacks[stackKey] = null;
             }

             // Destroy collections
             each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
                     destroyObjectProperties(coll);
             });
             i = plotLinesAndBands.length;
             while (i--) { // #1975
                     plotLinesAndBands[i].destroy();
             }

             // Destroy local variables
             each([&#39;stackTotalGroup&#39;, &#39;axisLine&#39;, &#39;axisTitle&#39;, &#39;axisGroup&#39;, &#39;cross&#39;, &#39;gridGroup&#39;, &#39;labelGroup&#39;], function (prop) {
                     if (axis[prop]) {
                             axis[prop] = axis[prop].destroy();
                     }
             });

             // Destroy crosshair
             if (this.cross) {
                     this.cross.destroy();
             }
     },

     /**
 Draw the crosshair
/
     drawCrosshair: function (e, point) {
             if (!this.crosshair) { return; }// Do not draw crosshairs if you don&#39;t have too.

             if ((defined(point) || !pick(this.crosshair.snap, true)) === false) {
                     this.hideCrosshair();
                     return;
             }

             var path,
                     options = this.crosshair,
                     animation = options.animation,
                     pos;

             // Get the path
             if (!pick(options.snap, true)) {
                     pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
             } else if (defined(point)) {
                     /*jslint eqeq: true*/
                     pos = (this.chart.inverted != this.horiz) ? point.plotX : this.len - point.plotY;
                     /*jslint eqeq: false*/
             }

             if (this.isRadial) {
                     path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y));
             } else {
                     path = this.getPlotLinePath(null, null, null, null, pos);
             }

             if (path === null) {
                     this.hideCrosshair();
                     return;
             }

             // Draw the cross
             if (this.cross) {
                     this.cross
                             .attr({ visibility: VISIBLE })[animation ? &#39;animate&#39; : &#39;attr&#39;]({ d: path }, animation);
             } else {
                     var attribs = {
                             &#39;stroke-width&#39;: options.width || 1,
                             stroke: options.color || &#39;#C0C0C0&#39;,
                             zIndex: options.zIndex || 2
                     };
                     if (options.dashStyle) {
                             attribs.dashstyle = options.dashStyle;
                     }
                     this.cross = this.chart.renderer.path(path).attr(attribs).add();
             }
     },

     /**
     Hide the crosshair.
/
     hideCrosshair: function () {
             if (this.cross) {
                     this.cross.hide();
             }
     }</pre>

<p>}; // end Axis</p>

<p>extend(Axis.prototype, AxisPlotLineOrBandExtension);</p>

<p>/**</p>

<pre> Set the tick positions to a time unit that makes sense, for example
 on the first of each month or on every Monday. Return an array
 with the time positions. Used in datetime axes as well as for grouping
 data on a datetime axis.

 @param {Object} normalizedInterval The interval in axis values (ms) and the count
 @param {Number} min The minimum in axis values
 @param {Number} max The maximum in axis values
 @param {Number} startOfWeek
/</pre>

<p>Axis.prototype.getTimeTicks = function (normalizedInterval, min, max,
startOfWeek) {</p>

<pre>var tickPositions = [],
        i,
        higherRanks = {},
        useUTC = defaultOptions.global.useUTC,
        minYear, // used in months and years as a basis for Date.UTC()
        minDate = new Date(min - timezoneOffset),
        interval = normalizedInterval.unitRange,
        count = normalizedInterval.count;

if (defined(min)) { // #1300
        if (interval &gt;= timeUnits.second) { // second
                minDate.setMilliseconds(0);
                minDate.setSeconds(interval &gt;= timeUnits.minute ? 0 :
                        count * mathFloor(minDate.getSeconds() / count));
        }

        if (interval &gt;= timeUnits.minute) { // minute
                minDate[setMinutes](interval &gt;= timeUnits.hour ? 0 :
                        count * mathFloor(minDate[getMinutes]() / count));
        }

        if (interval &gt;= timeUnits.hour) { // hour
                minDate[setHours](interval &gt;= timeUnits.day ? 0 :
                        count * mathFloor(minDate[getHours]() / count));
        }

        if (interval &gt;= timeUnits.day) { // day
                minDate[setDate](interval &gt;= timeUnits.month ? 1 :
                        count * mathFloor(minDate[getDate]() / count));
        }

        if (interval &gt;= timeUnits.month) { // month
                minDate[setMonth](interval &gt;= timeUnits.year ? 0 :
                        count * mathFloor(minDate[getMonth]() / count));
                minYear = minDate[getFullYear]();
        }

        if (interval &gt;= timeUnits.year) { // year
                minYear -= minYear % count;
                minDate[setFullYear](minYear);
        }

        // week is a special case that runs outside the hierarchy
        if (interval === timeUnits.week) {
                // get start of current week, independent of count
                minDate[setDate](minDate[getDate]() - minDate[getDay]() +
                        pick(startOfWeek, 1));
        }

        // get tick positions
        i = 1;
        if (timezoneOffset) {
                minDate = new Date(minDate.getTime() + timezoneOffset);
        }
        minYear = minDate[getFullYear]();
        var time = minDate.getTime(),
                minMonth = minDate[getMonth](),
                minDateDate = minDate[getDate](),
                localTimezoneOffset = (timeUnits.day + 
                                (useUTC ? timezoneOffset : minDate.getTimezoneOffset() * 60 * 1000)
                        ) % timeUnits.day; // #950, #3359

        // iterate and add tick positions at appropriate values
        while (time &lt; max) {
                tickPositions.push(time);

                // if the interval is years, use Date.UTC to increase years
                if (interval === timeUnits.year) {
                        time = makeTime(minYear + i * count, 0);

                // if the interval is months, use Date.UTC to increase months
                } else if (interval === timeUnits.month) {
                        time = makeTime(minYear, minMonth + i * count);

                // if we&#39;re using global time, the interval is not fixed as it jumps
                // one hour at the DST crossover
                } else if (!useUTC &amp;&amp; (interval === timeUnits.day || interval === timeUnits.week)) {
                        time = makeTime(minYear, minMonth, minDateDate +
                                i * count * (interval === timeUnits.day ? 1 : 7));

                // else, the interval is fixed and we use simple addition
                } else {
                        time += interval * count;
                }

                i++;
        }

        // push the last time
        tickPositions.push(time);

        // mark new days if the time is dividible by day (#1649, #1760)
        each(grep(tickPositions, function (time) {
                return interval &lt;= timeUnits.hour &amp;&amp; time % timeUnits.day === localTimezoneOffset;
        }), function (time) {
                higherRanks[time] = &#39;day&#39;;
        });
}

// record information on the chosen unit - for dynamic label formatter
tickPositions.info = extend(normalizedInterval, {
        higherRanks: higherRanks,
        totalRange: interval * count
});

return tickPositions;</pre>

<p>};</p>

<p>/**</p>

<pre> Get a normalized tick interval for dates. Returns a configuration object with
 unit range (interval), count and name. Used to prepare data for getTimeTicks. 
 Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
 of segments in stock charts, the normalizing logic was extracted in order to 
 prevent it for running over again for each segment having the same interval. 
 #662, #697.
/</pre>

<p>Axis.prototype.normalizeTimeTickInterval = function (tickInterval,
unitsOption) {</p>

<pre>var units = unitsOption || [[
                        &#39;millisecond&#39;, // unit name
                        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
                ], [
                        &#39;second&#39;,
                        [1, 2, 5, 10, 15, 30]
                ], [
                        &#39;minute&#39;,
                        [1, 2, 5, 10, 15, 30]
                ], [
                        &#39;hour&#39;,
                        [1, 2, 3, 4, 6, 8, 12]
                ], [
                        &#39;day&#39;,
                        [1, 2]
                ], [
                        &#39;week&#39;,
                        [1, 2]
                ], [
                        &#39;month&#39;,
                        [1, 2, 3, 4, 6]
                ], [
                        &#39;year&#39;,
                        null
                ]],
        unit = units[units.length - 1], // default unit is years
        interval = timeUnits[unit[0]],
        multiples = unit[1],
        count,
        i;

// loop through the units to find the one that best fits the tickInterval
for (i = 0; i &lt; units.length; i++) {
        unit = units[i];
        interval = timeUnits[unit[0]];
        multiples = unit[1];

        if (units[i + 1]) {
                // lessThan is in the middle between the highest multiple and the next unit.
                var lessThan = (interval * multiples[multiples.length - 1] +
                                        timeUnits[units[i + 1][0]]) / 2;

                // break and keep the current unit
                if (tickInterval &lt;= lessThan) {
                        break;
                }
        }
}

// prevent 2.5 years intervals, though 25, 250 etc. are allowed
if (interval === timeUnits.year &amp;&amp; tickInterval &lt; 5 * interval) {
        multiples = [1, 2, 5];
}

// get the count
count = normalizeTickInterval(
        tickInterval / interval, 
        multiples,
        unit[0] === &#39;year&#39; ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
);

return {
        unitRange: interval,
        count: count,
        unitName: unit[0]
};</pre>

<p>};/**</p>

<pre> Methods defined on the Axis prototype
/</pre>

<p>/**</p>

<pre> Set the tick positions of a logarithmic axis
/</pre>

<p>Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {</p>

<pre>var axis = this,
        options = axis.options,
        axisLength = axis.len,
        // Since we use this method for both major and minor ticks,
        // use a local variable and return the result
        positions = []; 

// Reset
if (!minor) {
        axis._minorAutoInterval = null;
}

// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
if (interval &gt;= 0.5) {
        interval = mathRound(interval);
        positions = axis.getLinearTickPositions(interval, min, max);

// Second case: We need intermediary ticks. For example 
// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
} else if (interval &gt;= 0.08) {
        var roundedMin = mathFloor(min),
                intermediate,
                i,
                j,
                len,
                pos,
                lastPos,
                break2;

        if (interval &gt; 0.3) {
                intermediate = [1, 2, 4];
        } else if (interval &gt; 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
                intermediate = [1, 2, 4, 6, 8];
        } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
                intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        }

        for (i = roundedMin; i &lt; max + 1 &amp;&amp; !break2; i++) {
                len = intermediate.length;
                for (j = 0; j &lt; len &amp;&amp; !break2; j++) {
                        pos = log2lin(lin2log(i) * intermediate[j]);
                        if (pos &gt; min &amp;&amp; (!minor || lastPos &lt;= max) &amp;&amp; lastPos !== UNDEFINED) { // #1670, lastPos is #3113
                                positions.push(lastPos);
                        }

                        if (lastPos &gt; max) {
                                break2 = true;
                        }
                        lastPos = pos;
                }
        }

// Third case: We are so deep in between whole logarithmic values that
// we might as well handle the tick positions like a linear axis. For
// example 1.01, 1.02, 1.03, 1.04.
} else {
        var realMin = lin2log(min),
                realMax = lin2log(max),
                tickIntervalOption = options[minor ? &#39;minorTickInterval&#39; : &#39;tickInterval&#39;],
                filteredTickIntervalOption = tickIntervalOption === &#39;auto&#39; ? null : tickIntervalOption,
                tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
                totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;

        interval = pick(
                filteredTickIntervalOption,
                axis._minorAutoInterval,
                (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
        );

        interval = normalizeTickInterval(
                interval, 
                null, 
                getMagnitude(interval)
        );

        positions = map(axis.getLinearTickPositions(
                interval, 
                realMin,
                realMax 
        ), log2lin);

        if (!minor) {
                axis._minorAutoInterval = interval / 5;
        }
}

// Set the axis-level tickInterval variable 
if (!minor) {
        axis.tickInterval = interval;
}
return positions;</pre>

<p>};/**</p>

<pre> The tooltip object
 @param {Object} chart The chart instance
 @param {Object} options Tooltip options
/</pre>

<p>var Tooltip = Highcharts.Tooltip = function () {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">init</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
</pre>

<p>};</p>

<p>Tooltip.prototype = {</p>

<pre>     init: function (chart, options) {

             var borderWidth = options.borderWidth,
                     style = options.style,
                     padding = pInt(style.padding);

             // Save the chart and options
             this.chart = chart;
             this.options = options;

             // Keep track of the current series
             //this.currentSeries = UNDEFINED;

             // List of crosshairs
             this.crosshairs = [];

             // Current values of x and y when animating
             this.now = { x: 0, y: 0 };

             // The tooltip is initially hidden
             this.isHidden = true;

             // create the label
             this.label = chart.renderer.label(&#39;&#39;, 0, 0, options.shape || &#39;callout&#39;, null, null, options.useHTML, null, &#39;tooltip&#39;)
                     .attr({
                             padding: padding,
                             fill: options.backgroundColor,
                             &#39;stroke-width&#39;: borderWidth,
                             r: options.borderRadius,
                             zIndex: 8
                     })
                     .css(style)
                     .css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
                     .add()
                     .attr({ y: -9999 }); // #2301, #2657

             // When using canVG the shadow shows up as a gray circle
             // even if the tooltip is hidden.
             if (!useCanVG) {
                     this.label.shadow(options.shadow);
             }

             // Public property for getting the shared state.
             this.shared = options.shared;
     },

     /**
 Destroy the tooltip and its elements.
/
     destroy: function () {
             // Destroy and clear local variables
             if (this.label) {
                     this.label = this.label.destroy();
             }
             clearTimeout(this.hideTimer);
             clearTimeout(this.tooltipTimeout);
     },

     /**
 Provide a soft movement for the tooltip

 @param {Number} x
 @param {Number} y
 @private
/
     move: function (x, y, anchorX, anchorY) {
             var tooltip = this,
                     now = tooltip.now,
                     animate = tooltip.options.animation !== false &amp;&amp; !tooltip.isHidden &amp;&amp; 
                             // When we get close to the target position, abort animation and land on the right place (#3056)
                             (mathAbs(x - now.x) &gt; 1 || mathAbs(y - now.y) &gt; 1),
                     skipAnchor = tooltip.followPointer || tooltip.len &gt; 1;

             // Get intermediate values for animation
             extend(now, {
                     x: animate ? (2 * now.x + x) / 3 : x,
                     y: animate ? (now.y + y) / 2 : y,
                     anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
                     anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
             });

             // Move to the intermediate value
             tooltip.label.attr(now);

             // Run on next tick of the mouse tracker
             if (animate) {

                     // Never allow two timeouts
                     clearTimeout(this.tooltipTimeout);

                     // Set the fixed interval ticking for the smooth tooltip
                     this.tooltipTimeout = setTimeout(function () {
                             // The interval function may still be running during destroy, so check that the chart is really there before calling.
                             if (tooltip) {
                                     tooltip.move(x, y, anchorX, anchorY);
                             }
                     }, 32);

             }
     },

     /**
 Hide the tooltip
/
     hide: function (delay) {
             var tooltip = this,
                     hoverPoints;

             clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
             if (!this.isHidden) {
                     hoverPoints = this.chart.hoverPoints;

                     this.hideTimer = setTimeout(function () {
                             tooltip.label.fadeOut();
                             tooltip.isHidden = true;
                     }, pick(delay, this.options.hideDelay, 500));

                     // hide previous hoverPoints and set new
                     if (hoverPoints) {
                             each(hoverPoints, function (point) {
                                     point.setState();
                             });
                     }

                     this.chart.hoverPoints = null;
             }
     },

     /** 
 Extendable method to get the anchor position of the tooltip
 from a point or set of points
/
     getAnchor: function (points, mouseEvent) {
             var ret,
                     chart = this.chart,
                     inverted = chart.inverted,
                     plotTop = chart.plotTop,
                     plotX = 0,
                     plotY = 0,
                     yAxis;

             points = splat(points);

             // Pie uses a special tooltipPos
             ret = points[0].tooltipPos;

             // When tooltip follows mouse, relate the position to the mouse
             if (this.followPointer &amp;&amp; mouseEvent) {
                     if (mouseEvent.chartX === UNDEFINED) {
                             mouseEvent = chart.pointer.normalize(mouseEvent);
                     }
                     ret = [
                             mouseEvent.chartX - chart.plotLeft,
                             mouseEvent.chartY - plotTop
                     ];
             }
             // When shared, use the average position
             if (!ret) {
                     each(points, function (point) {
                             yAxis = point.series.yAxis;
                             plotX += point.plotX;
                             plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
                                     (!inverted &amp;&amp; yAxis ? yAxis.top - plotTop : 0); // #1151
                     });

                     plotX /= points.length;
                     plotY /= points.length;

                     ret = [
                             inverted ? chart.plotWidth - plotY : plotX,
                             this.shared &amp;&amp; !inverted &amp;&amp; points.length &gt; 1 &amp;&amp; mouseEvent ? 
                                     mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
                                     inverted ? chart.plotHeight - plotX : plotY
                     ];
             }

             return map(ret, mathRound);
     },

     /**
 Place the tooltip in a chart without spilling over
 and not covering the point it self.
/
     getPosition: function (boxWidth, boxHeight, point) {

             var chart = this.chart,
                     distance = this.distance,
                     ret = {},
                     swapped,
                     first = [&#39;y&#39;, chart.chartHeight, boxHeight, point.plotY + chart.plotTop],
                     second = [&#39;x&#39;, chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],
                     // The far side is right or bottom
                     preferFarSide = point.ttBelow || (chart.inverted &amp;&amp; !point.negative) || (!chart.inverted &amp;&amp; point.negative),
                     /**
   Handle the preferred dimension. When the preferred dimension is tooltip
   on top or bottom of the point, it will look for space there.
  /
                     firstDimension = function (dim, outerSize, innerSize, point) {
                             var roomLeft = innerSize &lt; point - distance,
                                     roomRight = point + distance + innerSize &lt; outerSize,
                                     alignedLeft = point - distance - innerSize,
                                     alignedRight = point + distance;

                             if (preferFarSide &amp;&amp; roomRight) {
                                     ret[dim] = alignedRight;
                             } else if (!preferFarSide &amp;&amp; roomLeft) {
                                     ret[dim] = alignedLeft;
                             } else if (roomLeft) {
                                     ret[dim] = alignedLeft;
                             } else if (roomRight) {
                                     ret[dim] = alignedRight;
                             } else {
                                     return false;
                             }
                     },
                     /**
   Handle the secondary dimension. If the preferred dimension is tooltip
   on top or bottom of the point, the second dimension is to align the tooltip
   above the point, trying to align center but allowing left or right
   align within the chart box.
  /
                     secondDimension = function (dim, outerSize, innerSize, point) {
                             // Too close to the edge, return false and swap dimensions
                             if (point &lt; distance || point &gt; outerSize - distance) {
                                     return false;

                             // Align left/top
                             } else if (point &lt; innerSize / 2) {
                                     ret[dim] = 1;
                             // Align right/bottom
                             } else if (point &gt; outerSize - innerSize / 2) {
                                     ret[dim] = outerSize - innerSize - 2;
                             // Align center
                             } else {
                                     ret[dim] = point - innerSize / 2;
                             }
                     },
                     /**
   Swap the dimensions 
  /
                     swap = function (count) {
                             var temp = first;
                             first = second;
                             second = temp;
                             swapped = count;
                     },
                     run = function () {
                             if (firstDimension.apply(0, first) !== false) {
                                     if (secondDimension.apply(0, second) === false &amp;&amp; !swapped) {
                                             swap(true);
                                             run();
                                     }
                             } else if (!swapped) {
                                     swap(true);
                                     run();
                             } else {
                                     ret.x = ret.y = 0;
                             }
                     };

             // Under these conditions, prefer the tooltip on the side of the point
             if (chart.inverted || this.len &gt; 1) {
                     swap();
             }
             run();

             return ret;

     },

     /**
 In case no user defined formatter is given, this will be used. Note that the context
 here is an object holding point, series, x, y etc.
/
     defaultFormatter: function (tooltip) {
             var items = this.points || splat(this),
                     series = items[0].series,
                     s;

             // build the header
             s = [tooltip.tooltipHeaderFormatter(items[0])];

             // build the values
             each(items, function (item) {
                     series = item.series;
                     s.push((series.tooltipFormatter &amp;&amp; series.tooltipFormatter(item)) ||
                             item.point.tooltipFormatter(series.tooltipOptions.pointFormat));
             });

             // footer
             s.push(tooltip.options.footerFormat || &#39;&#39;);

             return s.join(&#39;&#39;);
     },

     /**
 Refresh the tooltip&#39;s text and position.
 @param {Object} point
/
     refresh: function (point, mouseEvent) {
             var tooltip = this,
                     chart = tooltip.chart,
                     label = tooltip.label,
                     options = tooltip.options,
                     x,
                     y,
                     anchor,
                     textConfig = {},
                     text,
                     pointConfig = [],
                     formatter = options.formatter || tooltip.defaultFormatter,
                     hoverPoints = chart.hoverPoints,
                     borderColor,
                     shared = tooltip.shared,
                     currentSeries;

             clearTimeout(this.hideTimer);

             // get the reference point coordinates (pie charts use tooltipPos)
             tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
             anchor = tooltip.getAnchor(point, mouseEvent);
             x = anchor[0];
             y = anchor[1];

             // shared tooltip, array is sent over
             if (shared &amp;&amp; !(point.series &amp;&amp; point.series.noSharedTooltip)) {

                     // hide previous hoverPoints and set new

                     chart.hoverPoints = point;
                     if (hoverPoints) {
                             each(hoverPoints, function (point) {
                                     point.setState();
                             });
                     }

                     each(point, function (item) {
                             item.setState(HOVER_STATE);

                             pointConfig.push(item.getLabelConfig());
                     });

                     textConfig = {
                             x: point[0].category,
                             y: point[0].y
                     };
                     textConfig.points = pointConfig;
                     this.len = pointConfig.length;
                     point = point[0];

             // single point tooltip
             } else {
                     textConfig = point.getLabelConfig();
             }
             text = formatter.call(textConfig, tooltip);

             // register the current series
             currentSeries = point.series;
             this.distance = pick(currentSeries.tooltipOptions.distance, 16);

             // update the inner HTML
             if (text === false) {
                     this.hide();
             } else {

                     // show it
                     if (tooltip.isHidden) {
                             stop(label);
                             label.attr(&#39;opacity&#39;, 1).show();
                     }

                     // update text
                     label.attr({
                             text: text
                     });

                     // set the stroke color of the box
                     borderColor = options.borderColor || point.color || currentSeries.color || &#39;#606060&#39;;
                     label.attr({
                             stroke: borderColor
                     });

                     tooltip.updatePosition({ plotX: x, plotY: y, negative: point.negative, ttBelow: point.ttBelow });

                     this.isHidden = false;
             }
             fireEvent(chart, &#39;tooltipRefresh&#39;, {
                             text: text,
                             x: x + chart.plotLeft,
                             y: y + chart.plotTop,
                             borderColor: borderColor
                     });
     },

     /**
 Find the new position and perform the move
/
     updatePosition: function (point) {
             var chart = this.chart,
                     label = this.label, 
                     pos = (this.options.positioner || this.getPosition).call(
                             this,
                             label.width,
                             label.height,
                             point
                     );

             // do the move
             this.move(
                     mathRound(pos.x), 
                     mathRound(pos.y), 
                     point.plotX + chart.plotLeft, 
                     point.plotY + chart.plotTop
             );
     },

     /**
 Format the header of the tooltip
/
     tooltipHeaderFormatter: function (point) {
             var series = point.series,
                     tooltipOptions = series.tooltipOptions,
                     dateTimeLabelFormats = tooltipOptions.dateTimeLabelFormats,
                     xDateFormat = tooltipOptions.xDateFormat,
                     xAxis = series.xAxis,
                     isDateTime = xAxis &amp;&amp; xAxis.options.type === &#39;datetime&#39; &amp;&amp; isNumber(point.key),
                     headerFormat = tooltipOptions.headerFormat,
                     closestPointRange = xAxis &amp;&amp; xAxis.closestPointRange,
                     n;

             // Guess the best date format based on the closest point distance (#568)
             if (isDateTime &amp;&amp; !xDateFormat) {
                     if (closestPointRange) {
                             for (n in timeUnits) {
                                     if (timeUnits[n] &gt;= closestPointRange || 
                                                     // If the point is placed every day at 23:59, we need to show
                                                     // the minutes as well. This logic only works for time units less than 
                                                     // a day, since all higher time units are dividable by those. #2637.
                                                     (timeUnits[n] &lt;= timeUnits.day &amp;&amp; point.key % timeUnits[n] &gt; 0)) {
                                             xDateFormat = dateTimeLabelFormats[n];
                                             break;
                                     }
                             }
                     } else {
                             xDateFormat = dateTimeLabelFormats.day;
                     }

                     xDateFormat = xDateFormat || dateTimeLabelFormats.year; // #2546, 2581

             }

             // Insert the header date format if any
             if (isDateTime &amp;&amp; xDateFormat) {
                     headerFormat = headerFormat.replace(&#39;{point.key}&#39;, &#39;{point.key:&#39; + xDateFormat + &#39;}&#39;);
             }

             return format(headerFormat, {
                     point: point,
                     series: series
             });
     }</pre>

<p>};</p>

<p>var hoverChartIndex;</p>

<p>// Global flag for touch support hasTouch =
doc.documentElement.ontouchstart !== UNDEFINED;</p>

<p>/**</p>

<pre> The mouse tracker object. All methods starting with &quot;on&quot; are primary DOM event handlers. 
 Subsequent methods should be named differently from what they are doing.
 @param {Object} chart The Chart instance
 @param {Object} options The root options object
/</pre>

<p>var Pointer = Highcharts.Pointer = function (chart, options) {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">init</span>(<span class="ruby-identifier">chart</span>, <span class="ruby-identifier">options</span>);
</pre>

<p>};</p>

<p>Pointer.prototype = {</p>

<pre>     /**
 Initialize Pointer
/
     init: function (chart, options) {

             var chartOptions = options.chart,
                     chartEvents = chartOptions.events,
                     zoomType = useCanVG ? &#39;&#39; : chartOptions.zoomType,
                     inverted = chart.inverted,
                     zoomX,
                     zoomY;

             // Store references
             this.options = options;
             this.chart = chart;

             // Zoom status
             this.zoomX = zoomX = /x/.test(zoomType);
             this.zoomY = zoomY = /y/.test(zoomType);
             this.zoomHor = (zoomX &amp;&amp; !inverted) || (zoomY &amp;&amp; inverted);
             this.zoomVert = (zoomY &amp;&amp; !inverted) || (zoomX &amp;&amp; inverted);
             this.hasZoom = zoomX || zoomY;

             // Do we need to handle click on a touch device?
             this.runChartClick = chartEvents &amp;&amp; !!chartEvents.click;

             this.pinchDown = [];
             this.lastValidTouch = {};

             if (Highcharts.Tooltip &amp;&amp; options.tooltip.enabled) {
                     chart.tooltip = new Tooltip(chart, options.tooltip);
                     this.followTouchMove = options.tooltip.followTouchMove;
             }

             this.setDOMEvents();
     }, 

     /**
 Add crossbrowser support for chartX and chartY
 @param {Object} e The event object in standard browsers
/
     normalize: function (e, chartPosition) {
             var chartX,
                     chartY,
                     ePos;

             // common IE normalizing
             e = e || window.event;

             // Framework specific normalizing (#1165)
             e = washMouseEvent(e);

             // More IE normalizing, needs to go after washMouseEvent
             if (!e.target) {
                     e.target = e.srcElement;
             }

             // iOS (#2757)
             ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

             // Get mouse position
             if (!chartPosition) {
                     this.chartPosition = chartPosition = offset(this.chart.container);
             }

             // chartX and chartY
             if (ePos.pageX === UNDEFINED) { // IE &lt; 9. #886.
                     chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
                             // for IE10 quirks mode within framesets
                     chartY = e.y;
             } else {
                     chartX = ePos.pageX - chartPosition.left;
                     chartY = ePos.pageY - chartPosition.top;
             }

             return extend(e, {
                     chartX: mathRound(chartX),
                     chartY: mathRound(chartY)
             });
     },

     /**
 Get the click position in terms of axis values.

 @param {Object} e A pointer event
/
     getCoordinates: function (e) {
             var coordinates = {
                             xAxis: [],
                             yAxis: []
                     };

             each(this.chart.axes, function (axis) {
                     coordinates[axis.isXAxis ? &#39;xAxis&#39; : &#39;yAxis&#39;].push({
                             axis: axis,
                             value: axis.toValue(e[axis.horiz ? &#39;chartX&#39; : &#39;chartY&#39;])
                     });
             });
             return coordinates;
     },

     /**
 Return the index in the tooltipPoints array, corresponding to pixel position in 
 the plot area.
/
     getIndex: function (e) {
             var chart = this.chart;
             return chart.inverted ? 
                     chart.plotHeight + chart.plotTop - e.chartY : 
                     e.chartX - chart.plotLeft;
     },

     /**
 With line type charts with a single tracker, get the point closest to the mouse.
 Run Point.onMouseOver and display tooltip for the point or points.
/
     runPointActions: function (e) {
             var pointer = this,
                     chart = pointer.chart,
                     series = chart.series,
                     tooltip = chart.tooltip,
                     followPointer,
                     point,
                     points,
                     hoverPoint = chart.hoverPoint,
                     hoverSeries = chart.hoverSeries,
                     i,
                     j,
                     distance = chart.chartWidth,
                     index = pointer.getIndex(e),
                     anchor;

             // shared tooltip
             if (tooltip &amp;&amp; pointer.options.tooltip.shared &amp;&amp; !(hoverSeries &amp;&amp; hoverSeries.noSharedTooltip)) {
                     points = [];

                     // loop over all series and find the ones with points closest to the mouse
                     i = series.length;
                     for (j = 0; j &lt; i; j++) {
                             if (series[j].visible &amp;&amp;
                                             series[j].options.enableMouseTracking !== false &amp;&amp;
                                             !series[j].noSharedTooltip &amp;&amp; series[j].singularTooltips !== true &amp;&amp; series[j].tooltipPoints.length) {
                                     point = series[j].tooltipPoints[index];
                                     if (point &amp;&amp; point.series) { // not a dummy point, #1544
                                             point._dist = mathAbs(index - point.clientX);
                                             distance = mathMin(distance, point._dist);
                                             points.push(point);
                                     }
                             }
                     }
                     // remove furthest points
                     i = points.length;
                     while (i--) {
                             if (points[i]._dist &gt; distance) {
                                     points.splice(i, 1);
                             }
                     }
                     // refresh the tooltip if necessary
                     if (points.length &amp;&amp; (points[0].clientX !== pointer.hoverX)) {
                             tooltip.refresh(points, e);
                             pointer.hoverX = points[0].clientX;
                     }
             }

             // Separate tooltip and general mouse events
             followPointer = hoverSeries &amp;&amp; hoverSeries.tooltipOptions.followPointer;
             if (hoverSeries &amp;&amp; hoverSeries.tracker &amp;&amp; !followPointer) { // #2584, #2830

                     // get the point
                     point = hoverSeries.tooltipPoints[index];

                     // a new point is hovered, refresh the tooltip
                     if (point &amp;&amp; point !== hoverPoint) {

                             // trigger the events
                             point.onMouseOver(e);

                     }

             } else if (tooltip &amp;&amp; followPointer &amp;&amp; !tooltip.isHidden) {
                     anchor = tooltip.getAnchor([{}], e);
                     tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
             }

             // Start the event listener to pick up the tooltip 
             if (tooltip &amp;&amp; !pointer._onDocumentMouseMove) {
                     pointer._onDocumentMouseMove = function (e) {
                             if (charts[hoverChartIndex]) {
                                     charts[hoverChartIndex].pointer.onDocumentMouseMove(e);
                             }
                     };
                     addEvent(doc, &#39;mousemove&#39;, pointer._onDocumentMouseMove);
             }

             // Draw independent crosshairs
             each(chart.axes, function (axis) {
                     axis.drawCrosshair(e, pick(point, hoverPoint));
             });
     },

     /**
 Reset the tracking by hiding the tooltip, the hover series state and the hover point

 @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
/
     reset: function (allowMove, delay) {
             var pointer = this,
                     chart = pointer.chart,
                     hoverSeries = chart.hoverSeries,
                     hoverPoint = chart.hoverPoint,
                     tooltip = chart.tooltip,
                     tooltipPoints = tooltip &amp;&amp; tooltip.shared ? chart.hoverPoints : hoverPoint;

             // Narrow in allowMove
             allowMove = allowMove &amp;&amp; tooltip &amp;&amp; tooltipPoints;

             // Check if the points have moved outside the plot area, #1003
             if (allowMove &amp;&amp; splat(tooltipPoints)[0].plotX === UNDEFINED) {
                     allowMove = false;
             }       

             // Just move the tooltip, #349
             if (allowMove) {
                     tooltip.refresh(tooltipPoints);
                     if (hoverPoint) { // #2500
                             hoverPoint.setState(hoverPoint.state, true);
                     }

             // Full reset
             } else {

                     if (hoverPoint) {
                             hoverPoint.onMouseOut();
                     }

                     if (hoverSeries) {
                             hoverSeries.onMouseOut();
                     }

                     if (tooltip) {
                             tooltip.hide(delay);
                     }

                     if (pointer._onDocumentMouseMove) {
                             removeEvent(doc, &#39;mousemove&#39;, pointer._onDocumentMouseMove);
                             pointer._onDocumentMouseMove = null;
                     }

                     // Remove crosshairs
                     each(chart.axes, function (axis) {
                             axis.hideCrosshair();
                     });

                     pointer.hoverX = null;

             }
     },

     /**
 Scale series groups to a certain scale and translation
/
     scaleGroups: function (attribs, clip) {

             var chart = this.chart,
                     seriesAttribs;

             // Scale each series
             each(chart.series, function (series) {
                     seriesAttribs = attribs || series.getPlotBox(); // #1701
                     if (series.xAxis &amp;&amp; series.xAxis.zoomEnabled) {
                             series.group.attr(seriesAttribs);
                             if (series.markerGroup) {
                                     series.markerGroup.attr(seriesAttribs);
                                     series.markerGroup.clip(clip ? chart.clipRect : null);
                             }
                             if (series.dataLabelsGroup) {
                                     series.dataLabelsGroup.attr(seriesAttribs);
                             }
                     }
             });

             // Clip
             chart.clipRect.attr(clip || chart.clipBox);
     },

     /**
 Start a drag operation
/
     dragStart: function (e) {
             var chart = this.chart;

             // Record the start position
             chart.mouseIsDown = e.type;
             chart.cancelClick = false;
             chart.mouseDownX = this.mouseDownX = e.chartX;
             chart.mouseDownY = this.mouseDownY = e.chartY;
     },

     /**
 Perform a drag operation in response to a mousemove event while the mouse is down
/
     drag: function (e) {

             var chart = this.chart,
                     chartOptions = chart.options.chart,
                     chartX = e.chartX,
                     chartY = e.chartY,
                     zoomHor = this.zoomHor,
                     zoomVert = this.zoomVert,
                     plotLeft = chart.plotLeft,
                     plotTop = chart.plotTop,
                     plotWidth = chart.plotWidth,
                     plotHeight = chart.plotHeight,
                     clickedInside,
                     size,
                     mouseDownX = this.mouseDownX,
                     mouseDownY = this.mouseDownY,
                     panKey = chartOptions.panKey &amp;&amp; e[chartOptions.panKey + &#39;Key&#39;];

             // If the mouse is outside the plot area, adjust to cooordinates
             // inside to prevent the selection marker from going outside
             if (chartX &lt; plotLeft) {
                     chartX = plotLeft;
             } else if (chartX &gt; plotLeft + plotWidth) {
                     chartX = plotLeft + plotWidth;
             }

             if (chartY &lt; plotTop) {
                     chartY = plotTop;
             } else if (chartY &gt; plotTop + plotHeight) {
                     chartY = plotTop + plotHeight;
             }

             // determine if the mouse has moved more than 10px
             this.hasDragged = Math.sqrt(
                     Math.pow(mouseDownX - chartX, 2) +
                     Math.pow(mouseDownY - chartY, 2)
             );

             if (this.hasDragged &gt; 10) {
                     clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

                     // make a selection
                     if (chart.hasCartesianSeries &amp;&amp; (this.zoomX || this.zoomY) &amp;&amp; clickedInside &amp;&amp; !panKey) {
                             if (!this.selectionMarker) {
                                     this.selectionMarker = chart.renderer.rect(
                                             plotLeft,
                                             plotTop,
                                             zoomHor ? 1 : plotWidth,
                                             zoomVert ? 1 : plotHeight,
                                             0
                                     )
                                     .attr({
                                             fill: chartOptions.selectionMarkerFill || &#39;rgba(69,114,167,0.25)&#39;,
                                             zIndex: 7
                                     })
                                     .add();
                             }
                     }

                     // adjust the width of the selection marker
                     if (this.selectionMarker &amp;&amp; zoomHor) {
                             size = chartX - mouseDownX;
                             this.selectionMarker.attr({
                                     width: mathAbs(size),
                                     x: (size &gt; 0 ? 0 : size) + mouseDownX
                             });
                     }
                     // adjust the height of the selection marker
                     if (this.selectionMarker &amp;&amp; zoomVert) {
                             size = chartY - mouseDownY;
                             this.selectionMarker.attr({
                                     height: mathAbs(size),
                                     y: (size &gt; 0 ? 0 : size) + mouseDownY
                             });
                     }

                     // panning
                     if (clickedInside &amp;&amp; !this.selectionMarker &amp;&amp; chartOptions.panning) {
                             chart.pan(e, chartOptions.panning);
                     }
             }
     },

     /**
 On mouse up or touch end across the entire document, drop the selection.
/
     drop: function (e) {
             var chart = this.chart,
                     hasPinched = this.hasPinched;

             if (this.selectionMarker) {
                     var selectionData = {
                                     xAxis: [],
                                     yAxis: [],
                                     originalEvent: e.originalEvent || e
                             },
                             selectionBox = this.selectionMarker,
                             selectionLeft = selectionBox.attr ? selectionBox.attr(&#39;x&#39;) : selectionBox.x,
                             selectionTop = selectionBox.attr ? selectionBox.attr(&#39;y&#39;) : selectionBox.y,
                             selectionWidth = selectionBox.attr ? selectionBox.attr(&#39;width&#39;) : selectionBox.width,
                             selectionHeight = selectionBox.attr ? selectionBox.attr(&#39;height&#39;) : selectionBox.height,
                             runZoom;

                     // a selection has been made
                     if (this.hasDragged || hasPinched) {

                             // record each axis&#39; min and max
                             each(chart.axes, function (axis) {
                                     if (axis.zoomEnabled) {
                                             var horiz = axis.horiz,
                                                     minPixelPadding = e.type === &#39;touchend&#39; ? axis.minPixelPadding: 0, // #1207, #3075
                                                     selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
                                                     selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

                                             if (!isNaN(selectionMin) &amp;&amp; !isNaN(selectionMax)) { // #859
                                                     selectionData[axis.coll].push({
                                                             axis: axis,
                                                             min: mathMin(selectionMin, selectionMax), // for reversed axes,
                                                             max: mathMax(selectionMin, selectionMax)
                                                     });
                                                     runZoom = true;
                                             }
                                     }
                             });
                             if (runZoom) {
                                     fireEvent(chart, &#39;selection&#39;, selectionData, function (args) { 
                                             chart.zoom(extend(args, hasPinched ? { animation: false } : null)); 
                                     });
                             }

                     }
                     this.selectionMarker = this.selectionMarker.destroy();

                     // Reset scaling preview
                     if (hasPinched) {
                             this.scaleGroups();
                     }
             }

             // Reset all
             if (chart) { // it may be destroyed on mouse up - #877
                     css(chart.container, { cursor: chart._cursor });
                     chart.cancelClick = this.hasDragged &gt; 10; // #370
                     chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
                     this.pinchDown = [];
             }
     },

     onContainerMouseDown: function (e) {

             e = this.normalize(e);

             // issue #295, dragging not always working in Firefox
             if (e.preventDefault) {
                     e.preventDefault();
             }

             this.dragStart(e);
     },

     onDocumentMouseUp: function (e) {
             if (charts[hoverChartIndex]) {
                     charts[hoverChartIndex].pointer.drop(e);
             }
     },

     /**
 Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
 Issue #149 workaround. The mouseleave event does not always fire. 
/
     onDocumentMouseMove: function (e) {
             var chart = this.chart,
                     chartPosition = this.chartPosition,
                     hoverSeries = chart.hoverSeries;

             e = this.normalize(e, chartPosition);

             // If we&#39;re outside, hide the tooltip
             if (chartPosition &amp;&amp; hoverSeries &amp;&amp; !this.inClass(e.target, &#39;highcharts-tracker&#39;) &amp;&amp;
                             !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
                     this.reset();
             }
     },

     /**
 When mouse leaves the container, hide the tooltip.
/
     onContainerMouseLeave: function () {
             var chart = charts[hoverChartIndex];
             if (chart) {
                     chart.pointer.reset();
                     chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
             }
     },

     // The mousemove, touchmove and touchstart event handler
     onContainerMouseMove: function (e) {

             var chart = this.chart;

             hoverChartIndex = chart.index;

             e = this.normalize(e);          
             e.returnValue = false; // #2251, #3224

             if (chart.mouseIsDown === &#39;mousedown&#39;) {
                     this.drag(e);
             } 

             // Show the tooltip and run mouse over events (#977)
             if ((this.inClass(e.target, &#39;highcharts-tracker&#39;) || 
                             chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) &amp;&amp; !chart.openMenu) {
                     this.runPointActions(e);
             }
     },

     /**
 Utility to detect whether an element has, or has a parent with, a specific
 class name. Used on detection of tracker objects and on deciding whether
 hovering the tooltip should cause the active series to mouse out.
/
     inClass: function (element, className) {
             var elemClassName;
             while (element) {
                     elemClassName = attr(element, &#39;class&#39;);
                     if (elemClassName) {
                             if (elemClassName.indexOf(className) !== -1) {
                                     return true;
                             } else if (elemClassName.indexOf(PREFIX + &#39;container&#39;) !== -1) {
                                     return false;
                             }
                     }
                     element = element.parentNode;
             }               
     },

     onTrackerMouseOut: function (e) {
             var series = this.chart.hoverSeries,
                     relatedTarget = e.relatedTarget || e.toElement,
                     relatedSeries = relatedTarget &amp;&amp; relatedTarget.point &amp;&amp; relatedTarget.point.series; // #2499

             if (series &amp;&amp; !series.options.stickyTracking &amp;&amp; !this.inClass(relatedTarget, PREFIX + &#39;tooltip&#39;) &amp;&amp;
                             relatedSeries !== series) {
                     series.onMouseOut();
             }
     },

     onContainerClick: function (e) {
             var chart = this.chart,
                     hoverPoint = chart.hoverPoint, 
                     plotLeft = chart.plotLeft,
                     plotTop = chart.plotTop;

             e = this.normalize(e);
             e.cancelBubble = true; // IE specific

             if (!chart.cancelClick) {

                     // On tracker click, fire the series and point events. #783, #1583
                     if (hoverPoint &amp;&amp; this.inClass(e.target, PREFIX + &#39;tracker&#39;)) {

                             // the series click event
                             fireEvent(hoverPoint.series, &#39;click&#39;, extend(e, {
                                     point: hoverPoint
                             }));

                             // the point click event
                             if (chart.hoverPoint) { // it may be destroyed (#1844)
                                     hoverPoint.firePointEvent(&#39;click&#39;, e);
                             }

                     // When clicking outside a tracker, fire a chart event
                     } else {
                             extend(e, this.getCoordinates(e));

                             // fire a click event in the chart
                             if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
                                     fireEvent(chart, &#39;click&#39;, e);
                             }
                     }

             }
     },

     /**
 Set the JS DOM events on the container and document. This method should contain
 a one-to-one assignment between methods and their handlers. Any advanced logic should
 be moved to the handler reflecting the event&#39;s name.
/
     setDOMEvents: function () {

             var pointer = this,
                     container = pointer.chart.container;

             container.onmousedown = function (e) {
                     pointer.onContainerMouseDown(e);
             };
             container.onmousemove = function (e) {
                     pointer.onContainerMouseMove(e);
             };
             container.onclick = function (e) {
                     pointer.onContainerClick(e);
             };
             addEvent(container, &#39;mouseleave&#39;, pointer.onContainerMouseLeave);
             if (chartCount === 1) {
                     addEvent(doc, &#39;mouseup&#39;, pointer.onDocumentMouseUp);
             }
             if (hasTouch) {
                     container.ontouchstart = function (e) {
                             pointer.onContainerTouchStart(e);
                     };
                     container.ontouchmove = function (e) {
                             pointer.onContainerTouchMove(e);
                     };
                     if (chartCount === 1) {
                             addEvent(doc, &#39;touchend&#39;, pointer.onDocumentTouchEnd);
                     }
             }

     },

     /**
 Destroys the Pointer object and disconnects DOM events.
/
     destroy: function () {
             var prop;

             removeEvent(this.chart.container, &#39;mouseleave&#39;, this.onContainerMouseLeave);
             if (!chartCount) {
                     removeEvent(doc, &#39;mouseup&#39;, this.onDocumentMouseUp);
                     removeEvent(doc, &#39;touchend&#39;, this.onDocumentTouchEnd);
             }

             // memory and CPU leak
             clearInterval(this.tooltipTimeout);

             for (prop in this) {
                     this[prop] = null;
             }
     }</pre>

<p>};</p>

<p>/* Support for touch devices */ extend(Highcharts.Pointer.prototype, {</p>

<pre>     /**
 Run translation operations
/
     pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
             if (this.zoomHor || this.pinchHor) {
                     this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
             }
             if (this.zoomVert || this.pinchVert) {
                     this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
             }
     },

     /**
 Run translation operations for each direction (horizontal and vertical) independently
/
     pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
             var chart = this.chart,
                     xy = horiz ? &#39;x&#39; : &#39;y&#39;,
                     XY = horiz ? &#39;X&#39; : &#39;Y&#39;,
                     sChartXY = &#39;chart&#39; + XY,
                     wh = horiz ? &#39;width&#39; : &#39;height&#39;,
                     plotLeftTop = chart[&#39;plot&#39; + (horiz ? &#39;Left&#39; : &#39;Top&#39;)],
                     selectionWH,
                     selectionXY,
                     clipXY,
                     scale = forcedScale || 1,
                     inverted = chart.inverted,
                     bounds = chart.bounds[horiz ? &#39;h&#39; : &#39;v&#39;],
                     singleTouch = pinchDown.length === 1,
                     touch0Start = pinchDown[0][sChartXY],
                     touch0Now = touches[0][sChartXY],
                     touch1Start = !singleTouch &amp;&amp; pinchDown[1][sChartXY],
                     touch1Now = !singleTouch &amp;&amp; touches[1][sChartXY],
                     outOfBounds,
                     transformScale,
                     scaleKey,
                     setScale = function () {
                             if (!singleTouch &amp;&amp; mathAbs(touch0Start - touch1Start) &gt; 20) { // Don&#39;t zoom if fingers are too close on this axis
                                     scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); 
                             }

                             clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
                             selectionWH = chart[&#39;plot&#39; + (horiz ? &#39;Width&#39; : &#39;Height&#39;)] / scale;
                     };

             // Set the scale, first pass
             setScale();

             selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

             // Out of bounds
             if (selectionXY &lt; bounds.min) {
                     selectionXY = bounds.min;
                     outOfBounds = true;
             } else if (selectionXY + selectionWH &gt; bounds.max) {
                     selectionXY = bounds.max - selectionWH;
                     outOfBounds = true;
             }

             // Is the chart dragged off its bounds, determined by dataMin and dataMax?
             if (outOfBounds) {

                     // Modify the touchNow position in order to create an elastic drag movement. This indicates
                     // to the user that the chart is responsive but can&#39;t be dragged further.
                     touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
                     if (!singleTouch) {
                             touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
                     }

                     // Set the scale, second pass to adapt to the modified touchNow positions
                     setScale();

             } else {
                     lastValidTouch[xy] = [touch0Now, touch1Now];
             }

             // Set geometry for clipping, selection and transformation
             if (!inverted) { // TODO: implement clipping for inverted charts
                     clip[xy] = clipXY - plotLeftTop;
                     clip[wh] = selectionWH;
             }
             scaleKey = inverted ? (horiz ? &#39;scaleY&#39; : &#39;scaleX&#39;) : &#39;scale&#39; + XY;
             transformScale = inverted ? 1 / scale : scale;

             selectionMarker[wh] = selectionWH;
             selectionMarker[xy] = selectionXY;
             transform[scaleKey] = scale;
             transform[&#39;translate&#39; + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
     },

     /**
 Handle touch events with two touches
/
     pinch: function (e) {

             var self = this,
                     chart = self.chart,
                     pinchDown = self.pinchDown,
                     followTouchMove = self.followTouchMove,
                     touches = e.touches,
                     touchesLength = touches.length,
                     lastValidTouch = self.lastValidTouch,
                     hasZoom = self.hasZoom,
                     selectionMarker = self.selectionMarker,
                     transform = {},
                     fireClickEvent = touchesLength === 1 &amp;&amp; ((self.inClass(e.target, PREFIX + &#39;tracker&#39;) &amp;&amp; 
                             chart.runTrackerClick) || self.runChartClick),
                     clip = {};

             // On touch devices, only proceed to trigger click if a handler is defined
             if ((hasZoom || followTouchMove) &amp;&amp; !fireClickEvent) {
                     e.preventDefault();
             }

             // Normalize each touch
             map(touches, function (e) {
                     return self.normalize(e);
             });

             // Register the touch start position
             if (e.type === &#39;touchstart&#39;) {
                     each(touches, function (e, i) {
                             pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
                     });
                     lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] &amp;&amp; pinchDown[1].chartX];
                     lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] &amp;&amp; pinchDown[1].chartY];

                     // Identify the data bounds in pixels
                     each(chart.axes, function (axis) {
                             if (axis.zoomEnabled) {
                                     var bounds = chart.bounds[axis.horiz ? &#39;h&#39; : &#39;v&#39;],
                                             minPixelPadding = axis.minPixelPadding,
                                             min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
                                             max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
                                             absMin = mathMin(min, max),
                                             absMax = mathMax(min, max);

                                     // Store the bounds for use in the touchmove handler
                                     bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
                                     bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
                             }
                     });
                     self.res = true; // reset on next move

             // Event type is touchmove, handle panning and pinching
             } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first

                     // Set the marker
                     if (!selectionMarker) {
                             self.selectionMarker = selectionMarker = extend({
                                     destroy: noop
                             }, chart.plotBox);
                     }

                     self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

                     self.hasPinched = hasZoom;

                     // Scale and translate the groups to provide visual feedback during pinching
                     self.scaleGroups(transform, clip);

                     // Optionally move the tooltip on touchmove
                     if (!hasZoom &amp;&amp; followTouchMove &amp;&amp; touchesLength === 1) {
                             this.runPointActions(self.normalize(e));
                     } else if (self.res) {
                             self.res = false;
                             this.reset(false, 0);
                     }
             }
     },

     onContainerTouchStart: function (e) {
             var chart = this.chart;

             hoverChartIndex = chart.index;

             if (e.touches.length === 1) {

                     e = this.normalize(e);

                     if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {

                             // Run mouse events and display tooltip etc
                             this.runPointActions(e);

                             this.pinch(e);

                     } else {
                             // Hide the tooltip on touching outside the plot area (#1203)
                             this.reset();
                     }

             } else if (e.touches.length === 2) {
                     this.pinch(e);
             }   
     },

     onContainerTouchMove: function (e) {
             if (e.touches.length === 1 || e.touches.length === 2) {
                     this.pinch(e);
             }
     },

     onDocumentTouchEnd: function (e) {
             if (charts[hoverChartIndex]) {
                     charts[hoverChartIndex].pointer.drop(e);
             }
     }</pre>

<p>}); if (win.PointerEvent || win.MSPointerEvent) {</p>

<pre>     // The touches object keeps track of the points being touched at all times
     var touches = {},
             hasPointerEvent = !!win.PointerEvent,
             getWebkitTouches = function () {
                     var key, fake = [];
                     fake.item = function (i) { return this[i]; };
                     for (key in touches) {
                             if (touches.hasOwnProperty(key)) {
                                     fake.push({
                                             pageX: touches[key].pageX,
                                             pageY: touches[key].pageY,
                                             target: touches[key].target
                                     });
                             }
                     }
                     return fake;
             },
             translateMSPointer = function (e, method, wktype, callback) {
                     var p;
                     e = e.originalEvent || e;
                     if ((e.pointerType === &#39;touch&#39; || e.pointerType === e.MSPOINTER_TYPE_TOUCH) &amp;&amp; charts[hoverChartIndex]) {
                             callback(e);
                             p = charts[hoverChartIndex].pointer;
                             p[method]({
                                     type: wktype,
                                     target: e.currentTarget,
                                     preventDefault: noop,
                                     touches: getWebkitTouches()
                             });                             
                     }
             };

     /**
 Extend the Pointer prototype with methods for each event handler and more
/
     extend(Pointer.prototype, {
             onContainerPointerDown: function (e) {
                     translateMSPointer(e, &#39;onContainerTouchStart&#39;, &#39;touchstart&#39;, function (e) {
                             touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
                     });
             },
             onContainerPointerMove: function (e) {
                     translateMSPointer(e, &#39;onContainerTouchMove&#39;, &#39;touchmove&#39;, function (e) {
                             touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
                             if (!touches[e.pointerId].target) {
                                     touches[e.pointerId].target = e.currentTarget;
                             }
                     });
             },
             onDocumentPointerUp: function (e) {
                     translateMSPointer(e, &#39;onContainerTouchEnd&#39;, &#39;touchend&#39;, function (e) {
                             delete touches[e.pointerId];
                     });
             },

             /**
  Add or remove the MS Pointer specific events
 /
             batchMSEvents: function (fn) {
                     fn(this.chart.container, hasPointerEvent ? &#39;pointerdown&#39; : &#39;MSPointerDown&#39;, this.onContainerPointerDown);
                     fn(this.chart.container, hasPointerEvent ? &#39;pointermove&#39; : &#39;MSPointerMove&#39;, this.onContainerPointerMove);
                     fn(doc, hasPointerEvent ? &#39;pointerup&#39; : &#39;MSPointerUp&#39;, this.onDocumentPointerUp);
             }
     });

     // Disable default IE actions for pinch and such on chart element
     wrap(Pointer.prototype, &#39;init&#39;, function (proceed, chart, options) {
             proceed.call(this, chart, options);
             if (this.hasZoom || this.followTouchMove) {
                     css(chart.container, {
                             &#39;-ms-touch-action&#39;: NONE,
                             &#39;touch-action&#39;: NONE
                     });
             }
     });

     // Add IE specific touch events to chart
     wrap(Pointer.prototype, &#39;setDOMEvents&#39;, function (proceed) {
             proceed.apply(this);
             if (this.hasZoom || this.followTouchMove) {
                     this.batchMSEvents(addEvent);
             }
     });
     // Destroy MS events also
     wrap(Pointer.prototype, &#39;destroy&#39;, function (proceed) {
             this.batchMSEvents(removeEvent);
             proceed.call(this);
     });</pre>

<p>} /**</p>

<pre> The overview of the chart&#39;s series
/</pre>

<p>var Legend = Highcharts.Legend = function (chart, options) {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">init</span>(<span class="ruby-identifier">chart</span>, <span class="ruby-identifier">options</span>);
</pre>

<p>};</p>

<p>Legend.prototype = {</p>

<pre>     /**
 Initialize the legend
/
     init: function (chart, options) {

             var legend = this,
                     itemStyle = options.itemStyle,
                     padding = pick(options.padding, 8),
                     itemMarginTop = options.itemMarginTop || 0;

             this.options = options;

             if (!options.enabled) {
                     return;
             }

             legend.itemStyle = itemStyle;
             legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
             legend.itemMarginTop = itemMarginTop;
             legend.padding = padding;
             legend.initialItemX = padding;
             legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
             legend.maxItemWidth = 0;
             legend.chart = chart;
             legend.itemHeight = 0;
             legend.lastLineHeight = 0;
             legend.symbolWidth = pick(options.symbolWidth, 16);
             legend.pages = [];

             // Render it
             legend.render();

             // move checkboxes
             addEvent(legend.chart, &#39;endResize&#39;, function () { 
                     legend.positionCheckboxes();
             });

     },

     /**
 Set the colors for the legend item
 @param {Object} item A Series or Point instance
 @param {Object} visible Dimmed or colored
/
     colorizeItem: function (item, visible) {
             var legend = this,
                     options = legend.options,
                     legendItem = item.legendItem,
                     legendLine = item.legendLine,
                     legendSymbol = item.legendSymbol,
                     hiddenColor = legend.itemHiddenStyle.color,
                     textColor = visible ? options.itemStyle.color : hiddenColor,
                     symbolColor = visible ? (item.legendColor || item.color || &#39;#CCC&#39;) : hiddenColor,
                     markerOptions = item.options &amp;&amp; item.options.marker,
                     symbolAttr = { fill: symbolColor },
                     key,
                     val;

             if (legendItem) {
                     legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
             }
             if (legendLine) {
                     legendLine.attr({ stroke: symbolColor });
             }

             if (legendSymbol) {

                     // Apply marker options
                     if (markerOptions &amp;&amp; legendSymbol.isMarker) { // #585
                             symbolAttr.stroke = symbolColor;
                             markerOptions = item.convertAttribs(markerOptions);
                             for (key in markerOptions) {
                                     val = markerOptions[key];
                                     if (val !== UNDEFINED) {
                                             symbolAttr[key] = val;
                                     }
                             }
                     }

                     legendSymbol.attr(symbolAttr);
             }
     },

     /**
 Position the legend item
 @param {Object} item A Series or Point instance
/
     positionItem: function (item) {
             var legend = this,
                     options = legend.options,
                     symbolPadding = options.symbolPadding,
                     ltr = !options.rtl,
                     legendItemPos = item._legendItemPos,
                     itemX = legendItemPos[0],
                     itemY = legendItemPos[1],
                     checkbox = item.checkbox;

             if (item.legendGroup) {
                     item.legendGroup.translate(
                             ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
                             itemY
                     );
             }

             if (checkbox) {
                     checkbox.x = itemX;
                     checkbox.y = itemY;
             }
     },

     /**
 Destroy a single legend item
 @param {Object} item The series or point
/
     destroyItem: function (item) {
             var checkbox = item.checkbox;

             // destroy SVG elements
             each([&#39;legendItem&#39;, &#39;legendLine&#39;, &#39;legendSymbol&#39;, &#39;legendGroup&#39;], function (key) {
                     if (item[key]) {
                             item[key] = item[key].destroy();
                     }
             });

             if (checkbox) {
                     discardElement(item.checkbox);
             }
     },

     /**
 Destroys the legend.
/
     destroy: function () {
             var legend = this,
                     legendGroup = legend.group,
                     box = legend.box;

             if (box) {
                     legend.box = box.destroy();
             }

             if (legendGroup) {
                     legend.group = legendGroup.destroy();
             }
     },

     /**
 Position the checkboxes after the width is determined
/
     positionCheckboxes: function (scrollOffset) {
             var alignAttr = this.group.alignAttr,
                     translateY,
                     clipHeight = this.clipHeight || this.legendHeight;

             if (alignAttr) {
                     translateY = alignAttr.translateY;
                     each(this.allItems, function (item) {
                             var checkbox = item.checkbox,
                                     top;

                             if (checkbox) {
                                     top = (translateY + checkbox.y + (scrollOffset || 0) + 3);
                                     css(checkbox, {
                                             left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
                                             top: top + PX,
                                             display: top &gt; translateY - 6 &amp;&amp; top &lt; translateY + clipHeight - 6 ? &#39;&#39; : NONE
                                     });
                             }
                     });
             }
     },

     /**
 Render the legend title on top of the legend
/
     renderTitle: function () {
             var options = this.options,
                     padding = this.padding,
                     titleOptions = options.title,
                     titleHeight = 0,
                     bBox;

             if (titleOptions.text) {
                     if (!this.title) {
                             this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, &#39;legend-title&#39;)
                                     .attr({ zIndex: 1 })
                                     .css(titleOptions.style)
                                     .add(this.group);
                     }
                     bBox = this.title.getBBox();
                     titleHeight = bBox.height;
                     this.offsetWidth = bBox.width; // #1717
                     this.contentGroup.attr({ translateY: titleHeight });
             }
             this.titleHeight = titleHeight;
     },

     /**
 Render a single specific legend item
 @param {Object} item A series or point
/
     renderItem: function (item) {
             var legend = this,
                     chart = legend.chart,
                     renderer = chart.renderer,
                     options = legend.options,
                     horizontal = options.layout === &#39;horizontal&#39;,
                     symbolWidth = legend.symbolWidth,
                     symbolPadding = options.symbolPadding,
                     itemStyle = legend.itemStyle,
                     itemHiddenStyle = legend.itemHiddenStyle,
                     padding = legend.padding,
                     itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
                     ltr = !options.rtl,
                     itemHeight,
                     widthOption = options.width,
                     itemMarginBottom = options.itemMarginBottom || 0,
                     itemMarginTop = legend.itemMarginTop,
                     initialItemX = legend.initialItemX,
                     bBox,
                     itemWidth,
                     li = item.legendItem,
                     series = item.series &amp;&amp; item.series.drawLegendSymbol ? item.series : item,
                     seriesOptions = series.options,
                     showCheckbox = legend.createCheckboxForItem &amp;&amp; seriesOptions &amp;&amp; seriesOptions.showCheckbox,
                     useHTML = options.useHTML;

             if (!li) { // generate it once, later move it

                     // Generate the group box
                     // A group to hold the symbol and text. Text is to be appended in Legend class.
                     item.legendGroup = renderer.g(&#39;legend-item&#39;)
                             .attr({ zIndex: 1 })
                             .add(legend.scrollGroup);

                     // Generate the list item text and add it to the group
                     item.legendItem = li = renderer.text(
                                     options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item),
                                     ltr ? symbolWidth + symbolPadding : -symbolPadding,
                                     legend.baseline || 0,
                                     useHTML
                             )
                             .css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
                             .attr({
                                     align: ltr ? &#39;left&#39; : &#39;right&#39;,
                                     zIndex: 2
                             })
                             .add(item.legendGroup);

                     // Get the baseline for the first item - the font size is equal for all
                     if (!legend.baseline) {
                             legend.baseline = renderer.fontMetrics(itemStyle.fontSize, li).f + 3 + itemMarginTop;
                             li.attr(&#39;y&#39;, legend.baseline);
                     }

                     // Draw the legend symbol inside the group box
                     series.drawLegendSymbol(legend, item);

                     if (legend.setItemEvents) {
                             legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
                     }                       

                     // Colorize the items
                     legend.colorizeItem(item, item.visible);

                     // add the HTML checkbox on top
                     if (showCheckbox) {
                             legend.createCheckboxForItem(item);                             
                     }
             }

             // calculate the positions for the next line
             bBox = li.getBBox();

             itemWidth = item.checkboxOffset = 
                     options.itemWidth || 
                     item.legendItemWidth || 
                     symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
             legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

             // if the item exceeds the width, start a new line
             if (horizontal &amp;&amp; legend.itemX - initialItemX + itemWidth &gt;
                             (widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
                     legend.itemX = initialItemX;
                     legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
                     legend.lastLineHeight = 0; // reset for next line
             }

             // If the item exceeds the height, start a new column
             /*if (!horizontal &amp;&amp; legend.itemY + options.y + itemHeight &gt; chart.chartHeight - spacingTop - spacingBottom) {
                     legend.itemY = legend.initialItemY;
                     legend.itemX += legend.maxItemWidth;
                     legend.maxItemWidth = 0;
             }*/

             // Set the edge positions
             legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
             legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
             legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

             // cache the position of the newly generated or reordered items
             item._legendItemPos = [legend.itemX, legend.itemY];

             // advance
             if (horizontal) {
                     legend.itemX += itemWidth;

             } else {
                     legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
                     legend.lastLineHeight = itemHeight;
             }

             // the width of the widest item
             legend.offsetWidth = widthOption || mathMax(
                     (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
                     legend.offsetWidth
             );
     },

     /**
 Get all items, which is one item per series for normal series and one item per point
 for pie series.
/
     getAllItems: function () {
             var allItems = [];
             each(this.chart.series, function (series) {
                     var seriesOptions = series.options;

                     // Handle showInLegend. If the series is linked to another series, defaults to false.
                     if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
                             return;
                     }

                     // use points or series for the legend item depending on legendType
                     allItems = allItems.concat(
                                     series.legendItems ||
                                     (seriesOptions.legendType === &#39;point&#39; ?
                                                     series.data :
                                                     series)
                     );
             });
             return allItems;
     },

     /**
 Render the legend. This method can be called both before and after
 chart.render. If called after, it will only rearrange items instead
 of creating new ones.
/
     render: function () {
             var legend = this,
                     chart = legend.chart,
                     renderer = chart.renderer,
                     legendGroup = legend.group,
                     allItems,
                     display,
                     legendWidth,
                     legendHeight,
                     box = legend.box,
                     options = legend.options,
                     padding = legend.padding,
                     legendBorderWidth = options.borderWidth,
                     legendBackgroundColor = options.backgroundColor;

             legend.itemX = legend.initialItemX;
             legend.itemY = legend.initialItemY;
             legend.offsetWidth = 0;
             legend.lastItemY = 0;

             if (!legendGroup) {
                     legend.group = legendGroup = renderer.g(&#39;legend&#39;)
                             .attr({ zIndex: 7 }) 
                             .add();
                     legend.contentGroup = renderer.g()
                             .attr({ zIndex: 1 }) // above background
                             .add(legendGroup);
                     legend.scrollGroup = renderer.g()
                             .add(legend.contentGroup);
             }

             legend.renderTitle();

             // add each series or point
             allItems = legend.getAllItems();

             // sort by legendIndex
             stableSort(allItems, function (a, b) {
                     return ((a.options &amp;&amp; a.options.legendIndex) || 0) - ((b.options &amp;&amp; b.options.legendIndex) || 0);
             });

             // reversed legend
             if (options.reversed) {
                     allItems.reverse();
             }

             legend.allItems = allItems;
             legend.display = display = !!allItems.length;

             // render the items
             each(allItems, function (item) {
                     legend.renderItem(item); 
             });

             // Draw the border
             legendWidth = options.width || legend.offsetWidth;
             legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;

             legendHeight = legend.handleOverflow(legendHeight);

             if (legendBorderWidth || legendBackgroundColor) {
                     legendWidth += padding;
                     legendHeight += padding;

                     if (!box) {
                             legend.box = box = renderer.rect(
                                     0,
                                     0,
                                     legendWidth,
                                     legendHeight,
                                     options.borderRadius,
                                     legendBorderWidth || 0
                             ).attr({
                                     stroke: options.borderColor,
                                     &#39;stroke-width&#39;: legendBorderWidth || 0,
                                     fill: legendBackgroundColor || NONE
                             })
                             .add(legendGroup)
                             .shadow(options.shadow);
                             box.isNew = true;

                     } else if (legendWidth &gt; 0 &amp;&amp; legendHeight &gt; 0) {
                             box[box.isNew ? &#39;attr&#39; : &#39;animate&#39;](
                                     box.crisp({ width: legendWidth, height: legendHeight })
                             );
                             box.isNew = false;
                     }

                     // hide the border if no items
                     box[display ? &#39;show&#39; : &#39;hide&#39;]();
             }

             legend.legendWidth = legendWidth;
             legend.legendHeight = legendHeight;

             // Now that the legend width and height are established, put the items in the 
             // final position
             each(allItems, function (item) {
                     legend.positionItem(item);
             });

             // 1.x compatibility: positioning based on style
             /*var props = [&#39;left&#39;, &#39;right&#39;, &#39;top&#39;, &#39;bottom&#39;],
                     prop,
                     i = 4;
             while (i--) {
                     prop = props[i];
                     if (options.style[prop] &amp;&amp; options.style[prop] !== &#39;auto&#39;) {
                             options[i &lt; 2 ? &#39;align&#39; : &#39;verticalAlign&#39;] = prop;
                             options[i &lt; 2 ? &#39;x&#39; : &#39;y&#39;] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
                     }
             }*/

             if (display) {
                     legendGroup.align(extend({
                             width: legendWidth,
                             height: legendHeight
                     }, options), true, &#39;spacingBox&#39;);
             }

             if (!chart.isResizing) {
                     this.positionCheckboxes();
             }
     },

     /**
 Set up the overflow handling by adding navigation with up and down arrows below the
 legend.
/
     handleOverflow: function (legendHeight) {
             var legend = this,
                     chart = this.chart,
                     renderer = chart.renderer,
                     options = this.options,
                     optionsY = options.y,
                     alignTop = options.verticalAlign === &#39;top&#39;,
                     spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
                     maxHeight = options.maxHeight,
                     clipHeight,
                     clipRect = this.clipRect,
                     navOptions = options.navigation,
                     animation = pick(navOptions.animation, true),
                     arrowSize = navOptions.arrowSize || 12,
                     nav = this.nav,
                     pages = this.pages,
                     lastY,
                     allItems = this.allItems;

             // Adjust the height
             if (options.layout === &#39;horizontal&#39;) {
                     spaceHeight /= 2;
             }
             if (maxHeight) {
                     spaceHeight = mathMin(spaceHeight, maxHeight);
             }

             // Reset the legend height and adjust the clipping rectangle
             pages.length = 0;
             if (legendHeight &gt; spaceHeight &amp;&amp; !options.useHTML) {

                     this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - this.padding, 0);
                     this.currentPage = pick(this.currentPage, 1);
                     this.fullHeight = legendHeight;

                     // Fill pages with Y positions so that the top of each a legend item defines
                     // the scroll top for each page (#2098)
                     each(allItems, function (item, i) {
                             var y = item._legendItemPos[1],
                                     h = mathRound(item.legendItem.getBBox().height),
                                     len = pages.length;

                             if (!len || (y - pages[len - 1] &gt; clipHeight &amp;&amp; (lastY || y) !== pages[len - 1])) {
                                     pages.push(lastY || y);
                                     len++;
                             }

                             if (i === allItems.length - 1 &amp;&amp; y + h - pages[len - 1] &gt; clipHeight) {
                                     pages.push(y);
                             }
                             if (y !== lastY) {
                                     lastY = y;
                             }
                     });

                     // Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
                     if (!clipRect) {
                             clipRect = legend.clipRect = renderer.clipRect(0, this.padding, 9999, 0);
                             legend.contentGroup.clip(clipRect);
                     }
                     clipRect.attr({
                             height: clipHeight
                     });

                     // Add navigation elements
                     if (!nav) {
                             this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
                             this.up = renderer.symbol(&#39;triangle&#39;, 0, 0, arrowSize, arrowSize)
                                     .on(&#39;click&#39;, function () {
                                             legend.scroll(-1, animation);
                                     })
                                     .add(nav);
                             this.pager = renderer.text(&#39;&#39;, 15, 10)
                                     .css(navOptions.style)
                                     .add(nav);
                             this.down = renderer.symbol(&#39;triangle-down&#39;, 0, 0, arrowSize, arrowSize)
                                     .on(&#39;click&#39;, function () {
                                             legend.scroll(1, animation);
                                     })
                                     .add(nav);
                     }

                     // Set initial position
                     legend.scroll(0);

                     legendHeight = spaceHeight;

             } else if (nav) {
                     clipRect.attr({
                             height: chart.chartHeight
                     });
                     nav.hide();
                     this.scrollGroup.attr({
                             translateY: 1
                     });
                     this.clipHeight = 0; // #1379
             }

             return legendHeight;
     },

     /**
 Scroll the legend by a number of pages
 @param {Object} scrollBy
 @param {Object} animation
/
     scroll: function (scrollBy, animation) {
             var pages = this.pages,
                     pageCount = pages.length,
                     currentPage = this.currentPage + scrollBy,
                     clipHeight = this.clipHeight,
                     navOptions = this.options.navigation,
                     activeColor = navOptions.activeColor,
                     inactiveColor = navOptions.inactiveColor,
                     pager = this.pager,
                     padding = this.padding,
                     scrollOffset;

             // When resizing while looking at the last page
             if (currentPage &gt; pageCount) {
                     currentPage = pageCount;
             }

             if (currentPage &gt; 0) {

                     if (animation !== UNDEFINED) {
                             setAnimation(animation, this.chart);
                     }

                     this.nav.attr({
                             translateX: padding,
                             translateY: clipHeight + this.padding + 7 + this.titleHeight,
                             visibility: VISIBLE
                     });
                     this.up.attr({
                                     fill: currentPage === 1 ? inactiveColor : activeColor
                             })
                             .css({
                                     cursor: currentPage === 1 ? &#39;default&#39; : &#39;pointer&#39;
                             });
                     pager.attr({
                             text: currentPage + &#39;/&#39; + pageCount
                     });
                     this.down.attr({
                                     x: 18 + this.pager.getBBox().width, // adjust to text width
                                     fill: currentPage === pageCount ? inactiveColor : activeColor
                             })
                             .css({
                                     cursor: currentPage === pageCount ? &#39;default&#39; : &#39;pointer&#39;
                             });

                     scrollOffset = -pages[currentPage - 1] + this.initialItemY;

                     this.scrollGroup.animate({
                             translateY: scrollOffset
                     });                     

                     this.currentPage = currentPage;
                     this.positionCheckboxes(scrollOffset);
             }

     }</pre>

<p>};</p>

<p>/*</p>

<pre> LegendSymbolMixin
/</pre>

<p>var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {</p>

<pre>     /**
 Get the series&#39; symbol in the legend

 @param {Object} legend The legend object
 @param {Object} item The series (this) or point
/
     drawRectangle: function (legend, item) {
             var symbolHeight = legend.options.symbolHeight || 12;

             item.legendSymbol = this.chart.renderer.rect(
                     0,
                     legend.baseline - 5 - (symbolHeight / 2),
                     legend.symbolWidth,
                     symbolHeight,
                     legend.options.symbolRadius || 0
             ).attr({
                     zIndex: 3
             }).add(item.legendGroup);               

     },

     /**
 Get the series&#39; symbol in the legend. This method should be overridable to create custom 
 symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.

 @param {Object} legend The legend object
/
     drawLineMarker: function (legend) {

             var options = this.options,
                     markerOptions = options.marker,
                     radius,
                     legendOptions = legend.options,
                     legendSymbol,
                     symbolWidth = legend.symbolWidth,
                     renderer = this.chart.renderer,
                     legendItemGroup = this.legendGroup,
                     verticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize, this.legendItem).b * 0.3),
                     attr;

             // Draw the line
             if (options.lineWidth) {
                     attr = {
                             &#39;stroke-width&#39;: options.lineWidth
                     };
                     if (options.dashStyle) {
                             attr.dashstyle = options.dashStyle;
                     }
                     this.legendLine = renderer.path([
                             M,
                             0,
                             verticalCenter,
                             L,
                             symbolWidth,
                             verticalCenter
                     ])
                     .attr(attr)
                     .add(legendItemGroup);
             }

             // Draw the marker
             if (markerOptions &amp;&amp; markerOptions.enabled !== false) {
                     radius = markerOptions.radius;
                     this.legendSymbol = legendSymbol = renderer.symbol(
                             this.symbol,
                             (symbolWidth / 2) - radius,
                             verticalCenter - radius,
                             2 * radius,
                             2 * radius
                     )
                     .add(legendItemGroup);
                     legendSymbol.isMarker = true;
             }
     }</pre>

<p>};</p>

<p>// Workaround for #2030, horizontal legend items not displaying in IE11
Preview, // and for #2580, a similar drawing flaw in Firefox 26. // TODO:
Explore if there&#39;s a general cause for this. The problem may be related
// to nested group elements, as the legend item texts are within 4 group
elements. if (/Trident/7.0/.test(userAgent) || isFirefox) {</p>

<pre>wrap(Legend.prototype, &#39;positionItem&#39;, function (proceed, item) {
        var legend = this,
                runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
                        if (item._legendItemPos) {
                                proceed.call(legend, item);
                        }
                };

        // Do it now, for export and to get checkbox placement
        runPositionItem();

        // Do it after to work around the core issue
        setTimeout(runPositionItem);
});</pre>

<p>} /**</p>

<pre> The chart class
 @param {Object} options
 @param {Function} callback Function to run when the chart has loaded
/</pre>

<p>function Chart() {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">init</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
</pre>

<p>}</p>

<p>Chart.prototype = {</p>

<pre>      /**
  Initialize the chart
 /
      init: function (userOptions, callback) {

              // Handle regular options
              var options,
                      seriesOptions = userOptions.series; // skip merging data points to increase performance

              userOptions.series = null;
              options = merge(defaultOptions, userOptions); // do the merge
              options.series = userOptions.series = seriesOptions; // set back the series data
              this.userOptions = userOptions;

              var optionsChart = options.chart;

              // Create margin &amp; spacing array
              this.margin = this.splashArray(&#39;margin&#39;, optionsChart);
              this.spacing = this.splashArray(&#39;spacing&#39;, optionsChart);

              var chartEvents = optionsChart.events;

              //this.runChartClick = chartEvents &amp;&amp; !!chartEvents.click;
              this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

              this.callback = callback;
              this.isResizing = 0;
              this.options = options;
              //chartTitleOptions = UNDEFINED;
              //chartSubtitleOptions = UNDEFINED;

              this.axes = [];
              this.series = [];
              this.hasCartesianSeries = optionsChart.showAxes;
              //this.axisOffset = UNDEFINED;
              //this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
              //this.inverted = UNDEFINED;
              //this.loadingShown = UNDEFINED;
              //this.container = UNDEFINED;
              //this.chartWidth = UNDEFINED;
              //this.chartHeight = UNDEFINED;
              //this.marginRight = UNDEFINED;
              //this.marginBottom = UNDEFINED;
              //this.containerWidth = UNDEFINED;
              //this.containerHeight = UNDEFINED;
              //this.oldChartWidth = UNDEFINED;
              //this.oldChartHeight = UNDEFINED;

              //this.renderTo = UNDEFINED;
              //this.renderToClone = UNDEFINED;

              //this.spacingBox = UNDEFINED

              //this.legend = UNDEFINED;

              // Elements
              //this.chartBackground = UNDEFINED;
              //this.plotBackground = UNDEFINED;
              //this.plotBGImage = UNDEFINED;
              //this.plotBorder = UNDEFINED;
              //this.loadingDiv = UNDEFINED;
              //this.loadingSpan = UNDEFINED;

              var chart = this,
                      eventType;

              // Add the chart to the global lookup
              chart.index = charts.length;
              charts.push(chart);
              chartCount++;

              // Set up auto resize
              if (optionsChart.reflow !== false) {
                      addEvent(chart, &#39;load&#39;, function () {
                              chart.initReflow();
                      });
              }

              // Chart event handlers
              if (chartEvents) {
                      for (eventType in chartEvents) {
                              addEvent(chart, eventType, chartEvents[eventType]);
                      }
              }

              chart.xAxis = [];
              chart.yAxis = [];

              // Expose methods and variables
              chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
              chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

              chart.firstRender();
      },

      /**
  Initialize an individual series, called internally before render time
 /
      initSeries: function (options) {
              var chart = this,
                      optionsChart = chart.options.chart,
                      type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
                      series,
                      constr = seriesTypes[type];

              // No such series type
              if (!constr) {
                      error(17, true);
              }

              series = new constr();
              series.init(this, options);
              return series;
      },

      /**
  Check whether a given point is within the plot area

  @param {Number} plotX Pixel x relative to the plot area
  @param {Number} plotY Pixel y relative to the plot area
  @param {Boolean} inverted Whether the chart is inverted
 /
      isInsidePlot: function (plotX, plotY, inverted) {
              var x = inverted ? plotY : plotX,
                      y = inverted ? plotX : plotY;

              return x &gt;= 0 &amp;&amp;
                      x &lt;= this.plotWidth &amp;&amp;
                      y &gt;= 0 &amp;&amp;
                      y &lt;= this.plotHeight;
      },

      /**
  Adjust all axes tick amounts
 /
      adjustTickAmounts: function () {
              if (this.options.chart.alignTicks !== false) {
                      each(this.axes, function (axis) {
                              axis.adjustTickAmount();
                      });
              }
              this.maxTicks = null;
      },

      /**
  Redraw legend, axes or series based on updated data

  @param {Boolean|Object} animation Whether to apply animation, and optionally animation
     configuration
 /
      redraw: function (animation) {
              var chart = this,
                      axes = chart.axes,
                      series = chart.series,
                      pointer = chart.pointer,
                      legend = chart.legend,
                      redrawLegend = chart.isDirtyLegend,
                      hasStackedSeries,
                      hasDirtyStacks,
                      hasCartesianSeries = chart.hasCartesianSeries,
                      isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
                      seriesLength = series.length,
                      i = seriesLength,
                      serie,
                      renderer = chart.renderer,
                      isHiddenChart = renderer.isHidden(),
                      afterRedraw = [];

              setAnimation(animation, chart);

              if (isHiddenChart) {
                      chart.cloneRenderTo();
              }

              // Adjust title layout (reflow multiline text)
              chart.layOutTitles();

              // link stacked series
              while (i--) {
                      serie = series[i];

                      if (serie.options.stacking) {
                              hasStackedSeries = true;

                              if (serie.isDirty) {
                                      hasDirtyStacks = true;
                                      break;
                              }
                      }
              }
              if (hasDirtyStacks) { // mark others as dirty
                      i = seriesLength;
                      while (i--) {
                              serie = series[i];
                              if (serie.options.stacking) {
                                      serie.isDirty = true;
                              }
                      }
              }

              // handle updated data in the series
              each(series, function (serie) {
                      if (serie.isDirty) { // prepare the data so axis can read it
                              if (serie.options.legendType === &#39;point&#39;) {
                                      redrawLegend = true;
                              }
                      }
              });

              // handle added or removed series
              if (redrawLegend &amp;&amp; legend.options.enabled) { // series or pie points are added or removed
                      // draw legend graphics
                      legend.render();

                      chart.isDirtyLegend = false;
              }

              // reset stacks
              if (hasStackedSeries) {
                      chart.getStacks();
              }

              if (hasCartesianSeries) {
                      if (!chart.isResizing) {

                              // reset maxTicks
                              chart.maxTicks = null;

                              // set axes scales
                              each(axes, function (axis) {
                                      axis.setScale();
                              });
                      }

                      chart.adjustTickAmounts();
              }

              chart.getMargins(); // #3098

              if (hasCartesianSeries) {
                      // If one axis is dirty, all axes must be redrawn (#792, #2169)
                      each(axes, function (axis) {
                              if (axis.isDirty) {
                                      isDirtyBox = true;
                              }
                      });

                      // redraw axes
                      each(axes, function (axis) {

                              // Fire &#39;afterSetExtremes&#39; only if extremes are set
                              if (axis.isDirtyExtremes) { // #821
                                      axis.isDirtyExtremes = false;
                                      afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
                                              fireEvent(axis, &#39;afterSetExtremes&#39;, extend(axis.eventArgs, axis.getExtremes())); // #747, #751
                                              delete axis.eventArgs;
                                      });
                              }

                              if (isDirtyBox || hasStackedSeries) {
                                      axis.redraw();
                              }
                      });
              }

              // the plot areas size has changed
              if (isDirtyBox) {
                      chart.drawChartBox();
              }

              // redraw affected series
              each(series, function (serie) {
                      if (serie.isDirty &amp;&amp; serie.visible &amp;&amp;
                                      (!serie.isCartesian || serie.xAxis)) { // issue #153
                              serie.redraw();
                      }
              });

              // move tooltip or reset
              if (pointer) {
                      pointer.reset(true);
              }

              // redraw if canvas
              renderer.draw();

              // fire the event
              fireEvent(chart, &#39;redraw&#39;); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw

              if (isHiddenChart) {
                      chart.cloneRenderTo(true);
              }

              // Fire callbacks that are put on hold until after the redraw
              each(afterRedraw, function (callback) {
                      callback.call();
              });
      },

      /**
  Get an axis, series or point object by id.
  @param id {String} The id as given in the configuration options
 /
      get: function (id) {
              var chart = this,
                      axes = chart.axes,
                      series = chart.series;

              var i,
                      j,
                      points;

              // search axes
              for (i = 0; i &lt; axes.length; i++) {
                      if (axes[i].options.id === id) {
                              return axes[i];
                      }
              }

              // search series
              for (i = 0; i &lt; series.length; i++) {
                      if (series[i].options.id === id) {
                              return series[i];
                      }
              }

              // search points
              for (i = 0; i &lt; series.length; i++) {
                      points = series[i].points || [];
                      for (j = 0; j &lt; points.length; j++) {
                              if (points[j].id === id) {
                                      return points[j];
                              }
                      }
              }
              return null;
      },

      /**
  Create the Axis instances based on the config options
 /
      getAxes: function () {
              var chart = this,
                      options = this.options,
                      xAxisOptions = options.xAxis = splat(options.xAxis || {}),
                      yAxisOptions = options.yAxis = splat(options.yAxis || {}),
                      optionsArray,
                      axis;

              // make sure the options are arrays and add some members
              each(xAxisOptions, function (axis, i) {
                      axis.index = i;
                      axis.isX = true;
              });

              each(yAxisOptions, function (axis, i) {
                      axis.index = i;
              });

              // concatenate all axis options into one array
              optionsArray = xAxisOptions.concat(yAxisOptions);

              each(optionsArray, function (axisOptions) {
                      axis = new Axis(chart, axisOptions);
              });

              chart.adjustTickAmounts();
      },

      /**
  Get the currently selected points from all series
 /
      getSelectedPoints: function () {
              var points = [];
              each(this.series, function (serie) {
                      points = points.concat(grep(serie.points || [], function (point) {
                              return point.selected;
                      }));
              });
              return points;
      },

      /**
  Get the currently selected series
 /
      getSelectedSeries: function () {
              return grep(this.series, function (serie) {
                      return serie.selected;
              });
      },

      /**
  Generate stacks for each series and calculate stacks total values
 /
      getStacks: function () {
              var chart = this;

              // reset stacks for each yAxis
              each(chart.yAxis, function (axis) {
                      if (axis.stacks &amp;&amp; axis.hasVisibleSeries) {
                              axis.oldStacks = axis.stacks;
                      }
              });

              each(chart.series, function (series) {
                      if (series.options.stacking &amp;&amp; (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
                              series.stackKey = series.type + pick(series.options.stack, &#39;&#39;);
                      }
              });
      },      

      /**
  Show the title and subtitle of the chart

  @param titleOptions {Object} New title options
  @param subtitleOptions {Object} New subtitle options

 /
      setTitle: function (titleOptions, subtitleOptions, redraw) {
              var chart = this,
                      options = chart.options,
                      chartTitleOptions,
                      chartSubtitleOptions;

              chartTitleOptions = options.title = merge(options.title, titleOptions);
              chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

              // add title and subtitle
              each([
                      [&#39;title&#39;, titleOptions, chartTitleOptions],
                      [&#39;subtitle&#39;, subtitleOptions, chartSubtitleOptions]
              ], function (arr) {
                      var name = arr[0],
                              title = chart[name],
                              titleOptions = arr[1],
                              chartTitleOptions = arr[2];

                      if (title &amp;&amp; titleOptions) {
                              chart[name] = title = title.destroy(); // remove old
                      }

                      if (chartTitleOptions &amp;&amp; chartTitleOptions.text &amp;&amp; !title) {
                              chart[name] = chart.renderer.text(
                                      chartTitleOptions.text,
                                      0,
                                      0,
                                      chartTitleOptions.useHTML
                              )
                              .attr({
                                      align: chartTitleOptions.align,
                                      &#39;class&#39;: PREFIX + name,
                                      zIndex: chartTitleOptions.zIndex || 4
                              })
                              .css(chartTitleOptions.style)
                              .add();
                      }       
              });
              chart.layOutTitles(redraw);
      },

      /**
  Lay out the chart titles and cache the full offset height for use in getMargins
 /
      layOutTitles: function (redraw) {
              var titleOffset = 0,
                      title = this.title,
                      subtitle = this.subtitle,
                      options = this.options,
                      titleOptions = options.title,
                      subtitleOptions = options.subtitle,
                      requiresDirtyBox,
                      renderer = this.renderer,
                      autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

              if (title) {
                      title
                              .css({ width: (titleOptions.width || autoWidth) + PX })
                              .align(extend({ 
                                      y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
                              }, titleOptions), false, &#39;spacingBox&#39;);

                      if (!titleOptions.floating &amp;&amp; !titleOptions.verticalAlign) {
                              titleOffset = title.getBBox().height;
                      }
              }
              if (subtitle) {
                      subtitle
                              .css({ width: (subtitleOptions.width || autoWidth) + PX })
                              .align(extend({ 
                                      y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b 
                              }, subtitleOptions), false, &#39;spacingBox&#39;);

                      if (!subtitleOptions.floating &amp;&amp; !subtitleOptions.verticalAlign) {
                              titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
                      }
              }

              requiresDirtyBox = this.titleOffset !== titleOffset;                            
              this.titleOffset = titleOffset; // used in getMargins

              if (!this.isDirtyBox &amp;&amp; requiresDirtyBox) {
                      this.isDirtyBox = requiresDirtyBox;
                      // Redraw if necessary (#2719, #2744)           
                      if (this.hasRendered &amp;&amp; pick(redraw, true) &amp;&amp; this.isDirtyBox) {
                              this.redraw();
                      }
              }
      },

      /**
  Get chart width and height according to options and container size
 /
      getChartSize: function () {
              var chart = this,
                      optionsChart = chart.options.chart,
                      widthOption = optionsChart.width,
                      heightOption = optionsChart.height,
                      renderTo = chart.renderToClone || chart.renderTo;

              // get inner width and height from jQuery (#824)
              if (!defined(widthOption)) {
                      chart.containerWidth = adapterRun(renderTo, &#39;width&#39;);
              }
              if (!defined(heightOption)) {
                      chart.containerHeight = adapterRun(renderTo, &#39;height&#39;);
              }

              chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
              chart.chartHeight = mathMax(0, pick(heightOption,
                      // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
                      chart.containerHeight &gt; 19 ? chart.containerHeight : 400));
      },

      /**
  Create a clone of the chart&#39;s renderTo div and place it outside the viewport to allow
  size computation on chart.render and chart.redraw
 /
      cloneRenderTo: function (revert) {
              var clone = this.renderToClone,
                      container = this.container;

              // Destroy the clone and bring the container back to the real renderTo div
              if (revert) {
                      if (clone) {
                              this.renderTo.appendChild(container);
                              discardElement(clone);
                              delete this.renderToClone;
                      }

              // Set up the clone
              } else {
                      if (container &amp;&amp; container.parentNode === this.renderTo) {
                              this.renderTo.removeChild(container); // do not clone this
                      }
                      this.renderToClone = clone = this.renderTo.cloneNode(0);
                      css(clone, {
                              position: ABSOLUTE,
                              top: &#39;-9999px&#39;,
                              display: &#39;block&#39; // #833
                      });
                      if (clone.style.setProperty) { // #2631
                              clone.style.setProperty(&#39;display&#39;, &#39;block&#39;, &#39;important&#39;);
                      }
                      doc.body.appendChild(clone);
                      if (container) {
                              clone.appendChild(container);
                      }
              }
      },

      /**
  Get the containing element, determine the size and create the inner container
  div to hold the chart
 /
      getContainer: function () {
              var chart = this,
                      container,
                      optionsChart = chart.options.chart,
                      chartWidth,
                      chartHeight,
                      renderTo,
                      indexAttrName = &#39;data-highcharts-chart&#39;,
                      oldChartIndex,
                      containerId;

              chart.renderTo = renderTo = optionsChart.renderTo;
              containerId = PREFIX + idCounter++;

              if (isString(renderTo)) {
                      chart.renderTo = renderTo = doc.getElementById(renderTo);
              }

              // Display an error if the renderTo is wrong
              if (!renderTo) {
                      error(13, true);
              }

              // If the container already holds a chart, destroy it. The check for hasRendered is there
              // because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
              // attribute and the SVG contents, but not an interactive chart. So in this case,
              // charts[oldChartIndex] will point to the wrong chart if any (#2609).
              oldChartIndex = pInt(attr(renderTo, indexAttrName));
              if (!isNaN(oldChartIndex) &amp;&amp; charts[oldChartIndex] &amp;&amp; charts[oldChartIndex].hasRendered) {
                      charts[oldChartIndex].destroy();
              }               

              // Make a reference to the chart from the div
              attr(renderTo, indexAttrName, chart.index);

              // remove previous chart
              renderTo.innerHTML = &#39;&#39;;

              // If the container doesn&#39;t have an offsetWidth, it has or is a child of a node
              // that has display:none. We need to temporarily move it out to a visible
              // state to determine the size, else the legend and tooltips won&#39;t render
              // properly. The allowClone option is used in sparklines as a micro optimization,
              // saving about 1-2 ms each chart.
              if (!optionsChart.skipClone &amp;&amp; !renderTo.offsetWidth) {
                      chart.cloneRenderTo();
              }

              // get the width and height
              chart.getChartSize();
              chartWidth = chart.chartWidth;
              chartHeight = chart.chartHeight;

              // create the inner container
              chart.container = container = createElement(DIV, {
                              className: PREFIX + &#39;container&#39; +
                                      (optionsChart.className ? &#39; &#39; + optionsChart.className : &#39;&#39;),
                              id: containerId
                      }, extend({
                              position: RELATIVE,
                              overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
                                      // content overflow in IE
                              width: chartWidth + PX,
                              height: chartHeight + PX,
                              textAlign: &#39;left&#39;,
                              lineHeight: &#39;normal&#39;, // #427
                              zIndex: 0, // #1072
                              &#39;-webkit-tap-highlight-color&#39;: &#39;rgba(0,0,0,0)&#39;
                      }, optionsChart.style),
                      chart.renderToClone || renderTo
              );

              // cache the cursor (#1650)
              chart._cursor = container.style.cursor;

              // Initialize the renderer
              chart.renderer =
                      optionsChart.forExport ? // force SVG, used for SVG export
                              new SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :
                              new Renderer(container, chartWidth, chartHeight, optionsChart.style);

              if (useCanVG) {
                      // If we need canvg library, extend and configure the renderer
                      // to get the tracker for translating mouse events
                      chart.renderer.create(chart, container, chartWidth, chartHeight);
              }
      },

      /**
  Calculate margins by rendering axis labels in a preliminary position. Title,
  subtitle and legend have already been rendered at this stage, but will be
  moved into their final positions
 /
      getMargins: function () {
              var chart = this,
                      spacing = chart.spacing,
                      axisOffset,
                      legend = chart.legend,
                      margin = chart.margin,
                      legendOptions = chart.options.legend,
                      legendMargin = pick(legendOptions.margin, 20),
                      legendX = legendOptions.x,
                      legendY = legendOptions.y,
                      align = legendOptions.align,
                      verticalAlign = legendOptions.verticalAlign,
                      titleOffset = chart.titleOffset;

              chart.resetMargins();
              axisOffset = chart.axisOffset;

              // Adjust for title and subtitle
              if (titleOffset &amp;&amp; !defined(margin[0])) {
                      chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
              }

              // Adjust for legend
              if (legend.display &amp;&amp; !legendOptions.floating) {
                      if (align === &#39;right&#39;) { // horizontal alignment handled first
                              if (!defined(margin[1])) {
                                      chart.marginRight = mathMax(
                                              chart.marginRight,
                                              legend.legendWidth - legendX + legendMargin + spacing[1]
                                      );
                              }
                      } else if (align === &#39;left&#39;) {
                              if (!defined(margin[3])) {
                                      chart.plotLeft = mathMax(
                                              chart.plotLeft,
                                              legend.legendWidth + legendX + legendMargin + spacing[3]
                                      );
                              }

                      } else if (verticalAlign === &#39;top&#39;) {
                              if (!defined(margin[0])) {
                                      chart.plotTop = mathMax(
                                              chart.plotTop,
                                              legend.legendHeight + legendY + legendMargin + spacing[0]
                                      );
                              }

                      } else if (verticalAlign === &#39;bottom&#39;) {
                              if (!defined(margin[2])) {
                                      chart.marginBottom = mathMax(
                                              chart.marginBottom,
                                              legend.legendHeight - legendY + legendMargin + spacing[2]
                                      );
                              }
                      }
              }

              // adjust for scroller
              if (chart.extraBottomMargin) {
                      chart.marginBottom += chart.extraBottomMargin;
              }
              if (chart.extraTopMargin) {
                      chart.plotTop += chart.extraTopMargin;
              }

              // pre-render axes to get labels offset width
              if (chart.hasCartesianSeries) {
                      each(chart.axes, function (axis) {
                              axis.getOffset();
                      });
              }

              if (!defined(margin[3])) {
                      chart.plotLeft += axisOffset[3];
              }
              if (!defined(margin[0])) {
                      chart.plotTop += axisOffset[0];
              }
              if (!defined(margin[2])) {
                      chart.marginBottom += axisOffset[2];
              }
              if (!defined(margin[1])) {
                      chart.marginRight += axisOffset[1];
              }

              chart.setChartSize();

      },

      /**
  Resize the chart to its container if size is not explicitly set
 /
      reflow: function (e) {
              var chart = this,
                      optionsChart = chart.options.chart,
                      renderTo = chart.renderTo,
                      width = optionsChart.width || adapterRun(renderTo, &#39;width&#39;),
                      height = optionsChart.height || adapterRun(renderTo, &#39;height&#39;),
                      target = e ? e.target : win, // #805 - MooTools doesn&#39;t supply e
                      doReflow = function () {
                              if (chart.container) { // It may have been destroyed in the meantime (#1257)
                                      chart.setSize(width, height, false);
                                      chart.hasUserSize = null;
                              }
                      };

              // Width and height checks for display:none. Target is doc in IE8 and Opera,
              // win in Firefox, Chrome and IE9.
              if (!chart.hasUserSize &amp;&amp; width &amp;&amp; height &amp;&amp; (target === win || target === doc)) {
                      if (width !== chart.containerWidth || height !== chart.containerHeight) {
                              clearTimeout(chart.reflowTimeout);
                              if (e) { // Called from window.resize
                                      chart.reflowTimeout = setTimeout(doReflow, 100);
                              } else { // Called directly (#2224)
                                      doReflow();
                              }
                      }
                      chart.containerWidth = width;
                      chart.containerHeight = height;
              }
      },

      /**
  Add the event handlers necessary for auto resizing
 /
      initReflow: function () {
              var chart = this,
                      reflow = function (e) {
                              chart.reflow(e);
                      };

              addEvent(win, &#39;resize&#39;, reflow);
              addEvent(chart, &#39;destroy&#39;, function () {
                      removeEvent(win, &#39;resize&#39;, reflow);
              });
      },

      /**
  Resize the chart to a given width and height
  @param {Number} width
  @param {Number} height
  @param {Object|Boolean} animation
 /
      setSize: function (width, height, animation) {
              var chart = this,
                      chartWidth,
                      chartHeight,
                      fireEndResize;

              // Handle the isResizing counter
              chart.isResizing += 1;
              fireEndResize = function () {
                      if (chart) {
                              fireEvent(chart, &#39;endResize&#39;, null, function () {
                                      chart.isResizing -= 1;
                              });
                      }
              };

              // set the animation for the current process
              setAnimation(animation, chart);

              chart.oldChartHeight = chart.chartHeight;
              chart.oldChartWidth = chart.chartWidth;
              if (defined(width)) {
                      chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
                      chart.hasUserSize = !!chartWidth;
              }
              if (defined(height)) {
                      chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
              }

              // Resize the container with the global animation applied if enabled (#2503)
              (globalAnimation ? animate : css)(chart.container, {
                      width: chartWidth + PX,
                      height: chartHeight + PX
              }, globalAnimation);

              chart.setChartSize(true);
              chart.renderer.setSize(chartWidth, chartHeight, animation);

              // handle axes
              chart.maxTicks = null;
              each(chart.axes, function (axis) {
                      axis.isDirty = true;
                      axis.setScale();
              });

              // make sure non-cartesian series are also handled
              each(chart.series, function (serie) {
                      serie.isDirty = true;
              });

              chart.isDirtyLegend = true; // force legend redraw
              chart.isDirtyBox = true; // force redraw of plot and chart border

              chart.layOutTitles(); // #2857
              chart.getMargins();

              chart.redraw(animation);

              chart.oldChartHeight = null;
              fireEvent(chart, &#39;resize&#39;);

              // fire endResize and set isResizing back
              // If animation is disabled, fire without delay
              if (globalAnimation === false) {
                      fireEndResize();
              } else { // else set a timeout with the animation duration
                      setTimeout(fireEndResize, (globalAnimation &amp;&amp; globalAnimation.duration) || 500);
              }
      },

      /**
  Set the public chart properties. This is done before and after the pre-render
  to determine margin sizes
 /
      setChartSize: function (skipAxes) {
              var chart = this,
                      inverted = chart.inverted,
                      renderer = chart.renderer,
                      chartWidth = chart.chartWidth,
                      chartHeight = chart.chartHeight,
                      optionsChart = chart.options.chart,
                      spacing = chart.spacing,
                      clipOffset = chart.clipOffset,
                      clipX,
                      clipY,
                      plotLeft,
                      plotTop,
                      plotWidth,
                      plotHeight,
                      plotBorderWidth;

              chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
              chart.plotTop = plotTop = mathRound(chart.plotTop);
              chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
              chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

              chart.plotSizeX = inverted ? plotHeight : plotWidth;
              chart.plotSizeY = inverted ? plotWidth : plotHeight;

              chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

              // Set boxes used for alignment
              chart.spacingBox = renderer.spacingBox = {
                      x: spacing[3],
                      y: spacing[0],
                      width: chartWidth - spacing[3] - spacing[1],
                      height: chartHeight - spacing[0] - spacing[2]
              };
              chart.plotBox = renderer.plotBox = {
                      x: plotLeft,
                      y: plotTop,
                      width: plotWidth,
                      height: plotHeight
              };

              plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
              clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
              clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
              chart.clipBox = {
                      x: clipX, 
                      y: clipY, 
                      width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), 
                      height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
              };

              if (!skipAxes) {
                      each(chart.axes, function (axis) {
                              axis.setAxisSize();
                              axis.setAxisTranslation();
                      });
              }
      },

      /**
  Initial margins before auto size margins are applied
 /
      resetMargins: function () {
              var chart = this,
                      spacing = chart.spacing,
                      margin = chart.margin;

              chart.plotTop = pick(margin[0], spacing[0]);
              chart.marginRight = pick(margin[1], spacing[1]);
              chart.marginBottom = pick(margin[2], spacing[2]);
              chart.plotLeft = pick(margin[3], spacing[3]);
              chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
              chart.clipOffset = [0, 0, 0, 0];
      },

      /**
  Draw the borders and backgrounds for chart and plot area
 /
      drawChartBox: function () {
              var chart = this,
                      optionsChart = chart.options.chart,
                      renderer = chart.renderer,
                      chartWidth = chart.chartWidth,
                      chartHeight = chart.chartHeight,
                      chartBackground = chart.chartBackground,
                      plotBackground = chart.plotBackground,
                      plotBorder = chart.plotBorder,
                      plotBGImage = chart.plotBGImage,
                      chartBorderWidth = optionsChart.borderWidth || 0,
                      chartBackgroundColor = optionsChart.backgroundColor,
                      plotBackgroundColor = optionsChart.plotBackgroundColor,
                      plotBackgroundImage = optionsChart.plotBackgroundImage,
                      plotBorderWidth = optionsChart.plotBorderWidth || 0,
                      mgn,
                      bgAttr,
                      plotLeft = chart.plotLeft,
                      plotTop = chart.plotTop,
                      plotWidth = chart.plotWidth,
                      plotHeight = chart.plotHeight,
                      plotBox = chart.plotBox,
                      clipRect = chart.clipRect,
                      clipBox = chart.clipBox;

              // Chart area
              mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

              if (chartBorderWidth || chartBackgroundColor) {
                      if (!chartBackground) {

                              bgAttr = {
                                      fill: chartBackgroundColor || NONE
                              };
                              if (chartBorderWidth) { // #980
                                      bgAttr.stroke = optionsChart.borderColor;
                                      bgAttr[&#39;stroke-width&#39;] = chartBorderWidth;
                              }
                              chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
                                              optionsChart.borderRadius, chartBorderWidth)
                                      .attr(bgAttr)
                                      .addClass(PREFIX + &#39;background&#39;)
                                      .add()
                                      .shadow(optionsChart.shadow);

                      } else { // resize
                              chartBackground.animate(
                                      chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
                              );
                      }
              }

              // Plot background
              if (plotBackgroundColor) {
                      if (!plotBackground) {
                              chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
                                      .attr({
                                              fill: plotBackgroundColor
                                      })
                                      .add()
                                      .shadow(optionsChart.plotShadow);
                      } else {
                              plotBackground.animate(plotBox);
                      }
              }
              if (plotBackgroundImage) {
                      if (!plotBGImage) {
                              chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
                                      .add();
                      } else {
                              plotBGImage.animate(plotBox);
                      }
              }

              // Plot clip
              if (!clipRect) {
                      chart.clipRect = renderer.clipRect(clipBox);
              } else {
                      clipRect.animate({
                              width: clipBox.width,
                              height: clipBox.height
                      });
              }

              // Plot area border
              if (plotBorderWidth) {
                      if (!plotBorder) {
                              chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
                                      .attr({
                                              stroke: optionsChart.plotBorderColor,
                                              &#39;stroke-width&#39;: plotBorderWidth,
                                              fill: NONE,
                                              zIndex: 1
                                      })
                                      .add();
                      } else {
                              plotBorder.animate(
                                      plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative
                              );
                      }
              }

              // reset
              chart.isDirtyBox = false;
      },

      /**
  Detect whether a certain chart property is needed based on inspecting its options
  and series. This mainly applies to the chart.invert property, and in extensions to 
  the chart.angular and chart.polar properties.
 /
      propFromSeries: function () {
              var chart = this,
                      optionsChart = chart.options.chart,
                      klass,
                      seriesOptions = chart.options.series,
                      i,
                      value;

              each([&#39;inverted&#39;, &#39;angular&#39;, &#39;polar&#39;], function (key) {

                      // The default series type&#39;s class
                      klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];

                      // Get the value from available chart-wide properties
                      value = (
                              chart[key] || // 1. it is set before
                              optionsChart[key] || // 2. it is set in the options
                              (klass &amp;&amp; klass.prototype[key]) // 3. it&#39;s default series class requires it
                      );

                      // 4. Check if any the chart&#39;s series require it
                      i = seriesOptions &amp;&amp; seriesOptions.length;
                      while (!value &amp;&amp; i--) {
                              klass = seriesTypes[seriesOptions[i].type];
                              if (klass &amp;&amp; klass.prototype[key]) {
                                      value = true;
                              }
                      }

                      // Set the chart property
                      chart[key] = value;     
              });

      },

      /**
  Link two or more series together. This is done initially from Chart.render,
  and after Chart.addSeries and Series.remove.
 /
      linkSeries: function () {
              var chart = this,
                      chartSeries = chart.series;

              // Reset links
              each(chartSeries, function (series) {
                      series.linkedSeries.length = 0;
              });

              // Apply new links
              each(chartSeries, function (series) {
                      var linkedTo = series.options.linkedTo;
                      if (isString(linkedTo)) {
                              if (linkedTo === &#39;:previous&#39;) {
                                      linkedTo = chart.series[series.index - 1];
                              } else {
                                      linkedTo = chart.get(linkedTo);
                              }
                              if (linkedTo) {
                                      linkedTo.linkedSeries.push(series);
                                      series.linkedParent = linkedTo;
                              }
                      }
              });
      },

      /**
  Render series for the chart
 /
      renderSeries: function () {
              each(this.series, function (serie) {
                      serie.translate();
                      if (serie.setTooltipPoints) {
                              serie.setTooltipPoints();
                      }
                      serie.render();
              });
      },

      /**
  Render labels for the chart
 /
      renderLabels: function () {
              var chart = this,
                      labels = chart.options.labels;
              if (labels.items) {
                      each(labels.items, function (label) {
                              var style = extend(labels.style, label.style),
                                      x = pInt(style.left) + chart.plotLeft,
                                      y = pInt(style.top) + chart.plotTop + 12;

                              // delete to prevent rewriting in IE
                              delete style.left;
                              delete style.top;

                              chart.renderer.text(
                                      label.html,
                                      x,
                                      y
                              )
                              .attr({ zIndex: 2 })
                              .css(style)
                              .add();

                      });
              }
      },

      /**
  Render all graphics for the chart
 /
      render: function () {
              var chart = this,
                      axes = chart.axes,
                      renderer = chart.renderer,
                      options = chart.options;

              // Title
              chart.setTitle();

              // Legend
              chart.legend = new Legend(chart, options.legend);

              chart.getStacks(); // render stacks

              // Get margins by pre-rendering axes
              // set axes scales
              each(axes, function (axis) {
                      axis.setScale();
              });

              chart.getMargins();

              chart.maxTicks = null; // reset for second pass
              each(axes, function (axis) {
                      axis.setTickPositions(true); // update to reflect the new margins
                      axis.setMaxTicks();
              });
              chart.adjustTickAmounts();
              chart.getMargins(); // second pass to check for new labels

              // Draw the borders and backgrounds
              chart.drawChartBox();           

              // Axes
              if (chart.hasCartesianSeries) {
                      each(axes, function (axis) {
                              axis.render();
                      });
              }

              // The series
              if (!chart.seriesGroup) {
                      chart.seriesGroup = renderer.g(&#39;series-group&#39;)
                              .attr({ zIndex: 3 })
                              .add();
              }
              chart.renderSeries();

              // Labels
              chart.renderLabels();

              // Credits
              chart.showCredits(options.credits);

              // Set flag
              chart.hasRendered = true;

      },

      /**
  Show chart credits based on config options
 /
      showCredits: function (credits) {
              if (credits.enabled &amp;&amp; !this.credits) {
                      this.credits = this.renderer.text(
                              credits.text,
                              0,
                              0
                      )
                      .on(&#39;click&#39;, function () {
                              if (credits.href) {
                                      location.href = credits.href;
                              }
                      })
                      .attr({
                              align: credits.position.align,
                              zIndex: 8
                      })
                      .css(credits.style)
                      .add()
                      .align(credits.position);
              }
      },

      /**
  Clean up memory usage
 /
      destroy: function () {
              var chart = this,
                      axes = chart.axes,
                      series = chart.series,
                      container = chart.container,
                      i,
                      parentNode = container &amp;&amp; container.parentNode;

              // fire the chart.destoy event
              fireEvent(chart, &#39;destroy&#39;);

              // Delete the chart from charts lookup array
              charts[chart.index] = UNDEFINED;
              chartCount--;
              chart.renderTo.removeAttribute(&#39;data-highcharts-chart&#39;);

              // remove events
              removeEvent(chart);

              // ==== Destroy collections:
              // Destroy axes
              i = axes.length;
              while (i--) {
                      axes[i] = axes[i].destroy();
              }

              // Destroy each series
              i = series.length;
              while (i--) {
                      series[i] = series[i].destroy();
              }

              // ==== Destroy chart properties:
              each([&#39;title&#39;, &#39;subtitle&#39;, &#39;chartBackground&#39;, &#39;plotBackground&#39;, &#39;plotBGImage&#39;, 
                              &#39;plotBorder&#39;, &#39;seriesGroup&#39;, &#39;clipRect&#39;, &#39;credits&#39;, &#39;pointer&#39;, &#39;scroller&#39;, 
                              &#39;rangeSelector&#39;, &#39;legend&#39;, &#39;resetZoomButton&#39;, &#39;tooltip&#39;, &#39;renderer&#39;], function (name) {
                      var prop = chart[name];

                      if (prop &amp;&amp; prop.destroy) {
                              chart[name] = prop.destroy();
                      }
              });

              // remove container and all SVG
              if (container) { // can break in IE when destroyed before finished loading
                      container.innerHTML = &#39;&#39;;
                      removeEvent(container);
                      if (parentNode) {
                              discardElement(container);
                      }

              }

              // clean it all up
              for (i in chart) {
                      delete chart[i];
              }

      },

      /**
  VML namespaces can&#39;t be added until after complete. Listening
  for Perini&#39;s doScroll hack is not enough.
 /
      isReadyToRender: function () {
              var chart = this;

              // Note: in spite of JSLint&#39;s complaints, win == win.top is required
              /*jslint eqeq: true*/
              if ((!hasSVG &amp;&amp; (win == win.top &amp;&amp; doc.readyState !== &#39;complete&#39;)) || (useCanVG &amp;&amp; !win.canvg)) {
              /*jslint eqeq: false*/
                      if (useCanVG) {
                              // Delay rendering until canvg library is downloaded and ready
                              CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);
                      } else {
                              doc.attachEvent(&#39;onreadystatechange&#39;, function () {
                                      doc.detachEvent(&#39;onreadystatechange&#39;, chart.firstRender);
                                      if (doc.readyState === &#39;complete&#39;) {
                                              chart.firstRender();
                                      }
                              });
                      }
                      return false;
              }
              return true;
      },

      /**
  Prepare for first rendering after all data are loaded
 /
      firstRender: function () {
              var chart = this,
                      options = chart.options,
                      callback = chart.callback;

              // Check whether the chart is ready to render
              if (!chart.isReadyToRender()) {
                      return;
              }

              // Create the container
              chart.getContainer();

              // Run an early event after the container and renderer are established
              fireEvent(chart, &#39;init&#39;);

              chart.resetMargins();
              chart.setChartSize();

              // Set the common chart properties (mainly invert) from the given series
              chart.propFromSeries();

              // get axes
              chart.getAxes();

              // Initialize the series
              each(options.series || [], function (serieOptions) {
                      chart.initSeries(serieOptions);
              });

              chart.linkSeries();

              // Run an event after axes and series are initialized, but before render. At this stage,
              // the series data is indexed and cached in the xData and yData arrays, so we can access
              // those before rendering. Used in Highstock. 
              fireEvent(chart, &#39;beforeRender&#39;); 

              // depends on inverted and on margins being set
              if (Highcharts.Pointer) {
                      chart.pointer = new Pointer(chart, options);
              }

              chart.render();

              // add canvas
              chart.renderer.draw();
              // run callbacks
              if (callback) {
                      callback.apply(chart, [chart]);
              }
              each(chart.callbacks, function (fn) {
                      fn.apply(chart, [chart]);
              });

              // If the chart was rendered outside the top container, put it back in
              chart.cloneRenderTo(true);

              fireEvent(chart, &#39;load&#39;);

      },

      /**
 Creates arrays for spacing and margin from given options.
/
      splashArray: function (target, options) {
              var oVar = options[target],
                      tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

              return [pick(options[target + &#39;Top&#39;], tArray[0]),
                              pick(options[target + &#39;Right&#39;], tArray[1]),
                              pick(options[target + &#39;Bottom&#39;], tArray[2]),
                              pick(options[target + &#39;Left&#39;], tArray[3])];
      }</pre>

<p>}; // end Chart</p>

<p>// Hook for exporting module Chart.prototype.callbacks = [];</p>

<p>var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {</p>

<pre>     /**
 Get the center of the pie based on the size and center options relative to the  
 plot area. Borrowed by the polar and gauge series types.
/
     getCenter: function () {

             var options = this.options,
                     chart = this.chart,
                     slicingRoom = 2 * (options.slicedOffset || 0),
                     handleSlicingRoom,
                     plotWidth = chart.plotWidth - 2 * slicingRoom,
                     plotHeight = chart.plotHeight - 2 * slicingRoom,
                     centerOption = options.center,
                     positions = [pick(centerOption[0], &#39;50%&#39;), pick(centerOption[1], &#39;50%&#39;), options.size || &#39;100%&#39;, options.innerSize || 0],
                     smallestSize = mathMin(plotWidth, plotHeight),
                     isPercent;

             return map(positions, function (length, i) {
                     isPercent = /%$/.test(length);
                     handleSlicingRoom = i &lt; 2 || (i === 2 &amp;&amp; isPercent);
                     return (isPercent ?
                             // i == 0: centerX, relative to width
                             // i == 1: centerY, relative to height
                             // i == 2: size, relative to smallestSize
                             // i == 4: innerSize, relative to smallestSize
                             [plotWidth, plotHeight, smallestSize, smallestSize][i] *
                                     pInt(length) / 100 :
                             length) + (handleSlicingRoom ? slicingRoom : 0);
             });
     }</pre>

<p>};</p>

<p>/**</p>

<pre> The Point object and prototype. Inheritable and used as base for PiePoint
/</pre>

<p>var Point = function () {}; Point.prototype = {</p>

<pre>     /**
 Initialize the point
 @param {Object} series The series object containing this point
 @param {Object} options The data in either number, array or object format
/
     init: function (series, options, x) {

             var point = this,
                     colors;
             point.series = series;
             point.applyOptions(options, x);
             point.pointAttr = {};

             if (series.options.colorByPoint) {
                     colors = series.options.colors || series.chart.options.colors;
                     point.color = point.color || colors[series.colorCounter++];
                     // loop back to zero
                     if (series.colorCounter === colors.length) {
                             series.colorCounter = 0;
                     }
             }

             series.chart.pointCount++;
             return point;
     },
     /**
 Apply the options containing the x and y data and possible some extra properties.
 This is called on point init or from point.update.

 @param {Object} options
/
     applyOptions: function (options, x) {
             var point = this,
                     series = point.series,
                     pointValKey = series.options.pointValKey || series.pointValKey;

             options = Point.prototype.optionsToObject.call(this, options);

             // copy options directly to point
             extend(point, options);
             point.options = point.options ? extend(point.options, options) : options;

             // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
             if (pointValKey) {
                     point.y = point[pointValKey];
             }

             // If no x is set by now, get auto incremented value. All points must have an
             // x value, however the y value can be null to create a gap in the series
             if (point.x === UNDEFINED &amp;&amp; series) {
                     point.x = x === UNDEFINED ? series.autoIncrement() : x;
             }

             return point;
     },

     /**
 Transform number or array configs into objects
/
     optionsToObject: function (options) {
             var ret = {},
                     series = this.series,
                     pointArrayMap = series.pointArrayMap || [&#39;y&#39;],
                     valueCount = pointArrayMap.length,
                     firstItemType,
                     i = 0,
                     j = 0;

             if (typeof options === &#39;number&#39; || options === null) {
                     ret[pointArrayMap[0]] = options;

             } else if (isArray(options)) {
                     // with leading x value
                     if (options.length &gt; valueCount) {
                             firstItemType = typeof options[0];
                             if (firstItemType === &#39;string&#39;) {
                                     ret.name = options[0];
                             } else if (firstItemType === &#39;number&#39;) {
                                     ret.x = options[0];
                             }
                             i++;
                     }
                     while (j &lt; valueCount) {
                             ret[pointArrayMap[j++]] = options[i++];
                     }
             } else if (typeof options === &#39;object&#39;) {
                     ret = options;

                     // This is the fastest way to detect if there are individual point dataLabels that need
                     // to be considered in drawDataLabels. These can only occur in object configs.
                     if (options.dataLabels) {
                             series._hasPointLabels = true;
                     }

                     // Same approach as above for markers
                     if (options.marker) {
                             series._hasPointMarkers = true;
                     }
             }
             return ret;
     },

     /**
 Destroy a point to clear memory. Its reference still stays in series.data.
/
     destroy: function () {
             var point = this,
                     series = point.series,
                     chart = series.chart,
                     hoverPoints = chart.hoverPoints,
                     prop;

             chart.pointCount--;

             if (hoverPoints) {
                     point.setState();
                     erase(hoverPoints, point);
                     if (!hoverPoints.length) {
                             chart.hoverPoints = null;
                     }

             }
             if (point === chart.hoverPoint) {
                     point.onMouseOut();
             }

             // remove all events
             if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
                     removeEvent(point);
                     point.destroyElements();
             }

             if (point.legendItem) { // pies have legend items
                     chart.legend.destroyItem(point);
             }

             for (prop in point) {
                     point[prop] = null;
             }

     },

     /**
 Destroy SVG elements associated with the point
/
     destroyElements: function () {
             var point = this,
                     props = [&#39;graphic&#39;, &#39;dataLabel&#39;, &#39;dataLabelUpper&#39;, &#39;group&#39;, &#39;connector&#39;, &#39;shadowGroup&#39;],
                     prop,
                     i = 6;
             while (i--) {
                     prop = props[i];
                     if (point[prop]) {
                             point[prop] = point[prop].destroy();
                     }
             }
     },

     /**
 Return the configuration hash needed for the data label and tooltip formatters
/
     getLabelConfig: function () {
             var point = this;
             return {
                     x: point.category,
                     y: point.y,
                     key: point.name || point.category,
                     series: point.series,
                     point: point,
                     percentage: point.percentage,
                     total: point.total || point.stackTotal
             };
     },      

     /**
 Extendable method for formatting each point&#39;s tooltip line

 @return {String} A string to be concatenated in to the common tooltip text
/
     tooltipFormatter: function (pointFormat) {

             // Insert options for valueDecimals, valuePrefix, and valueSuffix
             var series = this.series,
                     seriesTooltipOptions = series.tooltipOptions,
                     valueDecimals = pick(seriesTooltipOptions.valueDecimals, &#39;&#39;),
                     valuePrefix = seriesTooltipOptions.valuePrefix || &#39;&#39;,
                     valueSuffix = seriesTooltipOptions.valueSuffix || &#39;&#39;;

             // Loop over the point array map and replace unformatted values with sprintf formatting markup
             each(series.pointArrayMap || [&#39;y&#39;], function (key) {
                     key = &#39;{point.&#39; + key; // without the closing bracket
                     if (valuePrefix || valueSuffix) {
                             pointFormat = pointFormat.replace(key + &#39;}&#39;, valuePrefix + key + &#39;}&#39; + valueSuffix);
                     }
                     pointFormat = pointFormat.replace(key + &#39;}&#39;, key + &#39;:,.&#39; + valueDecimals + &#39;f}&#39;);
             });

             return format(pointFormat, {
                     point: this,
                     series: this.series
             });
     },

     /**
 Fire an event on the Point object. Must not be renamed to fireEvent, as this
 causes a name clash in MooTools
 @param {String} eventType
 @param {Object} eventArgs Additional event arguments
 @param {Function} defaultFunction Default event handler
/
     firePointEvent: function (eventType, eventArgs, defaultFunction) {
             var point = this,
                     series = this.series,
                     seriesOptions = series.options;

             // load event handlers on demand to save time on mouseover/out
             if (seriesOptions.point.events[eventType] || (point.options &amp;&amp; point.options.events &amp;&amp; point.options.events[eventType])) {
                     this.importEvents();
             }

             // add default handler if in selection mode
             if (eventType === &#39;click&#39; &amp;&amp; seriesOptions.allowPointSelect) {
                     defaultFunction = function (event) {
                             // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
                             point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                     };
             }

             fireEvent(this, eventType, eventArgs, defaultFunction);
     }</pre>

<p>};/**</p>

<pre> @classDescription The base function which all other series types inherit from. The data in the series is stored
 in various arrays.

 - First, series.options.data contains all the original config options for
 each point whether added by options or methods like series.addPoint.
 - Next, series.data contains those values converted to points, but in case the series data length
 exceeds the cropThreshold, or if the data is grouped, series.data doesn&#39;t contain all the points. It
 only contains the points that have been created on demand.
 - Then there&#39;s series.points that contains all currently visible point objects. In case of cropping,
 the cropped-away points are not part of this array. The series.points array starts at series.cropStart
 compared to series.data and series.options.data. If however the series data is grouped, these can&#39;t
 be correlated one to one.
 - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
 - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.

 @param {Object} chart
 @param {Object} options
/</pre>

<p>var Series = function () {};</p>

<p>Series.prototype = {</p>

<pre>     isCartesian: true,
     type: &#39;line&#39;,
     pointClass: Point,
     sorted: true, // requires the data to be sorted
     requireSorting: true,
     pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
             stroke: &#39;lineColor&#39;,
             &#39;stroke-width&#39;: &#39;lineWidth&#39;,
             fill: &#39;fillColor&#39;,
             r: &#39;radius&#39;
     },
     axisTypes: [&#39;xAxis&#39;, &#39;yAxis&#39;],
     colorCounter: 0,
     parallelArrays: [&#39;x&#39;, &#39;y&#39;], // each point&#39;s x and y values are stored in this.xData and this.yData
     init: function (chart, options) {
             var series = this,
                     eventType,
                     events,
                     chartSeries = chart.series,
                     sortByIndex = function (a, b) {
                             return pick(a.options.index, a._i) - pick(b.options.index, b._i);
                     };

             series.chart = chart;
             series.options = options = series.setOptions(options); // merge with plotOptions
             series.linkedSeries = [];

             // bind the axes
             series.bindAxes();

             // set some variables
             extend(series, {
                     name: options.name,
                     state: NORMAL_STATE,
                     pointAttr: {},
                     visible: options.visible !== false, // true by default
                     selected: options.selected === true // false by default
             });

             // special
             if (useCanVG) {
                     options.animation = false;
             }

             // register event listeners
             events = options.events;
             for (eventType in events) {
                     addEvent(series, eventType, events[eventType]);
             }
             if (
                     (events &amp;&amp; events.click) ||
                     (options.point &amp;&amp; options.point.events &amp;&amp; options.point.events.click) ||
                     options.allowPointSelect
             ) {
                     chart.runTrackerClick = true;
             }

             series.getColor();
             series.getSymbol();

             // Set the data
             each(series.parallelArrays, function (key) {
                     series[key + &#39;Data&#39;] = [];
             });
             series.setData(options.data, false);

             // Mark cartesian
             if (series.isCartesian) {
                     chart.hasCartesianSeries = true;
             }

             // Register it in the chart
             chartSeries.push(series);
             series._i = chartSeries.length - 1;

             // Sort series according to index option (#248, #1123, #2456)
             stableSort(chartSeries, sortByIndex);
             if (this.yAxis) {
                     stableSort(this.yAxis.series, sortByIndex);
             }

             each(chartSeries, function (series, i) {
                     series.index = i;
                     series.name = series.name || &#39;Series &#39; + (i + 1);
             });

     },

     /**
 Set the xAxis and yAxis properties of cartesian series, and register the series
 in the axis.series array
/
     bindAxes: function () {
             var series = this,
                     seriesOptions = series.options,
                     chart = series.chart,
                     axisOptions;

             each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

                     each(chart[AXIS], function (axis) { // loop through the chart&#39;s axis objects
                             axisOptions = axis.options;

                             // apply if the series xAxis or yAxis option mathches the number of the
                             // axis, or if undefined, use the first axis
                             if ((seriesOptions[AXIS] === axisOptions.index) ||
                                             (seriesOptions[AXIS] !== UNDEFINED &amp;&amp; seriesOptions[AXIS] === axisOptions.id) ||
                                             (seriesOptions[AXIS] === UNDEFINED &amp;&amp; axisOptions.index === 0)) {

                                     // register this series in the axis.series lookup
                                     axis.series.push(series);

                                     // set this series.xAxis or series.yAxis reference
                                     series[AXIS] = axis;

                                     // mark dirty for redraw
                                     axis.isDirty = true;
                             }
                     });

                     // The series needs an X and an Y axis
                     if (!series[AXIS] &amp;&amp; series.optionalAxis !== AXIS) {
                             error(18, true);
                     }

             });
     },

     /**
 For simple series types like line and column, the data values are held in arrays like
 xData and yData for quick lookup to find extremes and more. For multidimensional series
 like bubble and map, this can be extended with arrays like zData and valueData by
 adding to the series.parallelArrays array.
/
     updateParallelArrays: function (point, i) {
             var series = point.series,
                     args = arguments,
                     fn = typeof i === &#39;number&#39; ?
                              // Insert the value in the given position
                             function (key) {
                                     var val = key === &#39;y&#39; &amp;&amp; series.toYData ? series.toYData(point) : point[key];
                                     series[key + &#39;Data&#39;][i] = val;
                             } :
                             // Apply the method specified in i with the following arguments as arguments
                             function (key) {
                                     Array.prototype[i].apply(series[key + &#39;Data&#39;], Array.prototype.slice.call(args, 2));
                             };

             each(series.parallelArrays, fn);
     },

     /**
 Return an auto incremented x value based on the pointStart and pointInterval options.
 This is only used if an x value is not given for the point that calls autoIncrement.
/
     autoIncrement: function () {
             var series = this,
                     options = series.options,
                     xIncrement = series.xIncrement;

             xIncrement = pick(xIncrement, options.pointStart, 0);

             series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);

             series.xIncrement = xIncrement + series.pointInterval;
             return xIncrement;
     },

     /**
 Divide the series data into segments divided by null values.
/
     getSegments: function () {
             var series = this,
                     lastNull = -1,
                     segments = [],
                     i,
                     points = series.points,
                     pointsLength = points.length;

             if (pointsLength) { // no action required for []

                     // if connect nulls, just remove null points
                     if (series.options.connectNulls) {
                             i = pointsLength;
                             while (i--) {
                                     if (points[i].y === null) {
                                             points.splice(i, 1);
                                     }
                             }
                             if (points.length) {
                                     segments = [points];
                             }

                     // else, split on null points
                     } else {
                             each(points, function (point, i) {
                                     if (point.y === null) {
                                             if (i &gt; lastNull + 1) {
                                                     segments.push(points.slice(lastNull + 1, i));
                                             }
                                             lastNull = i;
                                     } else if (i === pointsLength - 1) { // last value
                                             segments.push(points.slice(lastNull + 1, i + 1));
                                     }
                             });
                     }
             }

             // register it
             series.segments = segments;
     },

     /**
 Set the series options by merging from the options tree
 @param {Object} itemOptions
/
     setOptions: function (itemOptions) {
             var chart = this.chart,
                     chartOptions = chart.options,
                     plotOptions = chartOptions.plotOptions,
                     userOptions = chart.userOptions || {},
                     userPlotOptions = userOptions.plotOptions || {},
                     typeOptions = plotOptions[this.type],
                     options;

             this.userOptions = itemOptions;

             options = merge(
                     typeOptions,
                     plotOptions.series,
                     itemOptions
             );

             // The tooltip options are merged between global and series specific options
             this.tooltipOptions = merge(
                     defaultOptions.tooltip,
                     defaultOptions.plotOptions[this.type].tooltip,
                     userOptions.tooltip,
                     userPlotOptions.series &amp;&amp; userPlotOptions.series.tooltip,
                     userPlotOptions[this.type] &amp;&amp; userPlotOptions[this.type].tooltip,
                     itemOptions.tooltip
             );

             // Delete marker object if not allowed (#1125)
             if (typeOptions.marker === null) {
                     delete options.marker;
             }

             return options;

     },

     getCyclic: function (prop, value, defaults) {
             var i,
                     userOptions = this.userOptions,
                     indexName = &#39;_&#39; + prop + &#39;Index&#39;,
                     counterName = prop + &#39;Counter&#39;;

             if (!value) {
                     if (defined(userOptions[indexName])) { // after Series.update()
                             i = userOptions[indexName];
                     } else {
                             userOptions[indexName] = i = this.chart[counterName] % defaults.length;
                             this.chart[counterName] += 1;
                     }
                     value = defaults[i];
             }
             this[prop] = value;
     },

     /**
 Get the series&#39; color
/
     getColor: function () {
             if (!this.options.colorByPoint) {
                     this.getCyclic(&#39;color&#39;, this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
             }
     },
     /**
 Get the series&#39; symbol
/
     getSymbol: function () {
             var seriesMarkerOption = this.options.marker;

             this.getCyclic(&#39;symbol&#39;, seriesMarkerOption.symbol, this.chart.options.symbols);

             // don&#39;t substract radius in image symbols (#604)
             if (/^url/.test(this.symbol)) {
                     seriesMarkerOption.radius = 0;
             }
     },

     drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

     /**
 Replace the series data with a new set of data
 @param {Object} data
 @param {Object} redraw
/
     setData: function (data, redraw, animation, updatePoints) {
             var series = this,
                     oldData = series.points,
                     oldDataLength = (oldData &amp;&amp; oldData.length) || 0,
                     dataLength,
                     options = series.options,
                     chart = series.chart,
                     firstPoint = null,
                     xAxis = series.xAxis,
                     hasCategories = xAxis &amp;&amp; !!xAxis.categories,
                     tooltipPoints = series.tooltipPoints,
                     i,
                     turboThreshold = options.turboThreshold,
                     pt,
                     xData = this.xData,
                     yData = this.yData,
                     pointArrayMap = series.pointArrayMap,
                     valueCount = pointArrayMap &amp;&amp; pointArrayMap.length;

             data = data || [];
             dataLength = data.length;
             redraw = pick(redraw, true);

             // If the point count is the same as is was, just run Point.update which is
             // cheaper, allows animation, and keeps references to points.
             if (updatePoints !== false &amp;&amp; dataLength &amp;&amp; oldDataLength === dataLength &amp;&amp; !series.cropped &amp;&amp; !series.hasGroupedData) {
                     each(data, function (point, i) {
                             oldData[i].update(point, false, null, false);
                     });

             } else {

                     // Reset properties
                     series.xIncrement = null;
                     series.pointRange = hasCategories ? 1 : options.pointRange;

                     series.colorCounter = 0; // for series with colorByPoint (#1547)

                     // Update parallel arrays
                     each(this.parallelArrays, function (key) {
                             series[key + &#39;Data&#39;].length = 0;
                     });

                     // In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
                     // first value is tested, and we assume that all the rest are defined the same
                     // way. Although the &#39;for&#39; loops are similar, they are repeated inside each
                     // if-else conditional for max performance.
                     if (turboThreshold &amp;&amp; dataLength &gt; turboThreshold) {

                             // find the first non-null point
                             i = 0;
                             while (firstPoint === null &amp;&amp; i &lt; dataLength) {
                                     firstPoint = data[i];
                                     i++;
                             }

                             if (isNumber(firstPoint)) { // assume all points are numbers
                                     var x = pick(options.pointStart, 0),
                                             pointInterval = pick(options.pointInterval, 1);

                                     for (i = 0; i &lt; dataLength; i++) {
                                             xData[i] = x;
                                             yData[i] = data[i];
                                             x += pointInterval;
                                     }
                                     series.xIncrement = x;
                             } else if (isArray(firstPoint)) { // assume all points are arrays
                                     if (valueCount) { // [x, low, high] or [x, o, h, l, c]
                                             for (i = 0; i &lt; dataLength; i++) {
                                                     pt = data[i];
                                                     xData[i] = pt[0];
                                                     yData[i] = pt.slice(1, valueCount + 1);
                                             }
                                     } else { // [x, y]
                                             for (i = 0; i &lt; dataLength; i++) {
                                                     pt = data[i];
                                                     xData[i] = pt[0];
                                                     yData[i] = pt[1];
                                             }
                                     }
                             } else {
                                     error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
                             }
                     } else {
                             for (i = 0; i &lt; dataLength; i++) {
                                     if (data[i] !== UNDEFINED) { // stray commas in oldIE
                                             pt = { series: series };
                                             series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                                             series.updateParallelArrays(pt, i);
                                             if (hasCategories &amp;&amp; pt.name) {
                                                     xAxis.names[pt.x] = pt.name; // #2046
                                             }
                                     }
                             }
                     }

                     // Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
                     if (isString(yData[0])) {
                             error(14, true);
                     }

                     series.data = [];
                     series.options.data = data;
                     //series.zData = zData;

                     // destroy old points
                     i = oldDataLength;
                     while (i--) {
                             if (oldData[i] &amp;&amp; oldData[i].destroy) {
                                     oldData[i].destroy();
                             }
                     }
                     if (tooltipPoints) { // #2594
                             tooltipPoints.length = 0;
                     }

                     // reset minRange (#878)
                     if (xAxis) {
                             xAxis.minRange = xAxis.userMinRange;
                     }

                     // redraw
                     series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
                     animation = false;
             }

             if (redraw) {
                     chart.redraw(animation);
             }
     },

     /**
 Process the data by cropping away unused data points if the series is longer
 than the crop threshold. This saves computing time for lage series.
/
     processData: function (force) {
             var series = this,
                     processedXData = series.xData, // copied during slice operation below
                     processedYData = series.yData,
                     dataLength = processedXData.length,
                     croppedData,
                     cropStart = 0,
                     cropped,
                     distance,
                     closestPointRange,
                     xAxis = series.xAxis,
                     i, // loop variable
                     options = series.options,
                     cropThreshold = options.cropThreshold,
                     activePointCount = 0,
                     isCartesian = series.isCartesian,
                     xExtremes,
                     min,
                     max;

             // If the series data or axes haven&#39;t changed, don&#39;t go through this. Return false to pass
             // the message on to override methods like in data grouping.
             if (isCartesian &amp;&amp; !series.isDirty &amp;&amp; !xAxis.isDirty &amp;&amp; !series.yAxis.isDirty &amp;&amp; !force) {
                     return false;
             }

             if (xAxis) {
                     xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
                     min = xExtremes.min;
                     max = xExtremes.max;
             }

             // optionally filter out points outside the plot area
             if (isCartesian &amp;&amp; series.sorted &amp;&amp; (!cropThreshold || dataLength &gt; cropThreshold || series.forceCrop)) {

                     // it&#39;s outside current extremes
                     if (processedXData[dataLength - 1] &lt; min || processedXData[0] &gt; max) {
                             processedXData = [];
                             processedYData = [];

                     // only crop if it&#39;s actually spilling out
                     } else if (processedXData[0] &lt; min || processedXData[dataLength - 1] &gt; max) {
                             croppedData = this.cropData(series.xData, series.yData, min, max);
                             processedXData = croppedData.xData;
                             processedYData = croppedData.yData;
                             cropStart = croppedData.start;
                             cropped = true;
                             activePointCount = processedXData.length;
                     }
             }

             // Find the closest distance between processed points
             for (i = processedXData.length - 1; i &gt;= 0; i--) {
                     distance = processedXData[i] - processedXData[i - 1];

                     if (!cropped &amp;&amp; processedXData[i] &gt; min &amp;&amp; processedXData[i] &lt; max) {
                             activePointCount++;
                     }

                     if (distance &gt; 0 &amp;&amp; (closestPointRange === UNDEFINED || distance &lt; closestPointRange)) {
                             closestPointRange = distance;

                     // Unsorted data is not supported by the line tooltip, as well as data grouping and
                     // navigation in Stock charts (#725) and width calculation of columns (#1900)
                     } else if (distance &lt; 0 &amp;&amp; series.requireSorting) {
                             error(15);
                     }
             }

             // Record the properties
             series.cropped = cropped; // undefined or true
             series.cropStart = cropStart;
             series.processedXData = processedXData;
             series.processedYData = processedYData;
             series.activePointCount = activePointCount;

             if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
                     series.pointRange = closestPointRange || 1;
             }
             series.closestPointRange = closestPointRange;

     },

     /**
 Iterate over xData and crop values between min and max. Returns object containing crop start/end
 cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
/
     cropData: function (xData, yData, min, max) {
             var dataLength = xData.length,
                     cropStart = 0,
                     cropEnd = dataLength,
                     cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
                     i;

             // iterate up to find slice start
             for (i = 0; i &lt; dataLength; i++) {
                     if (xData[i] &gt;= min) {
                             cropStart = mathMax(0, i - cropShoulder);
                             break;
                     }
             }

             // proceed to find slice end
             for (; i &lt; dataLength; i++) {
                     if (xData[i] &gt; max) {
                             cropEnd = i + cropShoulder;
                             break;
                     }
             }

             return {
                     xData: xData.slice(cropStart, cropEnd),
                     yData: yData.slice(cropStart, cropEnd),
                     start: cropStart,
                     end: cropEnd
             };
     },

     /**
 Generate the data point after the data has been processed by cropping away
 unused points and optionally grouped in Highcharts Stock.
/
     generatePoints: function () {
             var series = this,
                     options = series.options,
                     dataOptions = options.data,
                     data = series.data,
                     dataLength,
                     processedXData = series.processedXData,
                     processedYData = series.processedYData,
                     pointClass = series.pointClass,
                     processedDataLength = processedXData.length,
                     cropStart = series.cropStart || 0,
                     cursor,
                     hasGroupedData = series.hasGroupedData,
                     point,
                     points = [],
                     i;

             if (!data &amp;&amp; !hasGroupedData) {
                     var arr = [];
                     arr.length = dataOptions.length;
                     data = series.data = arr;
             }

             for (i = 0; i &lt; processedDataLength; i++) {
                     cursor = cropStart + i;
                     if (!hasGroupedData) {
                             if (data[cursor]) {
                                     point = data[cursor];
                             } else if (dataOptions[cursor] !== UNDEFINED) { // #970
                                     data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
                             }
                             points[i] = point;
                     } else {
                             // splat the y data in case of ohlc data array
                             points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
                     }
                     points[i].index = cursor; // For faster access in Point.update
             }

             // Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
             // swithching view from non-grouped data to grouped data (#637)
             if (data &amp;&amp; (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
                     for (i = 0; i &lt; dataLength; i++) {
                             if (i === cropStart &amp;&amp; !hasGroupedData) { // when has grouped data, clear all points
                                     i += processedDataLength;
                             }
                             if (data[i]) {
                                     data[i].destroyElements();
                                     data[i].plotX = UNDEFINED; // #1003
                             }
                     }
             }

             series.data = data;
             series.points = points;
     },

     /**
 Calculate Y extremes for visible data
/
     getExtremes: function (yData) {
             var xAxis = this.xAxis,
                     yAxis = this.yAxis,
                     xData = this.processedXData,
                     yDataLength,
                     activeYData = [],
                     activeCounter = 0,
                     xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
                     xMin = xExtremes.min,
                     xMax = xExtremes.max,
                     validValue,
                     withinRange,
                     dataMin,
                     dataMax,
                     x,
                     y,
                     i,
                     j;

             yData = yData || this.stackedYData || this.processedYData;
             yDataLength = yData.length;

             for (i = 0; i &lt; yDataLength; i++) {

                     x = xData[i];
                     y = yData[i];

                     // For points within the visible range, including the first point outside the
                     // visible range, consider y extremes
                     validValue = y !== null &amp;&amp; y !== UNDEFINED &amp;&amp; (!yAxis.isLog || (y.length || y &gt; 0));
                     withinRange = this.getExtremesFromAll || this.cropped || ((xData[i + 1] || x) &gt;= xMin &amp;&amp;
                             (xData[i - 1] || x) &lt;= xMax);

                     if (validValue &amp;&amp; withinRange) {

                             j = y.length;
                             if (j) { // array, like ohlc or range data
                                     while (j--) {
                                             if (y[j] !== null) {
                                                     activeYData[activeCounter++] = y[j];
                                             }
                                     }
                             } else {
                                     activeYData[activeCounter++] = y;
                             }
                     }
             }
             this.dataMin = pick(dataMin, arrayMin(activeYData));
             this.dataMax = pick(dataMax, arrayMax(activeYData));
     },

     /**
 Translate data points from raw data values to chart specific positioning data
 needed later in drawPoints, drawGraph and drawTracker.
/
     translate: function () {
             if (!this.processedXData) { // hidden series
                     this.processData();
             }
             this.generatePoints();
             var series = this,
                     options = series.options,
                     stacking = options.stacking,
                     xAxis = series.xAxis,
                     categories = xAxis.categories,
                     yAxis = series.yAxis,
                     points = series.points,
                     dataLength = points.length,
                     hasModifyValue = !!series.modifyValue,
                     i,
                     pointPlacement = options.pointPlacement,
                     dynamicallyPlaced = pointPlacement === &#39;between&#39; || isNumber(pointPlacement),
                     threshold = options.threshold;

             // Translate each point
             for (i = 0; i &lt; dataLength; i++) {
                     var point = points[i],
                             xValue = point.x,
                             yValue = point.y,
                             yBottom = point.low,
                             stack = stacking &amp;&amp; yAxis.stacks[(series.negStacks &amp;&amp; yValue &lt; threshold ? &#39;-&#39; : &#39;&#39;) + series.stackKey],
                             pointStack,
                             stackValues;

                     // Discard disallowed y values for log axes
                     if (yAxis.isLog &amp;&amp; yValue &lt;= 0) {
                             point.y = yValue = null;
                             error(10);
                     }

                     // Get the plotX translation
                     point.plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === &#39;flags&#39;); // Math.round fixes #591

                     // Calculate the bottom y value for stacked series
                     if (stacking &amp;&amp; series.visible &amp;&amp; stack &amp;&amp; stack[xValue]) {

                             pointStack = stack[xValue];
                             stackValues = pointStack.points[series.index + &#39;,&#39; + i];
                             yBottom = stackValues[0];
                             yValue = stackValues[1];

                             if (yBottom === 0) {
                                     yBottom = pick(threshold, yAxis.min);
                             }
                             if (yAxis.isLog &amp;&amp; yBottom &lt;= 0) { // #1200, #1232
                                     yBottom = null;
                             }

                             point.total = point.stackTotal = pointStack.total;
                             point.percentage = pointStack.total &amp;&amp; (point.y / pointStack.total * 100);
                             point.stackY = yValue;

                             // Place the stack label
                             pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

                     }

                     // Set translated yBottom or remove it
                     point.yBottom = defined(yBottom) ?
                             yAxis.translate(yBottom, 0, 1, 0, 1) :
                             null;

                     // general hook, used for Highstock compare mode
                     if (hasModifyValue) {
                             yValue = series.modifyValue(yValue, point);
                     }

                     // Set the the plotY value, reset it for redraws
                     point.plotY = (typeof yValue === &#39;number&#39; &amp;&amp; yValue !== Infinity) ?
                             //mathRound(yAxis.translate(yValue, 0, 1, 0, 1) * 10) / 10 : // Math.round fixes #591
                             yAxis.translate(yValue, 0, 1, 0, 1) :
                             UNDEFINED;

                     // Set client related positions for mouse tracking
                     point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : point.plotX; // #1514

                     point.negative = point.y &lt; (threshold || 0);

                     // some API data
                     point.category = categories &amp;&amp; categories[point.x] !== UNDEFINED ?
                             categories[point.x] : point.x;

             }

             // now that we have the cropped data, build the segments
             series.getSegments();
     },

     /**
 Animate in the series
/
     animate: function (init) {
             var series = this,
                     chart = series.chart,
                     renderer = chart.renderer,
                     clipRect,
                     markerClipRect,
                     animation = series.options.animation,
                     clipBox = series.clipBox || chart.clipBox,
                     inverted = chart.inverted,
                     sharedClipKey;

             // Animation option is set to true
             if (animation &amp;&amp; !isObject(animation)) {
                     animation = defaultPlotOptions[series.type].animation;
             }
             sharedClipKey = [&#39;_sharedClip&#39;, animation.duration, animation.easing, clipBox.height].join(&#39;,&#39;);

             // Initialize the animation. Set up the clipping rectangle.
             if (init) {

                     // If a clipping rectangle with the same properties is currently present in the chart, use that.
                     clipRect = chart[sharedClipKey];
                     markerClipRect = chart[sharedClipKey + &#39;m&#39;];
                     if (!clipRect) {
                             chart[sharedClipKey] = clipRect = renderer.clipRect(
                                     extend(clipBox, { width: 0 })
                             );

                             chart[sharedClipKey + &#39;m&#39;] = markerClipRect = renderer.clipRect(
                                     -99, // include the width of the first marker
                                     inverted ? -chart.plotLeft : -chart.plotTop,
                                     99,
                                     inverted ? chart.chartWidth : chart.chartHeight
                             );
                     }
                     series.group.clip(clipRect);
                     series.markerGroup.clip(markerClipRect);
                     series.sharedClipKey = sharedClipKey;

             // Run the animation
             } else {
                     clipRect = chart[sharedClipKey];
                     if (clipRect) {
                             clipRect.animate({
                                     width: chart.plotSizeX
                             }, animation);
                     }
                     if (chart[sharedClipKey + &#39;m&#39;]) {
                             chart[sharedClipKey + &#39;m&#39;].animate({
                                     width: chart.plotSizeX + 99
                             }, animation);
                     }

                     // Delete this function to allow it only once
                     series.animate = null;

             }
     },

     /**
 This runs after animation to land on the final plot clipping
/
     afterAnimate: function () {
             var chart = this.chart,
                     sharedClipKey = this.sharedClipKey,
                     group = this.group,
                     clipBox = this.clipBox;

             if (group &amp;&amp; this.options.clip !== false) {
                     if (!sharedClipKey || !clipBox) {
                             group.clip(clipBox ? chart.renderer.clipRect(clipBox) : chart.clipRect);
                     }
                     this.markerGroup.clip(); // no clip
             }

             fireEvent(this, &#39;afterAnimate&#39;);

             // Remove the shared clipping rectancgle when all series are shown
             setTimeout(function () {
                     if (sharedClipKey &amp;&amp; chart[sharedClipKey]) {
                             if (!clipBox) {
                                     chart[sharedClipKey] = chart[sharedClipKey].destroy();
                             }
                             if (chart[sharedClipKey + &#39;m&#39;]) {
                                     chart[sharedClipKey + &#39;m&#39;] = chart[sharedClipKey + &#39;m&#39;].destroy();
                             }
                     }
             }, 100);
     },

     /**
 Draw the markers
/
     drawPoints: function () {
             var series = this,
                     pointAttr,
                     points = series.points,
                     chart = series.chart,
                     plotX,
                     plotY,
                     i,
                     point,
                     radius,
                     symbol,
                     isImage,
                     graphic,
                     options = series.options,
                     seriesMarkerOptions = options.marker,
                     seriesPointAttr = series.pointAttr[&#39;&#39;],
                     pointMarkerOptions,
                     hasPointMarker,
                     enabled,
                     isInside,
                     markerGroup = series.markerGroup,
                     globallyEnabled = pick(
                             seriesMarkerOptions.enabled, 
                             !series.requireSorting || series.activePointCount &lt; (0.5 * series.xAxis.len / seriesMarkerOptions.radius)
                     );

             if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

                     i = points.length;
                     while (i--) {
                             point = points[i];
                             plotX = mathFloor(point.plotX); // #1843
                             plotY = point.plotY;
                             graphic = point.graphic;
                             pointMarkerOptions = point.marker || {};
                             hasPointMarker = !!point.marker;
                             enabled = (globallyEnabled &amp;&amp; pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
                             isInside = chart.isInsidePlot(mathRound(plotX), plotY, chart.inverted); // #1858

                             // only draw the point if y is defined
                             if (enabled &amp;&amp; plotY !== UNDEFINED &amp;&amp; !isNaN(plotY) &amp;&amp; point.y !== null) {

                                     // shortcuts
                                     pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
                                     radius = pointAttr.r;
                                     symbol = pick(pointMarkerOptions.symbol, series.symbol);
                                     isImage = symbol.indexOf(&#39;url&#39;) === 0;

                                     if (graphic) { // update
                                             graphic[isInside ? &#39;show&#39; : &#39;hide&#39;](true) // Since the marker group isn&#39;t clipped, each individual marker must be toggled
                                                     .animate(extend({
                                                             x: plotX - radius,
                                                             y: plotY - radius
                                                     }, graphic.symbolName ? { // don&#39;t apply to image symbols #507
                                                             width: 2 * radius,
                                                             height: 2 * radius
                                                     } : {}));
                                     } else if (isInside &amp;&amp; (radius &gt; 0 || isImage)) {
                                             point.graphic = graphic = chart.renderer.symbol(
                                                     symbol,
                                                     plotX - radius,
                                                     plotY - radius,
                                                     2 * radius,
                                                     2 * radius,
                                                     hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
                                             )
                                             .attr(pointAttr)
                                             .add(markerGroup);
                                     }

                             } else if (graphic) {
                                     point.graphic = graphic.destroy(); // #1269
                             }
                     }
             }

     },

     /**
 Convert state properties from API naming conventions to SVG attributes

 @param {Object} options API options object
 @param {Object} base1 SVG attribute object to inherit from
 @param {Object} base2 Second level SVG attribute object to inherit from
/
     convertAttribs: function (options, base1, base2, base3) {
             var conversion = this.pointAttrToOptions,
                     attr,
                     option,
                     obj = {};

             options = options || {};
             base1 = base1 || {};
             base2 = base2 || {};
             base3 = base3 || {};

             for (attr in conversion) {
                     option = conversion[attr];
                     obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
             }
             return obj;
     },

     /**
 Get the state attributes. Each series type has its own set of attributes
 that are allowed to change on a point&#39;s state change. Series wide attributes are stored for
 all series, and additionally point specific attributes are stored for all
 points with individual marker options. If such options are not defined for the point,
 a reference to the series wide attributes is stored in point.pointAttr.
/
     getAttribs: function () {
             var series = this,
                     seriesOptions = series.options,
                     normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
                     stateOptions = normalOptions.states,
                     stateOptionsHover = stateOptions[HOVER_STATE],
                     pointStateOptionsHover,
                     seriesColor = series.color,
                     normalDefaults = {
                             stroke: seriesColor,
                             fill: seriesColor
                     },
                     points = series.points || [], // #927
                     i,
                     point,
                     seriesPointAttr = [],
                     pointAttr,
                     pointAttrToOptions = series.pointAttrToOptions,
                     hasPointSpecificOptions = series.hasPointSpecificOptions,
                     negativeColor = seriesOptions.negativeColor,
                     defaultLineColor = normalOptions.lineColor,
                     defaultFillColor = normalOptions.fillColor,
                     turboThreshold = seriesOptions.turboThreshold,
                     attr,
                     key;

             // series type specific modifications
             if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

                     // if no hover radius is given, default to normal radius + 2
                     stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;
                     stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

             } else { // column, bar, pie

                     // if no hover color is given, brighten the normal color
                     stateOptionsHover.color = stateOptionsHover.color ||
                             Color(stateOptionsHover.color || seriesColor)
                                     .brighten(stateOptionsHover.brightness).get();
             }

             // general point attributes for the series normal state
             seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

             // HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
             each([HOVER_STATE, SELECT_STATE], function (state) {
                     seriesPointAttr[state] =
                                     series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
             });

             // set it
             series.pointAttr = seriesPointAttr;

             // Generate the point-specific attribute collections if specific point
             // options are given. If not, create a referance to the series wide point
             // attributes
             i = points.length;
             if (!turboThreshold || i &lt; turboThreshold || hasPointSpecificOptions) {
                     while (i--) {
                             point = points[i];
                             normalOptions = (point.options &amp;&amp; point.options.marker) || point.options;
                             if (normalOptions &amp;&amp; normalOptions.enabled === false) {
                                     normalOptions.radius = 0;
                             }

                             if (point.negative &amp;&amp; negativeColor) {
                                     point.color = point.fillColor = negativeColor;
                             }

                             hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

                             // check if the point has specific visual options
                             if (point.options) {
                                     for (key in pointAttrToOptions) {
                                             if (defined(normalOptions[pointAttrToOptions[key]])) {
                                                     hasPointSpecificOptions = true;
                                             }
                                     }
                             }

                             // a specific marker config object is defined for the individual point:
                             // create it&#39;s own attribute collection
                             if (hasPointSpecificOptions) {
                                     normalOptions = normalOptions || {};
                                     pointAttr = [];
                                     stateOptions = normalOptions.states || {}; // reassign for individual point
                                     pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

                                     // Handle colors for column and pies
                                     if (!seriesOptions.marker) { // column, bar, point
                                             // If no hover color is given, brighten the normal color. #1619, #2579
                                             pointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color &amp;&amp; stateOptionsHover.color) ||
                                                     Color(point.color)
                                                             .brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
                                                             .get();
                                     }

                                     // normal point state inherits series wide normal state
                                     attr = { color: point.color }; // #868
                                     if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
                                             attr.fillColor = point.color;
                                     }
                                     if (!defaultLineColor) {
                                             attr.lineColor = point.color; // Bubbles take point color, line markers use white
                                     }
                                     pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

                                     // inherit from point normal and series hover
                                     pointAttr[HOVER_STATE] = series.convertAttribs(
                                             stateOptions[HOVER_STATE],
                                             seriesPointAttr[HOVER_STATE],
                                             pointAttr[NORMAL_STATE]
                                     );

                                     // inherit from point normal and series hover
                                     pointAttr[SELECT_STATE] = series.convertAttribs(
                                             stateOptions[SELECT_STATE],
                                             seriesPointAttr[SELECT_STATE],
                                             pointAttr[NORMAL_STATE]
                                     );

                             // no marker config object is created: copy a reference to the series-wide
                             // attribute collection
                             } else {
                                     pointAttr = seriesPointAttr;
                             }

                             point.pointAttr = pointAttr;
                     }
             }
     },

     /**
 Clear DOM objects and free up memory
/
     destroy: function () {
             var series = this,
                     chart = series.chart,
                     issue134 = /AppleWebKit\/533/.test(userAgent),
                     destroy,
                     i,
                     data = series.data || [],
                     point,
                     prop,
                     axis;

             // add event hook
             fireEvent(series, &#39;destroy&#39;);

             // remove all events
             removeEvent(series);

             // erase from axes
             each(series.axisTypes || [], function (AXIS) {
                     axis = series[AXIS];
                     if (axis) {
                             erase(axis.series, series);
                             axis.isDirty = axis.forceRedraw = true;
                     }
             });

             // remove legend items
             if (series.legendItem) {
                     series.chart.legend.destroyItem(series);
             }

             // destroy all points with their elements
             i = data.length;
             while (i--) {
                     point = data[i];
                     if (point &amp;&amp; point.destroy) {
                             point.destroy();
                     }
             }
             series.points = null;

             // Clear the animation timeout if we are destroying the series during initial animation
             clearTimeout(series.animationTimeout);

             // destroy all SVGElements associated to the series
             each([&#39;area&#39;, &#39;graph&#39;, &#39;dataLabelsGroup&#39;, &#39;group&#39;, &#39;markerGroup&#39;, &#39;tracker&#39;,
                             &#39;graphNeg&#39;, &#39;areaNeg&#39;, &#39;posClip&#39;, &#39;negClip&#39;], function (prop) {
                     if (series[prop]) {

                             // issue 134 workaround
                             destroy = issue134 &amp;&amp; prop === &#39;group&#39; ?
                                     &#39;hide&#39; :
                                     &#39;destroy&#39;;

                             series[prop][destroy]();
                     }
             });

             // remove from hoverSeries
             if (chart.hoverSeries === series) {
                     chart.hoverSeries = null;
             }
             erase(chart.series, series);

             // clear all members
             for (prop in series) {
                     delete series[prop];
             }
     },

     /**
 Return the graph path of a segment
/
     getSegmentPath: function (segment) {
             var series = this,
                     segmentPath = [],
                     step = series.options.step;

             // build the segment line
             each(segment, function (point, i) {

                     var plotX = point.plotX,
                             plotY = point.plotY,
                             lastPoint;

                     if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
                             segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

                     } else {

                             // moveTo or lineTo
                             segmentPath.push(i ? L : M);

                             // step line?
                             if (step &amp;&amp; i) {
                                     lastPoint = segment[i - 1];
                                     if (step === &#39;right&#39;) {
                                             segmentPath.push(
                                                     lastPoint.plotX,
                                                     plotY
                                             );

                                     } else if (step === &#39;center&#39;) {
                                             segmentPath.push(
                                                     (lastPoint.plotX + plotX) / 2,
                                                     lastPoint.plotY,
                                                     (lastPoint.plotX + plotX) / 2,
                                                     plotY
                                             );

                                     } else {
                                             segmentPath.push(
                                                     plotX,
                                                     lastPoint.plotY
                                             );
                                     }
                             }

                             // normal line to next point
                             segmentPath.push(
                                     point.plotX,
                                     point.plotY
                             );
                     }
             });

             return segmentPath;
     },

     /**
 Get the graph path
/
     getGraphPath: function () {
             var series = this,
                     graphPath = [],
                     segmentPath,
                     singlePoints = []; // used in drawTracker

             // Divide into segments and build graph and area paths
             each(series.segments, function (segment) {

                     segmentPath = series.getSegmentPath(segment);

                     // add the segment to the graph, or a single point for tracking
                     if (segment.length &gt; 1) {
                             graphPath = graphPath.concat(segmentPath);
                     } else {
                             singlePoints.push(segment[0]);
                     }
             });

             // Record it for use in drawGraph and drawTracker, and return graphPath
             series.singlePoints = singlePoints;
             series.graphPath = graphPath;

             return graphPath;

     },

     /**
 Draw the actual graph
/
     drawGraph: function () {
             var series = this,
                     options = this.options,
                     props = [[&#39;graph&#39;, options.lineColor || this.color]],
                     lineWidth = options.lineWidth,
                     dashStyle =  options.dashStyle,
                     roundCap = options.linecap !== &#39;square&#39;,
                     graphPath = this.getGraphPath(),
                     negativeColor = options.negativeColor;

             if (negativeColor) {
                     props.push([&#39;graphNeg&#39;, negativeColor]);
             }

             // draw the graph
             each(props, function (prop, i) {
                     var graphKey = prop[0],
                             graph = series[graphKey],
                             attribs;

                     if (graph) {
                             stop(graph); // cancel running animations, #459
                             graph.animate({ d: graphPath });

                     } else if (lineWidth &amp;&amp; graphPath.length) { // #1487
                             attribs = {
                                     stroke: prop[1],
                                     &#39;stroke-width&#39;: lineWidth,
                                     fill: NONE,
                                     zIndex: 1 // #1069
                             };
                             if (dashStyle) {
                                     attribs.dashstyle = dashStyle;
                             } else if (roundCap) {
                                     attribs[&#39;stroke-linecap&#39;] = attribs[&#39;stroke-linejoin&#39;] = &#39;round&#39;;
                             }

                             series[graphKey] = series.chart.renderer.path(graphPath)
                                     .attr(attribs)
                                     .add(series.group)
                                     .shadow(!i &amp;&amp; options.shadow);
                     }
             });
     },

     /**
 Clip the graphs into the positive and negative coloured graphs
/
     clipNeg: function () {
             var options = this.options,
                     chart = this.chart,
                     renderer = chart.renderer,
                     negativeColor = options.negativeColor || options.negativeFillColor,
                     translatedThreshold,
                     posAttr,
                     negAttr,
                     graph = this.graph,
                     area = this.area,
                     posClip = this.posClip,
                     negClip = this.negClip,
                     chartWidth = chart.chartWidth,
                     chartHeight = chart.chartHeight,
                     chartSizeMax = mathMax(chartWidth, chartHeight),
                     yAxis = this.yAxis,
                     above,
                     below;

             if (negativeColor &amp;&amp; (graph || area)) {
                     translatedThreshold = mathRound(yAxis.toPixels(options.threshold || 0, true));
                     if (translatedThreshold &lt; 0) {
                             chartSizeMax -= translatedThreshold; // #2534
                     }
                     above = {
                             x: 0,
                             y: 0,
                             width: chartSizeMax,
                             height: translatedThreshold
                     };
                     below = {
                             x: 0,
                             y: translatedThreshold,
                             width: chartSizeMax,
                             height: chartSizeMax
                     };

                     if (chart.inverted) {

                             above.height = below.y = chart.plotWidth - translatedThreshold;
                             if (renderer.isVML) {
                                     above = {
                                             x: chart.plotWidth - translatedThreshold - chart.plotLeft,
                                             y: 0,
                                             width: chartWidth,
                                             height: chartHeight
                                     };
                                     below = {
                                             x: translatedThreshold + chart.plotLeft - chartWidth,
                                             y: 0,
                                             width: chart.plotLeft + translatedThreshold,
                                             height: chartWidth
                                     };
                             }
                     }

                     if (yAxis.reversed) {
                             posAttr = below;
                             negAttr = above;
                     } else {
                             posAttr = above;
                             negAttr = below;
                     }

                     if (posClip) { // update
                             posClip.animate(posAttr);
                             negClip.animate(negAttr);
                     } else {

                             this.posClip = posClip = renderer.clipRect(posAttr);
                             this.negClip = negClip = renderer.clipRect(negAttr);

                             if (graph &amp;&amp; this.graphNeg) {
                                     graph.clip(posClip);
                                     this.graphNeg.clip(negClip);
                             }

                             if (area) {
                                     area.clip(posClip);
                                     this.areaNeg.clip(negClip);
                             }
                     }
             }
     },

     /**
 Initialize and perform group inversion on series.group and series.markerGroup
/
     invertGroups: function () {
             var series = this,
                     chart = series.chart;

             // Pie, go away (#1736)
             if (!series.xAxis) {
                     return;
             }

             // A fixed size is needed for inversion to work
             function setInvert() {
                     var size = {
                             width: series.yAxis.len,
                             height: series.xAxis.len
                     };

                     each([&#39;group&#39;, &#39;markerGroup&#39;], function (groupName) {
                             if (series[groupName]) {
                                     series[groupName].attr(size).invert();
                             }
                     });
             }

             addEvent(chart, &#39;resize&#39;, setInvert); // do it on resize
             addEvent(series, &#39;destroy&#39;, function () {
                     removeEvent(chart, &#39;resize&#39;, setInvert);
             });

             // Do it now
             setInvert(); // do it now

             // On subsequent render and redraw, just do setInvert without setting up events again
             series.invertGroups = setInvert;
     },

     /**
 General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
 series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
/
     plotGroup: function (prop, name, visibility, zIndex, parent) {
             var group = this[prop],
                     isNew = !group;

             // Generate it on first call
             if (isNew) {
                     this[prop] = group = this.chart.renderer.g(name)
                             .attr({
                                     visibility: visibility,
                                     zIndex: zIndex || 0.1 // IE8 needs this
                             })
                             .add(parent);
             }
             // Place it on first and subsequent (redraw) calls
             group[isNew ? &#39;attr&#39; : &#39;animate&#39;](this.getPlotBox());
             return group;
     },

     /**
 Get the translation and scale for the plot area of this series
/
     getPlotBox: function () {
             var chart = this.chart,
                     xAxis = this.xAxis,
                     yAxis = this.yAxis;

             // Swap axes for inverted (#2339)
             if (chart.inverted) {
                     xAxis = yAxis;
                     yAxis = this.xAxis;
             }
             return {
                     translateX: xAxis ? xAxis.left : chart.plotLeft,
                     translateY: yAxis ? yAxis.top : chart.plotTop,
                     scaleX: 1, // #1623
                     scaleY: 1
             };
     },

     /**
 Render the graph and markers
/
     render: function () {
             var series = this,
                     chart = series.chart,
                     group,
                     options = series.options,
                     animation = options.animation,
                     // Animation doesn&#39;t work in IE8 quirks when the group div is hidden,
                     // and looks bad in other oldIE
                     animDuration = (animation &amp;&amp; !!series.animate &amp;&amp; chart.renderer.isSVG &amp;&amp; pick(animation.duration, 500)) || 0,
                     visibility = series.visible ? VISIBLE : HIDDEN,
                     zIndex = options.zIndex,
                     hasRendered = series.hasRendered,
                     chartSeriesGroup = chart.seriesGroup;

             // the group
             group = series.plotGroup(
                     &#39;group&#39;,
                     &#39;series&#39;,
                     visibility,
                     zIndex,
                     chartSeriesGroup
             );

             series.markerGroup = series.plotGroup(
                     &#39;markerGroup&#39;,
                     &#39;markers&#39;,
                     visibility,
                     zIndex,
                     chartSeriesGroup
             );

             // initiate the animation
             if (animDuration) {
                     series.animate(true);
             }

             // cache attributes for shapes
             series.getAttribs();

             // SVGRenderer needs to know this before drawing elements (#1089, #1795)
             group.inverted = series.isCartesian ? chart.inverted : false;

             // draw the graph if any
             if (series.drawGraph) {
                     series.drawGraph();
                     series.clipNeg();
             }

             each(series.points, function (point) {
                     if (point.redraw) {
                             point.redraw();
                     }
             });

             // draw the data labels (inn pies they go before the points)
             if (series.drawDataLabels) {
                     series.drawDataLabels();
             }

             // draw the points
             if (series.visible) {
                     series.drawPoints();
             }

             // draw the mouse tracking area
             if (series.drawTracker &amp;&amp; series.options.enableMouseTracking !== false) {
                     series.drawTracker();
             }

             // Handle inverted series and tracker groups
             if (chart.inverted) {
                     series.invertGroups();
             }

             // Initial clipping, must be defined after inverting groups for VML
             if (options.clip !== false &amp;&amp; !series.sharedClipKey &amp;&amp; !hasRendered) {
                     group.clip(chart.clipRect);
             }

             // Run the animation
             if (animDuration) {
                     series.animate();
             } 

             // Call the afterAnimate function on animation complete (but don&#39;t overwrite the animation.complete option
             // which should be available to the user).
             if (!hasRendered) {
                     if (animDuration) {
                             series.animationTimeout = setTimeout(function () {
                                     series.afterAnimate();
                             }, animDuration);
                     } else {
                             series.afterAnimate();
                     }
             }

             series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
             // (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
             series.hasRendered = true;
     },

     /**
 Redraw the series after an update in the axes.
/
     redraw: function () {
             var series = this,
                     chart = series.chart,
                     wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
                     group = series.group,
                     xAxis = series.xAxis,
                     yAxis = series.yAxis;

             // reposition on resize
             if (group) {
                     if (chart.inverted) {
                             group.attr({
                                     width: chart.plotWidth,
                                     height: chart.plotHeight
                             });
                     }

                     group.animate({
                             translateX: pick(xAxis &amp;&amp; xAxis.left, chart.plotLeft),
                             translateY: pick(yAxis &amp;&amp; yAxis.top, chart.plotTop)
                     });
             }

             series.translate();
             if (series.setTooltipPoints) {
                     series.setTooltipPoints(true);
             }
             series.render();

             if (wasDirtyData) {
                     fireEvent(series, &#39;updatedData&#39;);
             }
     }</pre>

<p>}; // end Series prototype</p>

<p>/**</p>

<pre> The class for stack items
/</pre>

<p>function StackItem(axis, options, isNegative, x, stackOption) {</p>

<pre>var inverted = axis.chart.inverted;

this.axis = axis;

// Tells if the stack is negative
this.isNegative = isNegative;

// Save the options to be able to style the label
this.options = options;

// Save the x value to be able to position the label later
this.x = x;

// Initialize total value
this.total = null;

// This will keep each points&#39; extremes stored by series.index and point index
this.points = {};

// Save the stack option on the series configuration object, and whether to treat it as percent
this.stack = stackOption;

// The align options and text align varies on whether the stack is negative and
// if the chart is inverted or not.
// First test the user supplied value, then use the dynamic.
this.alignOptions = {
        align: options.align || (inverted ? (isNegative ? &#39;left&#39; : &#39;right&#39;) : &#39;center&#39;),
        verticalAlign: options.verticalAlign || (inverted ? &#39;middle&#39; : (isNegative ? &#39;bottom&#39; : &#39;top&#39;)),
        y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
        x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
};

this.textAlign = options.textAlign || (inverted ? (isNegative ? &#39;right&#39; : &#39;left&#39;) : &#39;center&#39;);</pre>

<p>}</p>

<p>StackItem.prototype = {</p>

<pre>     destroy: function () {
             destroyObjectProperties(this, this.axis);
     },

     /**
 Renders the stack total label and adds it to the stack label group.
/
     render: function (group) {
             var options = this.options,
                     formatOption = options.format,
                     str = formatOption ?
                             format(formatOption, this) : 
                             options.formatter.call(this);  // format the text in the label

             // Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
             if (this.label) {
                     this.label.attr({text: str, visibility: HIDDEN});
             // Create new label
             } else {
                     this.label =
                             this.axis.chart.renderer.text(str, null, null, options.useHTML)         // dummy positions, actual position updated with setOffset method in columnseries
                                     .css(options.style)                             // apply style
                                     .attr({
                                             align: this.textAlign,                          // fix the text-anchor
                                             rotation: options.rotation,     // rotation
                                             visibility: HIDDEN                                      // hidden until setOffset is called
                                     })                              
                                     .add(group);                                                    // add to the labels-group
             }
     },

     /**
 Sets the offset that the stack has from the x value and repositions the label.
/
     setOffset: function (xOffset, xWidth) {
             var stackItem = this,
                     axis = stackItem.axis,
                     chart = axis.chart,
                     inverted = chart.inverted,
                     neg = this.isNegative,                                                  // special treatment is needed for negative stacks
                     y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
                     yZero = axis.translate(0),                                              // stack origin
                     h = mathAbs(y - yZero),                                                 // stack height
                     x = chart.xAxis[0].translate(this.x) + xOffset, // stack x position
                     plotHeight = chart.plotHeight,
                     stackBox = {    // this is the box for the complete stack
                             x: inverted ? (neg ? y : y - h) : x,
                             y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
                             width: inverted ? h : xWidth,
                             height: inverted ? xWidth : h
                     },
                     label = this.label,
                     alignAttr;

             if (label) {
                     label.align(this.alignOptions, null, stackBox); // align the label to the box

                     // Set visibility (#678)
                     alignAttr = label.alignAttr;
                     label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? &#39;show&#39; : &#39;hide&#39;](true);
             }
     }</pre>

<p>};</p>

<p>// Stacking methods defined on the Axis prototype</p>

<p>/**</p>

<pre> Build the stacks from top down
/</pre>

<p>Axis.prototype.buildStacks = function () {</p>

<pre>var series = this.series,
        reversedStacks = pick(this.options.reversedStacks, true),
        i = series.length;
if (!this.isXAxis) {
        this.usePercentage = false;
        while (i--) {
                series[reversedStacks ? i : series.length - i - 1].setStackedPoints();
        }
        // Loop up again to compute percent stack
        if (this.usePercentage) {
                for (i = 0; i &lt; series.length; i++) {
                        series[i].setPercentStacks();
                }
        }
}</pre>

<p>};</p>

<p>Axis.prototype.renderStackTotals = function () {</p>

<pre>var axis = this,
        chart = axis.chart,
        renderer = chart.renderer,
        stacks = axis.stacks,
        stackKey, 
        oneStack, 
        stackCategory,
        stackTotalGroup = axis.stackTotalGroup;

// Create a separate group for the stack total labels
if (!stackTotalGroup) {
        axis.stackTotalGroup = stackTotalGroup =
                renderer.g(&#39;stack-labels&#39;)
                        .attr({
                                visibility: VISIBLE,
                                zIndex: 6
                        })
                        .add();
}

// plotLeft/Top will change when y axis gets wider so we need to translate the
// stackTotalGroup at every render call. See bug #506 and #516
stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

// Render each stack total
for (stackKey in stacks) {
        oneStack = stacks[stackKey];
        for (stackCategory in oneStack) {
                oneStack[stackCategory].render(stackTotalGroup);
        }
}</pre>

<p>};</p>

<p>// Stacking methods defnied for Series prototype</p>

<p>/**</p>

<pre> Adds series&#39; points value to corresponding stack
/</pre>

<p>Series.prototype.setStackedPoints = function () {</p>

<pre>if (!this.options.stacking || (this.visible !== true &amp;&amp; this.chart.options.chart.ignoreHiddenSeries !== false)) {
        return;
}

var series = this,
        xData = series.processedXData,
        yData = series.processedYData,
        stackedYData = [],
        yDataLength = yData.length,
        seriesOptions = series.options,
        threshold = seriesOptions.threshold,
        stackOption = seriesOptions.stack,
        stacking = seriesOptions.stacking,
        stackKey = series.stackKey,
        negKey = &#39;-&#39; + stackKey,
        negStacks = series.negStacks,
        yAxis = series.yAxis,
        stacks = yAxis.stacks,
        oldStacks = yAxis.oldStacks,
        isNegative,
        stack,
        other,
        key,
        pointKey,
        i,
        x,
        y;

// loop over the non-null y values and read them into a local array
for (i = 0; i &lt; yDataLength; i++) {
        x = xData[i];
        y = yData[i];
        pointKey = series.index + &#39;,&#39; + i;

        // Read stacked values into a stack based on the x value,
        // the sign of y and the stack key. Stacking is also handled for null values (#739)
        isNegative = negStacks &amp;&amp; y &lt; threshold;
        key = isNegative ? negKey : stackKey;

        // Create empty object for this stack if it doesn&#39;t exist yet
        if (!stacks[key]) {
                stacks[key] = {};
        }

        // Initialize StackItem for this x
        if (!stacks[key][x]) {
                if (oldStacks[key] &amp;&amp; oldStacks[key][x]) {
                        stacks[key][x] = oldStacks[key][x];
                        stacks[key][x].total = null;
                } else {
                        stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
                }
        }

        // If the StackItem doesn&#39;t exist, create it first
        stack = stacks[key][x];
        stack.points[pointKey] = [stack.cum || 0];

        // Add value to the stack total
        if (stacking === &#39;percent&#39;) {

                // Percent stacked column, totals are the same for the positive and negative stacks
                other = isNegative ? stackKey : negKey;
                if (negStacks &amp;&amp; stacks[other] &amp;&amp; stacks[other][x]) {
                        other = stacks[other][x];
                        stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

                // Percent stacked areas
                } else {
                        stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
                }
        } else {
                stack.total = correctFloat(stack.total + (y || 0));
        }

        stack.cum = (stack.cum || 0) + (y || 0);

        stack.points[pointKey].push(stack.cum);
        stackedYData[i] = stack.cum;

}

if (stacking === &#39;percent&#39;) {
        yAxis.usePercentage = true;
}

this.stackedYData = stackedYData; // To be used in getExtremes

// Reset old stacks
yAxis.oldStacks = {};</pre>

<p>};</p>

<p>/**</p>

<pre> Iterate over all stacks and compute the absolute values to percent
/</pre>

<p>Series.prototype.setPercentStacks = function () {</p>

<pre>var series = this,
        stackKey = series.stackKey,
        stacks = series.yAxis.stacks,
        processedXData = series.processedXData;

each([stackKey, &#39;-&#39; + stackKey], function (key) {
        var i = processedXData.length,
                x,
                stack,
                pointExtremes,
                totalFactor;

        while (i--) {
                x = processedXData[i];
                stack = stacks[key] &amp;&amp; stacks[key][x];
                pointExtremes = stack &amp;&amp; stack.points[series.index + &#39;,&#39; + i];
                if (pointExtremes) {
                        totalFactor = stack.total ? 100 / stack.total : 0;
                        pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
                        pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
                        series.stackedYData[i] = pointExtremes[1];
                }
        }
});</pre>

<p>};</p>

<p>// Extend the Chart prototype for dynamic methods extend(Chart.prototype, {</p>

<pre>     /**
 Add a series dynamically after  time

 @param {Object} options The config options
 @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
 @param {Boolean|Object} animation Whether to apply animation, and optionally animation
    configuration

 @return {Object} series The newly created series object
/
     addSeries: function (options, redraw, animation) {
             var series,
                     chart = this;

             if (options) {
                     redraw = pick(redraw, true); // defaults to true

                     fireEvent(chart, &#39;addSeries&#39;, { options: options }, function () {
                             series = chart.initSeries(options);

                             chart.isDirtyLegend = true; // the series array is out of sync with the display
                             chart.linkSeries();
                             if (redraw) {
                                     chart.redraw(animation);
                             }
                     });
             }

             return series;
     },

     /**
    Add an axis to the chart
    @param {Object} options The axis option
    @param {Boolean} isX Whether it is an X axis or a value axis
   /
     addAxis: function (options, isX, redraw, animation) {
             var key = isX ? &#39;xAxis&#39; : &#39;yAxis&#39;,
                     chartOptions = this.options,
                     axis;

             /*jslint unused: false*/
             axis = new Axis(this, merge(options, {
                     index: this[key].length,
                     isX: isX
             }));
             /*jslint unused: true*/

             // Push the new axis options to the chart options
             chartOptions[key] = splat(chartOptions[key] || {});
             chartOptions[key].push(options);

             if (pick(redraw, true)) {
                     this.redraw(animation);
             }
     },

     /**
 Dim the chart and show a loading text or symbol
 @param {String} str An optional text to show in the loading label instead of the default one
/
     showLoading: function (str) {
             var chart = this,
                     options = chart.options,
                     loadingDiv = chart.loadingDiv,
                     loadingOptions = options.loading,
                     setLoadingSize = function () {
                             if (loadingDiv) {
                                     css(loadingDiv, {
                                             left: chart.plotLeft + PX,
                                             top: chart.plotTop + PX,
                                             width: chart.plotWidth + PX,
                                             height: chart.plotHeight + PX
                                     });
                             }
                     };

             // create the layer at the first call
             if (!loadingDiv) {
                     chart.loadingDiv = loadingDiv = createElement(DIV, {
                             className: PREFIX + &#39;loading&#39;
                     }, extend(loadingOptions.style, {
                             zIndex: 10,
                             display: NONE
                     }), chart.container);

                     chart.loadingSpan = createElement(
                             &#39;span&#39;,
                             null,
                             loadingOptions.labelStyle,
                             loadingDiv
                     );
                     addEvent(chart, &#39;redraw&#39;, setLoadingSize); // #1080
             }

             // update text
             chart.loadingSpan.innerHTML = str || options.lang.loading;

             // show it
             if (!chart.loadingShown) {
                     css(loadingDiv, {
                             opacity: 0,
                             display: &#39;&#39;                             
                     });
                     animate(loadingDiv, {
                             opacity: loadingOptions.style.opacity
                     }, {
                             duration: loadingOptions.showDuration || 0
                     });
                     chart.loadingShown = true;
             }
             setLoadingSize();
     },

     /**
 Hide the loading layer
/
     hideLoading: function () {
             var options = this.options,
                     loadingDiv = this.loadingDiv;

             if (loadingDiv) {
                     animate(loadingDiv, {
                             opacity: 0
                     }, {
                             duration: options.loading.hideDuration || 100,
                             complete: function () {
                                     css(loadingDiv, { display: NONE });
                             }
                     });
             }
             this.loadingShown = false;
     }</pre>

<p>});</p>

<p>// extend the Point prototype for dynamic methods extend(Point.prototype, {</p>

<pre>     /**
 Update the point with new options (typically x/y data) and optionally redraw the series.

 @param {Object} options Point options as defined in the series.data array
 @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
 @param {Boolean|Object} animation Whether to apply animation, and optionally animation
    configuration

/
     update: function (options, redraw, animation, runEvent) {
             var point = this,
                     series = point.series,
                     graphic = point.graphic,
                     i,
                     chart = series.chart,
                     seriesOptions = series.options;

             redraw = pick(redraw, true);

             function update() {

                     point.applyOptions(options);

                     // Update visuals
                     if (isObject(options) &amp;&amp; !isArray(options)) {
                             // Defer the actual redraw until getAttribs has been called (#3260)
                             point.redraw = function () {
                                     if (graphic) {
                                             if (options &amp;&amp; options.marker &amp;&amp; options.marker.symbol) {
                                                     point.graphic = graphic.destroy();
                                             } else {
                                                     graphic.attr(point.pointAttr[point.state || &#39;&#39;]);
                                             }
                                     }
                                     if (options &amp;&amp; options.dataLabels &amp;&amp; point.dataLabel) { // #2468
                                             point.dataLabel = point.dataLabel.destroy();
                                     }
                                     point.redraw = null;
                             };
                     }

                     // record changes in the parallel arrays
                     i = point.index;
                     series.updateParallelArrays(point, i);

                     seriesOptions.data[i] = point.options;

                     // redraw
                     series.isDirty = series.isDirtyData = true;
                     if (!series.fixedBox &amp;&amp; series.hasCartesianSeries) { // #1906, #2320
                             chart.isDirtyBox = true;
                     }

                     if (seriesOptions.legendType === &#39;point&#39;) { // #1831, #1885
                             chart.legend.destroyItem(point);
                     }
                     if (redraw) {
                             chart.redraw(animation);
                     }
             }

             // Fire the event with a default handler of doing the update
             if (runEvent === false) { // When called from setData
                     update();
             } else {
                     point.firePointEvent(&#39;update&#39;, { options: options }, update);
             }
     },

     /**
 Remove a point and optionally redraw the series and if necessary the axes
 @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
 @param {Boolean|Object} animation Whether to apply animation, and optionally animation
    configuration
/
     remove: function (redraw, animation) {
             var point = this,
                     series = point.series,
                     points = series.points,
                     chart = series.chart,
                     i,
                     data = series.data;

             setAnimation(animation, chart);
             redraw = pick(redraw, true);

             // fire the event with a default handler of removing the point
             point.firePointEvent(&#39;remove&#39;, null, function () {

                     // splice all the parallel arrays
                     i = inArray(point, data);
                     if (data.length === points.length) {
                             points.splice(i, 1);
                     }
                     data.splice(i, 1);
                     series.options.data.splice(i, 1);
                     series.updateParallelArrays(point, &#39;splice&#39;, i, 1);

                     point.destroy();

                     // redraw
                     series.isDirty = true;
                     series.isDirtyData = true;
                     if (redraw) {
                             chart.redraw();
                     }
             });
     }</pre>

<p>});</p>

<p>// Extend the series prototype for dynamic methods extend(Series.prototype,
{</p>

<pre>     /**
 Add a point dynamically after chart load time
 @param {Object} options Point options as given in series.data
 @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
 @param {Boolean} shift If shift is true, a point is shifted off the start
    of the series as one is appended to the end.
 @param {Boolean|Object} animation Whether to apply animation, and optionally animation
    configuration
/
     addPoint: function (options, redraw, shift, animation) {
             var series = this,
                     seriesOptions = series.options,
                     data = series.data,
                     graph = series.graph,
                     area = series.area,
                     chart = series.chart,
                     names = series.xAxis &amp;&amp; series.xAxis.names,
                     currentShift = (graph &amp;&amp; graph.shift) || 0,
                     dataOptions = seriesOptions.data,
                     point,
                     isInTheMiddle,
                     xData = series.xData,
                     x,
                     i;

             setAnimation(animation, chart);

             // Make graph animate sideways
             if (shift) {
                     each([graph, area, series.graphNeg, series.areaNeg], function (shape) {
                             if (shape) {
                                     shape.shift = currentShift + 1;
                             }
                     });
             }
             if (area) {
                     area.isArea = true; // needed in animation, both with and without shift
             }

             // Optional redraw, defaults to true
             redraw = pick(redraw, true);

             // Get options and push the point to xData, yData and series.options. In series.generatePoints
             // the Point instance will be created on demand and pushed to the series.data array.
             point = { series: series };
             series.pointClass.prototype.applyOptions.apply(point, [options]);
             x = point.x;

             // Get the insertion point
             i = xData.length;
             if (series.requireSorting &amp;&amp; x &lt; xData[i - 1]) {
                     isInTheMiddle = true;
                     while (i &amp;&amp; xData[i - 1] &gt; x) {
                             i--;
                     }
             }

             series.updateParallelArrays(point, &#39;splice&#39;, i, 0, 0); // insert undefined item
             series.updateParallelArrays(point, i); // update it

             if (names &amp;&amp; point.name) {
                     names[x] = point.name;
             }
             dataOptions.splice(i, 0, options);

             if (isInTheMiddle) {
                     series.data.splice(i, 0, null);
                     series.processData();
             }

             // Generate points to be added to the legend (#1329)
             if (seriesOptions.legendType === &#39;point&#39;) {
                     series.generatePoints();
             }

             // Shift the first point off the parallel arrays
             // todo: consider series.removePoint(i) method
             if (shift) {
                     if (data[0] &amp;&amp; data[0].remove) {
                             data[0].remove(false);
                     } else {
                             data.shift();
                             series.updateParallelArrays(point, &#39;shift&#39;);

                             dataOptions.shift();
                     }
             }

             // redraw
             series.isDirty = true;
             series.isDirtyData = true;
             if (redraw) {
                     series.getAttribs(); // #1937
                     chart.redraw();
             }
     },

     /**
 Remove a series and optionally redraw the chart

 @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
 @param {Boolean|Object} animation Whether to apply animation, and optionally animation
    configuration
/

     remove: function (redraw, animation) {
             var series = this,
                     chart = series.chart;
             redraw = pick(redraw, true);

             if (!series.isRemoving) {  /* prevent triggering native event in jQuery
                             (calling the remove function from the remove event) */
                     series.isRemoving = true;

                     // fire the event with a default handler of removing the point
                     fireEvent(series, &#39;remove&#39;, null, function () {

                             // destroy elements
                             series.destroy();

                             // redraw
                             chart.isDirtyLegend = chart.isDirtyBox = true;
                             chart.linkSeries();

                             if (redraw) {
                                     chart.redraw(animation);
                             }
                     });

             }
             series.isRemoving = false;
     },

     /**
 Update the series with a new set of options
/
     update: function (newOptions, redraw) {
             var series = this,
                     chart = this.chart,
                     // must use user options when changing type because this.options is merged
                     // in with type specific plotOptions
                     oldOptions = this.userOptions,
                     oldType = this.type,
                     proto = seriesTypes[oldType].prototype,
                     preserve = [&#39;group&#39;, &#39;markerGroup&#39;, &#39;dataLabelsGroup&#39;],
                     n;

             // Make sure groups are not destroyed (#3094)
             each(preserve, function (prop) {
                     preserve[prop] = series[prop];
                     delete series[prop];
             });

             // Do the merge, with some forced options
             newOptions = merge(oldOptions, {
                     animation: false,
                     index: this.index,
                     pointStart: this.xData[0] // when updating after addPoint
             }, { data: this.options.data }, newOptions);

             // Destroy the series and reinsert methods from the type prototype
             this.remove(false);
             for (n in proto) { // Overwrite series-type specific methods (#2270)
                     if (proto.hasOwnProperty(n)) {
                             this[n] = UNDEFINED;
                     }
             }
             extend(this, seriesTypes[newOptions.type || oldType].prototype);

             // Re-register groups (#3094)
             each(preserve, function (prop) {
                     series[prop] = preserve[prop];
             });

             this.init(chart, newOptions);
             chart.linkSeries(); // Links are lost in this.remove (#3028)
             if (pick(redraw, true)) {
                     chart.redraw(false);
             }
     }</pre>

<p>});</p>

<p>// Extend the Axis.prototype for dynamic methods extend(Axis.prototype, {</p>

<pre>     /**
 Update the axis with a new options structure
/
     update: function (newOptions, redraw) {
             var chart = this.chart;

             newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

             this.destroy(true);
             this._addedPlotLB = UNDEFINED; // #1611, #2887

             this.init(chart, extend(newOptions, { events: UNDEFINED }));

             chart.isDirtyBox = true;
             if (pick(redraw, true)) {
                     chart.redraw();
             }
     },

     /**
    Remove the axis from the chart
   /
     remove: function (redraw) {
             var chart = this.chart,
                     key = this.coll, // xAxis or yAxis
                     axisSeries = this.series,
                     i = axisSeries.length;

             // Remove associated series (#2687)
             while (i--) {
                     if (axisSeries[i]) {
                             axisSeries[i].remove(false);
                     }
             }

             // Remove the axis
             erase(chart.axes, this);
             erase(chart[key], this);
             chart.options[key].splice(this.options.index, 1);
             each(chart[key], function (axis, i) { // Re-index, #1706
                     axis.options.index = i;
             });
             this.destroy();
             chart.isDirtyBox = true;

             if (pick(redraw, true)) {
                     chart.redraw();
             }
     },

     /**
 Update the axis title by options
/
     setTitle: function (newTitleOptions, redraw) {
             this.update({ title: newTitleOptions }, redraw);
     },

     /**
 Set new axis categories and optionally redraw
 @param {Array} categories
 @param {Boolean} redraw
/
     setCategories: function (categories, redraw) {
             this.update({ categories: categories }, redraw);
     }</pre>

<p>});</p>

<p>/**</p>

<pre> LineSeries object
/</pre>

<p>var LineSeries = extendClass(Series); seriesTypes.line = LineSeries;</p>

<p>/**</p>

<pre> Set the default options for area
/</pre>

<p>defaultPlotOptions.area = merge(defaultSeriesOptions, {</p>

<pre>threshold: 0
// trackByArea: false,
// lineColor: null, // overrides color, but lets fillColor be unaltered
// fillOpacity: 0.75,
// fillColor: null</pre>

<p>});</p>

<p>/**</p>

<pre> AreaSeries object
/</pre>

<p>var AreaSeries = extendClass(Series, {</p>

<pre>     type: &#39;area&#39;,
     /**
 For stacks, don&#39;t split segments on null values. Instead, draw null values with 
 no marker. Also insert dummy points for any X position that exists in other series
 in the stack.
/ 
     getSegments: function () {
             var series = this,
                     segments = [],
                     segment = [],
                     keys = [],
                     xAxis = this.xAxis,
                     yAxis = this.yAxis,
                     stack = yAxis.stacks[this.stackKey],
                     pointMap = {},
                     plotX,
                     plotY,
                     points = this.points,
                     connectNulls = this.options.connectNulls,
                     i,
                     x;

             if (this.options.stacking &amp;&amp; !this.cropped) { // cropped causes artefacts in Stock, and perf issue
                     // Create a map where we can quickly look up the points by their X value.
                     for (i = 0; i &lt; points.length; i++) {
                             pointMap[points[i].x] = points[i];
                     }

                     // Sort the keys (#1651)
                     for (x in stack) {
                             if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
                                     keys.push(+x);
                             }
                     }
                     keys.sort(function (a, b) {
                             return a - b;
                     });

                     each(keys, function (x) {
                             var y = 0,
                                     stackPoint;

                             if (connectNulls &amp;&amp; (!pointMap[x] || pointMap[x].y === null)) { // #1836
                                     return;

                             // The point exists, push it to the segment
                             } else if (pointMap[x]) {
                                     segment.push(pointMap[x]);

                             // There is no point for this X value in this series, so we 
                             // insert a dummy point in order for the areas to be drawn
                             // correctly.
                             } else {

                                     // Loop down the stack to find the series below this one that has
                                     // a value (#1991)
                                     for (i = series.index; i &lt;= yAxis.series.length; i++) {
                                             stackPoint = stack[x].points[i + &#39;,&#39; + x];
                                             if (stackPoint) {
                                                     y = stackPoint[1];
                                                     break;
                                             }
                                     }

                                     plotX = xAxis.translate(x);
                                     plotY = yAxis.toPixels(y, true);
                                     segment.push({ 
                                             y: null, 
                                             plotX: plotX,
                                             clientX: plotX, 
                                             plotY: plotY, 
                                             yBottom: plotY,
                                             onMouseOver: noop
                                     });
                             }
                     });

                     if (segment.length) {
                             segments.push(segment);
                     }

             } else {
                     Series.prototype.getSegments.call(this);
                     segments = this.segments;
             }

             this.segments = segments;
     },

     /**
 Extend the base Series getSegmentPath method by adding the path for the area.
 This path is pushed to the series.areaPath property.
/
     getSegmentPath: function (segment) {

             var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method
                     areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path
                     i,
                     options = this.options,
                     segLength = segmentPath.length,
                     translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181
                     yBottom;

             if (segLength === 3) { // for animation from 1 to two points
                     areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
             }
             if (options.stacking &amp;&amp; !this.closedStacks) {

                     // Follow stack back. Todo: implement areaspline. A general solution could be to 
                     // reverse the entire graphPath of the previous series, though may be hard with
                     // splines and with series with different extremes
                     for (i = segment.length - 1; i &gt;= 0; i--) {

                             yBottom = pick(segment[i].yBottom, translatedThreshold);

                             // step line?
                             if (i &lt; segment.length - 1 &amp;&amp; options.step) {
                                     areaSegmentPath.push(segment[i + 1].plotX, yBottom);
                             }

                             areaSegmentPath.push(segment[i].plotX, yBottom);
                     }

             } else { // follow zero line back
                     this.closeSegment(areaSegmentPath, segment, translatedThreshold);
             }
             this.areaPath = this.areaPath.concat(areaSegmentPath);
             return segmentPath;
     },

     /**
 Extendable method to close the segment path of an area. This is overridden in polar 
 charts.
/
     closeSegment: function (path, segment, translatedThreshold) {
             path.push(
                     L,
                     segment[segment.length - 1].plotX,
                     translatedThreshold,
                     L,
                     segment[0].plotX,
                     translatedThreshold
             );
     },

     /**
 Draw the graph and the underlying area. This method calls the Series base
 function and adds the area. The areaPath is calculated in the getSegmentPath
 method called from Series.prototype.drawGraph.
/
     drawGraph: function () {

             // Define or reset areaPath
             this.areaPath = [];

             // Call the base method
             Series.prototype.drawGraph.apply(this);

             // Define local variables
             var series = this,
                     areaPath = this.areaPath,
                     options = this.options,
                     negativeColor = options.negativeColor,
                     negativeFillColor = options.negativeFillColor,
                     props = [[&#39;area&#39;, this.color, options.fillColor]]; // area name, main color, fill color

             if (negativeColor || negativeFillColor) {
                     props.push([&#39;areaNeg&#39;, negativeColor, negativeFillColor]);
             }

             each(props, function (prop) {
                     var areaKey = prop[0],
                             area = series[areaKey];

                     // Create or update the area
                     if (area) { // update
                             area.animate({ d: areaPath });

                     } else { // create
                             series[areaKey] = series.chart.renderer.path(areaPath)
                                     .attr({
                                             fill: pick(
                                                     prop[2],
                                                     Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()
                                             ),
                                             zIndex: 0 // #1069
                                     }).add(series.group);
                     }
             });
     },

     drawLegendSymbol: LegendSymbolMixin.drawRectangle</pre>

<p>});</p>

<p>seriesTypes.area = AreaSeries; /**</p>

<pre> Set the default options for spline
/</pre>

<p>defaultPlotOptions.spline = merge(defaultSeriesOptions);</p>

<p>/**</p>

<pre> SplineSeries object
/</pre>

<p>var SplineSeries = extendClass(Series, {</p>

<pre>     type: &#39;spline&#39;,

     /**
 Get the spline segment from a given point&#39;s previous neighbour to the given point
/
     getPointSpline: function (segment, point, i) {
             var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
                     denom = smoothing + 1,
                     plotX = point.plotX,
                     plotY = point.plotY,
                     lastPoint = segment[i - 1],
                     nextPoint = segment[i + 1],
                     leftContX,
                     leftContY,
                     rightContX,
                     rightContY,
                     ret;

             // find control points
             if (lastPoint &amp;&amp; nextPoint) {

                     var lastX = lastPoint.plotX,
                             lastY = lastPoint.plotY,
                             nextX = nextPoint.plotX,
                             nextY = nextPoint.plotY,
                             correction;

                     leftContX = (smoothing * plotX + lastX) / denom;
                     leftContY = (smoothing * plotY + lastY) / denom;
                     rightContX = (smoothing * plotX + nextX) / denom;
                     rightContY = (smoothing * plotY + nextY) / denom;

                     // have the two control points make a straight line through main point
                     correction = ((rightContY - leftContY) * (rightContX - plotX)) /
                             (rightContX - leftContX) + plotY - rightContY;

                     leftContY += correction;
                     rightContY += correction;

                     // to prevent false extremes, check that control points are between
                     // neighbouring points&#39; y values
                     if (leftContY &gt; lastY &amp;&amp; leftContY &gt; plotY) {
                             leftContY = mathMax(lastY, plotY);
                             rightContY = 2 * plotY - leftContY; // mirror of left control point
                     } else if (leftContY &lt; lastY &amp;&amp; leftContY &lt; plotY) {
                             leftContY = mathMin(lastY, plotY);
                             rightContY = 2 * plotY - leftContY;
                     }
                     if (rightContY &gt; nextY &amp;&amp; rightContY &gt; plotY) {
                             rightContY = mathMax(nextY, plotY);
                             leftContY = 2 * plotY - rightContY;
                     } else if (rightContY &lt; nextY &amp;&amp; rightContY &lt; plotY) {
                             rightContY = mathMin(nextY, plotY);
                             leftContY = 2 * plotY - rightContY;
                     }

                     // record for drawing in next point
                     point.rightContX = rightContX;
                     point.rightContY = rightContY;

             }

             // Visualize control points for debugging
             /*
             if (leftContX) {
                     this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
                             .attr({
                                     stroke: &#39;red&#39;,
                                     &#39;stroke-width&#39;: 1,
                                     fill: &#39;none&#39;
                             })
                             .add();
                     this.chart.renderer.path([&#39;M&#39;, leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
                             &#39;L&#39;, plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
                             .attr({
                                     stroke: &#39;red&#39;,
                                     &#39;stroke-width&#39;: 1
                             })
                             .add();
                     this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
                             .attr({
                                     stroke: &#39;green&#39;,
                                     &#39;stroke-width&#39;: 1,
                                     fill: &#39;none&#39;
                             })
                             .add();
                     this.chart.renderer.path([&#39;M&#39;, rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
                             &#39;L&#39;, plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
                             .attr({
                                     stroke: &#39;green&#39;,
                                     &#39;stroke-width&#39;: 1
                             })
                             .add();
             }
/

             // moveTo or lineTo
             if (!i) {
                     ret = [M, plotX, plotY];
             } else { // curve from last point to this
                     ret = [
                             &#39;C&#39;,
                             lastPoint.rightContX || lastPoint.plotX,
                             lastPoint.rightContY || lastPoint.plotY,
                             leftContX || plotX,
                             leftContY || plotY,
                             plotX,
                             plotY
                     ];
                     lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
             }
             return ret;
     }</pre>

<p>}); seriesTypes.spline = SplineSeries;</p>

<p>/**</p>

<pre> Set the default options for areaspline
/</pre>

<p>defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);</p>

<p>/**</p>

<pre> AreaSplineSeries object
/</pre>

<p>var areaProto = AreaSeries.prototype,</p>

<pre>AreaSplineSeries = extendClass(SplineSeries, {
        type: &#39;areaspline&#39;,
        closedStacks: true, // instead of following the previous graph back, follow the threshold back

        // Mix in methods from the area series
        getSegmentPath: areaProto.getSegmentPath,
        closeSegment: areaProto.closeSegment,
        drawGraph: areaProto.drawGraph,
        drawLegendSymbol: LegendSymbolMixin.drawRectangle
});</pre>

<p>seriesTypes.areaspline = AreaSplineSeries;</p>

<p>/**</p>

<pre> Set the default options for column
/</pre>

<p>defaultPlotOptions.column = merge(defaultSeriesOptions, {</p>

<pre>borderColor: &#39;#FFFFFF&#39;,
//borderWidth: 1,
borderRadius: 0,
//colorByPoint: undefined,
groupPadding: 0.2,
//grouping: true,
marker: null, // point options are specified in the base options
pointPadding: 0.1,
//pointWidth: null,
minPointLength: 0,
cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
states: {
        hover: {
                brightness: 0.1,
                shadow: false,
                halo: false
        },
        select: {
                color: &#39;#C0C0C0&#39;,
                borderColor: &#39;#000000&#39;,
                shadow: false
        }
},
dataLabels: {
        align: null, // auto
        verticalAlign: null, // auto
        y: null
},
stickyTracking: false,
tooltip: {
        distance: 6
},
threshold: 0</pre>

<p>});</p>

<p>/**</p>

<pre> ColumnSeries object
/</pre>

<p>var ColumnSeries = extendClass(Series, {</p>

<pre>     type: &#39;column&#39;,
     pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
             stroke: &#39;borderColor&#39;,
             fill: &#39;color&#39;,
             r: &#39;borderRadius&#39;
     },
     cropShoulder: 0,
     trackerGroups: [&#39;group&#39;, &#39;dataLabelsGroup&#39;],
     negStacks: true, // use separate negative stacks, unlike area stacks where a negative 
             // point is substracted from previous (#1910)

     /**
 Initialize the series
/
     init: function () {
             Series.prototype.init.apply(this, arguments);

             var series = this,
                     chart = series.chart;

             // if the series is added dynamically, force redraw of other
             // series affected by a new column
             if (chart.hasRendered) {
                     each(chart.series, function (otherSeries) {
                             if (otherSeries.type === series.type) {
                                     otherSeries.isDirty = true;
                             }
                     });
             }
     },

     /**
 Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
 pointWidth etc. 
/
     getColumnMetrics: function () {

             var series = this,
                     options = series.options,
                     xAxis = series.xAxis,
                     yAxis = series.yAxis,
                     reversedXAxis = xAxis.reversed,
                     stackKey,
                     stackGroups = {},
                     columnIndex,
                     columnCount = 0;

             // Get the total number of column type series.
             // This is called on every series. Consider moving this logic to a
             // chart.orderStacks() function and call it on init, addSeries and removeSeries
             if (options.grouping === false) {
                     columnCount = 1;
             } else {
                     each(series.chart.series, function (otherSeries) {
                             var otherOptions = otherSeries.options,
                                     otherYAxis = otherSeries.yAxis;
                             if (otherSeries.type === series.type &amp;&amp; otherSeries.visible &amp;&amp;
                                             yAxis.len === otherYAxis.len &amp;&amp; yAxis.pos === otherYAxis.pos) {  // #642, #2086
                                     if (otherOptions.stacking) {
                                             stackKey = otherSeries.stackKey;
                                             if (stackGroups[stackKey] === UNDEFINED) {
                                                     stackGroups[stackKey] = columnCount++;
                                             }
                                             columnIndex = stackGroups[stackKey];
                                     } else if (otherOptions.grouping !== false) { // #1162
                                             columnIndex = columnCount++;
                                     }
                                     otherSeries.columnIndex = columnIndex;
                             }
                     });
             }

             var categoryWidth = mathMin(
                             mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
                             xAxis.len // #1535
                     ),
                     groupPadding = categoryWidth * options.groupPadding,
                     groupWidth = categoryWidth - 2 * groupPadding,
                     pointOffsetWidth = groupWidth / columnCount,
                     optionPointWidth = options.pointWidth,
                     pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
                             pointOffsetWidth * options.pointPadding,
                     pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts
                     colIndex = (reversedXAxis ? 
                             columnCount - (series.columnIndex || 0) : // #1251
                             series.columnIndex) || 0,
                     pointXOffset = pointPadding + (groupPadding + colIndex *
                             pointOffsetWidth - (categoryWidth / 2)) *
                             (reversedXAxis ? -1 : 1);

             // Save it for reading in linked series (Error bars particularly)
             return (series.columnMetrics = { 
                     width: pointWidth, 
                     offset: pointXOffset 
             });

     },

     /**
 Translate each point to the plot area coordinate system and find shape positions
/
     translate: function () {
             var series = this,
                     chart = series.chart,
                     options = series.options,
                     borderWidth = series.borderWidth = pick(
                             options.borderWidth, 
                             series.activePointCount &gt; 0.5 * series.xAxis.len ? 0 : 1
                     ),
                     yAxis = series.yAxis,
                     threshold = options.threshold,
                     translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
                     minPointLength = pick(options.minPointLength, 5),
                     metrics = series.getColumnMetrics(),
                     pointWidth = metrics.width,
                     seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
                     pointXOffset = series.pointXOffset = metrics.offset,
                     xCrisp = -(borderWidth % 2 ? 0.5 : 0),
                     yCrisp = borderWidth % 2 ? 0.5 : 1;

             if (chart.renderer.isVML &amp;&amp; chart.inverted) {
                     yCrisp += 1;
             }

             // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
             // columns to have individual sizes. When pointPadding is greater, we strive for equal-width
             // columns (#2694).
             if (options.pointPadding) {
                     seriesBarW = mathCeil(seriesBarW);
             }

             Series.prototype.translate.apply(series);

             // Record the new values
             each(series.points, function (point) {
                     var yBottom = pick(point.yBottom, translatedThreshold),
                             plotY = mathMin(mathMax(-999 - yBottom, point.plotY), yAxis.len + 999 + yBottom), // Don&#39;t draw too far outside plot area (#1303, #2241)
                             barX = point.plotX + pointXOffset,
                             barW = seriesBarW,
                             barY = mathMin(plotY, yBottom),
                             right,
                             bottom,
                             fromTop,
                             barH = mathMax(plotY, yBottom) - barY;

                     // Handle options.minPointLength
                     if (mathAbs(barH) &lt; minPointLength) {
                             if (minPointLength) {
                                     barH = minPointLength;
                                     barY =
                                             mathRound(mathAbs(barY - translatedThreshold) &gt; minPointLength ? // stacked
                                                     yBottom - minPointLength : // keep position
                                                     translatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) &lt;= translatedThreshold ? minPointLength : 0)); // use exact yAxis.translation (#1485)
                             }
                     }

                     // Cache for access in polar
                     point.barX = barX;
                     point.pointWidth = pointWidth;

                     // Fix the tooltip on center of grouped columns (#1216, #424)
                     point.tooltipPos = chart.inverted ? 
                             [yAxis.len - plotY, series.xAxis.len - barX - barW / 2] : 
                             [barX + barW / 2, plotY + yAxis.pos - chart.plotTop];

                     // Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)
                     right = mathRound(barX + barW) + xCrisp;
                     barX = mathRound(barX) + xCrisp;
                     barW = right - barX;

                     fromTop = mathAbs(barY) &lt; 0.5;
                     bottom = mathRound(barY + barH) + yCrisp;
                     barY = mathRound(barY) + yCrisp;
                     barH = bottom - barY;

                     // Top edges are exceptions
                     if (fromTop) {
                             barY -= 1;
                             barH += 1;
                     }

                     // Register shape type and arguments to be used in drawPoints
                     point.shapeType = &#39;rect&#39;;
                     point.shapeArgs = {
                             x: barX,
                             y: barY,
                             width: barW,
                             height: barH
                     };

             });

     },

     getSymbol: noop,

     /**
 Use a solid rectangle like the area series types
/
     drawLegendSymbol: LegendSymbolMixin.drawRectangle,

     /**
 Columns have no graph
/
     drawGraph: noop,

     /**
 Draw the columns. For bars, the series.group is rotated, so the same coordinates
 apply for columns and bars. This method is inherited by scatter series.

/
     drawPoints: function () {
             var series = this,
                     chart = this.chart,
                     options = series.options,
                     renderer = chart.renderer,
                     animationLimit = options.animationLimit || 250,
                     shapeArgs,
                     pointAttr;

             // draw the columns
             each(series.points, function (point) {
                     var plotY = point.plotY,
                             graphic = point.graphic,
                             borderAttr;

                     if (plotY !== UNDEFINED &amp;&amp; !isNaN(plotY) &amp;&amp; point.y !== null) {
                             shapeArgs = point.shapeArgs;

                             borderAttr = defined(series.borderWidth) ? {
                                     &#39;stroke-width&#39;: series.borderWidth
                             } : {};

                             pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];

                             if (graphic) { // update
                                     stop(graphic);
                                     graphic.attr(borderAttr)[chart.pointCount &lt; animationLimit ? &#39;animate&#39; : &#39;attr&#39;](merge(shapeArgs));

                             } else {
                                     point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                                             .attr(pointAttr)
                                             .attr(borderAttr)
                                             .add(series.group)
                                             .shadow(options.shadow, null, options.stacking &amp;&amp; !options.borderRadius);
                             }

                     } else if (graphic) {
                             point.graphic = graphic.destroy(); // #1269
                     }
             });
     },

     /**
 Animate the column heights one by one from zero
 @param {Boolean} init Whether to initialize the animation or run it
/
     animate: function (init) {
             var series = this,
                     yAxis = this.yAxis,
                     options = series.options,
                     inverted = this.chart.inverted,
                     attr = {},
                     translatedThreshold;

             if (hasSVG) { // VML is too slow anyway
                     if (init) {
                             attr.scaleY = 0.001;
                             translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
                             if (inverted) {
                                     attr.translateX = translatedThreshold - yAxis.len;
                             } else {
                                     attr.translateY = translatedThreshold;
                             }
                             series.group.attr(attr);

                     } else { // run the animation

                             attr.scaleY = 1;
                             attr[inverted ? &#39;translateX&#39; : &#39;translateY&#39;] = yAxis.pos;
                             series.group.animate(attr, series.options.animation);

                             // delete this function to allow it only once
                             series.animate = null;
                     }
             }
     },

     /**
 Remove this series from the chart
/
     remove: function () {
             var series = this,
                     chart = series.chart;

             // column and bar series affects other series of the same type
             // as they are either stacked or grouped
             if (chart.hasRendered) {
                     each(chart.series, function (otherSeries) {
                             if (otherSeries.type === series.type) {
                                     otherSeries.isDirty = true;
                             }
                     });
             }

             Series.prototype.remove.apply(series, arguments);
     }</pre>

<p>}); seriesTypes.column = ColumnSeries; /**</p>

<pre> Set the default options for bar
/</pre>

<p>defaultPlotOptions.bar = merge(defaultPlotOptions.column); /**</p>

<pre> The Bar series class
/</pre>

<p>var BarSeries = extendClass(ColumnSeries, {</p>

<pre>type: &#39;bar&#39;,
inverted: true</pre>

<p>}); seriesTypes.bar = BarSeries;</p>

<p>/**</p>

<pre> Set the default options for scatter
/</pre>

<p>defaultPlotOptions.scatter = merge(defaultSeriesOptions, {</p>

<pre>lineWidth: 0,
tooltip: {
        headerFormat: &#39;&lt;span style=&quot;color:{series.color}&quot;&gt;\u25CF&lt;/span&gt; &lt;span style=&quot;font-size: 10px;&quot;&gt; {series.name}&lt;/span&gt;&lt;br/&gt;&#39;,
        pointFormat: &#39;x: &lt;b&gt;{point.x}&lt;/b&gt;&lt;br/&gt;y: &lt;b&gt;{point.y}&lt;/b&gt;&lt;br/&gt;&#39;
},
stickyTracking: false</pre>

<p>});</p>

<p>/**</p>

<pre> The scatter series class
/</pre>

<p>var ScatterSeries = extendClass(Series, {</p>

<pre>type: &#39;scatter&#39;,
sorted: false,
requireSorting: false,
noSharedTooltip: true,
trackerGroups: [&#39;markerGroup&#39;, &#39;dataLabelsGroup&#39;],
takeOrdinalPosition: false, // #2342
singularTooltips: true,
drawGraph: function () {
        if (this.options.lineWidth) {
                Series.prototype.drawGraph.call(this);
        }
}</pre>

<p>});</p>

<p>seriesTypes.scatter = ScatterSeries;</p>

<p>/**</p>

<pre> Set the default options for pie
/</pre>

<p>defaultPlotOptions.pie = merge(defaultSeriesOptions, {</p>

<pre>borderColor: &#39;#FFFFFF&#39;,
borderWidth: 1,
center: [null, null],
clip: false,
colorByPoint: true, // always true for pies
dataLabels: {
        // align: null,
        // connectorWidth: 1,
        // connectorColor: point.color,
        // connectorPadding: 5,
        distance: 30,
        enabled: true,
        formatter: function () { // #2945
                return this.point.name;
        }
        // softConnector: true,
        //y: 0
},
ignoreHiddenPoint: true,
//innerSize: 0,
legendType: &#39;point&#39;,
marker: null, // point options are specified in the base options
size: null,
showInLegend: false,
slicedOffset: 10,
states: {
        hover: {
                brightness: 0.1,
                shadow: false
        }
},
stickyTracking: false,
tooltip: {
        followPointer: true
}</pre>

<p>});</p>

<p>/**</p>

<pre> Extended point object for pies
/</pre>

<p>var PiePoint = extendClass(Point, {</p>

<pre>     /**
 Initiate the pie slice
/
     init: function () {

             Point.prototype.init.apply(this, arguments);

             var point = this,
                     toggleSlice;

             // Disallow negative values (#1530)
             if (point.y &lt; 0) {
                     point.y = null;
             }

             //visible: options.visible !== false,
             extend(point, {
                     visible: point.visible !== false,
                     name: pick(point.name, &#39;Slice&#39;)
             });

             // add event listener for select
             toggleSlice = function (e) {
                     point.slice(e.type === &#39;select&#39;);
             };
             addEvent(point, &#39;select&#39;, toggleSlice);
             addEvent(point, &#39;unselect&#39;, toggleSlice);

             return point;
     },

     /**
 Toggle the visibility of the pie slice
 @param {Boolean} vis Whether to show the slice or not. If undefined, the
    visibility is toggled
/
     setVisible: function (vis) {
             var point = this,
                     series = point.series,
                     chart = series.chart;

             // if called without an argument, toggle visibility
             point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
             series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

             // Show and hide associated elements
             each([&#39;graphic&#39;, &#39;dataLabel&#39;, &#39;connector&#39;, &#39;shadowGroup&#39;], function (key) {
                     if (point[key]) {
                             point[key][vis ? &#39;show&#39; : &#39;hide&#39;](true);
                     }
             });

             if (point.legendItem) {
                     chart.legend.colorizeItem(point, vis);
             }

             // Handle ignore hidden slices
             if (!series.isDirty &amp;&amp; series.options.ignoreHiddenPoint) {
                     series.isDirty = true;
                     chart.redraw();
             }
     },

     /**
 Set or toggle whether the slice is cut out from the pie
 @param {Boolean} sliced When undefined, the slice state is toggled
 @param {Boolean} redraw Whether to redraw the chart. True by default.
/
     slice: function (sliced, redraw, animation) {
             var point = this,
                     series = point.series,
                     chart = series.chart,
                     translation;

             setAnimation(animation, chart);

             // redraw is true by default
             redraw = pick(redraw, true);

             // if called without an argument, toggle
             point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
             series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

             translation = sliced ? point.slicedTranslation : {
                     translateX: 0,
                     translateY: 0
             };

             point.graphic.animate(translation);

             if (point.shadowGroup) {
                     point.shadowGroup.animate(translation);
             }

     },

     haloPath: function (size) {
             var shapeArgs = this.shapeArgs,
                     chart = this.series.chart;

             return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
                     innerR: this.shapeArgs.r,
                     start: shapeArgs.start,
                     end: shapeArgs.end
             });
     }</pre>

<p>});</p>

<p>/**</p>

<pre> The Pie series class
/</pre>

<p>var PieSeries = {</p>

<pre>     type: &#39;pie&#39;,
     isCartesian: false,
     pointClass: PiePoint,
     requireSorting: false,
     noSharedTooltip: true,
     trackerGroups: [&#39;group&#39;, &#39;dataLabelsGroup&#39;],
     axisTypes: [],
     pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
             stroke: &#39;borderColor&#39;,
             &#39;stroke-width&#39;: &#39;borderWidth&#39;,
             fill: &#39;color&#39;
     },
     singularTooltips: true,

     /**
 Pies have one color each point
/
     getColor: noop,

     /**
 Animate the pies in
/
     animate: function (init) {
             var series = this,
                     points = series.points,
                     startAngleRad = series.startAngleRad;

             if (!init) {
                     each(points, function (point) {
                             var graphic = point.graphic,
                                     args = point.shapeArgs;

                             if (graphic) {
                                     // start values
                                     graphic.attr({
                                             r: series.center[3] / 2, // animate from inner radius (#779)
                                             start: startAngleRad,
                                             end: startAngleRad
                                     });

                                     // animate
                                     graphic.animate({
                                             r: args.r,
                                             start: args.start,
                                             end: args.end
                                     }, series.options.animation);
                             }
                     });

                     // delete this function to allow it only once
                     series.animate = null;
             }
     },

     /**
 Extend the basic setData method by running processData and generatePoints immediately,
 in order to access the points from the legend.
/
     setData: function (data, redraw, animation, updatePoints) {
             Series.prototype.setData.call(this, data, false, animation, updatePoints);
             this.processData();
             this.generatePoints();
             if (pick(redraw, true)) {
                     this.chart.redraw(animation);
             } 
     },

     /**
 Extend the generatePoints method by adding total and percentage properties to each point
/
     generatePoints: function () {
             var i,
                     total = 0,
                     points,
                     len,
                     point,
                     ignoreHiddenPoint = this.options.ignoreHiddenPoint;

             Series.prototype.generatePoints.call(this);

             // Populate local vars
             points = this.points;
             len = points.length;

             // Get the total sum
             for (i = 0; i &lt; len; i++) {
                     point = points[i];
                     total += (ignoreHiddenPoint &amp;&amp; !point.visible) ? 0 : point.y;
             }
             this.total = total;

             // Set each point&#39;s properties
             for (i = 0; i &lt; len; i++) {
                     point = points[i];
                     point.percentage = total &gt; 0 ? (point.y / total) * 100 : 0;
                     point.total = total;
             }

     },

     /**
 Do translation for pie slices
/
     translate: function (positions) {
             this.generatePoints();

             var series = this,
                     cumulative = 0,
                     precision = 1000, // issue #172
                     options = series.options,
                     slicedOffset = options.slicedOffset,
                     connectorOffset = slicedOffset + options.borderWidth,
                     start,
                     end,
                     angle,
                     startAngle = options.startAngle || 0,
                     startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
                     endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
                     circ = endAngleRad - startAngleRad, //2 * mathPI,
                     points = series.points,
                     radiusX, // the x component of the radius vector for a given point
                     radiusY,
                     labelDistance = options.dataLabels.distance,
                     ignoreHiddenPoint = options.ignoreHiddenPoint,
                     i,
                     len = points.length,
                     point;

             // Get positions - either an integer or a percentage string must be given.
             // If positions are passed as a parameter, we&#39;re in a recursive loop for adjusting
             // space for data labels.
             if (!positions) {
                     series.center = positions = series.getCenter();
             }

             // utility for getting the x value from a given y, used for anticollision logic in data labels
             series.getX = function (y, left) {

                     angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

                     return positions[0] +
                             (left ? -1 : 1) *
                             (mathCos(angle) * (positions[2] / 2 + labelDistance));
             };

             // Calculate the geometry for each point
             for (i = 0; i &lt; len; i++) {

                     point = points[i];

                     // set start and end angle
                     start = startAngleRad + (cumulative * circ);
                     if (!ignoreHiddenPoint || point.visible) {
                             cumulative += point.percentage / 100;
                     }
                     end = startAngleRad + (cumulative * circ);

                     // set the shape
                     point.shapeType = &#39;arc&#39;;
                     point.shapeArgs = {
                             x: positions[0],
                             y: positions[1],
                             r: positions[2] / 2,
                             innerR: positions[3] / 2,
                             start: mathRound(start * precision) / precision,
                             end: mathRound(end * precision) / precision
                     };

                     // The angle must stay within -90 and 270 (#2645)
                     angle = (end + start) / 2;
                     if (angle &gt; 1.5 * mathPI) {
                             angle -= 2 * mathPI;
                     } else if (angle &lt; -mathPI / 2) {
                             angle += 2 * mathPI;
                     }

                     // Center for the sliced out slice
                     point.slicedTranslation = {
                             translateX: mathRound(mathCos(angle) * slicedOffset),
                             translateY: mathRound(mathSin(angle) * slicedOffset)
                     };

                     // set the anchor point for tooltips
                     radiusX = mathCos(angle) * positions[2] / 2;
                     radiusY = mathSin(angle) * positions[2] / 2;
                     point.tooltipPos = [
                             positions[0] + radiusX * 0.7,
                             positions[1] + radiusY * 0.7
                     ];

                     point.half = angle &lt; -mathPI / 2 || angle &gt; mathPI / 2 ? 1 : 0;
                     point.angle = angle;

                     // set the anchor point for data labels
                     connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
                     point.labelPos = [
                             positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
                             positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
                             positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
                             positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
                             positions[0] + radiusX, // landing point for connector
                             positions[1] + radiusY, // a/a
                             labelDistance &lt; 0 ? // alignment
                                     &#39;center&#39; :
                                     point.half ? &#39;right&#39; : &#39;left&#39;, // alignment
                             angle // center angle
                     ];

             }
     },

     drawGraph: null,

     /**
 Draw the data points
/
     drawPoints: function () {
             var series = this,
                     chart = series.chart,
                     renderer = chart.renderer,
                     groupTranslation,
                     //center,
                     graphic,
                     //group,
                     shadow = series.options.shadow,
                     shadowGroup,
                     shapeArgs;

             if (shadow &amp;&amp; !series.shadowGroup) {
                     series.shadowGroup = renderer.g(&#39;shadow&#39;)
                             .add(series.group);
             }

             // draw the slices
             each(series.points, function (point) {
                     graphic = point.graphic;
                     shapeArgs = point.shapeArgs;
                     shadowGroup = point.shadowGroup;

                     // put the shadow behind all points
                     if (shadow &amp;&amp; !shadowGroup) {
                             shadowGroup = point.shadowGroup = renderer.g(&#39;shadow&#39;)
                                     .add(series.shadowGroup);
                     }

                     // if the point is sliced, use special translation, else use plot area traslation
                     groupTranslation = point.sliced ? point.slicedTranslation : {
                             translateX: 0,
                             translateY: 0
                     };

                     //group.translate(groupTranslation[0], groupTranslation[1]);
                     if (shadowGroup) {
                             shadowGroup.attr(groupTranslation);
                     }

                     // draw the slice
                     if (graphic) {
                             graphic.animate(extend(shapeArgs, groupTranslation));
                     } else {
                             point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                                     .setRadialReference(series.center)
                                     .attr(
                                             point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]
                                     )
                                     .attr({ 
                                             &#39;stroke-linejoin&#39;: &#39;round&#39;
                                             //zIndex: 1 // #2722 (reversed)
                                     })
                                     .attr(groupTranslation)
                                     .add(series.group)
                                     .shadow(shadow, shadowGroup);   
                     }

                     // detect point specific visibility (#2430)
                     if (point.visible !== undefined) {
                             point.setVisible(point.visible);
                     }

             });

     },

     /**
 Utility for sorting data labels
/
     sortByAngle: function (points, sign) {
             points.sort(function (a, b) {
                     return a.angle !== undefined &amp;&amp; (b.angle - a.angle) * sign;
             });
     },              

     /**
 Use a simple symbol from LegendSymbolMixin
/
     drawLegendSymbol: LegendSymbolMixin.drawRectangle,

     /**
 Use the getCenter method from drawLegendSymbol
/
     getCenter: CenteredSeriesMixin.getCenter,

     /**
 Pies don&#39;t have point marker symbols
/
     getSymbol: noop</pre>

<p>}; PieSeries = extendClass(Series, PieSeries); seriesTypes.pie = PieSeries;</p>

<p>/**</p>

<pre> Draw the data labels
/</pre>

<p>Series.prototype.drawDataLabels = function () {</p>

<pre>var series = this,
        seriesOptions = series.options,
        cursor = seriesOptions.cursor,
        options = seriesOptions.dataLabels,
        points = series.points,
        pointOptions,
        generalOptions,
        hasRendered = series.hasRendered || 0,
        str,
        dataLabelsGroup;

if (options.enabled || series._hasPointLabels) {

        // Process default alignment of data labels for columns
        if (series.dlProcessOptions) {
                series.dlProcessOptions(options);
        }

        // Create a separate group for the data labels to avoid rotation
        dataLabelsGroup = series.plotGroup(
                &#39;dataLabelsGroup&#39;,
                &#39;data-labels&#39;,
                options.defer ? HIDDEN : VISIBLE,
                options.zIndex || 6
        );

        if (pick(options.defer, true)) {
                dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
                if (!hasRendered) {
                        addEvent(series, &#39;afterAnimate&#39;, function () {
                                if (series.visible) { // #3023, #3024
                                        dataLabelsGroup.show();
                                }
                                dataLabelsGroup[seriesOptions.animation ? &#39;animate&#39; : &#39;attr&#39;]({ opacity: 1 }, { duration: 200 });
                        });
                }
        }

        // Make the labels for each point
        generalOptions = options;
        each(points, function (point) {

                var enabled,
                        dataLabel = point.dataLabel,
                        labelConfig,
                        attr,
                        name,
                        rotation,
                        connector = point.connector,
                        isNew = true;

                // Determine if each data label is enabled
                pointOptions = point.options &amp;&amp; point.options.dataLabels;
                enabled = pick(pointOptions &amp;&amp; pointOptions.enabled, generalOptions.enabled); // #2282

                // If the point is outside the plot area, destroy it. #678, #820
                if (dataLabel &amp;&amp; !enabled) {
                        point.dataLabel = dataLabel.destroy();

                // Individual labels are disabled if the are explicitly disabled
                // in the point options, or if they fall outside the plot area.
                } else if (enabled) {

                        // Create individual options structure that can be extended without
                        // affecting others
                        options = merge(generalOptions, pointOptions);

                        rotation = options.rotation;

                        // Get the string
                        labelConfig = point.getLabelConfig();
                        str = options.format ?
                                format(options.format, labelConfig) :
                                options.formatter.call(labelConfig, options);

                        // Determine the color
                        options.style.color = pick(options.color, options.style.color, series.color, &#39;black&#39;);

                        // update existing label
                        if (dataLabel) {

                                if (defined(str)) {
                                        dataLabel
                                                .attr({
                                                        text: str
                                                });
                                        isNew = false;

                                } else { // #1437 - the label is shown conditionally
                                        point.dataLabel = dataLabel = dataLabel.destroy();
                                        if (connector) {
                                                point.connector = connector.destroy();
                                        }
                                }

                        // create new label
                        } else if (defined(str)) {
                                attr = {
                                        //align: align,
                                        fill: options.backgroundColor,
                                        stroke: options.borderColor,
                                        &#39;stroke-width&#39;: options.borderWidth,
                                        r: options.borderRadius || 0,
                                        rotation: rotation,
                                        padding: options.padding,
                                        zIndex: 1
                                };
                                // Remove unused attributes (#947)
                                for (name in attr) {
                                        if (attr[name] === UNDEFINED) {
                                                delete attr[name];
                                        }
                                }

                                dataLabel = point.dataLabel = series.chart.renderer[rotation ? &#39;text&#39; : &#39;label&#39;]( // labels don&#39;t support rotation
                                        str,
                                        0,
                                        -999,
                                        null,
                                        null,
                                        null,
                                        options.useHTML
                                )
                                .attr(attr)
                                .css(extend(options.style, cursor &amp;&amp; { cursor: cursor }))
                                .add(dataLabelsGroup)
                                .shadow(options.shadow);

                        }

                        if (dataLabel) {
                                // Now the data label is created and placed at 0,0, so we need to align it
                                series.alignDataLabel(point, dataLabel, options, null, isNew);
                        }
                }
        });
}</pre>

<p>};</p>

<p>/**</p>

<pre> Align each individual data label
/</pre>

<p>Series.prototype.alignDataLabel = function (point, dataLabel, options,
alignTo, isNew) {</p>

<pre>var chart = this.chart,
        inverted = chart.inverted,
        plotX = pick(point.plotX, -999),
        plotY = pick(point.plotY, -999),
        bBox = dataLabel.getBBox(),
        // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
        visible = this.visible &amp;&amp; (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
                (alignTo &amp;&amp; chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
        alignAttr; // the final position;

if (visible) {

        // The alignment box is a singular point
        alignTo = extend({
                x: inverted ? chart.plotWidth - plotY : plotX,
                y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
                width: 0,
                height: 0
        }, alignTo);

        // Add the text size for alignment calculation
        extend(options, {
                width: bBox.width,
                height: bBox.height
        });

        // Allow a hook for changing alignment in the last moment, then do the alignment
        if (options.rotation) { // Fancy box alignment isn&#39;t supported for rotated text
                dataLabel[isNew ? &#39;attr&#39; : &#39;animate&#39;]({
                                x: alignTo.x + options.x + alignTo.width / 2,
                                y: alignTo.y + options.y + alignTo.height / 2
                        })
                        .attr({ // #3003
                                align: options.align
                        });
        } else {
                dataLabel.align(options, null, alignTo);
                alignAttr = dataLabel.alignAttr;

                // Handle justify or crop
                if (pick(options.overflow, &#39;justify&#39;) === &#39;justify&#39;) {
                        this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);

                } else if (pick(options.crop, true)) {
                        // Now check that the data label is within the plot area
                        visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) &amp;&amp; chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);

                }
        }
}

// Show or hide based on the final aligned position
if (!visible) {
        dataLabel.attr({ y: -999 });
        dataLabel.placed = false; // don&#39;t animate back in
}</pre>

<p>};</p>

<p>/**</p>

<pre> If data labels fall partly outside the plot area, align them back in, in a way that
 doesn&#39;t hide the point.
/</pre>

<p>Series.prototype.justifyDataLabel = function (dataLabel, options,
alignAttr, bBox, alignTo, isNew) {</p>

<pre>var chart = this.chart,
        align = options.align,
        verticalAlign = options.verticalAlign,
        off,
        justified;

// Off left
off = alignAttr.x;
if (off &lt; 0) {
        if (align === &#39;right&#39;) {
                options.align = &#39;left&#39;;
        } else {
                options.x = -off;
        }
        justified = true;
}

// Off right
off = alignAttr.x + bBox.width;
if (off &gt; chart.plotWidth) {
        if (align === &#39;left&#39;) {
                options.align = &#39;right&#39;;
        } else {
                options.x = chart.plotWidth - off;
        }
        justified = true;
}

// Off top
off = alignAttr.y;
if (off &lt; 0) {
        if (verticalAlign === &#39;bottom&#39;) {
                options.verticalAlign = &#39;top&#39;;
        } else {
                options.y = -off;
        }
        justified = true;
}

// Off bottom
off = alignAttr.y + bBox.height;
if (off &gt; chart.plotHeight) {
        if (verticalAlign === &#39;top&#39;) {
                options.verticalAlign = &#39;bottom&#39;;
        } else {
                options.y = chart.plotHeight - off;
        }
        justified = true;
}

if (justified) {
        dataLabel.placed = !isNew;
        dataLabel.align(options, null, alignTo);
}</pre>

<p>};</p>

<p>/**</p>

<pre> Override the base drawDataLabels method by pie specific functionality
/</pre>

<p>if (seriesTypes.pie) {</p>

<pre>     seriesTypes.pie.prototype.drawDataLabels = function () {
             var series = this,
                     data = series.data,
                     point,
                     chart = series.chart,
                     options = series.options.dataLabels,
                     connectorPadding = pick(options.connectorPadding, 10),
                     connectorWidth = pick(options.connectorWidth, 1),
                     plotWidth = chart.plotWidth,
                     plotHeight = chart.plotHeight,
                     connector,
                     connectorPath,
                     softConnector = pick(options.softConnector, true),
                     distanceOption = options.distance,
                     seriesCenter = series.center,
                     radius = seriesCenter[2] / 2,
                     centerY = seriesCenter[1],
                     outside = distanceOption &gt; 0,
                     dataLabel,
                     dataLabelWidth,
                     labelPos,
                     labelHeight,
                     halves = [// divide the points into right and left halves for anti collision
                             [], // right
                             []  // left
                     ],
                     x,
                     y,
                     visibility,
                     rankArr,
                     i,
                     j,
                     overflow = [0, 0, 0, 0], // top, right, bottom, left
                     sort = function (a, b) {
                             return b.y - a.y;
                     };

             // get out if not enabled
             if (!series.visible || (!options.enabled &amp;&amp; !series._hasPointLabels)) {
                     return;
             }

             // run parent method
             Series.prototype.drawDataLabels.apply(series);

             // arrange points for detection collision
             each(data, function (point) {
                     if (point.dataLabel &amp;&amp; point.visible) { // #407, #2510
                             halves[point.half].push(point);
                     }
             });

             /* Loop over the points in each half, starting from the top and bottom
  of the pie to detect overlapping labels.
 /
             i = 2;
             while (i--) {

                     var slots = [],
                             slotsLength,
                             usedSlots = [],
                             points = halves[i],
                             pos,
                             bottom,
                             length = points.length,
                             slotIndex;

                     if (!length) {
                             continue;
                     }

                     // Sort by angle
                     series.sortByAngle(points, i - 0.5);

                     // Assume equal label heights on either hemisphere (#2630)
                     j = labelHeight = 0;
                     while (!labelHeight &amp;&amp; points[j]) { // #1569
                             labelHeight = points[j] &amp;&amp; points[j].dataLabel &amp;&amp; (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
                             j++;
                     }

                     // Only do anti-collision when we are outside the pie and have connectors (#856)
                     if (distanceOption &gt; 0) {

                             // Build the slots
                             bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
                             for (pos = mathMax(0, centerY - radius - distanceOption); pos &lt;= bottom; pos += labelHeight) {
                                     slots.push(pos);
                             }
                             slotsLength = slots.length;

                             /* Visualize the slots
                             if (!series.slotElements) {
                                     series.slotElements = [];
                             }
                             if (i === 1) {
                                     series.slotElements.forEach(function (elem) {
                                             elem.destroy();
                                     });
                                     series.slotElements.length = 0;
                             }

                             slots.forEach(function (pos, no) {
                                     var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
                                             slotY = pos + chart.plotTop;

                                     if (!isNaN(slotX)) {
                                             series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
                                                     .attr({
                                                             &#39;stroke-width&#39;: 1,
                                                             stroke: &#39;silver&#39;,
                                                             fill: &#39;rgba(0,0,255,0.1)&#39;
                                                     })
                                                     .add());
                                             series.slotElements.push(chart.renderer.text(&#39;Slot &#39;+ no, slotX, slotY + 4)
                                                     .attr({
                                                             fill: &#39;silver&#39;
                                                     }).add());
                                     }
                             });
                             // */

                             // if there are more values than available slots, remove lowest values
                             if (length &gt; slotsLength) {
                                     // create an array for sorting and ranking the points within each quarter
                                     rankArr = [].concat(points);
                                     rankArr.sort(sort);
                                     j = length;
                                     while (j--) {
                                             rankArr[j].rank = j;
                                     }
                                     j = length;
                                     while (j--) {
                                             if (points[j].rank &gt;= slotsLength) {
                                                     points.splice(j, 1);
                                             }
                                     }
                                     length = points.length;
                             }

                             // The label goes to the nearest open slot, but not closer to the edge than
                             // the label&#39;s index.
                             for (j = 0; j &lt; length; j++) {

                                     point = points[j];
                                     labelPos = point.labelPos;

                                     var closest = 9999,
                                             distance,
                                             slotI;

                                     // find the closest slot index
                                     for (slotI = 0; slotI &lt; slotsLength; slotI++) {
                                             distance = mathAbs(slots[slotI] - labelPos[1]);
                                             if (distance &lt; closest) {
                                                     closest = distance;
                                                     slotIndex = slotI;
                                             }
                                     }

                                     // if that slot index is closer to the edges of the slots, move it
                                     // to the closest appropriate slot
                                     if (slotIndex &lt; j &amp;&amp; slots[j] !== null) { // cluster at the top
                                             slotIndex = j;
                                     } else if (slotsLength  &lt; length - j + slotIndex &amp;&amp; slots[j] !== null) { // cluster at the bottom
                                             slotIndex = slotsLength - length + j;
                                             while (slots[slotIndex] === null) { // make sure it is not taken
                                                     slotIndex++;
                                             }
                                     } else {
                                             // Slot is taken, find next free slot below. In the next run, the next slice will find the
                                             // slot above these, because it is the closest one
                                             while (slots[slotIndex] === null) { // make sure it is not taken
                                                     slotIndex++;
                                             }
                                     }

                                     usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
                                     slots[slotIndex] = null; // mark as taken
                             }
                             // sort them in order to fill in from the top
                             usedSlots.sort(sort);
                     }

                     // now the used slots are sorted, fill them up sequentially
                     for (j = 0; j &lt; length; j++) {

                             var slot, naturalY;

                             point = points[j];
                             labelPos = point.labelPos;
                             dataLabel = point.dataLabel;
                             visibility = point.visible === false ? HIDDEN : VISIBLE;
                             naturalY = labelPos[1];

                             if (distanceOption &gt; 0) {
                                     slot = usedSlots.pop();
                                     slotIndex = slot.i;

                                     // if the slot next to currrent slot is free, the y value is allowed
                                     // to fall back to the natural position
                                     y = slot.y;
                                     if ((naturalY &gt; y &amp;&amp; slots[slotIndex + 1] !== null) ||
                                                     (naturalY &lt; y &amp;&amp;  slots[slotIndex - 1] !== null)) {
                                             y = mathMin(mathMax(0, naturalY), chart.plotHeight);
                                     }

                             } else {
                                     y = naturalY;
                             }

                             // get the x - use the natural x position for first and last slot, to prevent the top
                             // and botton slice connectors from touching each other on either side
                             x = options.justify ?
                                     seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
                                     series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);

                             // Record the placement and visibility
                             dataLabel._attr = {
                                     visibility: visibility,
                                     align: labelPos[6]
                             };
                             dataLabel._pos = {
                                     x: x + options.x +
                                             ({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
                                     y: y + options.y - 10 // 10 is for the baseline (label vs text)
                             };
                             dataLabel.connX = x;
                             dataLabel.connY = y;

                             // Detect overflowing data labels
                             if (this.options.size === null) {
                                     dataLabelWidth = dataLabel.width;
                                     // Overflow left
                                     if (x - dataLabelWidth &lt; connectorPadding) {
                                             overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

                                     // Overflow right
                                     } else if (x + dataLabelWidth &gt; plotWidth - connectorPadding) {
                                             overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
                                     }

                                     // Overflow top
                                     if (y - labelHeight / 2 &lt; 0) {
                                             overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

                                     // Overflow left
                                     } else if (y + labelHeight / 2 &gt; plotHeight) {
                                             overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
                                     }
                             }
                     } // for each point
             } // for each half

             // Do not apply the final placement and draw the connectors until we have verified
             // that labels are not spilling over.
             if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

                     // Place the labels in the final position
                     this.placeDataLabels();

                     // Draw the connectors
                     if (outside &amp;&amp; connectorWidth) {
                             each(this.points, function (point) {
                                     connector = point.connector;
                                     labelPos = point.labelPos;
                                     dataLabel = point.dataLabel;

                                     if (dataLabel &amp;&amp; dataLabel._pos) {
                                             visibility = dataLabel._attr.visibility;
                                             x = dataLabel.connX;
                                             y = dataLabel.connY;
                                             connectorPath = softConnector ? [
                                                     M,
                                                     x + (labelPos[6] === &#39;left&#39; ? 5 : -5), y, // end of the string at the label
                                                     &#39;C&#39;,
                                                     x, y, // first break, next to the label
                                                     2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
                                                     labelPos[2], labelPos[3], // second break
                                                     L,
                                                     labelPos[4], labelPos[5] // base
                                             ] : [
                                                     M,
                                                     x + (labelPos[6] === &#39;left&#39; ? 5 : -5), y, // end of the string at the label
                                                     L,
                                                     labelPos[2], labelPos[3], // second break
                                                     L,
                                                     labelPos[4], labelPos[5] // base
                                             ];

                                             if (connector) {
                                                     connector.animate({ d: connectorPath });
                                                     connector.attr(&#39;visibility&#39;, visibility);

                                             } else {
                                                     point.connector = connector = series.chart.renderer.path(connectorPath).attr({
                                                             &#39;stroke-width&#39;: connectorWidth,
                                                             stroke: options.connectorColor || point.color || &#39;#606060&#39;,
                                                             visibility: visibility
                                                             //zIndex: 0 // #2722 (reversed)
                                                     })
                                                     .add(series.dataLabelsGroup);
                                             }
                                     } else if (connector) {
                                             point.connector = connector.destroy();
                                     }
                             });
                     }
             }
     };
     /**
 Perform the final placement of the data labels after we have verified that they
 fall within the plot area.
/
     seriesTypes.pie.prototype.placeDataLabels = function () {
             each(this.points, function (point) {
                     var dataLabel = point.dataLabel,
                             _pos;

                     if (dataLabel) {
                             _pos = dataLabel._pos;
                             if (_pos) {
                                     dataLabel.attr(dataLabel._attr);
                                     dataLabel[dataLabel.moved ? &#39;animate&#39; : &#39;attr&#39;](_pos);
                                     dataLabel.moved = true;
                             } else if (dataLabel) {
                                     dataLabel.attr({ y: -999 });
                             }
                     }
             });
     };

     seriesTypes.pie.prototype.alignDataLabel =  noop;

     /**
 Verify whether the data labels are allowed to draw, or we should run more translation and data
 label positioning to keep them inside the plot area. Returns true when data labels are ready
 to draw.
/
     seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

             var center = this.center,
                     options = this.options,
                     centerOption = options.center,
                     minSize = options.minSize || 80,
                     newSize = minSize,
                     ret;

             // Handle horizontal size and center
             if (centerOption[0] !== null) { // Fixed center
                     newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

             } else { // Auto center
                     newSize = mathMax(
                             center[2] - overflow[1] - overflow[3], // horizontal overflow
                             minSize
                     );
                     center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
             }

             // Handle vertical size and center
             if (centerOption[1] !== null) { // Fixed center
                     newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

             } else { // Auto center
                     newSize = mathMax(
                             mathMin(
                                     newSize,
                                     center[2] - overflow[0] - overflow[2] // vertical overflow
                             ),
                             minSize
                     );
                     center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
             }

             // If the size must be decreased, we need to run translate and drawDataLabels again
             if (newSize &lt; center[2]) {
                     center[2] = newSize;
                     this.translate(center);
                     each(this.points, function (point) {
                             if (point.dataLabel) {
                                     point.dataLabel._pos = null; // reset
                             }
                     });

                     if (this.drawDataLabels) {
                             this.drawDataLabels();
                     }
             // Else, return true to indicate that the pie and its labels is within the plot area
             } else {
                     ret = true;
             }
             return ret;
     };</pre>

<p>}</p>

<p>if (seriesTypes.column) {</p>

<pre>     /**
 Override the basic data label alignment by adjusting for the position of the column
/
     seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {
             var chart = this.chart,
                     inverted = chart.inverted,
                     dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
                     below = point.below || (point.plotY &gt; pick(this.translatedThreshold, chart.plotSizeY)),
                     inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?

             // Align to the column itself, or the top of it
             if (dlBox) { // Area range uses this method but not alignTo
                     alignTo = merge(dlBox);

                     if (inverted) {
                             alignTo = {
                                     x: chart.plotWidth - alignTo.y - alignTo.height,
                                     y: chart.plotHeight - alignTo.x - alignTo.width,
                                     width: alignTo.height,
                                     height: alignTo.width
                             };
                     }

                     // Compute the alignment box
                     if (!inside) {
                             if (inverted) {
                                     alignTo.x += below ? 0 : alignTo.width;
                                     alignTo.width = 0;
                             } else {
                                     alignTo.y += below ? alignTo.height : 0;
                                     alignTo.height = 0;
                             }
                     }
             }

             // When alignment is undefined (typically columns and bars), display the individual
             // point below or above the point depending on the threshold
             options.align = pick(
                     options.align,
                     !inverted || inside ? &#39;center&#39; : below ? &#39;right&#39; : &#39;left&#39;
             );
             options.verticalAlign = pick(
                     options.verticalAlign,
                     inverted || inside ? &#39;middle&#39; : below ? &#39;top&#39; : &#39;bottom&#39;
             );

             // Call the parent method
             Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
     };</pre>

<p>}</p>

<p>/**</p>

<pre> TrackerMixin for points and graphs
/</pre>

<p>var TrackerMixin = Highcharts.TrackerMixin = {</p>

<pre>     drawTrackerPoint: function () {
             var series = this,
                     chart = series.chart,
                     pointer = chart.pointer,
                     cursor = series.options.cursor,
                     css = cursor &amp;&amp; { cursor: cursor },
                     onMouseOver = function (e) {
                             var target = e.target,
                             point;

                             if (chart.hoverSeries !== series) {
                                     series.onMouseOver();
                             }

                             while (target &amp;&amp; !point) {
                                     point = target.point;
                                     target = target.parentNode;
                             }

                             if (point !== UNDEFINED &amp;&amp; point !== chart.hoverPoint) { // undefined on graph in scatterchart
                                     point.onMouseOver(e);
                             }
                     };

             // Add reference to the point
             each(series.points, function (point) {
                     if (point.graphic) {
                             point.graphic.element.point = point;
                     }
                     if (point.dataLabel) {
                             point.dataLabel.element.point = point;
                     }
             });

             // Add the event listeners, we need to do this only once
             if (!series._hasTracking) {
                     each(series.trackerGroups, function (key) {
                             if (series[key]) { // we don&#39;t always have dataLabelsGroup
                                     series[key]
                                             .addClass(PREFIX + &#39;tracker&#39;)
                                             .on(&#39;mouseover&#39;, onMouseOver)
                                             .on(&#39;mouseout&#39;, function (e) { pointer.onTrackerMouseOut(e); })
                                             .css(css);
                                     if (hasTouch) {
                                             series[key].on(&#39;touchstart&#39;, onMouseOver);
                                     }
                             }
                     });
                     series._hasTracking = true;
             }
     },

     /**
 Draw the tracker object that sits above all data labels and markers to
 track mouse events on the graph or points. For the line type charts
 the tracker uses the same graphPath, but with a greater stroke width
 for better control.
/
     drawTrackerGraph: function () {
             var series = this,
                     options = series.options,
                     trackByArea = options.trackByArea,
                     trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
                     trackerPathLength = trackerPath.length,
                     chart = series.chart,
                     pointer = chart.pointer,
                     renderer = chart.renderer,
                     snap = chart.options.tooltip.snap,
                     tracker = series.tracker,
                     cursor = options.cursor,
                     css = cursor &amp;&amp; { cursor: cursor },
                     singlePoints = series.singlePoints,
                     singlePoint,
                     i,
                     onMouseOver = function () {
                             if (chart.hoverSeries !== series) {
                                     series.onMouseOver();
                             }
                     },
                     /*
   Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
   IE6: 0.002
   IE7: 0.002
   IE8: 0.002
   IE9: 0.00000000001 (unlimited)
   IE10: 0.0001 (exporting only)
   FF: 0.00000000001 (unlimited)
   Chrome: 0.000001
   Safari: 0.000001
   Opera: 0.00000000001 (unlimited)
  /
                     TRACKER_FILL = &#39;rgba(192,192,192,&#39; + (hasSVG ? 0.0001 : 0.002) + &#39;)&#39;;

             // Extend end points. A better way would be to use round linecaps,
             // but those are not clickable in VML.
             if (trackerPathLength &amp;&amp; !trackByArea) {
                     i = trackerPathLength + 1;
                     while (i--) {
                             if (trackerPath[i] === M) { // extend left side
                                     trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
                             }
                             if ((i &amp;&amp; trackerPath[i] === M) || i === trackerPathLength) { // extend right side
                                     trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
                             }
                     }
             }

             // handle single points
             for (i = 0; i &lt; singlePoints.length; i++) {
                     singlePoint = singlePoints[i];
                     trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
                     L, singlePoint.plotX + snap, singlePoint.plotY);
             }

             // draw the tracker
             if (tracker) {
                     tracker.attr({ d: trackerPath });
             } else { // create

                     series.tracker = renderer.path(trackerPath)
                     .attr({
                             &#39;stroke-linejoin&#39;: &#39;round&#39;, // #1225
                             visibility: series.visible ? VISIBLE : HIDDEN,
                             stroke: TRACKER_FILL,
                             fill: trackByArea ? TRACKER_FILL : NONE,
                             &#39;stroke-width&#39; : options.lineWidth + (trackByArea ? 0 : 2 * snap),
                             zIndex: 2
                     })
                     .add(series.group);

                     // The tracker is added to the series group, which is clipped, but is covered
                     // by the marker group. So the marker group also needs to capture events.
                     each([series.tracker, series.markerGroup], function (tracker) {
                             tracker.addClass(PREFIX + &#39;tracker&#39;)
                                     .on(&#39;mouseover&#39;, onMouseOver)
                                     .on(&#39;mouseout&#39;, function (e) { pointer.onTrackerMouseOut(e); })
                                     .css(css);

                             if (hasTouch) {
                                     tracker.on(&#39;touchstart&#39;, onMouseOver);
                             }
                     });
             }
     }</pre>

<p>}; /* End TrackerMixin */</p>

<p>/**</p>

<pre> Add tracking event listener to the series group, so the point graphics
 themselves act as trackers
/</pre>

<p>if (seriesTypes.column) {</p>

<pre class="ruby"><span class="ruby-constant">ColumnSeries</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">drawTracker</span> = <span class="ruby-constant">TrackerMixin</span>.<span class="ruby-identifier">drawTrackerPoint</span>;
</pre>

<p>}</p>

<p>if (seriesTypes.pie) {</p>

<pre class="ruby"><span class="ruby-identifier">seriesTypes</span>.<span class="ruby-identifier">pie</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">drawTracker</span> = <span class="ruby-constant">TrackerMixin</span>.<span class="ruby-identifier">drawTrackerPoint</span>;
</pre>

<p>}</p>

<p>if (seriesTypes.scatter) {</p>

<pre class="ruby"><span class="ruby-constant">ScatterSeries</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">drawTracker</span> = <span class="ruby-constant">TrackerMixin</span>.<span class="ruby-identifier">drawTrackerPoint</span>;
</pre>

<p>}</p>

<p>/*</p>

<pre> Extend Legend for item events 
/</pre>

<p>extend(Legend.prototype, {</p>

<pre>setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
var legend = this;
// Set the events on the item group, or in case of useHTML, the item itself (#1249)
(useHTML ? legendItem : item.legendGroup).on(&#39;mouseover&#39;, function () {
                item.setState(HOVER_STATE);
                legendItem.css(legend.options.itemHoverStyle);
        })
        .on(&#39;mouseout&#39;, function () {
                legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
                item.setState();
        })
        .on(&#39;click&#39;, function (event) {
                var strLegendItemClick = &#39;legendItemClick&#39;,
                        fnLegendItemClick = function () {
                                item.setVisible();
                        };

                // Pass over the click/touch event. #4.
                event = {
                        browserEvent: event
                };

                // click the name or symbol
                if (item.firePointEvent) { // point
                        item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
                } else {
                        fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
                }
        });
},

createCheckboxForItem: function (item) {
        var legend = this;

        item.checkbox = createElement(&#39;input&#39;, {
                type: &#39;checkbox&#39;,
                checked: item.selected,
                defaultChecked: item.selected // required by IE7
        }, legend.options.itemCheckboxStyle, legend.chart.container);

        addEvent(item.checkbox, &#39;click&#39;, function (event) {
                var target = event.target;
                fireEvent(item, &#39;checkboxClick&#39;, {
                                checked: target.checked
                        },
                        function () {
                                item.select();
                        }
                );
        });
}</pre>

<p>});</p>

<p>/*</p>

<pre> Add pointer cursor to legend itemstyle in defaultOptions
/</pre>

<p>defaultOptions.legend.itemStyle.cursor = &#39;pointer&#39;;</p>

<p>/*</p>

<pre> Extend the Chart object with interaction
/</pre>

<p>extend(Chart.prototype, {</p>

<pre>     /**
 Display the zoom button
/
     showResetZoom: function () {
             var chart = this,
                     lang = defaultOptions.lang,
                     btnOptions = chart.options.chart.resetZoomButton,
                     theme = btnOptions.theme,
                     states = theme.states,
                     alignTo = btnOptions.relativeTo === &#39;chart&#39; ? null : &#39;plotBox&#39;;

             this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states &amp;&amp; states.hover)
                     .attr({
                             align: btnOptions.position.align,
                             title: lang.resetZoomTitle
                     })
                     .add()
                     .align(btnOptions.position, false, alignTo);

     },

     /**
 Zoom out to 1:1
/
     zoomOut: function () {
             var chart = this;
             fireEvent(chart, &#39;selection&#39;, { resetSelection: true }, function () { 
                     chart.zoom();
             });
     },

     /**
 Zoom into a given portion of the chart given by axis coordinates
 @param {Object} event
/
     zoom: function (event) {
             var chart = this,
                     hasZoomed,
                     pointer = chart.pointer,
                     displayButton = false,
                     resetZoomButton;

             // If zoom is called with no arguments, reset the axes
             if (!event || event.resetSelection) {
                     each(chart.axes, function (axis) {
                             hasZoomed = axis.zoom();
                     });
             } else { // else, zoom in on all axes
                     each(event.xAxis.concat(event.yAxis), function (axisData) {
                             var axis = axisData.axis,
                                     isXAxis = axis.isXAxis;

                             // don&#39;t zoom more than minRange
                             if (pointer[isXAxis ? &#39;zoomX&#39; : &#39;zoomY&#39;] || pointer[isXAxis ? &#39;pinchX&#39; : &#39;pinchY&#39;]) {
                                     hasZoomed = axis.zoom(axisData.min, axisData.max);
                                     if (axis.displayBtn) {
                                             displayButton = true;
                                     }
                             }
                     });
             }

             // Show or hide the Reset zoom button
             resetZoomButton = chart.resetZoomButton;
             if (displayButton &amp;&amp; !resetZoomButton) {
                     chart.showResetZoom();
             } else if (!displayButton &amp;&amp; isObject(resetZoomButton)) {
                     chart.resetZoomButton = resetZoomButton.destroy();
             }

             // Redraw
             if (hasZoomed) {
                     chart.redraw(
                             pick(chart.options.chart.animation, event &amp;&amp; event.animation, chart.pointCount &lt; 100) // animation
                     );
             }
     },

     /**
 Pan the chart by dragging the mouse across the pane. This function is called
 on mouse move, and the distance to pan is computed from chartX compared to
 the first chartX position in the dragging operation.
/
     pan: function (e, panning) {

             var chart = this,
                     hoverPoints = chart.hoverPoints,
                     doRedraw;

             // remove active points for shared tooltip
             if (hoverPoints) {
                     each(hoverPoints, function (point) {
                             point.setState();
                     });
             }

             each(panning === &#39;xy&#39; ? [1, 0] : [1], function (isX) { // xy is used in maps
                     var mousePos = e[isX ? &#39;chartX&#39; : &#39;chartY&#39;],
                             axis = chart[isX ? &#39;xAxis&#39; : &#39;yAxis&#39;][0],
                             startPos = chart[isX ? &#39;mouseDownX&#39; : &#39;mouseDownY&#39;],
                             halfPointRange = (axis.pointRange || 0) / 2,
                             extremes = axis.getExtremes(),
                             newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
                             newMax = axis.toValue(startPos + chart[isX ? &#39;plotWidth&#39; : &#39;plotHeight&#39;] - mousePos, true) - halfPointRange;

                     if (axis.series.length &amp;&amp; newMin &gt; mathMin(extremes.dataMin, extremes.min) &amp;&amp; newMax &lt; mathMax(extremes.dataMax, extremes.max)) {
                             axis.setExtremes(newMin, newMax, false, false, { trigger: &#39;pan&#39; });
                             doRedraw = true;
                     }

                     chart[isX ? &#39;mouseDownX&#39; : &#39;mouseDownY&#39;] = mousePos; // set new reference for next run
             });

             if (doRedraw) {
                     chart.redraw(false);
             }
             css(chart.container, { cursor: &#39;move&#39; });
     }</pre>

<p>});</p>

<p>/*</p>

<pre> Extend the Point object with interaction
/</pre>

<p>extend(Point.prototype, {</p>

<pre>     /**
 Toggle the selection status of a point
 @param {Boolean} selected Whether to select or unselect the point.
 @param {Boolean} accumulate Whether to add to the previous selection. By default,
              this happens if the control key (Cmd on Mac) was pressed during clicking.
/
     select: function (selected, accumulate) {
             var point = this,
                     series = point.series,
                     chart = series.chart;

             selected = pick(selected, !point.selected);

             // fire the event with the defalut handler
             point.firePointEvent(selected ? &#39;select&#39; : &#39;unselect&#39;, { accumulate: accumulate }, function () {
                     point.selected = point.options.selected = selected;
                     series.options.data[inArray(point, series.data)] = point.options;

                     point.setState(selected &amp;&amp; SELECT_STATE);

                     // unselect all other points unless Ctrl or Cmd + click
                     if (!accumulate) {
                             each(chart.getSelectedPoints(), function (loopPoint) {
                                     if (loopPoint.selected &amp;&amp; loopPoint !== point) {
                                             loopPoint.selected = loopPoint.options.selected = false;
                                             series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
                                             loopPoint.setState(NORMAL_STATE);
                                                     loopPoint.firePointEvent(&#39;unselect&#39;);
                                     }
                             });
                     }
             });
     },

     /**
 Runs on mouse over the point
/
     onMouseOver: function (e) {
             var point = this,
                     series = point.series,
                     chart = series.chart,
                     tooltip = chart.tooltip,
                     hoverPoint = chart.hoverPoint;

             // set normal state to previous series
             if (hoverPoint &amp;&amp; hoverPoint !== point) {
                     hoverPoint.onMouseOut();
             }

             // trigger the event
             point.firePointEvent(&#39;mouseOver&#39;);

             // update the tooltip
             if (tooltip &amp;&amp; (!tooltip.shared || series.noSharedTooltip)) {
                     tooltip.refresh(point, e);
             }

             // hover this
             point.setState(HOVER_STATE);
             chart.hoverPoint = point;
     },

     /**
 Runs on mouse out from the point
/
     onMouseOut: function () {
             var chart = this.series.chart,
                     hoverPoints = chart.hoverPoints;

             this.firePointEvent(&#39;mouseOut&#39;);

             if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
                     this.setState();
                     chart.hoverPoint = null;
             }
     },

     /**
 Import events from the series&#39; and point&#39;s options. Only do it on
 demand, to save processing time on hovering.
/
     importEvents: function () {
             if (!this.hasImportedEvents) {
                     var point = this,
                             options = merge(point.series.options.point, point.options),
                             events = options.events,
                             eventType;

                     point.events = events;

                     for (eventType in events) {
                             addEvent(point, eventType, events[eventType]);
                     }
                     this.hasImportedEvents = true;

             }
     },

     /**
 Set the point&#39;s state
 @param {String} state
/
     setState: function (state, move) {
             var point = this,
                     plotX = point.plotX,
                     plotY = point.plotY,
                     series = point.series,
                     stateOptions = series.options.states,
                     markerOptions = defaultPlotOptions[series.type].marker &amp;&amp; series.options.marker,
                     normalDisabled = markerOptions &amp;&amp; !markerOptions.enabled,
                     markerStateOptions = markerOptions &amp;&amp; markerOptions.states[state],
                     stateDisabled = markerStateOptions &amp;&amp; markerStateOptions.enabled === false,
                     stateMarkerGraphic = series.stateMarkerGraphic,
                     pointMarker = point.marker || {},
                     chart = series.chart,
                     radius,
                     halo = series.halo,
                     haloOptions,
                     newSymbol,
                     pointAttr;

             state = state || NORMAL_STATE; // empty string
             pointAttr = point.pointAttr[state] || series.pointAttr[state];

             if (
                             // already has this state
                             (state === point.state &amp;&amp; !move) ||
                             // selected points don&#39;t respond to hover
                             (point.selected &amp;&amp; state !== SELECT_STATE) ||
                             // series&#39; state options is disabled
                             (stateOptions[state] &amp;&amp; stateOptions[state].enabled === false) ||
                             // general point marker&#39;s state options is disabled
                             (state &amp;&amp; (stateDisabled || (normalDisabled &amp;&amp; markerStateOptions.enabled === false))) ||
                             // individual point marker&#39;s state options is disabled
                             (state &amp;&amp; pointMarker.states &amp;&amp; pointMarker.states[state] &amp;&amp; pointMarker.states[state].enabled === false) // #1610

                     ) {
                     return;
             }

             // apply hover styles to the existing point
             if (point.graphic) {
                     radius = markerOptions &amp;&amp; point.graphic.symbolName &amp;&amp; pointAttr.r;
                     point.graphic.attr(merge(
                             pointAttr,
                             radius ? { // new symbol attributes (#507, #612)
                                     x: plotX - radius,
                                     y: plotY - radius,
                                     width: 2 * radius,
                                     height: 2 * radius
                             } : {}
                     ));

                     // Zooming in from a range with no markers to a range with markers
                     if (stateMarkerGraphic) {
                             stateMarkerGraphic.hide();
                     }
             } else {
                     // if a graphic is not applied to each point in the normal state, create a shared
                     // graphic for the hover state
                     if (state &amp;&amp; markerStateOptions) {
                             radius = markerStateOptions.radius;
                             newSymbol = pointMarker.symbol || series.symbol;

                             // If the point has another symbol than the previous one, throw away the
                             // state marker graphic and force a new one (#1459)
                             if (stateMarkerGraphic &amp;&amp; stateMarkerGraphic.currentSymbol !== newSymbol) {
                                     stateMarkerGraphic = stateMarkerGraphic.destroy();
                             }

                             // Add a new state marker graphic
                             if (!stateMarkerGraphic) {
                                     if (newSymbol) {
                                             series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
                                                     newSymbol,
                                                     plotX - radius,
                                                     plotY - radius,
                                                     2 * radius,
                                                     2 * radius
                                             )
                                             .attr(pointAttr)
                                             .add(series.markerGroup);
                                             stateMarkerGraphic.currentSymbol = newSymbol;
                                     }

                             // Move the existing graphic
                             } else {
                                     stateMarkerGraphic[move ? &#39;animate&#39; : &#39;attr&#39;]({ // #1054
                                             x: plotX - radius,
                                             y: plotY - radius
                                     });
                             }
                     }

                     if (stateMarkerGraphic) {
                             stateMarkerGraphic[state &amp;&amp; chart.isInsidePlot(plotX, plotY, chart.inverted) ? &#39;show&#39; : &#39;hide&#39;](); // #2450
                     }
             }

             // Show me your halo
             haloOptions = stateOptions[state] &amp;&amp; stateOptions[state].halo;
             if (haloOptions &amp;&amp; haloOptions.size) {
                     if (!halo) {
                             series.halo = halo = chart.renderer.path()
                                     .add(series.seriesGroup);
                     }
                     halo.attr(extend({
                             fill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()
                     }, haloOptions.attributes))[move ? &#39;animate&#39; : &#39;attr&#39;]({
                             d: point.haloPath(haloOptions.size)
                     });
             } else if (halo) {
                     halo.attr({ d: [] });
             }

             point.state = state;
     },

     haloPath: function (size) {
             var series = this.series,
                     chart = series.chart,
                     plotBox = series.getPlotBox(),
                     inverted = chart.inverted;

             return chart.renderer.symbols.circle(
                     plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, 
                     plotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, 
                     size * 2, 
                     size * 2
             );
     }</pre>

<p>});</p>

<p>/*</p>

<pre> Extend the Series object with interaction
/</pre>

<p>extend(Series.prototype, {</p>

<pre>     /**
 Series mouse over handler
/
     onMouseOver: function () {
             var series = this,
                     chart = series.chart,
                     hoverSeries = chart.hoverSeries;

             // set normal state to previous series
             if (hoverSeries &amp;&amp; hoverSeries !== series) {
                     hoverSeries.onMouseOut();
             }

             // trigger the event, but to save processing time,
             // only if defined
             if (series.options.events.mouseOver) {
                     fireEvent(series, &#39;mouseOver&#39;);
             }

             // hover this
             series.setState(HOVER_STATE);
             chart.hoverSeries = series;
     },

     /**
 Series mouse out handler
/
     onMouseOut: function () {
             // trigger the event only if listeners exist
             var series = this,
                     options = series.options,
                     chart = series.chart,
                     tooltip = chart.tooltip,
                     hoverPoint = chart.hoverPoint;

             // trigger mouse out on the point, which must be in this series
             if (hoverPoint) {
                     hoverPoint.onMouseOut();
             }

             // fire the mouse out event
             if (series &amp;&amp; options.events.mouseOut) {
                     fireEvent(series, &#39;mouseOut&#39;);
             }

             // hide the tooltip
             if (tooltip &amp;&amp; !options.stickyTracking &amp;&amp; (!tooltip.shared || series.noSharedTooltip)) {
                     tooltip.hide();
             }

             // set normal state
             series.setState();
             chart.hoverSeries = null;
     },

     /**
 Set the state of the graph
/
     setState: function (state) {
             var series = this,
                     options = series.options,
                     graph = series.graph,
                     graphNeg = series.graphNeg,
                     stateOptions = options.states,
                     lineWidth = options.lineWidth,
                     attribs;

             state = state || NORMAL_STATE;

             if (series.state !== state) {
                     series.state = state;

                     if (stateOptions[state] &amp;&amp; stateOptions[state].enabled === false) {
                             return;
                     }

                     if (state) {
                             lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0);
                     }

                     if (graph &amp;&amp; !graph.dashstyle) { // hover is turned off for dashed lines in VML
                             attribs = {
                                     &#39;stroke-width&#39;: lineWidth
                             };
                             // use attr because animate will cause any other animation on the graph to stop
                             graph.attr(attribs);
                             if (graphNeg) {
                                     graphNeg.attr(attribs);
                             }
                     }
             }
     },

     /**
 Set the visibility of the graph

 @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
                             the visibility is toggled.
/
     setVisible: function (vis, redraw) {
             var series = this,
                     chart = series.chart,
                     legendItem = series.legendItem,
                     showOrHide,
                     ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
                     oldVisibility = series.visible;

             // if called without an argument, toggle visibility
             series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
             showOrHide = vis ? &#39;show&#39; : &#39;hide&#39;;

             // show or hide elements
             each([&#39;group&#39;, &#39;dataLabelsGroup&#39;, &#39;markerGroup&#39;, &#39;tracker&#39;], function (key) {
                     if (series[key]) {
                             series[key][showOrHide]();
                     }
             });

             // hide tooltip (#1361)
             if (chart.hoverSeries === series) {
                     series.onMouseOut();
             }

             if (legendItem) {
                     chart.legend.colorizeItem(series, vis);
             }

             // rescale or adapt to resized chart
             series.isDirty = true;
             // in a stack, all other series are affected
             if (series.options.stacking) {
                     each(chart.series, function (otherSeries) {
                             if (otherSeries.options.stacking &amp;&amp; otherSeries.visible) {
                                     otherSeries.isDirty = true;
                             }
                     });
             }

             // show or hide linked series
             each(series.linkedSeries, function (otherSeries) {
                     otherSeries.setVisible(vis, false);
             });

             if (ignoreHiddenSeries) {
                     chart.isDirtyBox = true;
             }
             if (redraw !== false) {
                     chart.redraw();
             }

             fireEvent(series, showOrHide);
     },

     /**
 Memorize tooltip texts and positions
/
     setTooltipPoints: function (renew) {
             var series = this,
                     points = [],
                     pointsLength,
                     low,
                     high,
                     xAxis = series.xAxis,
                     xExtremes = xAxis &amp;&amp; xAxis.getExtremes(),
                     axisLength = xAxis ? (xAxis.tooltipLen || xAxis.len) : series.chart.plotSizeX, // tooltipLen and tooltipPosName used in polar
                     point,
                     pointX,
                     nextPoint,
                     i,
                     tooltipPoints = []; // a lookup array for each pixel in the x dimension

             // don&#39;t waste resources if tracker is disabled
             if (series.options.enableMouseTracking === false || series.singularTooltips) {
                     return;
             }

             // renew
             if (renew) {
                     series.tooltipPoints = null;
             }

             // concat segments to overcome null values
             each(series.segments || series.points, function (segment) {
                     points = points.concat(segment);
             });

             // Reverse the points in case the X axis is reversed
             if (xAxis &amp;&amp; xAxis.reversed) {
                     points = points.reverse();
             }

             // Polar needs additional shaping
             if (series.orderTooltipPoints) {
                     series.orderTooltipPoints(points);
             }

             // Assign each pixel position to the nearest point
             pointsLength = points.length;
             for (i = 0; i &lt; pointsLength; i++) {
                     point = points[i];
                     pointX = point.x;
                     if (pointX &gt;= xExtremes.min &amp;&amp; pointX &lt;= xExtremes.max) { // #1149
                             nextPoint = points[i + 1];

                             // Set this range&#39;s low to the last range&#39;s high plus one
                             low = high === UNDEFINED ? 0 : high + 1;
                             // Now find the new high
                             high = points[i + 1] ?
                                     mathMin(mathMax(0, mathFloor( // #2070
                                             (point.clientX + (nextPoint ? (nextPoint.wrappedClientX || nextPoint.clientX) : axisLength)) / 2
                                     )), axisLength) :
                                     axisLength;

                             while (low &gt;= 0 &amp;&amp; low &lt;= high) {
                                     tooltipPoints[low++] = point;
                             }
                     }
             }
             series.tooltipPoints = tooltipPoints;
     },

     /**
 Show the graph
/
     show: function () {
             this.setVisible(true);
     },

     /**
 Hide the graph
/
     hide: function () {
             this.setVisible(false);
     },

     /**
 Set the selected state of the graph

 @param selected {Boolean} True to select the series, false to unselect. If
                             UNDEFINED, the selection state is toggled.
/
     select: function (selected) {
             var series = this;
             // if called without an argument, toggle
             series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

             if (series.checkbox) {
                     series.checkbox.checked = selected;
             }

             fireEvent(series, selected ? &#39;select&#39; : &#39;unselect&#39;);
     },

     drawTracker: TrackerMixin.drawTrackerGraph</pre>

<p>}); // global variables extend(Highcharts, {</p>

<pre>// Constructors
Axis: Axis,
Chart: Chart,
Color: Color,
Point: Point,
Tick: Tick,     
Renderer: Renderer,
Series: Series,
SVGElement: SVGElement,
SVGRenderer: SVGRenderer,

// Various
arrayMin: arrayMin,
arrayMax: arrayMax,
charts: charts,
dateFormat: dateFormat,
format: format,
pathAnim: pathAnim,
getOptions: getOptions,
hasBidiBug: hasBidiBug,
isTouchDevice: isTouchDevice,
numberFormat: numberFormat,
seriesTypes: seriesTypes,
setOptions: setOptions,
addEvent: addEvent,
removeEvent: removeEvent,
createElement: createElement,
discardElement: discardElement,
css: css,
each: each,
extend: extend,
map: map,
merge: merge,
pick: pick,
splat: splat,
extendClass: extendClass,
pInt: pInt,
wrap: wrap,
svg: hasSVG,
canvas: useCanVG,
vml: !hasSVG &amp;&amp; !useCanVG,
product: PRODUCT,
version: VERSION</pre>

<p>});</p>

<p>}()); // ==ClosureCompiler== // @compilation_level SIMPLE_OPTIMIZATIONS</p>

<p>/**</p>

<pre> @license Highcharts JS v4.0.4 (2014-09-02)

 (c) 2009-2014 Torstein Honsi

 License: www.highcharts.com/license
/</pre>

<p>// JSLint options: /*global Highcharts, HighchartsAdapter, document,
window, navigator, setInterval, clearInterval, clearTimeout, setTimeout,
location, jQuery, $, console */</p>

<p>(function (Highcharts, UNDEFINED) { var arrayMin = Highcharts.arrayMin,</p>

<pre>      arrayMax = Highcharts.arrayMax,
      each = Highcharts.each,
      extend = Highcharts.extend,
      merge = Highcharts.merge,
      map = Highcharts.map,
      pick = Highcharts.pick,
      pInt = Highcharts.pInt,
      defaultPlotOptions = Highcharts.getOptions().plotOptions,
      seriesTypes = Highcharts.seriesTypes,
      extendClass = Highcharts.extendClass,
      splat = Highcharts.splat,
      wrap = Highcharts.wrap,
      Axis = Highcharts.Axis,
      Tick = Highcharts.Tick,
      Point = Highcharts.Point,
      Pointer = Highcharts.Pointer,
      CenteredSeriesMixin = Highcharts.CenteredSeriesMixin,
      TrackerMixin = Highcharts.TrackerMixin,
      Series = Highcharts.Series,
      math = Math,
      mathRound = math.round,
      mathFloor = math.floor,
      mathMax = math.max,
      Color = Highcharts.Color,
      noop = function () {};/**
 The Pane object allows options that are common to a set of X and Y axes.

 In the future, this can be extended to basic Highcharts and Highstock.
/</pre>

<p>function Pane(options, chart, firstAxis) {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">init</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">options</span>, <span class="ruby-identifier">chart</span>, <span class="ruby-identifier">firstAxis</span>);
</pre>

<p>}</p>

<p>// Extend the Pane prototype extend(Pane.prototype, {</p>

<pre>     /**
 Initiate the Pane object
/
     init: function (options, chart, firstAxis) {
             var pane = this,
                     backgroundOption,
                     defaultOptions = pane.defaultOptions;

             pane.chart = chart;

             // Set options
             if (chart.angular) { // gauges
                     defaultOptions.background = {}; // gets extended by this.defaultBackgroundOptions
             }
             pane.options = options = merge(defaultOptions, options);

             backgroundOption = options.background;

             // To avoid having weighty logic to place, update and remove the backgrounds,
             // push them to the first axis&#39; plot bands and borrow the existing logic there.
             if (backgroundOption) {
                     each([].concat(splat(backgroundOption)).reverse(), function (config) {
                             var backgroundColor = config.backgroundColor; // if defined, replace the old one (specific for gradients)
                             config = merge(pane.defaultBackgroundOptions, config);
                             if (backgroundColor) {
                                     config.backgroundColor = backgroundColor;
                             }
                             config.color = config.backgroundColor; // due to naming in plotBands
                             firstAxis.options.plotBands.unshift(config);
                     });
             }
     },

     /**
 The default options object
/
     defaultOptions: {
             // background: {conditional},
             center: [&#39;50%&#39;, &#39;50%&#39;],
             size: &#39;85%&#39;,
             startAngle: 0
             //endAngle: startAngle + 360
     },      

     /**
 The default background options
/
     defaultBackgroundOptions: {
             shape: &#39;circle&#39;,
             borderWidth: 1,
             borderColor: &#39;silver&#39;,
             backgroundColor: {
                     linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
                     stops: [
                             [0, &#39;#FFF&#39;],
                             [1, &#39;#DDD&#39;]
                     ]
             },
             from: -Number.MAX_VALUE, // corrected to axis min
             innerRadius: 0,
             to: Number.MAX_VALUE, // corrected to axis max
             outerRadius: &#39;105%&#39;
     }</pre>

<p>}); var axisProto = Axis.prototype,</p>

<pre class="ruby"><span class="ruby-identifier">tickProto</span> = <span class="ruby-constant">Tick</span>.<span class="ruby-identifier">prototype</span>;
</pre>

<p>/**</p>

<pre> Augmented methods for the x axis in order to hide it completely, used for the X axis in gauges
/</pre>

<p>var hiddenAxisMixin = {</p>

<pre>getOffset: noop,
redraw: function () {
        this.isDirty = false; // prevent setting Y axis dirty
},
render: function () {
        this.isDirty = false; // prevent setting Y axis dirty
},
setScale: noop,
setCategories: noop,
setTitle: noop</pre>

<p>};</p>

<p>/**</p>

<pre> Augmented methods for the value axis
/</pre>

<p>/*jslint unparam: true*/ var radialAxisMixin = {</p>

<pre>     isRadial: true,

     /**
 The default options extend defaultYAxisOptions
/
     defaultRadialGaugeOptions: {
             labels: {
                     align: &#39;center&#39;,
                     x: 0,
                     y: null // auto
             },
             minorGridLineWidth: 0,
             minorTickInterval: &#39;auto&#39;,
             minorTickLength: 10,
             minorTickPosition: &#39;inside&#39;,
             minorTickWidth: 1,
             tickLength: 10,
             tickPosition: &#39;inside&#39;,
             tickWidth: 2,
             title: {
                     rotation: 0
             },
             zIndex: 2 // behind dials, points in the series group
     },

     // Circular axis around the perimeter of a polar chart
     defaultRadialXOptions: {
             gridLineWidth: 1, // spokes
             labels: {
                     align: null, // auto
                     distance: 15,
                     x: 0,
                     y: null // auto
             },
             maxPadding: 0,
             minPadding: 0,
             showLastLabel: false, 
             tickLength: 0
     },

     // Radial axis, like a spoke in a polar chart
     defaultRadialYOptions: {
             gridLineInterpolation: &#39;circle&#39;,
             labels: {
                     align: &#39;right&#39;,
                     x: -3,
                     y: -2
             },
             showLastLabel: false,
             title: {
                     x: 4,
                     text: null,
                     rotation: 90
             }
     },

     /**
 Merge and set options
/
     setOptions: function (userOptions) {

             var options = this.options = merge(
                     this.defaultOptions,
                     this.defaultRadialOptions,
                     userOptions
             );

             // Make sure the plotBands array is instanciated for each Axis (#2649)
             if (!options.plotBands) {
                     options.plotBands = [];
             }

     },

     /**
 Wrap the getOffset method to return zero offset for title or labels in a radial 
 axis
/
     getOffset: function () {
             // Call the Axis prototype method (the method we&#39;re in now is on the instance)
             axisProto.getOffset.call(this);

             // Title or label offsets are not counted
             this.chart.axisOffset[this.side] = 0;

             // Set the center array
             this.center = this.pane.center = CenteredSeriesMixin.getCenter.call(this.pane);
     },

     /**
 Get the path for the axis line. This method is also referenced in the getPlotLinePath
 method.
/
     getLinePath: function (lineWidth, radius) {
             var center = this.center;
             radius = pick(radius, center[2] / 2 - this.offset);

             return this.chart.renderer.symbols.arc(
                     this.left + center[0],
                     this.top + center[1],
                     radius,
                     radius, 
                     {
                             start: this.startAngleRad,
                             end: this.endAngleRad,
                             open: true,
                             innerR: 0
                     }
             );
     },

     /**
 Override setAxisTranslation by setting the translation to the difference
 in rotation. This allows the translate method to return angle for 
 any given value.
/
     setAxisTranslation: function () {

             // Call uber method             
             axisProto.setAxisTranslation.call(this);

             // Set transA and minPixelPadding
             if (this.center) { // it&#39;s not defined the first time
                     if (this.isCircular) {

                             this.transA = (this.endAngleRad - this.startAngleRad) / 
                                     ((this.max - this.min) || 1);

                     } else { 
                             this.transA = (this.center[2] / 2) / ((this.max - this.min) || 1);
                     }

                     if (this.isXAxis) {
                             this.minPixelPadding = this.transA * this.minPointOffset;
                     } else {
                             // This is a workaround for regression #2593, but categories still don&#39;t position correctly.
                             // TODO: Implement true handling of Y axis categories on gauges.
                             this.minPixelPadding = 0; 
                     }
             }
     },

     /**
 In case of auto connect, add one closestPointRange to the max value right before
 tickPositions are computed, so that ticks will extend passed the real max.
/
     beforeSetTickPositions: function () {
             if (this.autoConnect) {
                     this.max += (this.categories &amp;&amp; 1) || this.pointRange || this.closestPointRange || 0; // #1197, #2260
             }
     },

     /**
 Override the setAxisSize method to use the arc&#39;s circumference as length. This
 allows tickPixelInterval to apply to pixel lengths along the perimeter
/
     setAxisSize: function () {

             axisProto.setAxisSize.call(this);

             if (this.isRadial) {

                     // Set the center array
                     this.center = this.pane.center = Highcharts.CenteredSeriesMixin.getCenter.call(this.pane);

                     // The sector is used in Axis.translate to compute the translation of reversed axis points (#2570)
                     if (this.isCircular) {
                             this.sector = this.endAngleRad - this.startAngleRad;    
                     }

                     // Axis len is used to lay out the ticks
                     this.len = this.width = this.height = this.center[2] * pick(this.sector, 1) / 2;

             }
     },

     /**
 Returns the x, y coordinate of a point given by a value and a pixel distance
 from center
/
     getPosition: function (value, length) {
             return this.postTranslate(
                     this.isCircular ? this.translate(value) : 0, // #2848
                     pick(this.isCircular ? length : this.translate(value), this.center[2] / 2) - this.offset
             );              
     },

     /**
 Translate from intermediate plotX (angle), plotY (axis.len - radius) to final chart coordinates. 
/
     postTranslate: function (angle, radius) {

             var chart = this.chart,
                     center = this.center;

             angle = this.startAngleRad + angle;

             return {
                     x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
                     y: chart.plotTop + center[1] + Math.sin(angle) * radius
             }; 

     },

     /**
 Find the path for plot bands along the radial axis
/
     getPlotBandPath: function (from, to, options) {
             var center = this.center,
                     startAngleRad = this.startAngleRad,
                     fullRadius = center[2] / 2,
                     radii = [
                             pick(options.outerRadius, &#39;100%&#39;),
                             options.innerRadius,
                             pick(options.thickness, 10)
                     ],
                     percentRegex = /%$/,
                     start,
                     end,
                     open,
                     isCircular = this.isCircular, // X axis in a polar chart
                     ret;

             // Polygonal plot bands
             if (this.options.gridLineInterpolation === &#39;polygon&#39;) {
                     ret = this.getPlotLinePath(from).concat(this.getPlotLinePath(to, true));

             // Circular grid bands
             } else {

                     // Plot bands on Y axis (radial axis) - inner and outer radius depend on to and from
                     if (!isCircular) {
                             radii[0] = this.translate(from);
                             radii[1] = this.translate(to);
                     }

                     // Convert percentages to pixel values
                     radii = map(radii, function (radius) {
                             if (percentRegex.test(radius)) {
                                     radius = (pInt(radius, 10) * fullRadius) / 100;
                             }
                             return radius;
                     });

                     // Handle full circle
                     if (options.shape === &#39;circle&#39; || !isCircular) {
                             start = -Math.PI / 2;
                             end = Math.PI * 1.5;
                             open = true;
                     } else {
                             start = startAngleRad + this.translate(from);
                             end = startAngleRad + this.translate(to);
                     }

                     ret = this.chart.renderer.symbols.arc(
                             this.left + center[0],
                             this.top + center[1],
                             radii[0],
                             radii[0],
                             {
                                     start: start,
                                     end: end,
                                     innerR: pick(radii[1], radii[0] - radii[2]),
                                     open: open
                             }
                     );
             }

             return ret;
     },

     /**
 Find the path for plot lines perpendicular to the radial axis.
/
     getPlotLinePath: function (value, reverse) {
             var axis = this,
                     center = axis.center,
                     chart = axis.chart,
                     end = axis.getPosition(value),
                     xAxis,
                     xy,
                     tickPositions,
                     ret;

             // Spokes
             if (axis.isCircular) {
                     ret = [&#39;M&#39;, center[0] + chart.plotLeft, center[1] + chart.plotTop, &#39;L&#39;, end.x, end.y];

             // Concentric circles                   
             } else if (axis.options.gridLineInterpolation === &#39;circle&#39;) {
                     value = axis.translate(value);
                     if (value) { // a value of 0 is in the center
                             ret = axis.getLinePath(0, value);
                     }
             // Concentric polygons 
             } else {
                     // Find the X axis in the same pane
                     each(chart.xAxis, function (a) {
                             if (a.pane === axis.pane) {
                                     xAxis = a;
                             }
                     });
                     ret = [];
                     value = axis.translate(value);
                     tickPositions = xAxis.tickPositions;
                     if (xAxis.autoConnect) {
                             tickPositions = tickPositions.concat([tickPositions[0]]);
                     }
                     // Reverse the positions for concatenation of polygonal plot bands
                     if (reverse) {
                             tickPositions = [].concat(tickPositions).reverse();
                     }

                     each(tickPositions, function (pos, i) {
                             xy = xAxis.getPosition(pos, value);
                             ret.push(i ? &#39;L&#39; : &#39;M&#39;, xy.x, xy.y);
                     });

             }
             return ret;
     },

     /**
 Find the position for the axis title, by default inside the gauge
/
     getTitlePosition: function () {
             var center = this.center,
                     chart = this.chart,
                     titleOptions = this.options.title;

             return { 
                     x: chart.plotLeft + center[0] + (titleOptions.x || 0), 
                     y: chart.plotTop + center[1] - ({ high: 0.5, middle: 0.25, low: 0 }[titleOptions.align] * 
                             center[2]) + (titleOptions.y || 0)  
             };
     }</pre>

<p>}; /*jslint unparam: false*/</p>

<p>/**</p>

<pre> Override axisProto.init to mix in special axis instance functions and function overrides
/</pre>

<p>wrap(axisProto, &#39;init&#39;, function (proceed, chart, userOptions) {</p>

<pre>var axis = this,
        angular = chart.angular,
        polar = chart.polar,
        isX = userOptions.isX,
        isHidden = angular &amp;&amp; isX,
        isCircular,
        startAngleRad,
        endAngleRad,
        options,
        chartOptions = chart.options,
        paneIndex = userOptions.pane || 0,
        pane,
        paneOptions;

// Before prototype.init
if (angular) {
        extend(this, isHidden ? hiddenAxisMixin : radialAxisMixin);
        isCircular =  !isX;
        if (isCircular) {
                this.defaultRadialOptions = this.defaultRadialGaugeOptions;
        }

} else if (polar) {
        //extend(this, userOptions.isX ? radialAxisMixin : radialAxisMixin);
        extend(this, radialAxisMixin);
        isCircular = isX;
        this.defaultRadialOptions = isX ? this.defaultRadialXOptions : merge(this.defaultYAxisOptions, this.defaultRadialYOptions);

}

// Run prototype.init
proceed.call(this, chart, userOptions);

if (!isHidden &amp;&amp; (angular || polar)) {
        options = this.options;

        // Create the pane and set the pane options.
        if (!chart.panes) {
                chart.panes = [];
        }
        this.pane = pane = chart.panes[paneIndex] = chart.panes[paneIndex] || new Pane(
                splat(chartOptions.pane)[paneIndex],
                chart,
                axis
        );
        paneOptions = pane.options;

        // Disable certain features on angular and polar axes
        chart.inverted = false;
        chartOptions.chart.zoomType = null;

        // Start and end angle options are
        // given in degrees relative to top, while internal computations are
        // in radians relative to right (like SVG).
        this.startAngleRad = startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180;
        this.endAngleRad = endAngleRad = (pick(paneOptions.endAngle, paneOptions.startAngle + 360)  - 90) * Math.PI / 180;
        this.offset = options.offset || 0;

        this.isCircular = isCircular;

        // Automatically connect grid lines?
        if (isCircular &amp;&amp; userOptions.max === UNDEFINED &amp;&amp; endAngleRad - startAngleRad === 2 * Math.PI) {
                this.autoConnect = true;
        }
}</pre>

<p>});</p>

<p>/**</p>

<pre> Add special cases within the Tick class&#39; methods for radial axes.
/</pre>

<p>wrap(tickProto, &#39;getPosition&#39;, function (proceed, horiz, pos,
tickmarkOffset, old) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">axis</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">axis</span>;

<span class="ruby-keyword">return</span> <span class="ruby-identifier">axis</span>.<span class="ruby-identifier">getPosition</span> <span class="ruby-operator">?</span> 
        <span class="ruby-identifier">axis</span>.<span class="ruby-identifier">getPosition</span>(<span class="ruby-identifier">pos</span>) <span class="ruby-operator">:</span>
        <span class="ruby-identifier">proceed</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">horiz</span>, <span class="ruby-identifier">pos</span>, <span class="ruby-identifier">tickmarkOffset</span>, <span class="ruby-identifier">old</span>);
</pre>

<p>});</p>

<p>/**</p>

<pre> Wrap the getLabelPosition function to find the center position of the label
 based on the distance option
/</pre>

<p>wrap(tickProto, &#39;getLabelPosition&#39;, function (proceed, x, y, label,
horiz, labelOptions, tickmarkOffset, index, step) {</p>

<pre>var axis = this.axis,
        optionsY = labelOptions.y,
        ret,
        align = labelOptions.align,
        angle = ((axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180) % 360;

if (axis.isRadial) {
        ret = axis.getPosition(this.pos, (axis.center[2] / 2) + pick(labelOptions.distance, -25));

        // Automatically rotated
        if (labelOptions.rotation === &#39;auto&#39;) {
                label.attr({ 
                        rotation: angle
                });

        // Vertically centered
        } else if (optionsY === null) {
                optionsY = axis.chart.renderer.fontMetrics(label.styles.fontSize).b - label.getBBox().height / 2;
        }

        // Automatic alignment
        if (align === null) {
                if (axis.isCircular) {
                        if (angle &gt; 20 &amp;&amp; angle &lt; 160) {
                                align = &#39;left&#39;; // right hemisphere
                        } else if (angle &gt; 200 &amp;&amp; angle &lt; 340) {
                                align = &#39;right&#39;; // left hemisphere
                        } else {
                                align = &#39;center&#39;; // top or bottom
                        }
                } else {
                        align = &#39;center&#39;;
                }
                label.attr({
                        align: align
                });
        }

        ret.x += labelOptions.x;
        ret.y += optionsY;

} else {
        ret = proceed.call(this, x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
}
return ret;</pre>

<p>});</p>

<p>/**</p>

<pre> Wrap the getMarkPath function to return the path of the radial marker
/</pre>

<p>wrap(tickProto, &#39;getMarkPath&#39;, function (proceed, x, y, tickLength,
tickWidth, horiz, renderer) {</p>

<pre>var axis = this.axis,
        endPoint,
        ret;

if (axis.isRadial) {
        endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);
        ret = [
                &#39;M&#39;,
                x,
                y,
                &#39;L&#39;,
                endPoint.x,
                endPoint.y
        ];
} else {
        ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);
}
return ret;</pre>

<p>});/*</p>

<pre> The AreaRangeSeries class

/</pre>

<p>/**</p>

<pre> Extend the default options with map options
/</pre>

<p>defaultPlotOptions.arearange = merge(defaultPlotOptions.area, {</p>

<pre>lineWidth: 1,
marker: null,
threshold: null,
tooltip: {
        pointFormat: &#39;&lt;span style=&quot;color:{series.color}&quot;&gt;\u25CF&lt;/span&gt; {series.name}: &lt;b&gt;{point.low}&lt;/b&gt; - &lt;b&gt;{point.high}&lt;/b&gt;&lt;br/&gt;&#39;
},
trackByArea: true,
dataLabels: {
        align: null,
        verticalAlign: null,
        xLow: 0,
        xHigh: 0,
        yLow: 0,
        yHigh: 0        
},
states: {
        hover: {
                halo: false
        }
}</pre>

<p>});</p>

<p>/**</p>

<pre> Add the series type
/</pre>

<p>seriesTypes.arearange = extendClass(seriesTypes.area, {</p>

<pre>     type: &#39;arearange&#39;,
     pointArrayMap: [&#39;low&#39;, &#39;high&#39;],
     toYData: function (point) {
             return [point.low, point.high];
     },
     pointValKey: &#39;low&#39;,

     /**
 Extend getSegments to force null points if the higher value is null. #1703.
/
     getSegments: function () {
             var series = this;

             each(series.points, function (point) {
                     if (!series.options.connectNulls &amp;&amp; (point.low === null || point.high === null)) {
                             point.y = null;
                     } else if (point.low === null &amp;&amp; point.high !== null) {
                             point.y = point.high;
                     }
             });
             Series.prototype.getSegments.call(this);
     },

     /**
 Translate data points from raw values x and y to plotX and plotY
/
     translate: function () {
             var series = this,
                     yAxis = series.yAxis;

             seriesTypes.area.prototype.translate.apply(series);

             // Set plotLow and plotHigh
             each(series.points, function (point) {

                     var low = point.low,
                             high = point.high,
                             plotY = point.plotY;

                     if (high === null &amp;&amp; low === null) {
                             point.y = null;
                     } else if (low === null) {
                             point.plotLow = point.plotY = null;
                             point.plotHigh = yAxis.translate(high, 0, 1, 0, 1);
                     } else if (high === null) {
                             point.plotLow = plotY;
                             point.plotHigh = null;
                     } else {
                             point.plotLow = plotY;
                             point.plotHigh = yAxis.translate(high, 0, 1, 0, 1);
                     }
             });
     },

     /**
 Extend the line series&#39; getSegmentPath method by applying the segment
 path to both lower and higher values of the range
/
     getSegmentPath: function (segment) {

             var lowSegment,
                     highSegment = [],
                     i = segment.length,
                     baseGetSegmentPath = Series.prototype.getSegmentPath,
                     point,
                     linePath,
                     lowerPath,
                     options = this.options,
                     step = options.step,
                     higherPath;

             // Remove nulls from low segment
             lowSegment = HighchartsAdapter.grep(segment, function (point) {
                     return point.plotLow !== null;
             });

             // Make a segment with plotX and plotY for the top values
             while (i--) {
                     point = segment[i];
                     if (point.plotHigh !== null) {
                             highSegment.push({
                                     plotX: point.plotX,
                                     plotY: point.plotHigh
                             });
                     }
             }

             // Get the paths
             lowerPath = baseGetSegmentPath.call(this, lowSegment);
             if (step) {
                     if (step === true) {
                             step = &#39;left&#39;;
                     }
                     options.step = { left: &#39;right&#39;, center: &#39;center&#39;, right: &#39;left&#39; }[step]; // swap for reading in getSegmentPath
             }
             higherPath = baseGetSegmentPath.call(this, highSegment);
             options.step = step;

             // Create a line on both top and bottom of the range
             linePath = [].concat(lowerPath, higherPath);

             // For the area path, we need to change the &#39;move&#39; statement into &#39;lineTo&#39; or &#39;curveTo&#39;
             higherPath[0] = &#39;L&#39;; // this probably doesn&#39;t work for spline                   
             this.areaPath = this.areaPath.concat(lowerPath, higherPath);

             return linePath;
     },

     /**
 Extend the basic drawDataLabels method by running it for both lower and higher
 values.
/
     drawDataLabels: function () {

             var data = this.data,
                     length = data.length,
                     i,
                     originalDataLabels = [],
                     seriesProto = Series.prototype,
                     dataLabelOptions = this.options.dataLabels,
                     align = dataLabelOptions.align,
                     point,
                     inverted = this.chart.inverted;

             if (dataLabelOptions.enabled || this._hasPointLabels) {

                     // Step 1: set preliminary values for plotY and dataLabel and draw the upper labels
                     i = length;
                     while (i--) {
                             point = data[i];

                             // Set preliminary values
                             point.y = point.high;
                             point._plotY = point.plotY;
                             point.plotY = point.plotHigh;

                             // Store original data labels and set preliminary label objects to be picked up 
                             // in the uber method
                             originalDataLabels[i] = point.dataLabel;
                             point.dataLabel = point.dataLabelUpper;

                             // Set the default offset
                             point.below = false;
                             if (inverted) {
                                     if (!align) {
                                             dataLabelOptions.align = &#39;left&#39;;
                                     }
                                     dataLabelOptions.x = dataLabelOptions.xHigh;                                                            
                             } else {
                                     dataLabelOptions.y = dataLabelOptions.yHigh;
                             }
                     }

                     if (seriesProto.drawDataLabels) {
                             seriesProto.drawDataLabels.apply(this, arguments); // #1209
                     }

                     // Step 2: reorganize and handle data labels for the lower values
                     i = length;
                     while (i--) {
                             point = data[i];

                             // Move the generated labels from step 1, and reassign the original data labels
                             point.dataLabelUpper = point.dataLabel;
                             point.dataLabel = originalDataLabels[i];

                             // Reset values
                             point.y = point.low;
                             point.plotY = point._plotY;

                             // Set the default offset
                             point.below = true;
                             if (inverted) {
                                     if (!align) {
                                             dataLabelOptions.align = &#39;right&#39;;
                                     }
                                     dataLabelOptions.x = dataLabelOptions.xLow;
                             } else {
                                     dataLabelOptions.y = dataLabelOptions.yLow;
                             }
                     }
                     if (seriesProto.drawDataLabels) {
                             seriesProto.drawDataLabels.apply(this, arguments);
                     }
             }

             dataLabelOptions.align = align;

     },

     alignDataLabel: function () {
             seriesTypes.column.prototype.alignDataLabel.apply(this, arguments);
     },

     getSymbol: noop,

     drawPoints: noop</pre>

<p>});/**</p>

<pre> The AreaSplineRangeSeries class
/</pre>

<p>defaultPlotOptions.areasplinerange = merge(defaultPlotOptions.arearange);</p>

<p>/**</p>

<pre> AreaSplineRangeSeries object
/</pre>

<p>seriesTypes.areasplinerange = extendClass(seriesTypes.arearange, {</p>

<pre>type: &#39;areasplinerange&#39;,
getPointSpline: seriesTypes.spline.prototype.getPointSpline</pre>

<p>});</p>

<p>(function () {</p>

<pre>     var colProto = seriesTypes.column.prototype;

     /**
 The ColumnRangeSeries class
/
     defaultPlotOptions.columnrange = merge(defaultPlotOptions.column, defaultPlotOptions.arearange, {
             lineWidth: 1,
             pointRange: null
     });

     /**
 ColumnRangeSeries object
/
     seriesTypes.columnrange = extendClass(seriesTypes.arearange, {
             type: &#39;columnrange&#39;,
             /**
  Translate data points from raw values x and y to plotX and plotY
 /
             translate: function () {
                     var series = this,
                             yAxis = series.yAxis,
                             plotHigh;

                     colProto.translate.apply(series);

                     // Set plotLow and plotHigh
                     each(series.points, function (point) {
                             var shapeArgs = point.shapeArgs,
                                     minPointLength = series.options.minPointLength,
                                     heightDifference,
                                     height,
                                     y;

                             point.tooltipPos = null; // don&#39;t inherit from column
                             point.plotHigh = plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);
                             point.plotLow = point.plotY;

                             // adjust shape
                             y = plotHigh;
                             height = point.plotY - plotHigh;

                             if (height &lt; minPointLength) {
                                     heightDifference = (minPointLength - height);
                                     height += heightDifference;
                                     y -= heightDifference / 2;
                             }
                             shapeArgs.height = height;
                             shapeArgs.y = y;
                     });
             },
             trackerGroups: [&#39;group&#39;, &#39;dataLabelsGroup&#39;],
             drawGraph: noop,
             pointAttrToOptions: colProto.pointAttrToOptions,
             drawPoints: colProto.drawPoints,
             drawTracker: colProto.drawTracker,
             animate: colProto.animate,
             getColumnMetrics: colProto.getColumnMetrics
     });</pre>

<p>}());</p>

<p>/*</p>

<pre> The GaugeSeries class
/</pre>

<p>/**</p>

<pre> Extend the default options
/</pre>

<p>defaultPlotOptions.gauge = merge(defaultPlotOptions.line, {</p>

<pre>dataLabels: {
        enabled: true,
        defer: false,
        y: 15,
        borderWidth: 1,
        borderColor: &#39;silver&#39;,
        borderRadius: 3,
        crop: false,
        style: {
                fontWeight: &#39;bold&#39;
        },
        verticalAlign: &#39;top&#39;,
        zIndex: 2
},
dial: {
        // radius: &#39;80%&#39;,
        // backgroundColor: &#39;black&#39;,
        // borderColor: &#39;silver&#39;,
        // borderWidth: 0,
        // baseWidth: 3,
        // topWidth: 1,
        // baseLength: &#39;70%&#39; // of radius
        // rearLength: &#39;10%&#39;
},
pivot: {
        //radius: 5,
        //borderWidth: 0
        //borderColor: &#39;silver&#39;,
        //backgroundColor: &#39;black&#39;
},
tooltip: {
        headerFormat: &#39;&#39;
},
showInLegend: false</pre>

<p>});</p>

<p>/**</p>

<pre> Extend the point object
/</pre>

<p>var GaugePoint = extendClass(Point, {</p>

<pre>     /**
 Don&#39;t do any hover colors or anything
/
     setState: function (state) {
             this.state = state;
     }</pre>

<p>});</p>

<p>/**</p>

<pre> Add the series type
/</pre>

<p>var GaugeSeries = {</p>

<pre>     type: &#39;gauge&#39;,
     pointClass: GaugePoint,

     // chart.angular will be set to true when a gauge series is present, and this will
     // be used on the axes
     angular: true, 
     drawGraph: noop,
     fixedBox: true,
     forceDL: true,
     trackerGroups: [&#39;group&#39;, &#39;dataLabelsGroup&#39;],

     /**
 Calculate paths etc
/
     translate: function () {

             var series = this,
                     yAxis = series.yAxis,
                     options = series.options,
                     center = yAxis.center;

             series.generatePoints();

             each(series.points, function (point) {

                     var dialOptions = merge(options.dial, point.dial),
                             radius = (pInt(pick(dialOptions.radius, 80)) * center[2]) / 200,
                             baseLength = (pInt(pick(dialOptions.baseLength, 70)) * radius) / 100,
                             rearLength = (pInt(pick(dialOptions.rearLength, 10)) * radius) / 100,
                             baseWidth = dialOptions.baseWidth || 3,
                             topWidth = dialOptions.topWidth || 1,
                             overshoot = options.overshoot,
                             rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true);

                     // Handle the wrap and overshoot options
                     if (overshoot &amp;&amp; typeof overshoot === &#39;number&#39;) {
                             overshoot = overshoot / 180 * Math.PI;
                             rotation = Math.max(yAxis.startAngleRad - overshoot, Math.min(yAxis.endAngleRad + overshoot, rotation));                        

                     } else if (options.wrap === false) {
                             rotation = Math.max(yAxis.startAngleRad, Math.min(yAxis.endAngleRad, rotation));
                     }

                     rotation = rotation * 180 / Math.PI;

                     point.shapeType = &#39;path&#39;;
                     point.shapeArgs = {
                             d: dialOptions.path || [
                                     &#39;M&#39;, 
                                     -rearLength, -baseWidth / 2, 
                                     &#39;L&#39;, 
                                     baseLength, -baseWidth / 2,
                                     radius, -topWidth / 2,
                                     radius, topWidth / 2,
                                     baseLength, baseWidth / 2,
                                     -rearLength, baseWidth / 2,
                                     &#39;z&#39;
                             ],
                             translateX: center[0],
                             translateY: center[1],
                             rotation: rotation
                     };

                     // Positions for data label
                     point.plotX = center[0];
                     point.plotY = center[1];
             });
     },

     /**
 Draw the points where each point is one needle
/
     drawPoints: function () {

             var series = this,
                     center = series.yAxis.center,
                     pivot = series.pivot,
                     options = series.options,
                     pivotOptions = options.pivot,
                     renderer = series.chart.renderer;

             each(series.points, function (point) {

                     var graphic = point.graphic,
                             shapeArgs = point.shapeArgs,
                             d = shapeArgs.d,
                             dialOptions = merge(options.dial, point.dial); // #1233

                     if (graphic) {
                             graphic.animate(shapeArgs);
                             shapeArgs.d = d; // animate alters it
                     } else {
                             point.graphic = renderer[point.shapeType](shapeArgs)
                                     .attr({
                                             stroke: dialOptions.borderColor || &#39;none&#39;,
                                             &#39;stroke-width&#39;: dialOptions.borderWidth || 0,
                                             fill: dialOptions.backgroundColor || &#39;black&#39;,
                                             rotation: shapeArgs.rotation // required by VML when animation is false
                                     })
                                     .add(series.group);
                     }
             });

             // Add or move the pivot
             if (pivot) {
                     pivot.animate({ // #1235
                             translateX: center[0],
                             translateY: center[1]
                     });
             } else {
                     series.pivot = renderer.circle(0, 0, pick(pivotOptions.radius, 5))
                             .attr({
                                     &#39;stroke-width&#39;: pivotOptions.borderWidth || 0,
                                     stroke: pivotOptions.borderColor || &#39;silver&#39;,
                                     fill: pivotOptions.backgroundColor || &#39;black&#39;
                             })
                             .translate(center[0], center[1])
                             .add(series.group);
             }
     },

     /**
 Animate the arrow up from startAngle
/
     animate: function (init) {
             var series = this;

             if (!init) {
                     each(series.points, function (point) {
                             var graphic = point.graphic;

                             if (graphic) {
                                     // start value
                                     graphic.attr({
                                             rotation: series.yAxis.startAngleRad * 180 / Math.PI
                                     });

                                     // animate
                                     graphic.animate({
                                             rotation: point.shapeArgs.rotation
                                     }, series.options.animation);
                             }
                     });

                     // delete this function to allow it only once
                     series.animate = null;
             }
     },

     render: function () {
             this.group = this.plotGroup(
                     &#39;group&#39;, 
                     &#39;series&#39;, 
                     this.visible ? &#39;visible&#39; : &#39;hidden&#39;, 
                     this.options.zIndex, 
                     this.chart.seriesGroup
             );
             Series.prototype.render.call(this);
             this.group.clip(this.chart.clipRect);
     },

     /**
 Extend the basic setData method by running processData and generatePoints immediately,
 in order to access the points from the legend.
/
     setData: function (data, redraw) {
             Series.prototype.setData.call(this, data, false);
             this.processData();
             this.generatePoints();
             if (pick(redraw, true)) {
                     this.chart.redraw();
             }
     },

     /**
 If the tracking module is loaded, add the point tracker
/
     drawTracker: TrackerMixin &amp;&amp; TrackerMixin.drawTrackerPoint</pre>

<p>}; seriesTypes.gauge = extendClass(seriesTypes.line, GaugeSeries);</p>

<p>/*
****************************************************************************</p>

<pre>Start Box plot series code                                                                                         *
***************************************************************************/</pre>

<p>// Set default options defaultPlotOptions.boxplot =
merge(defaultPlotOptions.column, {</p>

<pre>fillColor: &#39;#FFFFFF&#39;,
lineWidth: 1,
//medianColor: null,
medianWidth: 2,
states: {
        hover: {
                brightness: -0.3
        }
},
//stemColor: null,
//stemDashStyle: &#39;solid&#39;
//stemWidth: null,
threshold: null,
tooltip: {
        pointFormat: &#39;&lt;span style=&quot;color:{series.color}&quot;&gt;\u25CF&lt;/span&gt; &lt;b&gt; {series.name}&lt;/b&gt;&lt;br/&gt;&#39; +
                &#39;Maximum: {point.high}&lt;br/&gt;&#39; +
                &#39;Upper quartile: {point.q3}&lt;br/&gt;&#39; +
                &#39;Median: {point.median}&lt;br/&gt;&#39; +
                &#39;Lower quartile: {point.q1}&lt;br/&gt;&#39; +
                &#39;Minimum: {point.low}&lt;br/&gt;&#39;

},
//whiskerColor: null,
whiskerLength: &#39;50%&#39;,
whiskerWidth: 2</pre>

<p>});</p>

<p>// Create the series object seriesTypes.boxplot =
extendClass(seriesTypes.column, {</p>

<pre>     type: &#39;boxplot&#39;,
     pointArrayMap: [&#39;low&#39;, &#39;q1&#39;, &#39;median&#39;, &#39;q3&#39;, &#39;high&#39;], // array point configs are mapped to this
     toYData: function (point) { // return a plain array for speedy calculation
             return [point.low, point.q1, point.median, point.q3, point.high];
     },
     pointValKey: &#39;high&#39;, // defines the top of the tracker

     /**
 One-to-one mapping from options to SVG attributes
/
     pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
             fill: &#39;fillColor&#39;,
             stroke: &#39;color&#39;,
             &#39;stroke-width&#39;: &#39;lineWidth&#39;
     },

     /**
 Disable data labels for box plot
/
     drawDataLabels: noop,

     /**
 Translate data points from raw values x and y to plotX and plotY
/
     translate: function () {
             var series = this,
                     yAxis = series.yAxis,
                     pointArrayMap = series.pointArrayMap;

             seriesTypes.column.prototype.translate.apply(series);

             // do the translation on each point dimension
             each(series.points, function (point) {
                     each(pointArrayMap, function (key) {
                             if (point[key] !== null) {
                                     point[key + &#39;Plot&#39;] = yAxis.translate(point[key], 0, 1, 0, 1);
                             }
                     });
             });
     },

     /**
 Draw the data points
/
     drawPoints: function () {
             var series = this,  //state = series.state,
                     points = series.points,
                     options = series.options,
                     chart = series.chart,
                     renderer = chart.renderer,
                     pointAttr,
                     q1Plot,
                     q3Plot,
                     highPlot,
                     lowPlot,
                     medianPlot,
                     crispCorr,
                     crispX,
                     graphic,
                     stemPath,
                     stemAttr,
                     boxPath,
                     whiskersPath,
                     whiskersAttr,
                     medianPath,
                     medianAttr,
                     width,
                     left,
                     right,
                     halfWidth,
                     shapeArgs,
                     color,
                     doQuartiles = series.doQuartiles !== false, // error bar inherits this series type but doesn&#39;t do quartiles
                     whiskerLength = parseInt(series.options.whiskerLength, 10) / 100;

             each(points, function (point) {

                     graphic = point.graphic;
                     shapeArgs = point.shapeArgs; // the box
                     stemAttr = {};
                     whiskersAttr = {};
                     medianAttr = {};
                     color = point.color || series.color;

                     if (point.plotY !== UNDEFINED) {

                             pointAttr = point.pointAttr[point.selected ? &#39;selected&#39; : &#39;&#39;];

                             // crisp vector coordinates
                             width = shapeArgs.width;
                             left = mathFloor(shapeArgs.x);
                             right = left + width;
                             halfWidth = mathRound(width / 2);
                             //crispX = mathRound(left + halfWidth) + crispCorr;
                             q1Plot = mathFloor(doQuartiles ? point.q1Plot : point.lowPlot);// + crispCorr;
                             q3Plot = mathFloor(doQuartiles ? point.q3Plot : point.lowPlot);// + crispCorr;
                             highPlot = mathFloor(point.highPlot);// + crispCorr;
                             lowPlot = mathFloor(point.lowPlot);// + crispCorr;

                             // Stem attributes
                             stemAttr.stroke = point.stemColor || options.stemColor || color;
                             stemAttr[&#39;stroke-width&#39;] = pick(point.stemWidth, options.stemWidth, options.lineWidth);
                             stemAttr.dashstyle = point.stemDashStyle || options.stemDashStyle;

                             // Whiskers attributes
                             whiskersAttr.stroke = point.whiskerColor || options.whiskerColor || color;
                             whiskersAttr[&#39;stroke-width&#39;] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);

                             // Median attributes
                             medianAttr.stroke = point.medianColor || options.medianColor || color;
                             medianAttr[&#39;stroke-width&#39;] = pick(point.medianWidth, options.medianWidth, options.lineWidth);
                             medianAttr[&#39;stroke-linecap&#39;] = &#39;round&#39;; // #1638

                             // The stem
                             crispCorr = (stemAttr[&#39;stroke-width&#39;] % 2) / 2;
                             crispX = left + halfWidth + crispCorr;                          
                             stemPath = [
                                     // stem up
                                     &#39;M&#39;,
                                     crispX, q3Plot,
                                     &#39;L&#39;,
                                     crispX, highPlot,

                                     // stem down
                                     &#39;M&#39;,
                                     crispX, q1Plot,
                                     &#39;L&#39;,
                                     crispX, lowPlot
                             ];

                             // The box
                             if (doQuartiles) {
                                     crispCorr = (pointAttr[&#39;stroke-width&#39;] % 2) / 2;
                                     crispX = mathFloor(crispX) + crispCorr;
                                     q1Plot = mathFloor(q1Plot) + crispCorr;
                                     q3Plot = mathFloor(q3Plot) + crispCorr;
                                     left += crispCorr;
                                     right += crispCorr;
                                     boxPath = [
                                             &#39;M&#39;,
                                             left, q3Plot,
                                             &#39;L&#39;,
                                             left, q1Plot,
                                             &#39;L&#39;,
                                             right, q1Plot,
                                             &#39;L&#39;,
                                             right, q3Plot,
                                             &#39;L&#39;,
                                             left, q3Plot,
                                             &#39;z&#39;
                                     ];
                             }

                             // The whiskers
                             if (whiskerLength) {
                                     crispCorr = (whiskersAttr[&#39;stroke-width&#39;] % 2) / 2;
                                     highPlot = highPlot + crispCorr;
                                     lowPlot = lowPlot + crispCorr;
                                     whiskersPath = [
                                             // High whisker
                                             &#39;M&#39;,
                                             crispX - halfWidth * whiskerLength, 
                                             highPlot,
                                             &#39;L&#39;,
                                             crispX + halfWidth * whiskerLength, 
                                             highPlot,

                                             // Low whisker
                                             &#39;M&#39;,
                                             crispX - halfWidth * whiskerLength, 
                                             lowPlot,
                                             &#39;L&#39;,
                                             crispX + halfWidth * whiskerLength, 
                                             lowPlot
                                     ];
                             }

                             // The median
                             crispCorr = (medianAttr[&#39;stroke-width&#39;] % 2) / 2;                               
                             medianPlot = mathRound(point.medianPlot) + crispCorr;
                             medianPath = [
                                     &#39;M&#39;,
                                     left, 
                                     medianPlot,
                                     &#39;L&#39;,
                                     right, 
                                     medianPlot
                             ];

                             // Create or update the graphics
                             if (graphic) { // update

                                     point.stem.animate({ d: stemPath });
                                     if (whiskerLength) {
                                             point.whiskers.animate({ d: whiskersPath });
                                     }
                                     if (doQuartiles) {
                                             point.box.animate({ d: boxPath });
                                     }
                                     point.medianShape.animate({ d: medianPath });

                             } else { // create new
                                     point.graphic = graphic = renderer.g()
                                             .add(series.group);

                                     point.stem = renderer.path(stemPath)
                                             .attr(stemAttr)
                                             .add(graphic);

                                     if (whiskerLength) {
                                             point.whiskers = renderer.path(whiskersPath) 
                                                     .attr(whiskersAttr)
                                                     .add(graphic);
                                     }
                                     if (doQuartiles) {
                                             point.box = renderer.path(boxPath)
                                                     .attr(pointAttr)
                                                     .add(graphic);
                                     }       
                                     point.medianShape = renderer.path(medianPath)
                                             .attr(medianAttr)
                                             .add(graphic);
                             }
                     }
             });

     }</pre>

<p>});</p>

<p>/*
****************************************************************************</p>

<pre>End Box plot series code                                                                                             *
***************************************************************************/</pre>

<p>/*
****************************************************************************</p>

<pre>Start error bar series code                                                *
***************************************************************************/</pre>

<p>// 1 - set default options defaultPlotOptions.errorbar =
merge(defaultPlotOptions.boxplot, {</p>

<pre>color: &#39;#000000&#39;,
grouping: false,
linkedTo: &#39;:previous&#39;,
tooltip: {
        pointFormat: &#39;&lt;span style=&quot;color:{series.color}&quot;&gt;\u25CF&lt;/span&gt; {series.name}: &lt;b&gt;{point.low}&lt;/b&gt; - &lt;b&gt;{point.high}&lt;/b&gt;&lt;br/&gt;&#39;
},
whiskerWidth: null</pre>

<p>});</p>

<p>// 2 - Create the series object seriesTypes.errorbar =
extendClass(seriesTypes.boxplot, {</p>

<pre>     type: &#39;errorbar&#39;,
     pointArrayMap: [&#39;low&#39;, &#39;high&#39;], // array point configs are mapped to this
     toYData: function (point) { // return a plain array for speedy calculation
             return [point.low, point.high];
     },
     pointValKey: &#39;high&#39;, // defines the top of the tracker
     doQuartiles: false,
     drawDataLabels: seriesTypes.arearange ? seriesTypes.arearange.prototype.drawDataLabels : noop,

     /**
 Get the width and X offset, either on top of the linked series column
 or standalone
/
     getColumnMetrics: function () {
             return (this.linkedParent &amp;&amp; this.linkedParent.columnMetrics) || 
                     seriesTypes.column.prototype.getColumnMetrics.call(this);
     }</pre>

<p>});</p>

<p>/*
****************************************************************************</p>

<pre>End error bar series code                                                  *
***************************************************************************/</pre>

<p>/*
****************************************************************************</p>

<pre>Start Waterfall series code                                                *
***************************************************************************/</pre>

<p>// 1 - set default options defaultPlotOptions.waterfall =
merge(defaultPlotOptions.column, {</p>

<pre>lineWidth: 1,
lineColor: &#39;#333&#39;,
dashStyle: &#39;dot&#39;,
borderColor: &#39;#333&#39;,
states: {
        hover: {
                lineWidthPlus: 0 // #3126
        }
}</pre>

<p>});</p>

<p>// 2 - Create the series object seriesTypes.waterfall =
extendClass(seriesTypes.column, {</p>

<pre>     type: &#39;waterfall&#39;,

     upColorProp: &#39;fill&#39;,

     pointArrayMap: [&#39;low&#39;, &#39;y&#39;],

     pointValKey: &#39;y&#39;,

     /**
 Init waterfall series, force stacking
/
     init: function (chart, options) {
             // force stacking
             options.stacking = true;

             seriesTypes.column.prototype.init.call(this, chart, options);
     },

     /**
 Translate data points from raw values
/
     translate: function () {
             var series = this,
                     options = series.options,
                     yAxis = series.yAxis,
                     len,
                     i,
                     points,
                     point,
                     shapeArgs,
                     stack,
                     y,
                     previousY,
                     previousIntermediate,
                     stackPoint,
                     threshold = options.threshold,
                     tooltipY;

             // run column series translate
             seriesTypes.column.prototype.translate.apply(this);

             previousY = previousIntermediate = threshold;
             points = series.points;

             for (i = 0, len = points.length; i &lt; len; i++) {
                     // cache current point object
                     point = points[i];
                     shapeArgs = point.shapeArgs;

                     // get current stack
                     stack = series.getStack(i);
                     stackPoint = stack.points[series.index + &#39;,&#39; + i];

                     // override point value for sums
                     if (isNaN(point.y)) {
                             point.y = series.yData[i];
                     }

                     // up points
                     y = mathMax(previousY, previousY + point.y) + stackPoint[0];
                     shapeArgs.y = yAxis.translate(y, 0, 1);

                     // sum points
                     if (point.isSum) {
                             shapeArgs.y = yAxis.translate(stackPoint[1], 0, 1);
                             shapeArgs.height = yAxis.translate(stackPoint[0], 0, 1) - shapeArgs.y;

                     } else if (point.isIntermediateSum) {
                             shapeArgs.y = yAxis.translate(stackPoint[1], 0, 1);
                             shapeArgs.height = yAxis.translate(previousIntermediate, 0, 1) - shapeArgs.y;
                             previousIntermediate = stackPoint[1];

                     // if it&#39;s not the sum point, update previous stack end position
                     } else {
                             previousY += stack.total;
                     }

                     // negative points
                     if (shapeArgs.height &lt; 0) {
                             shapeArgs.y += shapeArgs.height;
                             shapeArgs.height *= -1;
                     }

                     point.plotY = shapeArgs.y = mathRound(shapeArgs.y) - (series.borderWidth % 2) / 2;
                     shapeArgs.height = mathMax(mathRound(shapeArgs.height), 0.001); // #3151
                     point.yBottom = shapeArgs.y + shapeArgs.height;

                     // Correct tooltip placement (#3014)
                     tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);
                     if (series.chart.inverted) {
                             point.tooltipPos[0] = yAxis.len - tooltipY;
                     } else {
                             point.tooltipPos[1] = tooltipY;
                     }

             }
     },

     /**
 Call default processData then override yData to reflect waterfall&#39;s extremes on yAxis
/
     processData: function (force) {
             var series = this,
                     options = series.options,
                     yData = series.yData,
                     points = series.points,
                     point,
                     dataLength = yData.length,
                     threshold = options.threshold || 0,
                     subSum,
                     sum,
                     dataMin,
                     dataMax,
                     y,
                     i;

             sum = subSum = dataMin = dataMax = threshold;

             for (i = 0; i &lt; dataLength; i++) {
                     y = yData[i];
                     point = points &amp;&amp; points[i] ? points[i] : {};

                     if (y === &quot;sum&quot; || point.isSum) {
                             yData[i] = sum;
                     } else if (y === &quot;intermediateSum&quot; || point.isIntermediateSum) {
                             yData[i] = subSum;
                     } else {
                             sum += y;
                             subSum += y;
                     }
                     dataMin = Math.min(sum, dataMin);
                     dataMax = Math.max(sum, dataMax);
             }

             Series.prototype.processData.call(this, force);

             // Record extremes
             series.dataMin = dataMin;
             series.dataMax = dataMax;
     },

     /**
 Return y value or string if point is sum
/
     toYData: function (pt) {
             if (pt.isSum) {
                     return (pt.x === 0 ? null : &quot;sum&quot;); //#3245 Error when first element is Sum or Intermediate Sum
             } else if (pt.isIntermediateSum) {
                     return (pt.x === 0 ? null : &quot;intermediateSum&quot;); //#3245
             }
             return pt.y;
     },

     /**
 Postprocess mapping between options and SVG attributes
/
     getAttribs: function () {
             seriesTypes.column.prototype.getAttribs.apply(this, arguments);

             var series = this,
                     options = series.options,
                     stateOptions = options.states,
                     upColor = options.upColor || series.color,
                     hoverColor = Highcharts.Color(upColor).brighten(0.1).get(),
                     seriesDownPointAttr = merge(series.pointAttr),
                     upColorProp = series.upColorProp;

             seriesDownPointAttr[&#39;&#39;][upColorProp] = upColor;
             seriesDownPointAttr.hover[upColorProp] = stateOptions.hover.upColor || hoverColor;
             seriesDownPointAttr.select[upColorProp] = stateOptions.select.upColor || upColor;

             each(series.points, function (point) {
                     if (point.y &gt; 0 &amp;&amp; !point.color) {
                             point.pointAttr = seriesDownPointAttr;
                             point.color = upColor;
                     }
             });
     },

     /**
 Draw columns&#39; connector lines
/
     getGraphPath: function () {

             var data = this.data,
                     length = data.length,
                     lineWidth = this.options.lineWidth + this.borderWidth,
                     normalizer = mathRound(lineWidth) % 2 / 2,
                     path = [],
                     M = &#39;M&#39;,
                     L = &#39;L&#39;,
                     prevArgs,
                     pointArgs,
                     i,
                     d;

             for (i = 1; i &lt; length; i++) {
                     pointArgs = data[i].shapeArgs;
                     prevArgs = data[i - 1].shapeArgs;

                     d = [
                             M,
                             prevArgs.x + prevArgs.width, prevArgs.y + normalizer,
                             L,
                             pointArgs.x, prevArgs.y + normalizer
                     ];

                     if (data[i - 1].y &lt; 0) {
                             d[2] += prevArgs.height;
                             d[5] += prevArgs.height;
                     }

                     path = path.concat(d);
             }

             return path;
     },

     /**
 Extremes are recorded in processData
/
     getExtremes: noop,

     /**
 Return stack for given index
/
     getStack: function (i) {
             var axis = this.yAxis,
                     stacks = axis.stacks,
                     key = this.stackKey;

             if (this.processedYData[i] &lt; this.options.threshold) {
                     key = &#39;-&#39; + key;
             }

             return stacks[key][i];
     },

     drawGraph: Series.prototype.drawGraph</pre>

<p>});</p>

<p>/*
****************************************************************************</p>

<pre>End Waterfall series code                                                  *
***************************************************************************/</pre>

<p>/*
****************************************************************************</p>

<pre>Start Bubble series code                                                                                               *
***************************************************************************/</pre>

<p>// 1 - set default options defaultPlotOptions.bubble =
merge(defaultPlotOptions.scatter, {</p>

<pre>dataLabels: {
        formatter: function () { // #2945
                return this.point.z;
        },
        inside: true,
        style: {
                color: &#39;white&#39;,
                textShadow: &#39;0px 0px 3px black&#39;
        },
        verticalAlign: &#39;middle&#39;
},
// displayNegative: true,
marker: {
        // fillOpacity: 0.5,
        lineColor: null, // inherit from series.color
        lineWidth: 1
},
minSize: 8,
maxSize: &#39;20%&#39;,
// negativeColor: null,
// sizeBy: &#39;area&#39;
states: {
        hover: {
                halo: {
                        size: 5
                }
        }
},
tooltip: {
        pointFormat: &#39;({point.x}, {point.y}), Size: {point.z}&#39;
},
turboThreshold: 0,
zThreshold: 0</pre>

<p>});</p>

<p>var BubblePoint = extendClass(Point, {</p>

<pre>haloPath: function () {
        return Point.prototype.haloPath.call(this, this.shapeArgs.r + this.series.options.states.hover.halo.size);
}</pre>

<p>});</p>

<p>// 2 - Create the series object seriesTypes.bubble =
extendClass(seriesTypes.scatter, {</p>

<pre>     type: &#39;bubble&#39;,
     pointClass: BubblePoint,
     pointArrayMap: [&#39;y&#39;, &#39;z&#39;],
     parallelArrays: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;],
     trackerGroups: [&#39;group&#39;, &#39;dataLabelsGroup&#39;],
     bubblePadding: true,

     /**
 Mapping between SVG attributes and the corresponding options
/
     pointAttrToOptions: { 
             stroke: &#39;lineColor&#39;,
             &#39;stroke-width&#39;: &#39;lineWidth&#39;,
             fill: &#39;fillColor&#39;
     },

     /**
 Apply the fillOpacity to all fill positions
/
     applyOpacity: function (fill) {
             var markerOptions = this.options.marker,
                     fillOpacity = pick(markerOptions.fillOpacity, 0.5);

             // When called from Legend.colorizeItem, the fill isn&#39;t predefined
             fill = fill || markerOptions.fillColor || this.color; 

             if (fillOpacity !== 1) {
                     fill = Color(fill).setOpacity(fillOpacity).get(&#39;rgba&#39;);
             }
             return fill;
     },

     /**
 Extend the convertAttribs method by applying opacity to the fill
/
     convertAttribs: function () {
             var obj = Series.prototype.convertAttribs.apply(this, arguments);

             obj.fill = this.applyOpacity(obj.fill);

             return obj;
     },

     /**
 Get the radius for each point based on the minSize, maxSize and each point&#39;s Z value. This
 must be done prior to Series.translate because the axis needs to add padding in 
 accordance with the point sizes.
/
     getRadii: function (zMin, zMax, minSize, maxSize) {
             var len,
                     i,
                     pos,
                     zData = this.zData,
                     radii = [],
                     sizeByArea = this.options.sizeBy !== &#39;width&#39;,
                     zRange;

             // Set the shape type and arguments to be picked up in drawPoints
             for (i = 0, len = zData.length; i &lt; len; i++) {
                     zRange = zMax - zMin;
                     pos = zRange &gt; 0 ? // relative size, a number between 0 and 1
                             (zData[i] - zMin) / (zMax - zMin) : 
                             0.5;
                     if (sizeByArea &amp;&amp; pos &gt;= 0) {
                             pos = Math.sqrt(pos);
                     }
                     radii.push(math.ceil(minSize + pos * (maxSize - minSize)) / 2);
             }
             this.radii = radii;
     },

     /**
 Perform animation on the bubbles
/
     animate: function (init) {
             var animation = this.options.animation;

             if (!init) { // run the animation
                     each(this.points, function (point) {
                             var graphic = point.graphic,
                                     shapeArgs = point.shapeArgs;

                             if (graphic &amp;&amp; shapeArgs) {
                                     // start values
                                     graphic.attr(&#39;r&#39;, 1);

                                     // animate
                                     graphic.animate({
                                             r: shapeArgs.r
                                     }, animation);
                             }
                     });

                     // delete this function to allow it only once
                     this.animate = null;
             }
     },

     /**
 Extend the base translate method to handle bubble size
/
     translate: function () {

             var i,
                     data = this.data,
                     point,
                     radius,
                     radii = this.radii;

             // Run the parent method
             seriesTypes.scatter.prototype.translate.call(this);

             // Set the shape type and arguments to be picked up in drawPoints
             i = data.length;

             while (i--) {
                     point = data[i];
                     radius = radii ? radii[i] : 0; // #1737

                     // Flag for negativeColor to be applied in Series.js
                     point.negative = point.z &lt; (this.options.zThreshold || 0);

                     if (radius &gt;= this.minPxSize / 2) {
                             // Shape arguments
                             point.shapeType = &#39;circle&#39;;
                             point.shapeArgs = {
                                     x: point.plotX,
                                     y: point.plotY,
                                     r: radius
                             };

                             // Alignment box for the data label
                             point.dlBox = {
                                     x: point.plotX - radius,
                                     y: point.plotY - radius,
                                     width: 2 * radius,
                                     height: 2 * radius
                             };
                     } else { // below zThreshold
                             point.shapeArgs = point.plotY = point.dlBox = UNDEFINED; // #1691
                     }
             }
     },

     /**
 Get the series&#39; symbol in the legend

 @param {Object} legend The legend object
 @param {Object} item The series (this) or point
/
     drawLegendSymbol: function (legend, item) {
             var radius = pInt(legend.itemStyle.fontSize) / 2;

             item.legendSymbol = this.chart.renderer.circle(
                     radius,
                     legend.baseline - radius,
                     radius
             ).attr({
                     zIndex: 3
             }).add(item.legendGroup);
             item.legendSymbol.isMarker = true;      

     },

     drawPoints: seriesTypes.column.prototype.drawPoints,
     alignDataLabel: seriesTypes.column.prototype.alignDataLabel</pre>

<p>});</p>

<p>/**</p>

<pre class="ruby"> <span class="ruby-constant">Add</span> <span class="ruby-identifier">logic</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">pad</span> <span class="ruby-identifier">each</span> <span class="ruby-identifier">axis</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">amount</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">pixels</span>
 <span class="ruby-identifier">necessary</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">avoid</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">bubbles</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">overflow</span>.
<span class="ruby-operator">/</span>
</pre>

<p>Axis.prototype.beforePadding = function () {</p>

<pre>var axis = this,
        axisLength = this.len,
        chart = this.chart,
        pxMin = 0, 
        pxMax = axisLength,
        isXAxis = this.isXAxis,
        dataKey = isXAxis ? &#39;xData&#39; : &#39;yData&#39;,
        min = this.min,
        extremes = {},
        smallestSize = math.min(chart.plotWidth, chart.plotHeight),
        zMin = Number.MAX_VALUE,
        zMax = -Number.MAX_VALUE,
        range = this.max - min,
        transA = axisLength / range,
        activeSeries = [];

// Handle padding on the second pass, or on redraw
if (this.tickPositions) {
        each(this.series, function (series) {

                var seriesOptions = series.options,
                        zData;

                if (series.bubblePadding &amp;&amp; (series.visible || !chart.options.chart.ignoreHiddenSeries)) {

                        // Correction for #1673
                        axis.allowZoomOutside = true;

                        // Cache it
                        activeSeries.push(series);

                        if (isXAxis) { // because X axis is evaluated first

                                // For each series, translate the size extremes to pixel values
                                each([&#39;minSize&#39;, &#39;maxSize&#39;], function (prop) {
                                        var length = seriesOptions[prop],
                                                isPercent = /%$/.test(length);

                                        length = pInt(length);
                                        extremes[prop] = isPercent ?
                                                smallestSize * length / 100 :
                                                length;

                                });
                                series.minPxSize = extremes.minSize;

                                // Find the min and max Z
                                zData = series.zData;
                                if (zData.length) { // #1735
                                        zMin = pick(seriesOptions.zMin, math.min(
                                                zMin,
                                                math.max(
                                                        arrayMin(zData), 
                                                        seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE
                                                )
                                        ));
                                        zMax = pick(seriesOptions.zMax, math.max(zMax, arrayMax(zData)));
                                }
                        }
                }
        });

        each(activeSeries, function (series) {

                var data = series[dataKey],
                        i = data.length,
                        radius;

                if (isXAxis) {
                        series.getRadii(zMin, zMax, extremes.minSize, extremes.maxSize);
                }

                if (range &gt; 0) {
                        while (i--) {
                                if (typeof data[i] === &#39;number&#39;) {
                                        radius = series.radii[i];
                                        pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);
                                        pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);
                                }
                        }
                }
        });

        if (activeSeries.length &amp;&amp; range &gt; 0 &amp;&amp; pick(this.options.min, this.userMin) === UNDEFINED &amp;&amp; pick(this.options.max, this.userMax) === UNDEFINED) {
                pxMax -= axisLength;
                transA *= (axisLength + pxMin - pxMax) / axisLength;
                this.min += pxMin / transA;
                this.max += pxMax / transA;
        }
}</pre>

<p>};</p>

<p>/*
****************************************************************************</p>

<pre>End Bubble series code                                                     *
***************************************************************************/</pre>

<p>(function () {</p>

<pre>     /**
 Extensions for polar charts. Additionally, much of the geometry required for polar charts is
 gathered in RadialAxes.js.

/

     var seriesProto = Series.prototype,
             pointerProto = Pointer.prototype,
             colProto;

     /**
 Translate a point&#39;s plotX and plotY from the internal angle and radius measures to 
 true plotX, plotY coordinates
/
     seriesProto.toXY = function (point) {
             var xy,
                     chart = this.chart,
                     plotX = point.plotX,
                     plotY = point.plotY,
                     clientX;

             // Save rectangular plotX, plotY for later computation
             point.rectPlotX = plotX;
             point.rectPlotY = plotY;

             // Record the angle in degrees for use in tooltip
             clientX = ((plotX / Math.PI * 180) + this.xAxis.pane.options.startAngle) % 360;
             if (clientX &lt; 0) { // #2665
                     clientX += 360;
             }
             point.clientX = clientX;

             // Find the polar plotX and plotY
             xy = this.xAxis.postTranslate(point.plotX, this.yAxis.len - plotY);
             point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
             point.plotY = point.polarPlotY = xy.y - chart.plotTop;
     };

     /** 
 Order the tooltip points to get the mouse capture ranges correct. #1915. 
/
     seriesProto.orderTooltipPoints = function (points) {
             if (this.chart.polar) {
                     points.sort(function (a, b) {
                             return a.clientX - b.clientX;
                     });

                     // Wrap mouse tracking around to capture movement on the segment to the left
                     // of the north point (#1469, #2093).
                     if (points[0]) {
                             points[0].wrappedClientX = points[0].clientX + 360;
                             points.push(points[0]);
                     }
             }
     };

     /**
 Add some special init logic to areas and areasplines
/
     function initArea(proceed, chart, options) {
             proceed.call(this, chart, options);
             if (this.chart.polar) {

                     /**
   Overridden method to close a segment path. While in a cartesian plane the area 
   goes down to the threshold, in the polar chart it goes to the center.
  /
                     this.closeSegment = function (path) {
                             var center = this.xAxis.center;
                             path.push(
                                     &#39;L&#39;,
                                     center[0],
                                     center[1]
                             );                      
                     };

                     // Instead of complicated logic to draw an area around the inner area in a stack,
                     // just draw it behind
                     this.closedStacks = true;
             }
     }

     if (seriesTypes.area) {         
             wrap(seriesTypes.area.prototype, &#39;init&#39;, initArea);     
     }
     if (seriesTypes.areaspline) {           
             wrap(seriesTypes.areaspline.prototype, &#39;init&#39;, initArea);                       
     }       

     if (seriesTypes.spline) {
             /**
  Overridden method for calculating a spline from one point to the next
 /
             wrap(seriesTypes.spline.prototype, &#39;getPointSpline&#39;, function (proceed, segment, point, i) {

                     var ret,
                             smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc;
                             denom = smoothing + 1,
                             plotX, 
                             plotY,
                             lastPoint,
                             nextPoint,
                             lastX,
                             lastY,
                             nextX,
                             nextY,
                             leftContX,
                             leftContY,
                             rightContX,
                             rightContY,
                             distanceLeftControlPoint,
                             distanceRightControlPoint,
                             leftContAngle,
                             rightContAngle,
                             jointAngle;

                     if (this.chart.polar) {

                             plotX = point.plotX;
                             plotY = point.plotY;
                             lastPoint = segment[i - 1];
                             nextPoint = segment[i + 1];

                             // Connect ends
                             if (this.connectEnds) {
                                     if (!lastPoint) {
                                             lastPoint = segment[segment.length - 2]; // not the last but the second last, because the segment is already connected
                                     }
                                     if (!nextPoint) {
                                             nextPoint = segment[1];
                                     }       
                             }

                             // find control points
                             if (lastPoint &amp;&amp; nextPoint) {

                                     lastX = lastPoint.plotX;
                                     lastY = lastPoint.plotY;
                                     nextX = nextPoint.plotX;
                                     nextY = nextPoint.plotY;
                                     leftContX = (smoothing * plotX + lastX) / denom;
                                     leftContY = (smoothing * plotY + lastY) / denom;
                                     rightContX = (smoothing * plotX + nextX) / denom;
                                     rightContY = (smoothing * plotY + nextY) / denom;
                                     distanceLeftControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2));
                                     distanceRightControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2));
                                     leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);
                                     rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);
                                     jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);

                                     // Ensure the right direction, jointAngle should be in the same quadrant as leftContAngle
                                     if (Math.abs(leftContAngle - jointAngle) &gt; Math.PI / 2) {
                                             jointAngle -= Math.PI;
                                     }

                                     // Find the corrected control points for a spline straight through the point
                                     leftContX = plotX + Math.cos(jointAngle) * distanceLeftControlPoint;
                                     leftContY = plotY + Math.sin(jointAngle) * distanceLeftControlPoint;
                                     rightContX = plotX + Math.cos(Math.PI + jointAngle) * distanceRightControlPoint;
                                     rightContY = plotY + Math.sin(Math.PI + jointAngle) * distanceRightControlPoint;

                                     // Record for drawing in next point
                                     point.rightContX = rightContX;
                                     point.rightContY = rightContY;

                             }

                             // moveTo or lineTo
                             if (!i) {
                                     ret = [&#39;M&#39;, plotX, plotY];
                             } else { // curve from last point to this
                                     ret = [
                                             &#39;C&#39;,
                                             lastPoint.rightContX || lastPoint.plotX,
                                             lastPoint.rightContY || lastPoint.plotY,
                                             leftContX || plotX,
                                             leftContY || plotY,
                                             plotX,
                                             plotY
                                     ];
                                     lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
                             }

                     } else {
                             ret = proceed.call(this, segment, point, i);
                     }
                     return ret;
             });
     }

     /**
 Extend translate. The plotX and plotY values are computed as if the polar chart were a
 cartesian plane, where plotX denotes the angle in radians and (yAxis.len - plotY) is the pixel distance from
 center. 
/
     wrap(seriesProto, &#39;translate&#39;, function (proceed) {

             // Run uber method
             proceed.call(this);

             // Postprocess plot coordinates
             if (this.chart.polar &amp;&amp; !this.preventPostTranslate) {
                     var points = this.points,
                             i = points.length;
                     while (i--) {
                             // Translate plotX, plotY from angle and radius to true plot coordinates
                             this.toXY(points[i]);
                     }
             }
     });

     /** 
 Extend getSegmentPath to allow connecting ends across 0 to provide a closed circle in 
 line-like series.
/
     wrap(seriesProto, &#39;getSegmentPath&#39;, function (proceed, segment) {

             var points = this.points;

             // Connect the path
             if (this.chart.polar &amp;&amp; this.options.connectEnds !== false &amp;&amp; 
                             segment[segment.length - 1] === points[points.length - 1] &amp;&amp; points[0].y !== null) {
                     this.connectEnds = true; // re-used in splines
                     segment = [].concat(segment, [points[0]]);
             }

             // Run uber method
             return proceed.call(this, segment);

     });

     function polarAnimate(proceed, init) {
             var chart = this.chart,
                     animation = this.options.animation,
                     group = this.group,
                     markerGroup = this.markerGroup,
                     center = this.xAxis.center,
                     plotLeft = chart.plotLeft,
                     plotTop = chart.plotTop,
                     attribs;

             // Specific animation for polar charts
             if (chart.polar) {

                     // Enable animation on polar charts only in SVG. In VML, the scaling is different, plus animation
                     // would be so slow it would&#39;t matter.
                     if (chart.renderer.isSVG) {

                             if (animation === true) {
                                     animation = {};
                             }

                             // Initialize the animation
                             if (init) {

                                     // Scale down the group and place it in the center
                                     attribs = {
                                             translateX: center[0] + plotLeft,
                                             translateY: center[1] + plotTop,
                                             scaleX: 0.001, // #1499
                                             scaleY: 0.001
                                     };

                                     group.attr(attribs);
                                     if (markerGroup) {
                                             //markerGroup.attrSetters = group.attrSetters;
                                             markerGroup.attr(attribs);
                                     }

                             // Run the animation
                             } else {
                                     attribs = {
                                             translateX: plotLeft,
                                             translateY: plotTop,
                                             scaleX: 1,
                                             scaleY: 1
                                     };
                                     group.animate(attribs, animation);
                                     if (markerGroup) {
                                             markerGroup.animate(attribs, animation);
                                     }

                                     // Delete this function to allow it only once
                                     this.animate = null;
                             }
                     }

             // For non-polar charts, revert to the basic animation
             } else {
                     proceed.call(this, init);
             } 
     }

     // Define the animate method for regular series
     wrap(seriesProto, &#39;animate&#39;, polarAnimate);

     /**
 Throw in a couple of properties to let setTooltipPoints know we&#39;re indexing the points
 in degrees (0-360), not plot pixel width.
/
     wrap(seriesProto, &#39;setTooltipPoints&#39;, function (proceed, renew) {

             if (this.chart.polar) {
                     extend(this.xAxis, {
                             tooltipLen: 360 // degrees are the resolution unit of the tooltipPoints array
                     });     
             }
             // Run uber method
             return proceed.call(this, renew);
     });

     if (seriesTypes.column) {

             colProto = seriesTypes.column.prototype;
             /**
 Define the animate method for columnseries
/
             wrap(colProto, &#39;animate&#39;, polarAnimate);

             /**
  Extend the column prototype&#39;s translate method
 /
             wrap(colProto, &#39;translate&#39;, function (proceed) {

                     var xAxis = this.xAxis,
                             len = this.yAxis.len,
                             center = xAxis.center,
                             startAngleRad = xAxis.startAngleRad,
                             renderer = this.chart.renderer,
                             start,
                             points,
                             point,
                             i;

                     this.preventPostTranslate = true;

                     // Run uber method
                     proceed.call(this);

                     // Postprocess plot coordinates
                     if (xAxis.isRadial) {
                             points = this.points;
                             i = points.length;
                             while (i--) {
                                     point = points[i];
                                     start = point.barX + startAngleRad;
                                     point.shapeType = &#39;path&#39;;
                                     point.shapeArgs = {
                                             d: renderer.symbols.arc(
                                                     center[0],
                                                     center[1],
                                                     len - point.plotY,
                                                     null, 
                                                     {
                                                             start: start,
                                                             end: start + point.pointWidth,
                                                             innerR: len - pick(point.yBottom, len)
                                                     }
                                             )
                                     };
                                     // Provide correct plotX, plotY for tooltip
                                     this.toXY(point); 
                                     point.tooltipPos = [point.plotX, point.plotY];
                                     point.ttBelow = point.plotY &gt; center[1];
                             }
                     }
             });

             /**
  Align column data labels outside the columns. #1199.
 /
             wrap(colProto, &#39;alignDataLabel&#39;, function (proceed, point, dataLabel, options, alignTo, isNew) {

                     if (this.chart.polar) {
                             var angle = point.rectPlotX / Math.PI * 180,
                                     align,
                                     verticalAlign;

                             // Align nicely outside the perimeter of the columns
                             if (options.align === null) {
                                     if (angle &gt; 20 &amp;&amp; angle &lt; 160) {
                                             align = &#39;left&#39;; // right hemisphere
                                     } else if (angle &gt; 200 &amp;&amp; angle &lt; 340) {
                                             align = &#39;right&#39;; // left hemisphere
                                     } else {
                                             align = &#39;center&#39;; // top or bottom
                                     }
                                     options.align = align;
                             }
                             if (options.verticalAlign === null) {
                                     if (angle &lt; 45 || angle &gt; 315) {
                                             verticalAlign = &#39;bottom&#39;; // top part
                                     } else if (angle &gt; 135 &amp;&amp; angle &lt; 225) {
                                             verticalAlign = &#39;top&#39;; // bottom part
                                     } else {
                                             verticalAlign = &#39;middle&#39;; // left or right
                                     }
                                     options.verticalAlign = verticalAlign;
                             }

                             seriesProto.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
                     } else {
                             proceed.call(this, point, dataLabel, options, alignTo, isNew);
                     }

             });             
     }

     /**
 Extend the mouse tracker to return the tooltip position index in terms of
 degrees rather than pixels
/
     wrap(pointerProto, &#39;getIndex&#39;, function (proceed, e) {
             var ret,
                     chart = this.chart,
                     center,
                     x,
                     y;

             if (chart.polar) {
                     center = chart.xAxis[0].center;
                     x = e.chartX - center[0] - chart.plotLeft;
                     y = e.chartY - center[1] - chart.plotTop;

                     ret = 180 - Math.round(Math.atan2(x, y) / Math.PI * 180);

             } else {

                     // Run uber method
                     ret = proceed.call(this, e);
             }
             return ret;
     });

     /**
 Extend getCoordinates to prepare for polar axis values
/
     wrap(pointerProto, &#39;getCoordinates&#39;, function (proceed, e) {
             var chart = this.chart,
                     ret = {
                             xAxis: [],
                             yAxis: []
                     };

             if (chart.polar) {      

                     each(chart.axes, function (axis) {
                             var isXAxis = axis.isXAxis,
                                     center = axis.center,
                                     x = e.chartX - center[0] - chart.plotLeft,
                                     y = e.chartY - center[1] - chart.plotTop;

                             ret[isXAxis ? &#39;xAxis&#39; : &#39;yAxis&#39;].push({
                                     axis: axis,
                                     value: axis.translate(
                                             isXAxis ?
                                                     Math.PI - Math.atan2(x, y) : // angle 
                                                     Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), // distance from center
                                             true
                                     )
                             });
                     });

             } else {
                     ret = proceed.call(this, e);
             }

             return ret;
     });</pre>

<p>}());</p>

<p>}(Highcharts)); /*</p>

<pre> Chartkick.js
 Create beautiful Javascript charts with minimal code
 https://github.com/ankane/chartkick.js
 v1.2.2
 MIT License
/</pre>

<p>/*jslint browser: true, indent: 2, plusplus: true, vars: true */</p>

<p>(function (window) {</p>

<pre>&#39;use strict&#39;;

var config = window.Chartkick || {};
var Chartkick, ISO8601_PATTERN, DECIMAL_SEPARATOR, adapters = [];

// helpers

function isArray(variable) {
  return Object.prototype.toString.call(variable) === &quot;[object Array]&quot;;
}

function isFunction(variable) {
  return variable instanceof Function;
}

function isPlainObject(variable) {
  return !isFunction(variable) &amp;&amp; variable instanceof Object;
}

// https://github.com/madrobby/zepto/blob/master/src/zepto.js
function extend(target, source) {
  var key;
  for (key in source) {
    if (isPlainObject(source[key]) || isArray(source[key])) {
      if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) {
        target[key] = {};
      }
      if (isArray(source[key]) &amp;&amp; !isArray(target[key])) {
        target[key] = [];
      }
      extend(target[key], source[key]);
    } else if (source[key] !== undefined) {
      target[key] = source[key];
    }
  }
}

function merge(obj1, obj2) {
  var target = {};
  extend(target, obj1);
  extend(target, obj2);
  return target;
}

// https://github.com/Do/iso8601.js
ISO8601_PATTERN = /(\d\d\d\d)(\-)?(\d\d)(\-)?(\d\d)(T)?(\d\d)(:)?(\d\d)?(:)?(\d\d)?([\.,]\d+)?($|Z|([\+\-])(\d\d)(:)?(\d\d)?)/i;
DECIMAL_SEPARATOR = String(1.5).charAt(1);

function parseISO8601(input) {
  var day, hour, matches, milliseconds, minutes, month, offset, result, seconds, type, year;
  type = Object.prototype.toString.call(input);
  if (type === &#39;[object Date]&#39;) {
    return input;
  }
  if (type !== &#39;[object String]&#39;) {
    return;
  }
  if (matches = input.match(ISO8601_PATTERN)) {
    year = parseInt(matches[1], 10);
    month = parseInt(matches[3], 10) - 1;
    day = parseInt(matches[5], 10);
    hour = parseInt(matches[7], 10);
    minutes = matches[9] ? parseInt(matches[9], 10) : 0;
    seconds = matches[11] ? parseInt(matches[11], 10) : 0;
    milliseconds = matches[12] ? parseFloat(DECIMAL_SEPARATOR + matches[12].slice(1)) * 1000 : 0;
    result = Date.UTC(year, month, day, hour, minutes, seconds, milliseconds);
    if (matches[13] &amp;&amp; matches[14]) {
      offset = matches[15] * 60;
      if (matches[17]) {
        offset += parseInt(matches[17], 10);
      }
      offset *= matches[14] === &#39;-&#39; ? -1 : 1;
      result -= offset * 60 * 1000;
    }
    return new Date(result);
  }
}
// end iso8601.js

function negativeValues(series) {
  var i, j, data;
  for (i = 0; i &lt; series.length; i++) {
    data = series[i].data;
    for (j = 0; j &lt; data.length; j++) {
      if (data[j][1] &lt; 0) {
        return true;
      }
    }
  }
  return false;
}

function jsOptionsFunc(defaultOptions, hideLegend, setMin, setMax, setStacked) {
  return function (series, opts, chartOptions) {
    var options = merge({}, defaultOptions);
    options = merge(options, chartOptions || {});

    // hide legend
    // this is *not* an external option!
    if (opts.hideLegend) {
      hideLegend(options);
    }

    // min
    if (&quot;min&quot; in opts) {
      setMin(options, opts.min);
    } else if (!negativeValues(series)) {
      setMin(options, 0);
    }

    // max
    if (&quot;max&quot; in opts) {
      setMax(options, opts.max);
    }

    if (opts.stacked) {
      setStacked(options);
    }

    if (opts.colors) {
      options.colors = opts.colors;
    }

    // merge library last
    options = merge(options, opts.library || {});

    return options;
  };
}

function setText(element, text) {
  if (document.body.innerText) {
    element.innerText = text;
  } else {
    element.textContent = text;
  }
}

function chartError(element, message) {
  setText(element, &quot;Error Loading Chart: &quot; + message);
  element.style.color = &quot;#ff0000&quot;;
}

function getJSON(element, url, success) {
  var $ = window.jQuery || window.Zepto || window.$;
  $.ajax({
    dataType: &quot;json&quot;,
    url: url,
    success: success,
    error: function (jqXHR, textStatus, errorThrown) {
      var message = (typeof errorThrown === &quot;string&quot;) ? errorThrown : errorThrown.message;
      chartError(element, message);
    }
  });
}

function errorCatcher(chart, callback) {
  try {
    callback(chart);
  } catch (err) {
    chartError(chart.element, err.message);
    throw err;
  }
}

function fetchDataSource(chart, callback) {
  if (typeof chart.dataSource === &quot;string&quot;) {
    getJSON(chart.element, chart.dataSource, function (data, textStatus, jqXHR) {
      chart.data = data;
      errorCatcher(chart, callback);
    });
  } else {
    chart.data = chart.dataSource;
    errorCatcher(chart, callback);
  }
}

// type conversions

function toStr(n) {
  return &quot;&quot; + n;
}

function toFloat(n) {
  return parseFloat(n);
}

function toDate(n) {
  if (typeof n !== &quot;object&quot;) {
    if (typeof n === &quot;number&quot;) {
      n = new Date(n * 1000); // ms
    } else { // str
      // try our best to get the str into iso8601
      // TODO be smarter about this
      var str = n.replace(/ /, &quot;T&quot;).replace(&quot; &quot;, &quot;&quot;).replace(&quot;UTC&quot;, &quot;Z&quot;);
      n = parseISO8601(str) || new Date(n);
    }
  }
  return n;
}

function toArr(n) {
  if (!isArray(n)) {
    var arr = [], i;
    for (i in n) {
      if (n.hasOwnProperty(i)) {
        arr.push([i, n[i]]);
      }
    }
    n = arr;
  }
  return n;
}

function sortByTime(a, b) {
  return a[0].getTime() - b[0].getTime();
}

if (&quot;Highcharts&quot; in window) {
  var HighchartsAdapter = new function () {
    var Highcharts = window.Highcharts;

    var defaultOptions = {
      chart: {},
      xAxis: {
        labels: {
          style: {
            fontSize: &quot;12px&quot;
          }
        }
      },
      yAxis: {
        title: {
          text: null
        },
        labels: {
          style: {
            fontSize: &quot;12px&quot;
          }
        }
      },
      title: {
        text: null
      },
      credits: {
        enabled: false
      },
      legend: {
        borderWidth: 0
      },
      tooltip: {
        style: {
          fontSize: &quot;12px&quot;
        }
      },
      plotOptions: {
        areaspline: {},
        series: {
          marker: {}
        }
      }
    };

    var hideLegend = function (options) {
      options.legend.enabled = false;
    };

    var setMin = function (options, min) {
      options.yAxis.min = min;
    };

    var setMax = function (options, max) {
      options.yAxis.max = max;
    };

    var setStacked = function (options) {
      options.plotOptions.series.stacking = &quot;normal&quot;;
    };

    var jsOptions = jsOptionsFunc(defaultOptions, hideLegend, setMin, setMax, setStacked);

    this.renderLineChart = function (chart, chartType) {
      chartType = chartType || &quot;spline&quot;;
      var chartOptions = {};
      if (chartType === &quot;areaspline&quot;) {
        chartOptions = {
          plotOptions: {
            areaspline: {
              stacking: &quot;normal&quot;
            },
            series: {
              marker: {
                enabled: false
              }
            }
          }
        };
      }
      var options = jsOptions(chart.data, chart.options, chartOptions), data, i, j;
      options.xAxis.type = chart.options.discrete ? &quot;category&quot; : &quot;datetime&quot;;
      options.chart.type = chartType;
      options.chart.renderTo = chart.element.id;

      var series = chart.data;
      for (i = 0; i &lt; series.length; i++) {
        data = series[i].data;
        if (!chart.options.discrete) {
          for (j = 0; j &lt; data.length; j++) {
            data[j][0] = data[j][0].getTime();
          }
        }
        series[i].marker = {symbol: &quot;circle&quot;};
      }
      options.series = series;
      new Highcharts.Chart(options);
    };

    this.renderPieChart = function (chart) {
      var chartOptions = {};
      if (chart.options.colors) {
        chartOptions.colors = chart.options.colors;
      }
      var options = merge(merge(defaultOptions, chartOptions), chart.options.library || {});
      options.chart.renderTo = chart.element.id;
      options.series = [{
        type: &quot;pie&quot;,
        name: &quot;Value&quot;,
        data: chart.data
      }];
      new Highcharts.Chart(options);
    };

    this.renderColumnChart = function (chart, chartType) {
      var chartType = chartType || &quot;column&quot;;
      var series = chart.data;
      var options = jsOptions(series, chart.options), i, j, s, d, rows = [];
      options.chart.type = chartType;
      options.chart.renderTo = chart.element.id;

      for (i = 0; i &lt; series.length; i++) {
        s = series[i];

        for (j = 0; j &lt; s.data.length; j++) {
          d = s.data[j];
          if (!rows[d[0]]) {
            rows[d[0]] = new Array(series.length);
          }
          rows[d[0]][i] = d[1];
        }
      }

      var categories = [];
      for (i in rows) {
        if (rows.hasOwnProperty(i)) {
          categories.push(i);
        }
      }
      options.xAxis.categories = categories;

      var newSeries = [];
      for (i = 0; i &lt; series.length; i++) {
        d = [];
        for (j = 0; j &lt; categories.length; j++) {
          d.push(rows[categories[j]][i] || 0);
        }

        newSeries.push({
          name: series[i].name,
          data: d
        });
      }
      options.series = newSeries;

      new Highcharts.Chart(options);
    };

    var self = this;

    this.renderBarChart = function (chart) {
      self.renderColumnChart(chart, &quot;bar&quot;);
    };

    this.renderAreaChart = function (chart) {
      self.renderLineChart(chart, &quot;areaspline&quot;);
    };
  };
  adapters.push(HighchartsAdapter);
}
if (window.google &amp;&amp; window.google.setOnLoadCallback) {
  var GoogleChartsAdapter = new function () {
    var google = window.google;

    var loaded = {};
    var callbacks = [];

    var runCallbacks = function () {
      var cb, call;
      for (var i = 0; i &lt; callbacks.length; i++) {
        cb = callbacks[i];
        call = google.visualization &amp;&amp; ((cb.pack == &quot;corechart&quot; &amp;&amp; google.visualization.LineChart) || (cb.pack == &quot;timeline&quot; &amp;&amp; google.visualization.Timeline))
        if (call) {
          cb.callback();
          callbacks.splice(i, 1);
          i--;
        }
      }
    };

    var waitForLoaded = function (pack, callback) {
      if (!callback) {
        callback = pack;
        pack = &quot;corechart&quot;;
      }

      callbacks.push({pack: pack, callback: callback});

      if (loaded[pack]) {
        runCallbacks();
      } else {
        loaded[pack] = true;

        // https://groups.google.com/forum/#!topic/google-visualization-api/fMKJcyA2yyI
        var loadOptions = {
          packages: [pack],
          callback: runCallbacks
        };
        if (config.language) {
          loadOptions.language = config.language;
        }
        google.load(&quot;visualization&quot;, &quot;1&quot;, loadOptions);
      }
    };

    // Set chart options
    var defaultOptions = {
      chartArea: {},
      fontName: &quot;&#39;Lucida Grande&#39;, &#39;Lucida Sans Unicode&#39;, Verdana, Arial, Helvetica, sans-serif&quot;,
      pointSize: 6,
      legend: {
        textStyle: {
          fontSize: 12,
          color: &quot;#444&quot;
        },
        alignment: &quot;center&quot;,
        position: &quot;right&quot;
      },
      curveType: &quot;function&quot;,
      hAxis: {
        textStyle: {
          color: &quot;#666&quot;,
          fontSize: 12
        },
        gridlines: {
          color: &quot;transparent&quot;
        },
        baselineColor: &quot;#ccc&quot;,
        viewWindow: {}
      },
      vAxis: {
        textStyle: {
          color: &quot;#666&quot;,
          fontSize: 12
        },
        baselineColor: &quot;#ccc&quot;,
        viewWindow: {}
      },
      tooltip: {
        textStyle: {
          color: &quot;#666&quot;,
          fontSize: 12
        }
      }
    };

    var hideLegend = function (options) {
      options.legend.position = &quot;none&quot;;
    };

    var setMin = function (options, min) {
      options.vAxis.viewWindow.min = min;
    };

    var setMax = function (options, max) {
      options.vAxis.viewWindow.max = max;
    };

    var setBarMin = function (options, min) {
      options.hAxis.viewWindow.min = min;
    };

    var setBarMax = function (options, max) {
      options.hAxis.viewWindow.max = max;
    };

    var setStacked = function (options) {
      options.isStacked = true;
    };

    var jsOptions = jsOptionsFunc(defaultOptions, hideLegend, setMin, setMax, setStacked);

    // cant use object as key
    var createDataTable = function (series, columnType) {
      var data = new google.visualization.DataTable();
      data.addColumn(columnType, &quot;&quot;);

      var i, j, s, d, key, rows = [];
      for (i = 0; i &lt; series.length; i++) {
        s = series[i];
        data.addColumn(&quot;number&quot;, s.name);

        for (j = 0; j &lt; s.data.length; j++) {
          d = s.data[j];
          key = (columnType === &quot;datetime&quot;) ? d[0].getTime() : d[0];
          if (!rows[key]) {
            rows[key] = new Array(series.length);
          }
          rows[key][i] = toFloat(d[1]);
        }
      }

      var rows2 = [];
      for (i in rows) {
        if (rows.hasOwnProperty(i)) {
          rows2.push([(columnType === &quot;datetime&quot;) ? new Date(toFloat(i)) : i].concat(rows[i]));
        }
      }
      if (columnType === &quot;datetime&quot;) {
        rows2.sort(sortByTime);
      }
      data.addRows(rows2);

      return data;
    };

    var resize = function (callback) {
      if (window.attachEvent) {
        window.attachEvent(&quot;onresize&quot;, callback);
      } else if (window.addEventListener) {
        window.addEventListener(&quot;resize&quot;, callback, true);
      }
      callback();
    };

    this.renderLineChart = function (chart) {
      waitForLoaded(function () {
        var options = jsOptions(chart.data, chart.options);
        var data = createDataTable(chart.data, chart.options.discrete ? &quot;string&quot; : &quot;datetime&quot;);
        chart.chart = new google.visualization.LineChart(chart.element);
        resize(function () {
          chart.chart.draw(data, options);
        });
      });
    };

    this.renderPieChart = function (chart) {
      waitForLoaded(function () {
        var chartOptions = {
          chartArea: {
            top: &quot;10%&quot;,
            height: &quot;80%&quot;
          }
        };
        if (chart.options.colors) {
          chartOptions.colors = chart.options.colors;
        }
        var options = merge(merge(defaultOptions, chartOptions), chart.options.library || {});

        var data = new google.visualization.DataTable();
        data.addColumn(&quot;string&quot;, &quot;&quot;);
        data.addColumn(&quot;number&quot;, &quot;Value&quot;);
        data.addRows(chart.data);

        chart.chart = new google.visualization.PieChart(chart.element);
        resize(function () {
          chart.chart.draw(data, options);
        });
      });
    };

    this.renderColumnChart = function (chart) {
      waitForLoaded(function () {
        var options = jsOptions(chart.data, chart.options);
        var data = createDataTable(chart.data, &quot;string&quot;);
        chart.chart = new google.visualization.ColumnChart(chart.element);
        resize(function () {
          chart.chart.draw(data, options);
        });
      });
    };

    this.renderBarChart = function (chart) {
      waitForLoaded(function () {
        var chartOptions = {
          hAxis: {
            gridlines: {
              color: &quot;#ccc&quot;
            }
          }
        };
        var options = jsOptionsFunc(defaultOptions, hideLegend, setBarMin, setBarMax, setStacked)(chart.data, chart.options, chartOptions);
        var data = createDataTable(chart.data, &quot;string&quot;);
        chart.chart = new google.visualization.BarChart(chart.element);
        resize(function () {
          chart.chart.draw(data, options);
        });
      });
    };

    this.renderAreaChart = function (chart) {
      waitForLoaded(function () {
        var chartOptions = {
          isStacked: true,
          pointSize: 0,
          areaOpacity: 0.5
        };
        var options = jsOptions(chart.data, chart.options, chartOptions);
        var data = createDataTable(chart.data, chart.options.discrete ? &quot;string&quot; : &quot;datetime&quot;);
        chart.chart = new google.visualization.AreaChart(chart.element);
        resize(function () {
          chart.chart.draw(data, options);
        });
      });
    };

    this.renderGeoChart = function (chart) {
      waitForLoaded(function () {
        var chartOptions = {
          legend: &quot;none&quot;,
          colorAxis: {
            colors: chart.options.colors || [&quot;#f6c7b6&quot;, &quot;#ce502d&quot;]
          }
        };
        var options = merge(merge(defaultOptions, chartOptions), chart.options.library || {});

        var data = new google.visualization.DataTable();
        data.addColumn(&quot;string&quot;, &quot;&quot;);
        data.addColumn(&quot;number&quot;, &quot;Value&quot;);
        data.addRows(chart.data);

        chart.chart = new google.visualization.GeoChart(chart.element);
        resize(function () {
          chart.chart.draw(data, options);
        });
      });
    };

    this.renderTimeline = function (chart) {
      waitForLoaded(&quot;timeline&quot;, function () {
        var chartOptions = {
          legend: &quot;none&quot;
        };

        if (chart.options.colors) {
          chartOptions.colorAxis.colors = chart.options.colors;
        }
        var options = merge(merge(defaultOptions, chartOptions), chart.options.library || {});

        var data = new google.visualization.DataTable();
        data.addColumn({type: &quot;string&quot;, id: &quot;Name&quot;});
        data.addColumn({type: &quot;date&quot;, id: &quot;Start&quot;});
        data.addColumn({type: &quot;date&quot;, id: &quot;End&quot;});
        data.addRows(chart.data);

        chart.chart = new google.visualization.Timeline(chart.element);

        resize(function () {
          chart.chart.draw(data, options);
        });
      });
    };
  };

  adapters.push(GoogleChartsAdapter);
}

// TODO add adapter option
// TODO remove chartType if cross-browser way
// to get the name of the chart class
function renderChart(chartType, chart) {
  var i, adapter, fnName;
  fnName = &quot;render&quot; + chartType;

  for (i = 0; i &lt; adapters.length; i++) {
    adapter = adapters[i];
    if (isFunction(adapter[fnName])) {
      return adapter[fnName](chart);
    }
  }
  throw new Error(&quot;No adapter found&quot;);
}

// process data

function processSeries(series, opts, time) {
  var i, j, data, r, key;

  // see if one series or multiple
  if (!isArray(series) || typeof series[0] !== &quot;object&quot; || isArray(series[0])) {
    series = [{name: &quot;Value&quot;, data: series}];
    opts.hideLegend = true;
  } else {
    opts.hideLegend = false;
  }
  if (opts.discrete) {
    time = false;
  }

  // right format
  for (i = 0; i &lt; series.length; i++) {
    data = toArr(series[i].data);
    r = [];
    for (j = 0; j &lt; data.length; j++) {
      key = data[j][0];
      key = time ? toDate(key) : toStr(key);
      r.push([key, toFloat(data[j][1])]);
    }
    if (time) {
      r.sort(sortByTime);
    }
    series[i].data = r;
  }

  return series;
}

function processSimple(data) {
  var perfectData = toArr(data), i;
  for (i = 0; i &lt; perfectData.length; i++) {
    perfectData[i] = [toStr(perfectData[i][0]), toFloat(perfectData[i][1])];
  }
  return perfectData;
}

function processTime(data)
{
  var i;
  for (i = 0; i &lt; data.length; i++) {
    data[i][1] = toDate(data[i][1]);
    data[i][2] = toDate(data[i][2]);
  }
  return data;
}

function processLineData(chart) {
  chart.data = processSeries(chart.data, chart.options, true);
  renderChart(&quot;LineChart&quot;, chart);
}

function processColumnData(chart) {
  chart.data = processSeries(chart.data, chart.options, false);
  renderChart(&quot;ColumnChart&quot;, chart);
}

function processPieData(chart) {
  chart.data = processSimple(chart.data);
  renderChart(&quot;PieChart&quot;, chart);
}

function processBarData(chart) {
  chart.data = processSeries(chart.data, chart.options, false);
  renderChart(&quot;BarChart&quot;, chart);
}

function processAreaData(chart) {
  chart.data = processSeries(chart.data, chart.options, true);
  renderChart(&quot;AreaChart&quot;, chart);
}

function processGeoData(chart) {
  chart.data = processSimple(chart.data);
  renderChart(&quot;GeoChart&quot;, chart);
}

function processTimelineData(chart) {
  chart.data = processTime(chart.data);
  renderChart(&quot;Timeline&quot;, chart);
}

function setElement(chart, element, dataSource, opts, callback) {
  if (typeof element === &quot;string&quot;) {
    element = document.getElementById(element);
  }
  chart.element = element;
  chart.options = opts || {};
  chart.dataSource = dataSource;
  Chartkick.charts[element.id] = chart;
  fetchDataSource(chart, callback);
}

// define classes

Chartkick = {
  LineChart: function (element, dataSource, opts) {
    setElement(this, element, dataSource, opts, processLineData);
  },
  PieChart: function (element, dataSource, opts) {
    setElement(this, element, dataSource, opts, processPieData);
  },
  ColumnChart: function (element, dataSource, opts) {
    setElement(this, element, dataSource, opts, processColumnData);
  },
  BarChart: function (element, dataSource, opts) {
    setElement(this, element, dataSource, opts, processBarData);
  },
  AreaChart: function (element, dataSource, opts) {
    setElement(this, element, dataSource, opts, processAreaData);
  },
  GeoChart: function (element, dataSource, opts) {
    setElement(this, element, dataSource, opts, processGeoData);
  },
  Timeline: function (element, dataSource, opts) {
    setElement(this, element, dataSource, opts, processTimelineData);
  },
  charts: {}
};

window.Chartkick = Chartkick;</pre>

<p>}(window)); (function() {</p>

<pre>(function($) {
  $.fn.china_city = function() {
    return this.each(function() {
      var selects;
      selects = $(this).find(&#39;.city-select&#39;);
      return selects.change(function() {
        var $this, next_selects;
        $this = $(this);
        next_selects = selects.slice(selects.index(this) + 1);
        $(&quot;option:gt(0)&quot;, next_selects).remove();
        if (next_selects.first()[0] &amp;&amp; $this.val() &amp;&amp; !$this.val().match(/--.*--/)) {
          return $.get(&quot;/china_city/&quot; + ($(this).val()), function(data) {
            var i, len, option;
            if (data.data != null) {
              data = data.data;
            }
            for (i = 0, len = data.length; i &lt; len; i++) {
              option = data[i];
              next_selects.first()[0].options.add(new Option(option[0], option[1]));
            }
            return next_selects.trigger(&#39;china_city:load_data_completed&#39;);
          });
        }
      });
    });
  };
  return $(document).on(&#39;ready page:load&#39;, function() {
    return $(&#39;.city-group&#39;).china_city();
  });
})(jQuery);</pre>

<p>}).call(this); /*!</p>

<pre> Bootstrap v3.3.4 (http://getbootstrap.com)
 Copyright 2011-2015 Twitter, Inc.
 Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
/</pre>

<p>if(undefined==typeof jQuery)throw new Error(Bootstrap&#39;s JavaScript
requires jQuery);+function(a){use strict;var b=a.fn.jquery.split( )[<a
href="0">0].split(.);if(b</a>&lt;<a href="1">2&&b</a>&lt;<a
href="0">9||1==b</a>&amp;&amp;<a href="1">9==b</a>&amp;&amp;<a
href="2">b</a>&lt;1)throw new Error(Bootstrap&#39;s JavaScript requires
jQuery version 1.9.1 or higher)}(jQuery),+function(a){use
strict;function b(){var
a=document.createElement(bootstrap),b={WebkitTransition:webkitTransitionEnd,MozTransition:transitionend,OTransition:oTransitionEnd
otransitionend,transition:transitionend};for(var c in b)if(void <a
href="c">0!==a.style</a>)return{<a
href="c">end:b</a>};return!1}a.fn.emulateTransitionEnd=function(b){var
c=!1,d=this;a(this).one(bsTransitionEnd,function(){c=!0});var
e=function(){c||a(d).trigger(a.support.transition.end)};return
setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&amp;&amp;(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return
a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void
0}})})}(jQuery),+function(a){use strict;function b(b){return
this.each(function(){var
c=a(this),e=c.data(bs.alert);e||c.data(bs.alert,e=new
d(this)),string==typeof <a href="b">b&&e</a>.call})}var <a
href="data-dismiss="alert"">c=</a>&#39;,d=function(b){a(b).on(click,c,this.close)};d.VERSION=3.3.4,d.TRANSITION_DURATION=150,d.prototype.close=function(b){function
c(){g.detach().trigger(closed.bs.alert).remove()}var <a
href="^\s">e=a(this),f=e.attr(data-target);f||(f=e.attr(href),f=f&&f.replace(/.*(?=#</a>*$)/,));var
g=a(f);b&amp;&amp;b.preventDefault(),g.length||(g=e.closest(.alert)),g.trigger(b=a.Event(close.bs.alert)),b.isDefaultPrevented()||(g.removeClass(in),a.support.transition&amp;&amp;g.hasClass(fade)?g.one(bsTransitionEnd,c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var
e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return
a.fn.alert=e,this},a(document).on(click.bs.alert.data-api,c,d.prototype.close)}(jQuery),+function(a){use
strict;function b(b){return this.each(function(){var
d=a(this),e=d.data(bs.button),f=object==typeof
b&amp;&amp;b;e||d.data(bs.button,e=new
c(this,f)),toggle==b?e.toggle():b&amp;&amp;e.setState(b)})}var
c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION=3.3.4,c.DEFAULTS={loadingText:loading},c.prototype.setState=function(b){var
<a
href="e">c=disabled,d=this.$element,e=d.is(input)?val:html,f=d.data();b+=Text,null==f.resetText&&d.data(resetText,d</a>()),setTimeout(a.proxy(function(){<a
href="e">d</a>(<a href="b">null==f</a>?<a href="b">this.options</a>:<a
href="b">f</a>),loadingText==b?(this.isLoading=!0,d.addClass.attr(c,c)):this.isLoading&amp;&amp;(this.isLoading=!1,d.removeClass.removeAttr)},this),0)},c.prototype.toggle=function(){var
<a
href="data-toggle="buttons"">a=!0,b=this.$element.closest(</a>&#39;);if(b.length){var
c=this.$element.find(input);radio==c.prop(type)&amp;&amp;(c.prop(checked)&amp;&amp;this.$element.hasClass(active)?a=!1:b.find(.active).removeClass(active)),a&amp;&amp;c.prop(checked,!this.$element.hasClass(active)).trigger(change)}else
this.$element.attr(aria-pressed,!this.$element.hasClass(active));a&amp;&amp;this.$element.toggleClass(active)};var
d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return
a.fn.button=d,this},<a
href="data-toggle^="button"">a(document).on(click.bs.button.data-api,</a>&#39;,function{var
d=a(c.target);d.hasClass(btn)||(d=d.closest(.btn)),b.call(d,toggle),c.preventDefault()}).on(focus.bs.button.data-api
<a
href="data-toggle^="button"">blur.bs.button.data-api,</a>&#39;,function(b){a(b.target).closest(.btn).toggleClass(focus,/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){use
strict;function b(b){return this.each(function(){var
d=a(this),e=d.data(bs.carousel),f=a.extend({},c.DEFAULTS,d.data(),object==typeof
b&amp;&amp;b),g=string==typeof b?b:f.slide;e||d.data(bs.carousel,e=new
c(this,f)),number==typeof <a
href="g">b?e.to(b):g?e</a>():f.interval&amp;&amp;e.pause().cycle()})}var
c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(.carousel-indicators),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&amp;&amp;this.$element.on(keydown.bs.carousel,a.proxy(this.keydown,this)),hover==this.options.pause&amp;&amp;!(ontouchstartin
document.documentElement)&amp;&amp;this.$element.on(mouseenter.bs.carousel,a.proxy(this.pause,this)).on(mouseleave.bs.carousel,a.proxy(this.cycle,this))};c.VERSION=3.3.4,c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:hover,wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case
37:this.prev();break;case
39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return
b||(this.paused=!1),this.interval&amp;&amp;clearInterval(this.interval),this.options.interval&amp;&amp;!this.paused&amp;&amp;(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return
this.$items=a.parent().children(.item),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var
c=this.getItemIndex(b),d=prev==a&amp;&amp;0===c||next==a&amp;&amp;c==this.$items.length-1;if(d&amp;&amp;!this.options.wrap)return
b;var e=prev==a?-1:1,f=(c+e)%this.$items.length;return
this.$items.eq(f)},c.prototype.to=function(a){var
b=this,c=this.getItemIndex(this.$active=this.$element.find(.item.active));return
a&gt;this.$items.length-1||0&gt;a?void
0:this.sliding?this.$element.one(slid.bs.carousel,function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a&gt;c?next:prev,this.$items.eq(a))},c.prototype.pause=function(b){return
b||(this.paused=!0),this.$element.find(.next,
.prev).length&amp;&amp;a.support.transition&amp;&amp;(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return
this.sliding?void 0:this.slide(next)},c.prototype.prev=function(){return
this.sliding?void 0:this.slide(prev)},c.prototype.slide=function(b,d){var
e=this.$element.find(.item.active),f=d||this.getItemForDirection(b,e),g=this.interval,h=next==b?left:right,i=this;if(f.hasClass(active))return
this.sliding=!1;var <a
href="0">j=f</a>,k=a.Event(slide.bs.carousel,{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&amp;&amp;this.pause(),this.$indicators.length){this.$indicators.find(.active).removeClass(active);var
<a
href="this.getItemIndex(f)">l=a(this.$indicators.children()</a>);l&amp;&amp;l.addClass(active)}var
m=a.Event(slid.bs.carousel,{relatedTarget:j,direction:h});return <a
href="0">a.support.transition&&this.$element.hasClass(slide)?(f.addClass(b),f</a>.offsetWidth,e.addClass(h),f.addClass(h),e.one(bsTransitionEnd,function(){<a
href="b,h">f.removeClass(</a>.join( )).<a
href=""active",h">addClass(active),e.removeClass(</a>.join(
)),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass(active),f.addClass(active),this.sliding=!1,this.$element.trigger(m)),g&amp;&amp;this.cycle(),this}};var
d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return
a.fn.carousel=d,this};var e=function{var <a
href="^\s">d,e=a(this),f=a(e.attr(data-target)||(d=e.attr(href))&&d.replace(/.*(?=#</a>+$)/,));if(f.hasClass(carousel)){var
g=a.extend({},f.data(),e.data()),h=e.attr(data-slide-to);h&amp;&amp;(g.interval=!1),b.call(f,g),h&amp;&amp;f.data(bs.carousel).to(h),c.preventDefault()}};<a
href="data-slide">a(document).on(click.bs.carousel.data-api,</a>,<a
href="data-slide-to">e).on(click.bs.carousel.data-api,</a>,e),a(window).on(load,function(){<a
href="data-ride="carousel"">a(</a>&#39;).each(function(){var
c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){use
strict;function b(b){var <a
href="^\s">c,d=b.attr(data-target)||(c=b.attr(href))&&c.replace(/.*(?=#</a>+$)/,);return
a(d)}function c(b){return this.each(function(){var
c=a(this),e=c.data(bs.collapse),f=a.extend({},d.DEFAULTS,c.data(),object==typeof
b&amp;&amp;b);!e&amp;&amp;f.toggle&amp;&amp;/show|hide/.test(b)&amp;&amp;(f.toggle=!1),e||c.data(bs.collapse,e=new
d(this,f)),string==typeof <a href="b">b&&e</a>()})}var
d=function(b,c){this.$element=a(b),this.options=a.extend({},<a
href="data-toggle="collapse"">d.DEFAULTS,c),this.$trigger=a(</a>[<a
href="data-toggle="collapse"">href=#b.id],</a>[data-target=#&#39;<code>b.id</code>&#39;]&#39;),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&amp;&amp;this.toggle()};d.VERSION=3.3.4,d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var
a=this.$element.hasClass(width);return
a?width:height},d.prototype.show=function(){if(!this.transitioning&amp;&amp;!this.$element.hasClass(in)){var
b,e=this.$parent&amp;&amp;this.$parent.children(.panel).children(.in,
.collapsing);if(!(e&amp;&amp;e.length&amp;&amp;(b=e.data(bs.collapse),b&amp;&amp;b.transitioning))){var
f=a.Event(show.bs.collapse);if(this.$element.trigger(f),!f.isDefaultPrevented()){e&amp;&amp;e.length&amp;&amp;(c.call(e,hide),b||e.data(bs.collapse,null));var
<a
href="g">g=this.dimension();this.$element.removeClass(collapse).addClass(collapsing)</a>(0).attr(aria-expanded,!0),this.$trigger.removeClass(collapsed).attr(aria-expanded,!0),this.transitioning=1;var
h=function(){this.$element.removeClass(collapsing).addClass(collapse <a
href="g">in)</a>(),this.transitioning=0,this.$element.trigger(shown.bs.collapse)};if(!a.support.transition)return
h.call(this);var <a href=""scroll",g">i=a.camelCase(</a>.<a
href="g">join(-));this.$element.one(bsTransitionEnd,a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)</a>(<a
href="0">this.$element</a>[i])}}}},d.prototype.hide=function(){if(!this.transitioning&amp;&amp;this.$element.hasClass(in)){var
b=a.Event(hide.bs.collapse);if(this.$element.trigger(b),!b.isDefaultPrevented()){var
<a href="c">c=this.dimension();this.$element</a>(<a
href="c">this.$element</a>())[0].offsetHeight,this.$element.addClass(collapsing).removeClass(collapse
in).attr(aria-expanded,!1),this.$trigger.addClass(collapsed).attr(aria-expanded,!1),this.transitioning=1;var
e=function(){this.transitioning=0,this.$element.removeClass(collapsing).addClass(collapse).trigger(hidden.bs.collapse)};return
a.support.transition?void <a
href="c">this.$element</a>(0).one(bsTransitionEnd,a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){<a
href="this.$element.hasClass("in")?"hide":"show"">this</a>()},d.prototype.getParent=function(){return
<a
href="data-toggle="collapse"">a(this.options.parent).find(</a>[data-parent=&#39;<code>this.options.parent</code>&#39;]&#39;).each(a.proxy(function(c,d){var
e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var
c=a.hasClass(in);a.attr(aria-expanded,c),b.toggleClass(collapsed,!c).attr(aria-expanded,c)};var
e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return
a.fn.collapse=e,this},<a
href="data-toggle="collapse"">a(document).on(click.bs.collapse.data-api,</a>&#39;,function(d){var
e=a(this);e.attr(data-target)||d.preventDefault();var
f=b(e),g=f.data(bs.collapse),h=g?toggle:e.data();c.call(f,h)})}(jQuery),+function(a){use
strict;function
b(b){b&amp;&amp;3===b.which||(a(e).remove(),a(f).each(function(){var
d=a(this),e=c(d),f={relatedTarget:this};e.hasClass(open)&amp;&amp;(e.trigger(b=a.Event(hide.bs.dropdown,f)),b.isDefaultPrevented()||(d.attr(aria-expanded,false),e.removeClass(open).trigger(hidden.bs.dropdown,f)))}))}function
c(b){var <a
href="A-Za-z">c=b.attr(data-target);c||(c=b.attr(href),c=c&&/#</a>/.<a
href="^\s">test&&c.replace(/.*(?=#</a>*$)/,));var d=c&amp;&amp;a;return
d&amp;&amp;d.length?d:b.parent()}function d(b){return
this.each(function(){var
c=a(this),d=c.data(bs.dropdown);d||c.data(bs.dropdown,d=new
g(this)),string==typeof <a href="b">b&&d</a>.call})}var <a
href="data-toggle="dropdown"">e=.dropdown-backdrop,f=</a>&#39;,g=function(b){a(b).on(click.bs.dropdown,this.toggle)};g.VERSION=3.3.4,g.prototype.toggle=function(d){var
e=a(this);if(!e.is(.disabled, :disabled)){var
f=c(e),g=f.hasClass(open);if(b(),!g){ontouchstartin
document.documentElement&amp;&amp;!f.closest(.navbar-nav).length&amp;&amp;a(&#39;&lt;div
class=dropdown-backdrop/&gt;&#39;).insertAfter(a(this)).on(click,b);var
h={relatedTarget:this};if(f.trigger(d=a.Event(show.bs.dropdown,h)),d.isDefaultPrevented())return;e.trigger(focus).attr(aria-expanded,true),f.toggleClass(open).trigger(shown.bs.dropdown,h)}return!1}},g.prototype.keydown=function(b){if(/(38|40|27|32)/.test(b.which)&amp;&amp;!/input|textarea/i.test(b.target.tagName)){var
d=a(this);if(b.preventDefault(),b.stopPropagation(),!d.is(.disabled,
:disabled)){var
e=c(d),g=e.hasClass(open);if(!g&amp;&amp;27!=b.which||g&amp;&amp;27==b.which)return
27==b.which&amp;&amp;e.find(f).trigger(focus),d.trigger(click);var h=
li:not(.disabled):visible <a
href="role="menu"">a,i=e.find(</a>&#39;<code>h</code>&#39;,
[role=listbox]&#39;+h);if(i.length){var
j=i.index(b.target);38==b.which&amp;&amp;j&gt;0&amp;&amp;j,40==b.which&amp;&amp;j&lt;i.length-1&amp;&amp;j++,~j||(j=0),i.eq(j).trigger(focus)}}}};var
h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return
a.fn.dropdown=h,this},a(document).on(click.bs.dropdown.data-api,b).on(click.bs.dropdown.data-api,.dropdown
form,function(a){a.stopPropagation()}).<a
href="role="menu"">on(click.bs.dropdown.data-api,f,g.prototype.toggle).on(keydown.bs.dropdown.data-api,f,g.prototype.keydown).on(keydown.bs.dropdown.data-api,</a>&#39;,<a
href="role="listbox"">g.prototype.keydown).on(keydown.bs.dropdown.data-api,</a>&#39;,g.prototype.keydown)}(jQuery),+function(a){use
strict;function b(b,d){return this.each(function(){var
e=a(this),f=e.data(bs.modal),g=a.extend({},c.DEFAULTS,e.data(),object==typeof
b&amp;&amp;b);f||e.data(bs.modal,f=new c(this,g)),string==typeof <a
href="b">b?f</a>(d):g.show&amp;&amp;f.show(d)})}var
c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(.modal-dialog),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&amp;&amp;this.$element.find(.modal-content).load(this.options.remote,a.proxy(function(){this.$element.trigger(loaded.bs.modal)},this))};c.VERSION=3.3.4,c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return
this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var
d=this,e=a.Event(show.bs.modal,{relatedTarget:b});<a
href="data-dismiss="modal"">this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass(modal-open),this.escape(),this.resize(),this.$element.on(click.dismiss.bs.modal,</a>&#39;,a.proxy(this.hide,this)),this.$dialog.on(mousedown.dismiss.bs.modal,function(){d.$element.one(mouseup.dismiss.bs.modal,function(b){a(b.target).is(d.$element)&amp;&amp;(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var
<a
href="0">e=a.support.transition&&d.$element.hasClass(fade);d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element</a>.offsetWidth,d.$element.addClass(in).attr(aria-hidden,!1),d.enforceFocus();var
f=a.Event(shown.bs.modal,{relatedTarget:b});e?d.$dialog.one(bsTransitionEnd,function(){d.$element.trigger(focus).trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger(focus).trigger(f)}))},c.prototype.hide=function(b){b&amp;&amp;b.preventDefault(),b=a.Event(hide.bs.modal),this.$element.trigger(b),this.isShown&amp;&amp;!b.isDefaultPrevented()&amp;&amp;(this.isShown=!1,this.escape(),this.resize(),a(document).off(focusin.bs.modal),this.$element.removeClass(in).attr(aria-hidden,!0).off(click.dismiss.bs.modal).off(mouseup.dismiss.bs.modal),this.$dialog.off(mousedown.dismiss.bs.modal),a.support.transition&amp;&amp;this.$element.hasClass(fade)?this.$element.one(bsTransitionEnd,a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off(focusin.bs.modal).on(focusin.bs.modal,a.proxy(function(a){<a
href="0">this.$element</a>===a.target||this.$element.has(a.target).length||this.$element.trigger(focus)},this))},c.prototype.escape=function(){this.isShown&amp;&amp;this.options.keyboard?this.$element.on(keydown.dismiss.bs.modal,a.proxy(function(a){27==a.which&amp;&amp;this.hide()},this)):this.isShown||this.$element.off(keydown.dismiss.bs.modal)},c.prototype.resize=function(){this.isShown?a(window).on(resize.bs.modal,a.proxy(this.handleUpdate,this)):a(window).off(resize.bs.modal)},c.prototype.hideModal=function(){var
a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass(modal-open),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger(hidden.bs.modal)})},c.prototype.removeBackdrop=function(){this.$backdrop&amp;&amp;this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var
d=this,e=this.$element.hasClass(fade)?fade:;if(this.isShown&amp;&amp;this.options.backdrop){var
f=a.support.transition&amp;&amp;e;if(this.$backdrop=a(&#39;&lt;div
class=modal-backdrop &#39;<code>e</code>&#39;
/&gt;&#39;).appendTo(this.$body),this.$element.on(click.dismiss.bs.modal,a.proxy(function(a){return
<a
href="0">this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&(static==this.options.backdrop?this.$element</a>.focus():this.hide()))},<a
href="0">this)),f&&this.$backdrop</a>.offsetWidth,this.$backdrop.addClass(in),!b)return;f?this.$backdrop.one(bsTransitionEnd,b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else
if(!this.isShown&amp;&amp;this.$backdrop){this.$backdrop.removeClass(in);var
g=function(){d.removeBackdrop(),b&amp;&amp;b()};a.support.transition&amp;&amp;this.$element.hasClass(fade)?this.$backdrop.one(bsTransitionEnd,g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else
b&amp;&amp;b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var
<a
href="0">a=this.$element</a>.scrollHeight&gt;document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&amp;&amp;a?this.scrollbarWidth:,paddingRight:this.bodyIsOverflowing&amp;&amp;!a?this.scrollbarWidth:})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:,paddingRight:})},c.prototype.checkScrollbar=function(){var
a=window.innerWidth;if(!a){var
b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth&lt;a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var
a=parseInt(this.$body.css(padding-right)||0,10);this.originalBodyPad=document.body.style.paddingRight||,this.bodyIsOverflowing&amp;&amp;this.$body.css(padding-right,a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css(padding-right,this.originalBodyPad)},c.prototype.measureScrollbar=function(){var
a=document.createElement(div);a.className=modal-scrollbar-measure,this.$body.append(a);var
b=a.offsetWidth-a.clientWidth;return <a
href="0">this.$body</a>.removeChild(a),b};var
d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return
a.fn.modal=d,this},<a
href="data-toggle="modal"">a(document).on(click.bs.modal.data-api,</a>&#39;,function{var
<a
href="^\s">d=a(this),e=d.attr(href),f=a(d.attr(data-target)||e&&e.replace(/.*(?=#</a>+$)/,)),g=f.data(bs.modal)?toggle:a.extend({remote:!/#/.test(e)&amp;&amp;e},f.data(),d.data());d.is(a)&amp;&amp;c.preventDefault(),f.one(show.bs.modal,function(a){a.isDefaultPrevented()||f.one(hidden.bs.modal,function(){d.is(:visible)&amp;&amp;d.trigger(focus)})}),b.call(f,g,this)})}(jQuery),+function(a){use
strict;function b(b){return this.each(function(){var
d=a(this),e=d.data(bs.tooltip),f=object==typeof
b&amp;&amp;b;(e||!/destroy|hide/.test(b))&amp;&amp;(e||d.data(bs.tooltip,e=new
c(this,f)),string==typeof <a href="b">b&&e</a>())})}var
c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.init(tooltip,a,b)};c.VERSION=3.3.4,c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:top,selector:!1,template:&#39;&lt;div
class=tooltip role=tooltip&gt;&lt;div
class=tooltip-arrow&gt;&lt;/div&gt;&lt;div
class=tooltip-inner&gt;&lt;/div&gt;&lt;/div&gt;&#39;,trigger:hover
focus,title:,delay:0,html:!1,container:!1,viewport:{selector:body,padding:0}},c.prototype.init=function(b,c,d){<a
href="0">if(this.enabled=!0,this.type=b,this.$element=a,this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(this.options.viewport.selector||this.options.viewport),this.$element</a>instanceof
document.constructor&amp;&amp;!this.options.selector)throw new
Error(`selector` option must be specified when initializing
<code>this.type</code> on the window.document object!);for(var
e=this.options.trigger.split( ),f=e.length;f;){var <a
href="f">g=e</a>;if(click==g)this.$element.on(click.+this.type,this.options.selector,a.proxy(this.toggle,this));else
if(manual!=g){var
h=hover==g?mouseenter:focusin,i=hover==g?mouseleave:focusout;this.$element.on(h+.+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+.+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:manual,selector:}):this.fixTitle()},c.prototype.getDefaults=function(){return
c.DEFAULTS},c.prototype.getOptions=function(b){return
b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&amp;&amp;number==typeof
b.delay&amp;&amp;(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var
b={},c=this.getDefaults();return
this._options&amp;&amp;a.each(this._options,function(a,d){<a
href="a">c</a>!=<a
href="a">d&&(b</a>=d)}),b},c.prototype.enter=function(b){var c=b instanceof
this.constructor?b:a(b.currentTarget).data(bs.+this.type);return
c&amp;&amp;c.$tip&amp;&amp;c.$tip.is(:visible)?void(c.hoverState=in):(c||(c=new
this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(bs.+this.type,c)),clearTimeout(c.timeout),c.hoverState=in,c.options.delay&amp;&amp;c.options.delay.show?void(c.timeout=setTimeout(function(){in==c.hoverState&amp;&amp;c.show()},c.options.delay.show)):c.show())},c.prototype.leave=function(b){var
c=b instanceof
this.constructor?b:a(b.currentTarget).data(bs.+this.type);return
c||(c=new
this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(bs.+this.type,c)),clearTimeout(c.timeout),c.hoverState=out,c.options.delay&amp;&amp;c.options.delay.hide?void(c.timeout=setTimeout(function(){out==c.hoverState&amp;&amp;c.hide()},c.options.delay.hide)):c.hide()},c.prototype.show=function(){var
b=a.Event(show.bs.+this.type);if(this.hasContent()&amp;&amp;this.enabled){this.$element.trigger(b);var
<a href="0">d=a.contains(this.$element</a>.<a
href="0">ownerDocument.documentElement,this.$element</a>);if(b.isDefaultPrevented()||!d)return;var
e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr(id,g),this.$element.attr(aria-describedby,g),this.options.animation&amp;&amp;f.addClass(fade);var
h=function==typeof <a
href="0">this.options.placement?this.options.placement.call(this,f</a>,<a
href="0">this.$element</a>):this.options.placement,i=/s?auto?s?/i,j=i.test(h);j&amp;&amp;(h=h.replace(i,)||top),f.detach().css({top:0,left:0,display:block}).addClass(h).data(bs.+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element);var
<a href="0">k=this.getPosition(),l=f</a>.<a
href="0">offsetWidth,m=f</a>.offsetHeight;if(j){var
n=h,o=this.options.container?a(this.options.container):this.$element.parent(),p=this.getPosition(o);h=bottom==h&amp;&amp;k.bottom+m&gt;p.bottom?top:top==h&amp;&amp;k.top-m&lt;p.top?bottom:right==h&amp;&amp;k.right+l&gt;p.width?left:left==h&amp;&amp;k.left-l&lt;p.left?right:h,f.removeClass(n).addClass(h)}var
q=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(q,h);var
r=function(){var
a=e.hoverState;e.$element.trigger(shown.bs.+e.type),e.hoverState=null,out==a&amp;&amp;e.leave(e)};a.support.transition&amp;&amp;this.$tip.hasClass(fade)?f.one(bsTransitionEnd,r).emulateTransitionEnd(c.TRANSITION_DURATION):r()}},c.prototype.applyPlacement=function(b,c){var
<a href="0">d=this.tip(),e=d</a>.<a href="0">offsetWidth,f=d</a>.<a
href="0">offsetHeight,g=parseInt(d.css(margin-top),10),h=parseInt(d.css(margin-left),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top=b.top+g,b.left=b.left+h,a.offset.setOffset(d</a>,a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass(in);var
<a href="0">i=d</a>.<a
href="0">offsetWidth,j=d</a>.offsetHeight;top==c&amp;&amp;j!=f&amp;&amp;(b.top=b.top+f-j);var
k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var
<a
href="0">l=/top|bottom/.test,m=l?2*k.left-e+i:2*k.top-f+j,n=l?offsetWidth:offsetHeight;d.offset(b),this.replaceArrow(m,d</a>[n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?left:top,50*(1-a/b)+%).css(c?top:left,)},c.prototype.setContent=function(){var
<a
href="this.options.html?"html":"text"">a=this.tip(),b=this.getTitle();a.find(.tooltip-inner)</a>(b),a.removeClass(fade
in top bottom left right)},c.prototype.hide=function(b){function
d(){in!=e.hoverState&amp;&amp;f.detach(),e.$element.removeAttr(aria-describedby).trigger(hidden.bs.+e.type),b&amp;&amp;b()}var
e=this,f=a(this.$tip),g=a.Event(hide.bs.+this.type);return
this.$element.trigger(g),g.isDefaultPrevented()?void
0:(f.removeClass(in),a.support.transition&amp;&amp;f.hasClass(fade)?f.one(bsTransitionEnd,d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var
a=this.$element;(a.attr(title)||string!=typeof
a.attr(data-original-title))&amp;&amp;a.attr(data-original-title,a.attr(title)||).attr(title,)},c.prototype.hasContent=function(){return
this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var
<a
href="0">c=b</a>,d=BODY==c.tagName,e=c.getBoundingClientRect();null==e.width&amp;&amp;(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var
f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return
a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){returnbottom==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:top==a?{top:b.top-d,left:b.left+b.width/2-c/2}:left==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var
e={top:0,left:0};if(!this.$viewport)return e;var
f=this.options.viewport&amp;&amp;this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var
h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h&lt;g.top?e.top=g.top-h:i&gt;g.top+g.height&amp;&amp;(e.top=g.top+g.height-i)}else{var
j=b.left-f,k=b.left+f+c;j&lt;g.left?e.left=g.left-j:k&gt;g.width&amp;&amp;(e.left=g.left+g.width-k)}return
e},c.prototype.getTitle=function(){var
a,b=this.$element,c=this.options;return
a=b.attr(data-original-title)||(function==typeof <a
href="0">c.title?c.title.call(b</a>):c.title)},c.prototype.getUID=function(a){do
a+=~~(1e6*Math.random());while(document.getElementById(a));return
a},c.prototype.tip=function(){return
this.$tip=this.$tip||a(this.options.template)},c.prototype.arrow=function(){return
this.$arrow=this.$arrow||this.tip().find(.tooltip-arrow)},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var
c=this;b&amp;&amp;(c=a(b.currentTarget).data(bs.+this.type),c||(c=new
this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(bs.+this.type,c))),c.tip().hasClass(in)?c.leave:c.enter},c.prototype.destroy=function(){var
a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off(.+a.type).removeData(bs.+a.type)})};var
d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return
a.fn.tooltip=d,this}}(jQuery),+function(a){use strict;function
b(b){return this.each(function(){var
d=a(this),e=d.data(bs.popover),f=object==typeof
b&amp;&amp;b;(e||!/destroy|hide/.test(b))&amp;&amp;(e||d.data(bs.popover,e=new
c(this,f)),string==typeof <a href="b">b&&e</a>())})}var
c=function(a,b){this.init(popover,a,b)};if(!a.fn.tooltip)throw new
Error(Popover requires
tooltip.js);c.VERSION=3.3.4,c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:right,trigger:click,content:,template:&#39;&lt;div
class=popover role=tooltip&gt;&lt;div
class=arrow&gt;&lt;/div&gt;&lt;h3
class=popover-title&gt;&lt;/h3&gt;&lt;div
class=popover-content&gt;&lt;/div&gt;&lt;/div&gt;&#39;}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return
c.DEFAULTS},c.prototype.setContent=function(){var <a
href="this.options.html?"html":"text"">a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(.popover-title)</a>(b),a.find(.popover-content).children().detach().end()[this.options.html?string==typeof
c?html:append:text],a.removeClass(fade top bottom left right
in),a.find(.popover-title).html()||a.find(.popover-title).hide()},c.prototype.hasContent=function(){return
this.getTitle()||this.getContent()},c.prototype.getContent=function(){var
a=this.$element,b=this.options;return
a.attr(data-content)||(function==typeof <a
href="0">b.content?b.content.call(a</a>):b.content)},c.prototype.arrow=function(){return
this.$arrow=this.$arrow||this.tip().find(.arrow)};var
d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return
a.fn.popover=d,this}}(jQuery),+function(a){use strict;function
b(c,d){this.$body=a(document.body),this.$scrollElement=a(a.is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||)+
.nav li &gt; <a
href="">a,this.offsets=[],this.targets=</a>,this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on(scroll.bs.scrollspy,a.proxy(this.process,this)),this.refresh(),this.process()}function
c{return this.each(function(){var
d=a(this),e=d.data(bs.scrollspy),f=object==typeof
c&amp;&amp;c;e||d.data(bs.scrollspy,e=new b(this,f)),string==typeof <a
href="c">c&&e</a>()})}b.VERSION=3.3.4,b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return
<a href="0">this.$scrollElement</a>.<a
href="0">scrollHeight||Math.max(this.$body</a>.scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var
<a href="">b=this,c=offset,d=0;this.offsets=[],this.targets=</a>,<a
href="0">this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement</a>)||(c=position,d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var
b=a(this),e=b.data(target)||b.attr(href),f=/^#./.test(e)&amp;&amp;a(e);return
<a
href="c">f&&f.length&&f.is(:visible)&&[[f</a>().top+d,e]]||null}).sort(function(a,b){return
<a href="0">a</a>-<a href="0">b</a>}).each(function(){<a
href="0">b.offsets.push(this</a>),<a
href="1">b.targets.push(this</a>)})},b.prototype.process=function(){var
a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&amp;&amp;this.refresh(),b&gt;=d)return
<a href="f.length-1">g!=(a=f</a>)&amp;&amp;<a
href="0">this.activate(a);if(g&&b<e</a>)return <a
href="a">this.activeTarget=null,this.clear();for(a=e.length;a;)g!=f</a>&amp;&amp;<a
href="a">b>=e</a>&amp;&amp;(void <a href="a+1">0===e</a>||<a
href="a+1">b<e</a>)&amp;&amp;<a
href="a">this.activate(f</a>)},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var
<a
href="data-target="'b'"">c=this.selector+</a>,&#39;<code>this.selector'[href="'b'"]</code>&#39;,d=a.parents(li).addClass(active);d.parent(.dropdown-menu).length&amp;&amp;(d=d.closest(li.dropdown).addClass(active)),d.trigger(activate.bs.scrollspy)},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,.active).removeClass(active)};var
d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return
a.fn.scrollspy=d,this},a(window).on(load.bs.scrollspy.data-api,function(){<a
href="data-spy="scroll"">a(</a>&#39;).each(function(){var
b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){use
strict;function b(b){return this.each(function(){var
d=a(this),e=d.data(bs.tab);e||d.data(bs.tab,e=new
c(this)),string==typeof <a href="b">b&&e</a>()})}var
c=function(b){this.element=a(b)};c.VERSION=3.3.4,c.TRANSITION_DURATION=150,c.prototype.show=function(){var
<a
href="^\s">b=this.element,c=b.closest(ul:not(.dropdown-menu)),d=b.data(target);if(d||(d=b.attr(href),d=d&&d.replace(/.*(?=#</a>*$)/,)),!b.parent(li).hasClass(active)){
var e=c.find(.active:last a),f=a.Event(hide.bs.tab,{<a
href="0">relatedTarget:b</a>}),g=a.Event(show.bs.tab,{<a
href="0">relatedTarget:e</a>});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&amp;&amp;!f.isDefaultPrevented()){var
h=a(d);this.activate(b.closest(li),c),this.activate(h,h.parent(),function(){e.trigger({<a
href="0">type:hidden.bs.tab,relatedTarget:b</a>}),b.trigger({<a
href="0">type:shown.bs.tab,relatedTarget:e</a>})})}}},c.prototype.activate=function(b,d,e){function
f(){g.removeClass(active).find(&gt; .dropdown-menu &gt; .<a
href="data-toggle="tab"">active).removeClass(active).end().find(</a>&#39;).<a
href="data-toggle="tab"">attr(aria-expanded,!1),b.addClass(active).find(</a>&#39;).<a
href="0">attr(aria-expanded,!0),h?(b</a>.<a
href="data-toggle="tab"">offsetWidth,b.addClass(in)):b.removeClass(fade),b.parent(.dropdown-menu).length&&b.closest(li.dropdown).addClass(active).end().find(</a>&#39;).attr(aria-expanded,!0),e&amp;&amp;e()}var
g=d.find(&gt;
.active),h=e&amp;&amp;a.support.transition&amp;&amp;(g.length&amp;&amp;g.hasClass(fade)||!!d.find(&gt;
.fade).length);g.length&amp;&amp;h?g.one(bsTransitionEnd,f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass(in)};var
d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return
a.fn.tab=d,this};var
e=function{c.preventDefault(),b.call(a(this),show)};<a
href="data-toggle="tab"">a(document).on(click.bs.tab.data-api,</a>&#39;,<a
href="data-toggle="pill"">e).on(click.bs.tab.data-api,</a>&#39;,e)}(jQuery),+function(a){use
strict;function b(b){return this.each(function(){var
d=a(this),e=d.data(bs.affix),f=object==typeof
b&amp;&amp;b;e||d.data(bs.affix,e=new c(this,f)),string==typeof <a
href="b">b&&e</a>()})}var
c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on(scroll.bs.affix.data-api,a.proxy(this.checkPosition,this)).on(click.bs.affix.data-api,a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION=3.3.4,c.RESET=affix
affix-top
affix-bottom,c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var
e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&amp;&amp;top==this.affixed)return
c&gt;e?top:!1;if(bottom==this.affixed)return
null!=c?e+this.unpin&lt;=f.top?!1:bottom:a-d&gt;=e+g?!1:bottom;var
h=null==this.affixed,i=h?e:f.top,j=h?g:b;return
null!=c&amp;&amp;c&gt;=e?top:null!=d&amp;&amp;i+j&gt;=a-d?bottom:!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return
this.pinnedOffset;this.$element.removeClass(c.RESET).addClass(affix);var
a=this.$target.scrollTop(),b=this.$element.offset();return
this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(:visible)){var
b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=a(document.body).height();object!=typeof
d&amp;&amp;(f=e=d),function==typeof
e&amp;&amp;(e=d.top(this.$element)),function==typeof
f&amp;&amp;(f=d.bottom(this.$element));var
h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&amp;&amp;this.$element.css(top,);var
i=affix+(h?-+h:),j=a.Event(i+.bs.affix);if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin=bottom==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace(affix,affixed)+.bs.affix)}bottom==h&amp;&amp;this.$element.offset({top:g-b-f})}};var
d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return
a.fn.affix=d,this},a(window).on(load,function(){<a
href="data-spy="affix"">a(</a>&#39;).each(function(){var
c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&amp;&amp;(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&amp;&amp;(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);
/* Respond.js: min/max-width media query polyfill.  Scott Jehl. MIT Lic.
j.mp/respondjs  */</p>

<p>(function( w ){</p>

<pre>&quot;use strict&quot;;

//exposed namespace
var respond = {};
w.respond = respond;

//define update even in native-mq-supporting browsers, to avoid errors
respond.update = function(){};

//define ajax obj
var requestQueue = [],
        xmlHttp = (function() {
                var xmlhttpmethod = false;
                try {
                        xmlhttpmethod = new w.XMLHttpRequest();
                }
                catch( e ){
                        xmlhttpmethod = new w.ActiveXObject( &quot;Microsoft.XMLHTTP&quot; );
                }
                return function(){
                        return xmlhttpmethod;
                };
        })(),

        //tweaked Ajax functions from Quirksmode
        ajax = function( url, callback ) {
                var req = xmlHttp();
                if (!req){
                        return;
                }
                req.open( &quot;GET&quot;, url, true );
                req.onreadystatechange = function () {
                        if ( req.readyState !== 4 || req.status !== 200 &amp;&amp; req.status !== 304 ){
                                return;
                        }
                        callback( req.responseText );
                };
                if ( req.readyState === 4 ){
                        return;
                }
                req.send( null );
        },
        isUnsupportedMediaQuery = function( query ) {
                return query.replace( respond.regex.minmaxwh, &#39;&#39; ).match( respond.regex.other );
        };

//expose for testing
respond.ajax = ajax;
respond.queue = requestQueue;
respond.unsupportedmq = isUnsupportedMediaQuery;
respond.regex = {
        media: /@media[^\{]+\{([^\{\}]*\{[^\}\{]*\})+/gi,
        keyframes: /@(?:\-(?:o|moz|webkit)\-)?keyframes[^\{]+\{(?:[^\{\}]*\{[^\}\{]*\})+[^\}]*\}/gi,
        comments: /\/\*[^*]*\*+([^/][^*]*\*+)*\//gi,
        urls: /(url\()[&#39;&quot;]?([^\/\)&#39;&quot;][^:\)&#39;&quot;]+)[&#39;&quot;]?(\))/g,
        findStyles: /@media *([^\{]+)\{([\S\s]+?)$/,
        only: /(only\s+)?([a-zA-Z]+)\s?/,
        minw: /\(\s*min\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/,
        maxw: /\(\s*max\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/,
        minmaxwh: /\(\s*m(in|ax)\-(height|width)\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/gi,
        other: /\([^\)]*\)/g
};

//expose media query support flag for external use
respond.mediaQueriesSupported = w.matchMedia &amp;&amp; w.matchMedia( &quot;only all&quot; ) !== null &amp;&amp; w.matchMedia( &quot;only all&quot; ).matches;

//if media queries are supported, exit here
if( respond.mediaQueriesSupported ){
        return;
}

//define vars
var doc = w.document,
        docElem = doc.documentElement,
        mediastyles = [],
        rules = [],
        appendedEls = [],
        parsedSheets = {},
        resizeThrottle = 30,
        head = doc.getElementsByTagName( &quot;head&quot; )[0] || docElem,
        base = doc.getElementsByTagName( &quot;base&quot; )[0],
        links = head.getElementsByTagName( &quot;link&quot; ),

        lastCall,
        resizeDefer,

        //cached container for 1em value, populated the first time it&#39;s needed
        eminpx,

        // returns the value of 1em in pixels
        getEmValue = function() {
                var ret,
                        div = doc.createElement(&#39;div&#39;),
                        body = doc.body,
                        originalHTMLFontSize = docElem.style.fontSize,
                        originalBodyFontSize = body &amp;&amp; body.style.fontSize,
                        fakeUsed = false;

                div.style.cssText = &quot;position:absolute;font-size:1em;width:1em&quot;;

                if( !body ){
                        body = fakeUsed = doc.createElement( &quot;body&quot; );
                        body.style.background = &quot;none&quot;;
                }

                // 1em in a media query is the value of the default font size of the browser
                // reset docElem and body to ensure the correct value is returned
                docElem.style.fontSize = &quot;100%&quot;;
                body.style.fontSize = &quot;100%&quot;;

                body.appendChild( div );

                if( fakeUsed ){
                        docElem.insertBefore( body, docElem.firstChild );
                }

                ret = div.offsetWidth;

                if( fakeUsed ){
                        docElem.removeChild( body );
                }
                else {
                        body.removeChild( div );
                }

                // restore the original values
                docElem.style.fontSize = originalHTMLFontSize;
                if( originalBodyFontSize ) {
                        body.style.fontSize = originalBodyFontSize;
                }

                //also update eminpx before returning
                ret = eminpx = parseFloat(ret);

                return ret;
        },

        //enable/disable styles
        applyMedia = function( fromResize ){
                var name = &quot;clientWidth&quot;,
                        docElemProp = docElem[ name ],
                        currWidth = doc.compatMode === &quot;CSS1Compat&quot; &amp;&amp; docElemProp || doc.body[ name ] || docElemProp,
                        styleBlocks     = {},
                        lastLink = links[ links.length-1 ],
                        now = (new Date()).getTime();

                //throttle resize calls
                if( fromResize &amp;&amp; lastCall &amp;&amp; now - lastCall &lt; resizeThrottle ){
                        w.clearTimeout( resizeDefer );
                        resizeDefer = w.setTimeout( applyMedia, resizeThrottle );
                        return;
                }
                else {
                        lastCall = now;
                }

                for( var i in mediastyles ){
                        if( mediastyles.hasOwnProperty( i ) ){
                                var thisstyle = mediastyles[ i ],
                                        min = thisstyle.minw,
                                        max = thisstyle.maxw,
                                        minnull = min === null,
                                        maxnull = max === null,
                                        em = &quot;em&quot;;

                                if( !!min ){
                                        min = parseFloat( min ) * ( min.indexOf( em ) &gt; -1 ? ( eminpx || getEmValue() ) : 1 );
                                }
                                if( !!max ){
                                        max = parseFloat( max ) * ( max.indexOf( em ) &gt; -1 ? ( eminpx || getEmValue() ) : 1 );
                                }

                                // if there&#39;s no media query at all (the () part), or min or max is not null, and if either is present, they&#39;re true
                                if( !thisstyle.hasquery || ( !minnull || !maxnull ) &amp;&amp; ( minnull || currWidth &gt;= min ) &amp;&amp; ( maxnull || currWidth &lt;= max ) ){
                                        if( !styleBlocks[ thisstyle.media ] ){
                                                styleBlocks[ thisstyle.media ] = [];
                                        }
                                        styleBlocks[ thisstyle.media ].push( rules[ thisstyle.rules ] );
                                }
                        }
                }

                //remove any existing respond style element(s)
                for( var j in appendedEls ){
                        if( appendedEls.hasOwnProperty( j ) ){
                                if( appendedEls[ j ] &amp;&amp; appendedEls[ j ].parentNode === head ){
                                        head.removeChild( appendedEls[ j ] );
                                }
                        }
                }
                appendedEls.length = 0;

                //inject active styles, grouped by media type
                for( var k in styleBlocks ){
                        if( styleBlocks.hasOwnProperty( k ) ){
                                var ss = doc.createElement( &quot;style&quot; ),
                                        css = styleBlocks[ k ].join( &quot;\n&quot; );

                                ss.type = &quot;text/css&quot;;
                                ss.media = k;

                                //originally, ss was appended to a documentFragment and sheets were appended in bulk.
                                //this caused crashes in IE in a number of circumstances, such as when the HTML element had a bg image set, so appending beforehand seems best. Thanks to @dvelyk for the initial research on this one!
                                head.insertBefore( ss, lastLink.nextSibling );

                                if ( ss.styleSheet ){
                                        ss.styleSheet.cssText = css;
                                }
                                else {
                                        ss.appendChild( doc.createTextNode( css ) );
                                }

                                //push to appendedEls to track for later removal
                                appendedEls.push( ss );
                        }
                }
        },
        //find media blocks in css text, convert to style blocks
        translate = function( styles, href, media ){
                var qs = styles.replace( respond.regex.comments, &#39;&#39; )
                                .replace( respond.regex.keyframes, &#39;&#39; )
                                .match( respond.regex.media ),
                        ql = qs &amp;&amp; qs.length || 0;

                //try to get CSS path
                href = href.substring( 0, href.lastIndexOf( &quot;/&quot; ) );

                var repUrls = function( css ){
                                return css.replace( respond.regex.urls, &quot;$1&quot; + href + &quot;$2$3&quot; );
                        },
                        useMedia = !ql &amp;&amp; media;

                //if path exists, tack on trailing slash
                if( href.length ){ href += &quot;/&quot;; }

                //if no internal queries exist, but media attr does, use that
                //note: this currently lacks support for situations where a media attr is specified on a link AND
                        //its associated stylesheet has internal CSS media queries.
                        //In those cases, the media attribute will currently be ignored.
                if( useMedia ){
                        ql = 1;
                }

                for( var i = 0; i &lt; ql; i++ ){
                        var fullq, thisq, eachq, eql;

                        //media attr
                        if( useMedia ){
                                fullq = media;
                                rules.push( repUrls( styles ) );
                        }
                        //parse for styles
                        else{
                                fullq = qs[ i ].match( respond.regex.findStyles ) &amp;&amp; RegExp.$1;
                                rules.push( RegExp.$2 &amp;&amp; repUrls( RegExp.$2 ) );
                        }

                        eachq = fullq.split( &quot;,&quot; );
                        eql = eachq.length;

                        for( var j = 0; j &lt; eql; j++ ){
                                thisq = eachq[ j ];

                                if( isUnsupportedMediaQuery( thisq ) ) {
                                        continue;
                                }

                                mediastyles.push( {
                                        media : thisq.split( &quot;(&quot; )[ 0 ].match( respond.regex.only ) &amp;&amp; RegExp.$2 || &quot;all&quot;,
                                        rules : rules.length - 1,
                                        hasquery : thisq.indexOf(&quot;(&quot;) &gt; -1,
                                        minw : thisq.match( respond.regex.minw ) &amp;&amp; parseFloat( RegExp.$1 ) + ( RegExp.$2 || &quot;&quot; ),
                                        maxw : thisq.match( respond.regex.maxw ) &amp;&amp; parseFloat( RegExp.$1 ) + ( RegExp.$2 || &quot;&quot; )
                                } );
                        }
                }

                applyMedia();
        },

        //recurse through request queue, get css text
        makeRequests = function(){
                if( requestQueue.length ){
                        var thisRequest = requestQueue.shift();

                        ajax( thisRequest.href, function( styles ){
                                translate( styles, thisRequest.href, thisRequest.media );
                                parsedSheets[ thisRequest.href ] = true;

                                // by wrapping recursive function call in setTimeout
                                // we prevent &quot;Stack overflow&quot; error in IE7
                                w.setTimeout(function(){ makeRequests(); },0);
                        } );
                }
        },

        //loop stylesheets, send text content to translate
        ripCSS = function(){

                for( var i = 0; i &lt; links.length; i++ ){
                        var sheet = links[ i ],
                        href = sheet.href,
                        media = sheet.media,
                        isCSS = sheet.rel &amp;&amp; sheet.rel.toLowerCase() === &quot;stylesheet&quot;;

                        //only links plz and prevent re-parsing
                        if( !!href &amp;&amp; isCSS &amp;&amp; !parsedSheets[ href ] ){
                                // selectivizr exposes css through the rawCssText expando
                                if (sheet.styleSheet &amp;&amp; sheet.styleSheet.rawCssText) {
                                        translate( sheet.styleSheet.rawCssText, href, media );
                                        parsedSheets[ href ] = true;
                                } else {
                                        if( (!/^([a-zA-Z:]*\/\/)/.test( href ) &amp;&amp; !base) ||
                                                href.replace( RegExp.$1, &quot;&quot; ).split( &quot;/&quot; )[0] === w.location.host ){
                                                // IE7 doesn&#39;t handle urls that start with &#39;//&#39; for ajax request
                                                // manually add in the protocol
                                                if ( href.substring(0,2) === &quot;//&quot; ) { href = w.location.protocol + href; }
                                                requestQueue.push( {
                                                        href: href,
                                                        media: media
                                                } );
                                        }
                                }
                        }
                }
                makeRequests();
        };

//translate CSS
ripCSS();

//expose update for re-running respond later on
respond.update = ripCSS;

//expose getEmValue
respond.getEmValue = getEmValue;

//adjust on resize
function callMedia(){
        applyMedia( true );
}

if( w.addEventListener ){
        w.addEventListener( &quot;resize&quot;, callMedia, false );
}
else if( w.attachEvent ){
        w.attachEvent( &quot;onresize&quot;, callMedia );
}</pre>

<p>})(this); /* *</p>

<pre>---------------------------------------- *
 v1.0
Author: VVG
QQ: 83816819
Mail: mysheller@163.com
http://www.cnblogs.com/NNUF/
---------------------------------------- *
Date: 2012-07-10
---------------------------------------- *
 /</pre>

<p>/* *</p>

<pre> Vcity
 /</pre>

<p>var Vcity = {}; /* *</p>

<pre>
@name _m
 /</pre>

<p>Vcity._m = {</p>

<pre>/*  */
$:function (arg, context) {
    var tagAll, n, eles = [], i, sub = arg.substring(1);
    context = context || document;
    if (typeof arg == &#39;string&#39;) {
        switch (arg.charAt(0)) {
            case &#39;#&#39;:
                return document.getElementById(sub);
                break;
            case &#39;.&#39;:
                if (context.getElementsByClassName) return context.getElementsByClassName(sub);
                tagAll = Vcity._m.$(&#39;*&#39;, context);
                n = tagAll.length;
                for (i = 0; i &lt; n; i++) {
                    if (tagAll[i].className.indexOf(sub) &gt; -1) eles.push(tagAll[i]);
                }
                return eles;
                break;
            default:
                return context.getElementsByTagName(arg);
                break;
        }
    }
},

/*  */
on:function (node, type, handler) {
    node.addEventListener ? node.addEventListener(type, handler, false) : node.attachEvent(&#39;on&#39; + type, handler);
},

/*  */
getEvent:function(event){
    return event || window.event;
},

/*  */
getTarget:function(event){
    return event.target || event.srcElement;
},

/*  */
getPos:function (node) {
    var scrollx = document.documentElement.scrollLeft || document.body.scrollLeft,
        scrollt = document.documentElement.scrollTop || document.body.scrollTop;
    var pos = node.getBoundingClientRect();
    return {top:pos.top + scrollt, right:pos.right + scrollx, bottom:pos.bottom + scrollt, left:pos.left + scrollx };
},

/*  */
addClass:function (c, node) {
    if(!node)return;
    node.className = Vcity._m.hasClass(c,node) ? node.className : node.className + &#39; &#39; + c ;
},

/*  */
removeClass:function (c, node) {
    var reg = new RegExp(&quot;(^|\\s+)&quot; + c + &quot;(\\s+|$)&quot;, &quot;g&quot;);
    if(!Vcity._m.hasClass(c,node))return;
    node.className = reg.test(node.className) ? node.className.replace(reg, &#39;&#39;) : node.className;
},

/* CLASS */
hasClass:function (c, node) {
    if(!node || !node.className)return false;
    return node.className.indexOf(c)&gt;-1;
},

/*  */
stopPropagation:function (event) {
    event = event || window.event;
    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
},
/*  */
trim:function (str) {
    return str.replace(/^\s+|\s+$/g,&#39;&#39;);
}</pre>

<p>};</p>

<p>/* ,|beijing|bj16 */ /* Vcity.allCity =
[&#39;|beijing|bj&#39;,&#39;|shanghai|sh&#39;,
&#39;|chongqing|cq&#39;,  &#39;|shenzhen|sz&#39;,
&#39;|guangzhou|gz&#39;, &#39;|hangzhou|hz&#39;,</p>

<pre>   &#39;|nanjing|nj&#39;, &#39;|shuzhou|sz&#39;, &#39;|tianjin|tj&#39;, &#39;|chengdu|cd&#39;, &#39;|nanchang|nc&#39;, &#39;|sanya|sy&#39;,&#39;|qingdao|qd&#39;,
   &#39;|xiamen|xm&#39;, &#39;|xian|xa&#39;,&#39;|changsha|cs&#39;,&#39;|hefei|hf&#39;,&#39;|xizang|xz&#39;, &#39;|neimenggu|nmg&#39;, &#39;|anqing|aq&#39;, &#39;|ataile|atl&#39;, &#39;|ankang|ak&#39;,
   &#39;|akesu|aks&#39;, &#39;|baotou|bt&#39;, &#39;|beihai|bh&#39;, &#39;|baise|bs&#39;,&#39;|baoshan|bs&#39;, &#39;|changzhi|cz&#39;, &#39;|changchun|cc&#39;, &#39;|changzhou|cz&#39;, &#39;|changdu|cd&#39;,
   &#39;|chaoyang|cy&#39;, &#39;|changde|cd&#39;, &#39;|changbaishan|cbs&#39;, &#39;|chifeng|cf&#39;, &#39;|datong|dt&#39;, &#39;|dalian|dl&#39;, &#39;|daxian|dx&#39;, &#39;|dongying|dy&#39;, &#39;|daqing|dq&#39;, &#39;|dandong|dd&#39;,
   &#39;|dali|dl&#39;, &#39;|dunhuang|dh&#39;, &#39;|eerduosi|eeds&#39;, &#39;|enshi|es&#39;, &#39;|fuzhou|fz&#39;, &#39;|fuyang|fy&#39;, &#39;|guiyang|gy&#39;,
   &#39;|guilin|gl&#39;, &#39;|guangyuan|gy&#39;, &#39;|geermu|gem&#39;, &#39;|huhehaote|hhht&#39;, &#39;|hami|hm&#39;,
   &#39;|heihe|hh&#39;, &#39;|hailaer|hle&#39;, &#39;|haerbin|heb&#39;, &#39;|haikou|hk&#39;, &#39;|huangshan|hs&#39;, &#39;|handan|hd&#39;,
   &#39;|hanzhong|hz&#39;, &#39;|hetian|ht&#39;, &#39;|jinjiang|jj&#39;,&#39;|jinhua|jh&#39;, &#39;|jinzhou|jz&#39;, &#39;|jingdezhen|jdz&#39;,
   &#39;|jiayuguan|jyg&#39;, &#39;|jinggangshan|jgs&#39;, &#39;|jining|jn&#39;, &#39;|jiujiang|jj&#39;, &#39;|jiamusi|jms&#39;, &#39;|jinan|jn&#39;,
   &#39;|kashi|ks&#39;, &#39;|kunming|km&#39;, &#39;|kangding|kd&#39;, &#39;|kelamayi|klmy&#39;, &#39;|kuerle|kel&#39;, &#39;|kuche|kc&#39;, &#39;|lanzhou|lz&#39;,
   &#39;|luoyang|ly&#39;, &#39;|lijiang|lj&#39;,&#39;|lishui|ls&#39;, &#39;|linzhi|lz&#39;, &#39;|liuzhou|lz&#39;, &#39;|luzhou|lz&#39;, &#39;|lianyungang|lyg&#39;, &#39;|liping|lp&#39;,
   &#39;|liancheng|lc&#39;, &#39;|lasa|ls&#39;, &#39;|lincang|lc&#39;, &#39;|linyi|ly&#39;, &#39;|mangshi|ms&#39;, &#39;|mudanjiang|mdj&#39;, &#39;|manzhouli|mzl&#39;, &#39;|mianyang|my&#39;,
   &#39;|meixian|mx&#39;, &#39;|mohe|mh&#39;, &#39;|nanchong|nc&#39;, &#39;|nanning|nn&#39;, &#39;|nanyang|ny&#39;, &#39;|nantong|nt&#39;, &#39;|nalati|nlt&#39;,
   &#39;|ningbo|nb&#39;, &#39;|panzhihua|pzh&#39;, &#39;|quzhou|qz&#39;, &#39;|qinhuangdao|qhd&#39;, &#39;|qingyang|qy&#39;, &#39;|qiqihaer|qqhe&#39;,
   &#39;|shijiazhuang|sjz&#39;,  &#39;|shenyang|sy&#39;, &#39;|simao|sm&#39;, &#39;|tongren|tr&#39;, &#39;|tacheng|tc&#39;, &#39;|tengchong|tc&#39;, &#39;|taizhou|tz&#39;,
   &#39;|tongliao|tl&#39;, &#39;|taiyuan|ty&#39;, &#39;|weihai|wh&#39;, &#39;|wuzhou|wz&#39;, &#39;|wenshan|ws&#39;, &#39;|wuxi|wx&#39;, &#39;|weifang|wf&#39;, &#39;|wuyishan|wys&#39;, &#39;|wulanhaote|wlht&#39;,
   &#39;|wenzhou|wz&#39;, &#39;|wulumuqi|wlmq&#39;, &#39;|wanzhou|wz&#39;, &#39;|wuhai|wh&#39;, &#39;|xingyi|xy&#39;, &#39;|xichang|xc&#39;,  &#39;|xiangfan|xf&#39;,
   &#39;|xining|xn&#39;, &#39;|xilinhaote|xlht&#39;, &#39;|xishuangbanna|xsbn&#39;, &#39;|xuzhou|xz&#39;, &#39;|yiwu|yw&#39;, &#39;|yongzhou|yz&#39;, &#39;|yulin|yl&#39;, &#39;|yanan|ya&#39;, &#39;|yuncheng|yc&#39;,
   &#39;|yantai|yt&#39;, &#39;|yinchuan|yc&#39;, &#39;|yichang|yc&#39;, &#39;|yibin|yb&#39;, &#39;|yancheng|yc&#39;, &#39;|yanji|yj&#39;, &#39;|yushu|ys&#39;, &#39;|yining|yn&#39;, &#39;|zhuhai|zh&#39;, &#39;|zhaotong|zt&#39;,
   &#39;|zhangjiajie|zjj&#39;, &#39;|zhoushan|zs&#39;, &#39;|zhengzhou|zz&#39;, &#39;|zhongwei|zw&#39;, &#39;|zhijiang|zj&#39;, &#39;|zhanjiang|zj&#39;];
/</pre>

<p>Vcity.allCity=[&#39;|beijing|bj&#39;,&#39;|shanghai|sh&#39;,
&#39;|chongqing|cq&#39;,  &#39;|shenzhen|sz&#39;,
&#39;|guangzhou|gz&#39;,&#39;|nanjing|nj&#39;,
&#39;|hangzhou|hz&#39;,</p>

<pre>&#39;|shuzhou|sz&#39;, &#39;|tianjin|tj&#39;, &#39;|chengdu|cd&#39;, &#39;|nanchang|nc&#39;, &#39;|sanya|sy&#39;,&#39;|qingdao|qd&#39;,
&#39;|xiamen|xm&#39;, &#39;|xian|xa&#39;,&#39;|changsha|cs&#39;,&#39;|hefei|hf&#39;,&#39;|kunming|km&#39;,&#39;|jinan|jn&#39;,&#39;|lasa|ls&#39;,
&#39;|shenyang|sy&#39;,&#39;|changchun|cc&#39;,&#39;|lanzhou|lz&#39;,&#39;|zhengzhou|zz&#39;,&#39;|guiyang|gy&#39;,
&#39;|bozhou|bz&#39;,&#39;|fuzhou|fz&#39;,&#39;|fuyang|fy&#39;,&#39;|suzhou|sz&#39;,&#39;|yichun|yc&#39;,&#39;|yulin|yl&#39;,
&#39;|aba|ab&#39;,&#39;|ankang|ak&#39;,&#39;|akesu|aks&#39;,&#39;|ali|al&#39;,&#39;|alashanmeng|alsm&#39;,&#39;|aletai|alt&#39;,&#39;|anqing|aq&#39;,&#39;|anshan|as&#39;,&#39;|anshun|as&#39;,&#39;|atushi|ats&#39;,&#39;|anyang|ay&#39;,&#39;|bangbu|bb&#39;,&#39;|baicheng|bc&#39;,&#39;|baoding|bd&#39;,&#39;|beihai|bh&#39;,&#39;|baoji|bj&#39;,&#39;|bijie|bj&#39;,&#39;|bole|bl&#39;,&#39;|baise|bs&#39;,&#39;|baoshan|bs&#39;,&#39;|baishan|bs&#39;,&#39;|baotou|bt&#39;,&#39;|benxi|bx&#39;,&#39;|bayan|by&#39;,&#39;|baiyin|by&#39;,&#39;|bazhong|bz&#39;,&#39;|binzhou|bz&#39;,&#39;|chengde|cd&#39;,&#39;|changde|cd&#39;,&#39;|changdu|cd&#39;,&#39;|chifeng|cf&#39;,&#39;|changji|cj&#39;,&#39;|changji|cj&#39;,&#39;|changshu|cs&#39;,&#39;|chuxiong|cx&#39;,&#39;|chaoyang|cy&#39;,&#39;|chongzuo|cz&#39;,&#39;|chuzhou|cz&#39;,&#39;|chizhou|cz&#39;,&#39;|cangzhou|cz&#39;,&#39;|changzhi|cz&#39;,&#39;|changzhou|cz&#39;,&#39;|chaozhou|cz&#39;,&#39;|chenzhou|cz&#39;,&#39;|dandong|dd&#39;,&#39;|dongguan|dg&#39;,&#39;|dehong|dh&#39;,&#39;|dali|dl&#39;,&#39;|dalian|dl&#39;,&#39;|daqing|dq&#39;,&#39;|datong|dt&#39;,&#39;|dingxi|dx&#39;,&#39;|daxinganling|dxal&#39;,&#39;|dongying|dy&#39;,&#39;|duyun|dy&#39;,&#39;|deyang|dy&#39;,&#39;|dezhou|dz&#39;,&#39;|dazhou|dz&#39;,&#39;|eerduosi|eeds&#39;,&#39;|enshi|es&#39;,&#39;|ezhou|ez&#39;,&#39;|fangchenggang|fcg&#39;,&#39;|foshan|fs&#39;,&#39;|fushun|fs&#39;,&#39;|fuxin|fx&#39;,&#39;|fuyang|fy&#39;,&#39;|fuzhou|fz&#39;,&#39;|guangan|ga&#39;,&#39;|guigang|gg&#39;,&#39;|guoluo|gl&#39;,&#39;|guilin|gl&#39;,&#39;|gannan|gn&#39;,&#39;|guyuan|gy&#39;,&#39;|guangyuan|gy&#39;,&#39;|ganzi|gz&#39;,&#39;|ganzhou|gz&#39;,&#39;|huaian|ha&#39;,&#39;|hebi|hb&#39;,&#39;|huaibei|hb&#39;,&#39;|haibei|hb&#39;,&#39;|hechi|hc&#39;,&#39;|handan|hd&#39;,&#39;|haidong|hd&#39;,&#39;|haerbin|heb&#39;,&#39;|huanggang|hg&#39;,&#39;|hegang|hg&#39;,&#39;|huaihua|hh&#39;,&#39;|honghe|hh&#39;,&#39;|heihe|hh&#39;,&#39;|huhehaote|hhht&#39;,&#39;|haikou|hk&#39;,&#39;|hulunbeier|hlbe&#39;,&#39;|huludao|hld&#39;,&#39;|haimen|hm&#39;,&#39;|hami|hm&#39;,&#39;|huangnan|hn&#39;,&#39;|huainan|hn&#39;,&#39;|hainan|hn&#39;,&#39;|huangshi|hs&#39;,&#39;|hengshui|hs&#39;,&#39;|huangshan|hs&#39;,&#39;|hetian|ht&#39;,&#39;|haixi|hx&#39;,&#39;|heyuan|hy&#39;,&#39;|hengyang|hy&#39;,&#39;|huizhou|hz&#39;,&#39;|hezhou|hz&#39;,&#39;|huzhou|hz&#39;,&#39;|hanzhong|hz&#39;,&#39;|heze|hz&#39;,&#39;|jian|ja&#39;,&#39;|jinchang|jc&#39;,&#39;|jincheng|jc&#39;,&#39;|jingdezhen|jdz&#39;,&#39;|jinhua|jh&#39;,&#39;|jinghong|jh&#39;,&#39;|jiujiang|jj&#39;,&#39;|jilin|jl&#39;,&#39;|jingmen|jm&#39;,&#39;|jiangmen|jm&#39;,&#39;|jimo|jm&#39;,&#39;|jiamusi|jms&#39;,&#39;|jining|jn&#39;,&#39;|jiaonan|jn&#39;,&#39;|jiuquan|jq&#39;,&#39;|jurong|jr&#39;,&#39;|jishou|js&#39;,&#39;|jintan|jt&#39;,&#39;|jixi|jx&#39;,&#39;|jiaxing|jx&#39;,&#39;|jieyang|jy&#39;,&#39;|jiangyin|jy&#39;,&#39;|jiayuguan|jyg&#39;,&#39;|jiaozhou|jz&#39;,&#39;|jingzhou|jz&#39;,&#39;|jinzhou|jz&#39;,&#39;|jinzhong|jz&#39;,&#39;|jiaozuo|jz&#39;,&#39;|kuerle|kel&#39;,&#39;|kaifeng|kf&#39;,&#39;|kaili|kl&#39;,&#39;|kelamayi|klmy&#39;,&#39;|kashi|ks&#39;,&#39;|kunshan|ks&#39;,&#39;|linan|la&#39;,&#39;|liuan|la&#39;,&#39;|laibin|lb&#39;,&#39;|liaocheng|lc&#39;,&#39;|lincang|lc&#39;,&#39;|loudi|ld&#39;,&#39;|linfen|lf&#39;,&#39;|langfang|lf&#39;,&#39;|luohe|lh&#39;,&#39;|lijiang|lj&#39;,&#39;|lvliang|ll&#39;,&#39;|longnan|ln&#39;,&#39;|liupanshui|lps&#39;,&#39;|lishui|ls&#39;,&#39;|liangshan|ls&#39;,&#39;|leshan|ls&#39;,&#39;|laiwu|lw&#39;,&#39;|linxia|lx&#39;,&#39;|laixi|lx&#39;,&#39;|luoyang|ly&#39;,&#39;|longyan|ly&#39;,&#39;|liaoyang|ly&#39;,&#39;|linyi|ly&#39;,&#39;|liyang|ly&#39;,&#39;|liaoyuan|ly&#39;,&#39;|lianyungang|lyg&#39;,&#39;|liuzhou|lz&#39;,&#39;|linzhi|lz&#39;,&#39;|luzhou|lz&#39;,&#39;|laizhou|lz&#39;,&#39;|maanshan|mas&#39;,&#39;|mudanjiang|mdj&#39;,&#39;|maoming|mm&#39;,&#39;|meishan|ms&#39;,&#39;|mianyang|my&#39;,&#39;|meizhou|mz&#39;,&#39;|ningbo|nb&#39;,&#39;|nanchong|nc&#39;,&#39;|ningde|nd&#39;,&#39;|neijiang|nj&#39;,&#39;|nujiang|nj&#39;,&#39;|nanning|nn&#39;,&#39;|nanping|np&#39;,&#39;|naqu|nq&#39;,&#39;|nantong|nt&#39;,&#39;|nanyang|ny&#39;,&#39;|pingdu|pd&#39;,&#39;|pingdingshan|pds&#39;,&#39;|puer|pe&#39;,&#39;|panjin|pj&#39;,&#39;|pingliang|pl&#39;,&#39;|penglai|pl&#39;,&#39;|putian|pt&#39;,&#39;|pingxiang|px&#39;,&#39;|puyang|py&#39;,&#39;|panzhihua|pzh&#39;,&#39;|qinhuangdao|qhd&#39;,&#39;|qujing|qj&#39;,&#39;|qiqihaer|qqhe&#39;,&#39;|qitaihe|qth&#39;,&#39;|qianxi|qx&#39;,&#39;|qingyang|qy&#39;,&#39;|qingyuan|qy&#39;,&#39;|quzhou|qz&#39;,&#39;|qinzhou|qz&#39;,&#39;|quanzhou|qz&#39;,&#39;|rongcheng|rc&#39;,&#39;|rikaze|rkz&#39;,&#39;|rushan|rs&#39;,&#39;|rizhao|rz&#39;,&#39;|shouguang|sg&#39;,&#39;|shaoguan|sg&#39;,&#39;|suihua|sh&#39;,&#39;|shihezi|shz&#39;,&#39;|shijiazhuang|sjz&#39;,&#39;|shangluo|sl&#39;,&#39;|sanming|sm&#39;,&#39;|sanmenxia|smx&#39;,&#39;|shannan|sn&#39;,&#39;|suining|sn&#39;,&#39;|siping|sp&#39;,&#39;|suqian|sq&#39;,&#39;|shangqiu|sq&#39;,&#39;|shangrao|sr&#39;,&#39;|shantou|st&#39;,&#39;|shanwei|sw&#39;,&#39;|shaoxing|sx&#39;,&#39;|songyuan|sy&#39;,&#39;|shaoyang|sy&#39;,&#39;|shiyan|sy&#39;,&#39;|shuangyashan|sys&#39;,&#39;|shuozhou|sz&#39;,&#39;|suizhou|sz&#39;,&#39;|suzhou|sz&#39;,&#39;|shizuishan|szs&#39;,&#39;|taian|ta&#39;,&#39;|tongchuan|tc&#39;,&#39;|tacheng|tc&#39;,&#39;|taicang|tc&#39;,&#39;|tonghua|th&#39;,&#39;|tongling|tl&#39;,&#39;|tongliao|tl&#39;,&#39;|tieling|tl&#39;,&#39;|tulufan|tlf&#39;,&#39;|tongren|tr&#39;,&#39;|tianshui|ts&#39;,&#39;|tangshan|ts&#39;,&#39;|taiyuan|ty&#39;,&#39;|taizhou|tz&#39;,&#39;|taizhou|tz&#39;,&#39;|wendeng|wd&#39;,&#39;|weifang|wf&#39;,&#39;|wafangdian|wfd&#39;,&#39;|wuhan|wh&#39;,&#39;|wuhu|wh&#39;,&#39;|wuhai|wh&#39;,&#39;|weihai|wh&#39;,&#39;|wujiang|wj&#39;,&#39;|wulan|wl&#39;,&#39;|wulumuqi|wlmq&#39;,&#39;|weinan|wn&#39;,&#39;|wenshan|ws&#39;,&#39;|wuwei|ww&#39;,&#39;|wuxi|wx&#39;,&#39;|wuzhong|wz&#39;,&#39;|wenzhou|wz&#39;,&#39;|wuzhou|wz&#39;,&#39;|xingan|xa&#39;,&#39;|xuancheng|xc&#39;,&#39;|xuchang|xc&#39;,&#39;|xiangfan|xf&#39;,&#39;|xiaogan|xg&#39;,&#39;|xianggelila|xgll&#39;,&#39;|xilinhaote|xlht&#39;,&#39;|xining|xn&#39;,&#39;|xianning|xn&#39;,&#39;|xiangtan|xt&#39;,&#39;|xingtai|xt&#39;,&#39;|xinxiang|xx&#39;,&#39;|xianyang|xy&#39;,&#39;|xinyang|xy&#39;,&#39;|xinyu|xy&#39;,&#39;|xuzhou|xz&#39;,&#39;|xinzhou|xz&#39;,&#39;|yanan|ya&#39;,&#39;|yaan|ya&#39;,&#39;|yanbian|yb&#39;,&#39;|yibin|yb&#39;,&#39;|yinchuan|yc&#39;,&#39;|yancheng|yc&#39;,&#39;|yuncheng|yc&#39;,&#39;|yichun|yc&#39;,&#39;|yichang|yc&#39;,&#39;|yunfu|yf&#39;,&#39;|yangjiang|yj&#39;,&#39;|yingkou|yk&#39;,&#39;|yulin|yl&#39;,&#39;|yining|yn&#39;,&#39;|yangquan|yq&#39;,&#39;|yushu|ys&#39;,&#39;|yingtan|yt&#39;,&#39;|yantai|yt&#39;,&#39;|yiwu|yw&#39;,&#39;|yixing|yx&#39;,&#39;|yuxi|yx&#39;,&#39;|yiyang|yy&#39;,&#39;|yueyang|yy&#39;,&#39;|yongzhou|yz&#39;,&#39;|yangzhou|yz&#39;,&#39;|zibo|zb&#39;,&#39;|zigong|zg&#39;,&#39;|zhuhai|zh&#39;,&#39;|zhuji|zj&#39;,&#39;|zhenjiang|zj&#39;,&#39;|zhanjiang|zj&#39;,&#39;|zhangjiagang|zjg&#39;,&#39;|zhangjiajie|zjj&#39;,&#39;|zhangjiakou|zjk&#39;,&#39;|zhoukou|zk&#39;,&#39;|zhumadian|zmd&#39;,&#39;|zhaoqing|zq&#39;,&#39;|zhangqiu|zq&#39;,&#39;|zhoushan|zs&#39;,&#39;|zhongshan|zs&#39;,&#39;|zhaotong|zt&#39;,&#39;|zhongwei|zw&#39;,&#39;|ziyang|zy&#39;,&#39;|zhangye|zy&#39;,&#39;|zhaoyuan|zy&#39;,&#39;|zunyi|zy&#39;,&#39;|zhuzhou|zz&#39;,&#39;|zhangzhou|zz&#39;,&#39;|zaozhuang|zz&#39;];</pre>

<p>/*   */</p>

<p>Vcity.regEx = /^([u4E00-u9FA5uf900-ufa2d]+)|(w+)|(w)w*$/i;
Vcity.regExChiese = /([u4E00-u9FA5uf900-ufa2d]+)/;</p>

<p>/* *</p>

<pre>oCitya-h,i-p,q-z,hot
{HOT:{hot:[]},ABCDEFGH:{a:[1,2,3],b:[1,2,3]},IJKLMNOP:{i:[1.2.3],j:[1,2,3]},QRSTUVWXYZ:{}}
 /</pre>

<p>(function () {</p>

<pre>var citys = Vcity.allCity, match, letter,
    regEx = Vcity.regEx,
    reg2 = /^[a-f]$/i, reg3 = /^[g-k]$/i, reg4 = /^[l-p]$/i, reg5 = /^[q-u]$/i, reg6 = /^[v-z]$/i;
if (!Vcity.oCity) {
    Vcity.oCity = {hot:{}, ABCDEF:{}, GHIJK:{}, LMNOP:{}, QRSTU:{}, VWXYZ:{}};
    //console.log(citys.length);
    for (var i = 0, n = citys.length; i &lt; n; i++) {
        match = regEx.exec(citys[i]);
        letter = match[3].toUpperCase();
        if (reg2.test(letter)) {
            if (!Vcity.oCity.ABCDEF[letter]) Vcity.oCity.ABCDEF[letter] = [];
            Vcity.oCity.ABCDEF[letter].push(match[1]);
        } else if (reg3.test(letter)) {
            if (!Vcity.oCity.GHIJK[letter]) Vcity.oCity.GHIJK[letter] = [];
            Vcity.oCity.GHIJK[letter].push(match[1]);
        } else if (reg4.test(letter)) {
            if (!Vcity.oCity.LMNOP[letter]) Vcity.oCity.LMNOP[letter] = [];
            Vcity.oCity.LMNOP[letter].push(match[1]);
        } else if (reg5.test(letter)) {
            if (!Vcity.oCity.QRSTU[letter]) Vcity.oCity.QRSTU[letter] = [];
            Vcity.oCity.QRSTU[letter].push(match[1]);
        } else if (reg6.test(letter)) {
            if (!Vcity.oCity.VWXYZ[letter]) Vcity.oCity.VWXYZ[letter] = [];
            Vcity.oCity.VWXYZ[letter].push(match[1]);
        }
        /*  25 */
        if(i&lt;25){
            if(!Vcity.oCity.hot[&#39;hot&#39;]) Vcity.oCity.hot[&#39;hot&#39;] = [];
            Vcity.oCity.hot[&#39;hot&#39;].push(match[1]);
        }
    }
}</pre>

<p>})(); /* HTML */ Vcity._template = [</p>

<pre>&#39;&lt;p class=&quot;citytip&quot;&gt;(/)&lt;/p&gt;&#39;,
&#39;&lt;ul&gt;&#39;,
&#39;&lt;li class=&quot;on&quot;&gt;&lt;/li&gt;&#39;,
&#39;&lt;li&gt;ABCDEF&lt;/li&gt;&#39;,
&#39;&lt;li&gt;GHIJK&lt;/li&gt;&#39;,
&#39;&lt;li&gt;LMNOP&lt;/li&gt;&#39;,
&#39;&lt;li&gt;QRSTU&lt;/li&gt;&#39;,
&#39;&lt;li&gt;VWXYZ&lt;/li&gt;&#39;,
&#39;&lt;/ul&gt;&#39;</pre>

<p>];</p>

<p>/* *</p>

<pre>
@CitySelector
 /</pre>

<p>Vcity.CitySelector = function () {</p>

<pre class="ruby"><span class="ruby-identifier">this</span>.<span class="ruby-identifier">initialize</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
</pre>

<p>};</p>

<p>Vcity.CitySelector.prototype = {</p>

<pre>constructor:Vcity.CitySelector,

/*  */

initialize :function (options) {
    var input = options.input;
    this.input = Vcity._m.$(&#39;#&#39;+ input);
    this.inputEvent();
},

/* *
   @createWarp
   BOX HTML 
    /

createWarp:function(){
    var inputPos = Vcity._m.getPos(this.input);
    var div = this.rootDiv = document.createElement(&#39;div&#39;);
    var that = this;

    // DIV
    Vcity._m.on(this.rootDiv,&#39;click&#39;,function(event){
        Vcity._m.stopPropagation(event);
    });

    // 
    Vcity._m.on(document, &#39;click&#39;, function (event) {
        event = Vcity._m.getEvent(event);
        var target = Vcity._m.getTarget(event);
        if(target == that.input) return false;
        //console.log(target.className);
        if (that.cityBox)Vcity._m.addClass(&#39;hide&#39;, that.cityBox);
        if (that.ul)Vcity._m.addClass(&#39;hide&#39;, that.ul);
        if(that.myIframe)Vcity._m.addClass(&#39;hide&#39;,that.myIframe);
    });
    div.className = &#39;citySelector&#39;;
    div.style.position = &#39;absolute&#39;;
    div.style.left = inputPos.left + &#39;px&#39;;
    div.style.top = inputPos.bottom + &#39;px&#39;;
    div.style.zIndex = 999999;

    // IE6IE6iframeSELECT
    var isIe = (document.all) ? true : false;
    var isIE6 = this.isIE6 = isIe &amp;&amp; !window.XMLHttpRequest;
    if(isIE6){
        var myIframe = this.myIframe =  document.createElement(&#39;iframe&#39;);
        myIframe.frameborder = &#39;0&#39;;
        myIframe.src = &#39;about:blank&#39;;
        myIframe.style.position = &#39;absolute&#39;;
        myIframe.style.zIndex = &#39;-1&#39;;
        this.rootDiv.appendChild(this.myIframe);
    }

    var childdiv = this.cityBox = document.createElement(&#39;div&#39;);
    childdiv.className = &#39;cityBox&#39;;
    childdiv.id = &#39;cityBox&#39;;
    childdiv.innerHTML = Vcity._template.join(&#39;&#39;);
    var hotCity = this.hotCity =  document.createElement(&#39;div&#39;);
    hotCity.className = &#39;hotCity&#39;;
    childdiv.appendChild(hotCity);
    div.appendChild(childdiv);
    this.createHotCity();
},

/* *
   @createHotCity
   TABDIVhot,a-h,i-p,q-z HTMLDOM
   {HOT:{hot:[]},ABCDEFGH:{a:[1,2,3],b:[1,2,3]},IJKLMNOP:{},QRSTUVWXYZ:{}}
   /

createHotCity:function(){
    var odiv,odl,odt,odd,odda=[],str,key,ckey,sortKey,regEx = Vcity.regEx,
        oCity = Vcity.oCity;
    for(key in oCity){
        odiv = this[key] = document.createElement(&#39;div&#39;);
        // hide
        odiv.className = key + &#39; &#39; + &#39;cityTab hide&#39;;
        sortKey=[];
        for(ckey in oCity[key]){
            sortKey.push(ckey);
            // ckeyABCDEDG
            sortKey.sort();
        }
        for(var j=0,k = sortKey.length;j&lt;k;j++){
            odl = document.createElement(&#39;dl&#39;);
            odt = document.createElement(&#39;dt&#39;);
            odd = document.createElement(&#39;dd&#39;);
            odt.innerHTML = sortKey[j] == &#39;hot&#39;?&#39;&amp;nbsp;&#39;:sortKey[j];
            odda = [];
            for(var i=0,n=oCity[key][sortKey[j]].length;i&lt;n;i++){
                str = &#39;&lt;a href=&quot;javascript:&quot;&gt;&#39; + oCity[key][sortKey[j]][i] + &#39;&lt;/a&gt;&#39;;
                odda.push(str);
            }
            odd.innerHTML = odda.join(&#39;&#39;);
            odl.appendChild(odt);
            odl.appendChild(odd);
            odiv.appendChild(odl);
        }

        // CSS
        Vcity._m.removeClass(&#39;hide&#39;,this.hot);
        this.hotCity.appendChild(odiv);
    }
    document.body.appendChild(this.rootDiv);
    /* IE6 */
    this.changeIframe();

    this.tabChange();
    this.linkEvent();
},

/* *
    tab
    @ tabChange
    /

tabChange:function(){
    var lis = Vcity._m.$(&#39;li&#39;,this.cityBox);
    var divs = Vcity._m.$(&#39;div&#39;,this.hotCity);
    var that = this;
    for(var i=0,n=lis.length;i&lt;n;i++){
        lis[i].index = i;
        lis[i].onclick = function(){
            for(var j=0;j&lt;n;j++){
                Vcity._m.removeClass(&#39;on&#39;,lis[j]);
                Vcity._m.addClass(&#39;hide&#39;,divs[j]);
            }
            Vcity._m.addClass(&#39;on&#39;,this);
            Vcity._m.removeClass(&#39;hide&#39;,divs[this.index]);
            /* IE6 TAB Iframe */
            that.changeIframe();
        };
    }
},

/* *
   LINK
    @linkEvent
    /

linkEvent:function(){
    var links = Vcity._m.$(&#39;a&#39;,this.hotCity);
    var that = this;
    for(var i=0,n=links.length;i&lt;n;i++){
        links[i].onclick = function(){
            that.input.value = this.innerHTML;
            Vcity._m.addClass(&#39;hide&#39;,that.cityBox);
            /* myIframe */
            Vcity._m.addClass(&#39;hide&#39;,that.myIframe);
            getData();
        };
    }
},
/* *
   INPUT
   @inputEvent
    /
inputEvent:function(){
    var that = this;
    Vcity._m.on(this.input,&#39;click&#39;,function(event){
        event = event || window.event;
        if(!that.cityBox){
            that.createWarp();
        }else if(!!that.cityBox &amp;&amp; Vcity._m.hasClass(&#39;hide&#39;,that.cityBox)){
            // slideul  slideul 
            if(!that.ul || (that.ul &amp;&amp; Vcity._m.hasClass(&#39;hide&#39;,that.ul))){
                Vcity._m.removeClass(&#39;hide&#39;,that.cityBox);

                /* IE6 iframe hide  */
                //alert(&#39;click&#39;);
                Vcity._m.removeClass(&#39;hide&#39;,that.myIframe);
                that.changeIframe();
            }
        }
    });
    Vcity._m.on(this.input,&#39;focus&#39;,function(){
        that.input.select();
        if(that.input.value == &#39;&#39;) that.input.value = &#39;&#39;;
    });
    Vcity._m.on(this.input,&#39;blur&#39;,function(){
        if(that.input.value == &#39;&#39;) that.input.value = &#39;&#39;;
    });
    Vcity._m.on(this.input,&#39;keyup&#39;,function(event){
        event = event || window.event;
        var keycode = event.keyCode;
        Vcity._m.addClass(&#39;hide&#39;,that.cityBox);
        that.createUl();

        /* iframe hide  */
        Vcity._m.removeClass(&#39;hide&#39;,that.myIframe);

        // 
        if(that.ul &amp;&amp; !Vcity._m.hasClass(&#39;hide&#39;,that.ul) &amp;&amp; !that.isEmpty){
            that.KeyboardEvent(event,keycode);
        }
    });
},

/* *
   
   @ createUl
    /

createUl:function () {
    //console.log(&#39;createUL&#39;);
    var str;
    var value = Vcity._m.trim(this.input.value);
    // value
    if (value !== &#39;&#39;) {
        var reg = new RegExp(&quot;^&quot; + value + &quot;|\\|&quot; + value, &#39;gi&#39;);
        var searchResult = [];
        for (var i = 0, n = Vcity.allCity.length; i &lt; n; i++) {
            if (reg.test(Vcity.allCity[i])) {
                var match = Vcity.regEx.exec(Vcity.allCity[i]);
                if (searchResult.length !== 0) {
                    str = &#39;&lt;li&gt;&lt;b class=&quot;cityname&quot;&gt;&#39; + match[1] + &#39;&lt;/b&gt;&lt;b class=&quot;cityspell&quot;&gt;&#39; + match[2] + &#39;&lt;/b&gt;&lt;/li&gt;&#39;;
                } else {
                    str = &#39;&lt;li class=&quot;on&quot;&gt;&lt;b class=&quot;cityname&quot;&gt;&#39; + match[1] + &#39;&lt;/b&gt;&lt;b class=&quot;cityspell&quot;&gt;&#39; + match[2] + &#39;&lt;/b&gt;&lt;/li&gt;&#39;;
                }
                searchResult.push(str);
            }
        }
        this.isEmpty = false;
        // 
        if (searchResult.length == 0) {
            this.isEmpty = true;
            str = &#39;&lt;li class=&quot;empty&quot;&gt; &quot;&lt;em&gt;&#39; + value + &#39;&lt;/em&gt;&quot;&lt;/li&gt;&#39;;
            searchResult.push(str);
        }
        // slideulul
        if (!this.ul) {
            var ul = this.ul = document.createElement(&#39;ul&#39;);
            ul.className = &#39;cityslide&#39;;
            this.rootDiv &amp;&amp; this.rootDiv.appendChild(ul);
            // 
            this.count = 0;
        } else if (this.ul &amp;&amp; Vcity._m.hasClass(&#39;hide&#39;, this.ul)) {
            this.count = 0;
            Vcity._m.removeClass(&#39;hide&#39;, this.ul);
        }
        this.ul.innerHTML = searchResult.join(&#39;&#39;);

        /* IE6 */
        this.changeIframe();

        // Li
        this.liEvent();
    }else{
        Vcity._m.addClass(&#39;hide&#39;,this.ul);
        Vcity._m.removeClass(&#39;hide&#39;,this.cityBox);

        Vcity._m.removeClass(&#39;hide&#39;,this.myIframe);

        this.changeIframe();
    }
},

/* IE6SELECT  IFRAME */
changeIframe:function(){
    if(!this.isIE6)return;
    this.myIframe.style.width = this.rootDiv.offsetWidth + &#39;px&#39;;
    this.myIframe.style.height = this.rootDiv.offsetHeight + &#39;px&#39;;
},

/* *
   Enter
   @ KeyboardEvent
    /

KeyboardEvent:function(event,keycode){
    var lis = Vcity._m.$(&#39;li&#39;,this.ul);
    var len = lis.length;
    switch(keycode){
        case 40: //
            this.count++;
            if(this.count &gt; len-1) this.count = 0;
            for(var i=0;i&lt;len;i++){
                Vcity._m.removeClass(&#39;on&#39;,lis[i]);
            }
            Vcity._m.addClass(&#39;on&#39;,lis[this.count]);
            break;
        case 38: //
            this.count--;
            if(this.count&lt;0) this.count = len-1;
            for(i=0;i&lt;len;i++){
                Vcity._m.removeClass(&#39;on&#39;,lis[i]);
            }
            Vcity._m.addClass(&#39;on&#39;,lis[this.count]);
            break;
        case 13: // enter
            this.input.value = Vcity.regExChiese.exec(lis[this.count].innerHTML)[0];
            Vcity._m.addClass(&#39;hide&#39;,this.ul);
            Vcity._m.addClass(&#39;hide&#39;,this.ul);
            /* IE6 */
            Vcity._m.addClass(&#39;hide&#39;,this.myIframe);
            getData();
            break;
        default:
            break;
    }
},

/* *
   li
   @ liEvent
    /

liEvent:function(){
    var that = this;
    var lis = Vcity._m.$(&#39;li&#39;,this.ul);
    for(var i = 0,n = lis.length;i &lt; n;i++){
        Vcity._m.on(lis[i],&#39;click&#39;,function(event){
            event = Vcity._m.getEvent(event);
            var target = Vcity._m.getTarget(event);
            that.input.value = Vcity.regExChiese.exec(target.innerHTML)[0];
            Vcity._m.addClass(&#39;hide&#39;,that.ul);
            /* IE6  */
            Vcity._m.addClass(&#39;hide&#39;,that.myIframe);
        });
        Vcity._m.on(lis[i],&#39;mouseover&#39;,function(event){
            event = Vcity._m.getEvent(event);
            var target = Vcity._m.getTarget(event);
            Vcity._m.addClass(&#39;on&#39;,target);
        });
        Vcity._m.on(lis[i],&#39;mouseout&#39;,function(event){
            event = Vcity._m.getEvent(event);
            var target = Vcity._m.getTarget(event);
            Vcity._m.removeClass(&#39;on&#39;,target);
        });
    }
}</pre>

<p>}; // This is a manifest file that&#39;ll be compiled into application.js,
which will include all the files // listed below. // // Any
JavaScript/Coffee file within this directory, lib/assets/javascripts,
vendor/assets/javascripts, // or any plugin&#39;s vendor/assets/javascripts
directory can be referenced here using a relative path. // // It&#39;s not
advisable to add code directly here, but if you do, it&#39;ll appear at the
bottom of the // compiled file. // // Read Sprockets <a
href="../../README_rdoc.html">README</a> (<a
href="https://github.com/sstephenson/sprockets#sprockets-directives">github.com/sstephenson/sprockets#sprockets-directives</a>)
for details // about supported directives. //</p>

<p>// require vendor/esl // require vendor/echarts/echarts // require
vendor/BMap/BMap</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

